-----label-----
0
-----code-----
TIFF*
TIFFClientOpen(
	const char* name, const char* mode,
	thandle_t clientdata,
	TIFFReadWriteProc readproc,
	TIFFReadWriteProc writeproc,
	TIFFSeekProc seekproc,
	TIFFCloseProc closeproc,
	TIFFSizeProc sizeproc,
	TIFFMapFileProc mapproc,
	TIFFUnmapFileProc unmapproc
)
{
	static const char module[] = "TIFFClientOpen";
	TIFF *tif;
	int m;
	const char* cp;

	/* The following are configuration checks. They should be redundant, but should not
	 * compile to any actual code in an optimised release build anyway. If any of them
	 * fail, (makefile-based or other) configuration is not correct */
	assert(sizeof(uint8)==1);
	assert(sizeof(int8)==1);
	assert(sizeof(uint16)==2);
	assert(sizeof(int16)==2);
	assert(sizeof(uint32)==4);
	assert(sizeof(int32)==4);
	assert(sizeof(uint64)==8);
	assert(sizeof(int64)==8);
	assert(sizeof(tmsize_t)==sizeof(void*));
	{
		union{
			uint8 a8[2];
			uint16 a16;
		} n;
		n.a8[0]=1;
		n.a8[1]=0;
		#ifdef WORDS_BIGENDIAN
		assert(n.a16==256);
		#else
		assert(n.a16==1);
		#endif
	}

	m = _TIFFgetMode(mode, module);
	if (m == -1)
		goto bad2;
	tif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));
	if (tif == NULL) {
		TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);
		goto bad2;
	}
	_TIFFmemset(tif, 0, sizeof (*tif));
	tif->tif_name = (char *)tif + sizeof (TIFF);
	strcpy(tif->tif_name, name);
	tif->tif_mode = m &~ (O_CREAT|O_TRUNC);
	tif->tif_curdir = (uint16) -1;		/* non-existent directory */
	tif->tif_curoff = 0;
	tif->tif_curstrip = (uint32) -1;	/* invalid strip */
	tif->tif_row = (uint32) -1;		/* read/write pre-increment */
	tif->tif_clientdata = clientdata;
	if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {
		TIFFErrorExt(clientdata, module,
		    "One of the client procedures is NULL pointer.");
		goto bad2;
	}
	tif->tif_readproc = readproc;
	tif->tif_writeproc = writeproc;
	tif->tif_seekproc = seekproc;
	tif->tif_closeproc = closeproc;
	tif->tif_sizeproc = sizeproc;
	if (mapproc)
		tif->tif_mapproc = mapproc;
	else
		tif->tif_mapproc = _tiffDummyMapProc;
	if (unmapproc)
		tif->tif_unmapproc = unmapproc;
	else
		tif->tif_unmapproc = _tiffDummyUnmapProc;
	_TIFFSetDefaultCompressionState(tif);    /* setup default state */
	/*
	 * Default is to return data MSB2LSB and enable the
	 * use of memory-mapped files and strip chopping when
	 * a file is opened read-only.
	 */
	tif->tif_flags = FILLORDER_MSB2LSB;
	if (m == O_RDONLY )
		tif->tif_flags |= TIFF_MAPPED;

	#ifdef STRIPCHOP_DEFAULT
	if (m == O_RDONLY || m == O_RDWR)
		tif->tif_flags |= STRIPCHOP_DEFAULT;
	#endif

	/*
	 * Process library-specific flags in the open mode string.
	 * The following flags may be used to control intrinsic library
	 * behaviour that may or may not be desirable (usually for
	 * compatibility with some application that claims to support
	 * TIFF but only supports some brain dead idea of what the
	 * vendor thinks TIFF is):
	 *
	 * 'l' use little-endian byte order for creating a file
	 * 'b' use big-endian byte order for creating a file
	 * 'L' read/write information using LSB2MSB bit order
	 * 'B' read/write information using MSB2LSB bit order
	 * 'H' read/write information using host bit order
	 * 'M' enable use of memory-mapped files when supported
	 * 'm' disable use of memory-mapped files
	 * 'C' enable strip chopping support when reading
	 * 'c' disable strip chopping support
	 * 'h' read TIFF header only, do not load the first IFD
	 * '4' ClassicTIFF for creating a file (default)
	 * '8' BigTIFF for creating a file
	 *
	 * The use of the 'l' and 'b' flags is strongly discouraged.
	 * These flags are provided solely because numerous vendors,
	 * typically on the PC, do not correctly support TIFF; they
	 * only support the Intel little-endian byte order.  This
	 * support is not configured by default because it supports
	 * the violation of the TIFF spec that says that readers *MUST*
	 * support both byte orders.  It is strongly recommended that
	 * you not use this feature except to deal with busted apps
	 * that write invalid TIFF.  And even in those cases you should
	 * bang on the vendors to fix their software.
	 *
	 * The 'L', 'B', and 'H' flags are intended for applications
	 * that can optimize operations on data by using a particular
	 * bit order.  By default the library returns data in MSB2LSB
	 * bit order for compatibility with older versions of this
	 * library.  Returning data in the bit order of the native CPU
	 * makes the most sense but also requires applications to check
	 * the value of the FillOrder tag; something they probably do
	 * not do right now.
	 *
	 * The 'M' and 'm' flags are provided because some virtual memory
	 * systems exhibit poor behaviour when large images are mapped.
	 * These options permit clients to control the use of memory-mapped
	 * files on a per-file basis.
	 *
	 * The 'C' and 'c' flags are provided because the library support
	 * for chopping up large strips into multiple smaller strips is not
	 * application-transparent and as such can cause problems.  The 'c'
	 * option permits applications that only want to look at the tags,
	 * for example, to get the unadulterated TIFF tag information.
	 */
	for (cp = mode; *cp; cp++)
		switch (*cp) {
			case 'b':
				#ifndef WORDS_BIGENDIAN
				if (m&O_CREAT)
					tif->tif_flags |= TIFF_SWAB;
				#endif
				break;
			case 'l':
				#ifdef WORDS_BIGENDIAN
				if ((m&O_CREAT))
					tif->tif_flags |= TIFF_SWAB;
				#endif
				break;
			case 'B':
				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |
				    FILLORDER_MSB2LSB;
				break;
			case 'L':
				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |
				    FILLORDER_LSB2MSB;
				break;
			case 'H':
				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |
				    HOST_FILLORDER;
				break;
			case 'M':
				if (m == O_RDONLY)
					tif->tif_flags |= TIFF_MAPPED;
				break;
			case 'm':
				if (m == O_RDONLY)
					tif->tif_flags &= ~TIFF_MAPPED;
				break;
			case 'C':
				if (m == O_RDONLY)
					tif->tif_flags |= TIFF_STRIPCHOP;
				break;
			case 'c':
				if (m == O_RDONLY)
					tif->tif_flags &= ~TIFF_STRIPCHOP;
				break;
			case 'h':
				tif->tif_flags |= TIFF_HEADERONLY;
				break;
			case '8':
				if (m&O_CREAT)
					tif->tif_flags |= TIFF_BIGTIFF;
				break;
		}
	/*
	 * Read in TIFF header.
	 */
	if ((m & O_TRUNC) ||
	    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {
		if (tif->tif_mode == O_RDONLY) {
			TIFFErrorExt(tif->tif_clientdata, name,
			    "Cannot read TIFF header");
			goto bad;
		}
		/*
		 * Setup header and write.
		 */
		#ifdef WORDS_BIGENDIAN
		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)
		    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;
		#else
		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)
		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;
		#endif
		if (!(tif->tif_flags&TIFF_BIGTIFF))
		{
			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;
			tif->tif_header.classic.tiff_diroff = 0;
			if (tif->tif_flags & TIFF_SWAB)
				TIFFSwabShort(&tif->tif_header.common.tiff_version);
			tif->tif_header_size = sizeof(TIFFHeaderClassic);
		}
		else
		{
			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;
			tif->tif_header.big.tiff_offsetsize = 8;
			tif->tif_header.big.tiff_unused = 0;
			tif->tif_header.big.tiff_diroff = 0;
			if (tif->tif_flags & TIFF_SWAB)
			{
				TIFFSwabShort(&tif->tif_header.common.tiff_version);
				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);
			}
			tif->tif_header_size = sizeof (TIFFHeaderBig);
		}
		/*
		 * The doc for "fopen" for some STD_C_LIBs says that if you
		 * open a file for modify ("+"), then you must fseek (or
		 * fflush?) between any freads and fwrites.  This is not
		 * necessary on most systems, but has been shown to be needed
		 * on Solaris.
		 */
		TIFFSeekFile( tif, 0, SEEK_SET );
		if (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {
			TIFFErrorExt(tif->tif_clientdata, name,
			    "Error writing TIFF header");
			goto bad;
		}
		/*
		 * Setup the byte order handling.
		 */
		if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {
			#ifndef WORDS_BIGENDIAN
			tif->tif_flags |= TIFF_SWAB;
			#endif
		} else {
			#ifdef WORDS_BIGENDIAN
			tif->tif_flags |= TIFF_SWAB;
			#endif
		}
		/*
		 * Setup default directory.
		 */
		if (!TIFFDefaultDirectory(tif))
			goto bad;
		tif->tif_diroff = 0;
		tif->tif_dirlist = NULL;
		tif->tif_dirlistsize = 0;
		tif->tif_dirnumber = 0;
		return (tif);
	}
	/*
	 * Setup the byte order handling.
	 */
	if (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&
	    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN
	    #if MDI_SUPPORT
	    &&
	    #if HOST_BIGENDIAN
	    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN
	    #else
	    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN
	    #endif
	    ) {
		TIFFErrorExt(tif->tif_clientdata, name,
		    "Not a TIFF or MDI file, bad magic number %d (0x%x)",
	    #else
	    ) {
		TIFFErrorExt(tif->tif_clientdata, name,
		    "Not a TIFF file, bad magic number %d (0x%x)",
	    #endif
		    tif->tif_header.common.tiff_magic,
		    tif->tif_header.common.tiff_magic);
		goto bad;
	}
	if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {
		#ifndef WORDS_BIGENDIAN
		tif->tif_flags |= TIFF_SWAB;
		#endif
	} else {
		#ifdef WORDS_BIGENDIAN
		tif->tif_flags |= TIFF_SWAB;
		#endif
	}
	if (tif->tif_flags & TIFF_SWAB) 
		TIFFSwabShort(&tif->tif_header.common.tiff_version);
	if ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&
	    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {
		TIFFErrorExt(tif->tif_clientdata, name,
		    "Not a TIFF file, bad version number %d (0x%x)",
		    tif->tif_header.common.tiff_version,
		    tif->tif_header.common.tiff_version);
		goto bad;
	}
	if (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)
	{
		if (tif->tif_flags & TIFF_SWAB)
			TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);
		tif->tif_header_size = sizeof(TIFFHeaderClassic);
	}
	else
	{
		if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))
		{
			TIFFErrorExt(tif->tif_clientdata, name,
			    "Cannot read TIFF header");
			goto bad;
		}
		if (tif->tif_flags & TIFF_SWAB)
		{
			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);
			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);
		}
		if (tif->tif_header.big.tiff_offsetsize != 8)
		{
			TIFFErrorExt(tif->tif_clientdata, name,
			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",
			    tif->tif_header.big.tiff_offsetsize,
			    tif->tif_header.big.tiff_offsetsize);
			goto bad;
		}
		if (tif->tif_header.big.tiff_unused != 0)
		{
			TIFFErrorExt(tif->tif_clientdata, name,
			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",
			    tif->tif_header.big.tiff_unused,
			    tif->tif_header.big.tiff_unused);
			goto bad;
		}
		tif->tif_header_size = sizeof(TIFFHeaderBig);
		tif->tif_flags |= TIFF_BIGTIFF;
	}
	tif->tif_flags |= TIFF_MYBUFFER;
	tif->tif_rawcp = tif->tif_rawdata = 0;
	tif->tif_rawdatasize = 0;
        tif->tif_rawdataoff = 0;
        tif->tif_rawdataloaded = 0;

	switch (mode[0]) {
		case 'r':
			if (!(tif->tif_flags&TIFF_BIGTIFF))
				tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;
			else
				tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;
			/*
			 * Try to use a memory-mapped file if the client
			 * has not explicitly suppressed usage with the
			 * 'm' flag in the open mode (see above).
			 */
			if (tif->tif_flags & TIFF_MAPPED)
			{
				toff_t n;
				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))
				{
					tif->tif_size=(tmsize_t)n;
					assert((toff_t)tif->tif_size==n);
				}
				else
					tif->tif_flags &= ~TIFF_MAPPED;
			}
			/*
			 * Sometimes we do not want to read the first directory (for example,
			 * it may be broken) and want to proceed to other directories. I this
			 * case we use the TIFF_HEADERONLY flag to open file and return
			 * immediately after reading TIFF header.
			 */
			if (tif->tif_flags & TIFF_HEADERONLY)
				return (tif);

			/*
			 * Setup initial directory.
			 */
			if (TIFFReadDirectory(tif)) {
				tif->tif_rawcc = (tmsize_t)-1;
				tif->tif_flags |= TIFF_BUFFERSETUP;
				return (tif);
			}
			break;
		case 'a':
			/*
			 * New directories are automatically append
			 * to the end of the directory chain when they
			 * are written out (see TIFFWriteDirectory).
			 */
			if (!TIFFDefaultDirectory(tif))
				goto bad;
			return (tif);
	}
bad:
	tif->tif_mode = O_RDONLY;	/* XXX avoid flush */
        TIFFCleanup(tif);
bad2:
	return ((TIFF*)0);
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
4,12
4,13
4,14
4,15
4,16
7,8
7,9
9,10
9,11
12,13
12,14
14,15
14,16
17,18
17,19
18,19
20,21
22,23
22,24
23,24
25,26
27,28
27,29
28,29
30,31
32,33
32,34
33,34
35,36
37,38
37,39
38,39
40,41
42,43
42,44
43,44
45,46
47,48
47,49
48,49
50,51
52,53
52,54
53,54
55,56
57,58
57,59
57,60
57,61
57,62
57,63
57,64
57,65
57,66
57,67
57,68
57,69
57,70
57,71
57,72
57,73
57,74
57,75
57,76
57,77
57,78
57,79
57,80
57,81
57,82
57,83
57,84
57,85
57,86
57,87
57,88
57,89
57,90
57,91
57,92
57,93
57,94
57,95
57,96
57,97
57,98
57,99
57,100
57,101
57,102
57,103
57,104
57,105
57,106
57,107
57,108
57,109
57,110
57,111
58,59
59,60
59,61
61,62
61,63
61,64
64,65
66,67
67,68
67,69
68,69
70,71
70,72
73,74
74,75
74,76
76,77
78,79
79,80
79,81
81,82
81,83
84,85
85,86
85,87
86,87
88,89
88,90
89,90
90,91
90,92
91,92
95,96
96,97
96,98
97,98
99,100
99,101
100,101
101,102
101,103
102,103
106,107
107,108
107,109
108,109
110,111
110,112
111,112
112,113
112,114
113,114
117,118
118,119
118,120
119,120
121,122
121,123
122,123
123,124
123,125
124,125
128,129
129,130
129,131
130,131
132,133
132,134
133,134
134,135
134,136
135,136
139,140
140,141
140,142
141,142
143,144
143,145
144,145
145,146
145,147
146,147
150,151
151,152
151,153
152,153
154,155
154,156
155,156
156,157
156,158
157,158
161,162
162,163
162,164
163,164
165,166
165,167
166,167
167,168
167,169
168,169
172,173
173,174
173,175
174,175
176,177
176,178
177,178
178,179
178,180
179,180
182,183
183,184
183,185
185,186
187,188
187,189
187,190
187,191
188,189
189,190
189,191
190,191
190,192
190,193
192,193
192,194
193,194
195,196
195,197
197,198
199,200
199,201
200,201
202,203
204,205
207,208
208,209
208,210
209,210
209,211
210,211
210,212
211,212
216,217
217,218
217,219
218,219
218,220
219,220
219,221
220,221
225,226
226,227
226,228
227,228
229,230
229,231
230,231
230,232
231,232
235,236
236,237
236,238
237,238
239,240
239,241
239,242
240,241
242,243
244,245
246,247
246,248
247,248
247,249
248,249
250,251
252,253
254,255
255,256
255,257
256,257
258,259
258,260
259,260
259,261
260,261
262,263
264,265
264,266
265,266
267,268
267,269
268,269
269,270
271,272
271,273
272,273
272,274
273,274
274,275
274,276
275,276
278,279
278,280
279,280
281,282
284,285
284,286
285,286
285,287
286,287
288,289
290,291
290,292
291,292
292,293
292,294
292,295
292,296
292,297
293,294
295,296
297,298
300,301
302,303
304,305
305,306
305,307
305,308
305,309
306,307
308,309
311,312
312,313
313,314
314,315
316,317
317,318
317,319
318,319
318,320
319,320
322,323
322,324
323,324
323,325
324,325
324,326
326,327
328,329
330,331
331,332
331,333
332,333
335,336
336,337
336,338
336,339
337,338
339,340
339,341
340,341
343,344
345,346
346,347
346,348
347,348
347,349
348,349
351,352
351,353
352,353
354,355
355,356
356,357
356,358
357,358
359,360
361,362
362,363
362,364
363,364
363,365
364,365
367,368
367,369
368,369
369,370
372,373
373,374
373,375
374,375
374,376
375,376
379,380
380,381
380,382
381,382
381,383
382,383
385,386
385,387
386,387
387,388
390,391
391,392
391,393
392,393
392,394
393,394
396,397
396,398
397,398
398,399
401,402
402,403
402,404
403,404
403,405
404,405
407,408
409,410
409,411
410,411
410,412
411,412
411,413
412,413
412,414
413,414
413,415
414,415
415,416
417,418
418,419
420,421
421,422
423,424
424,425
426,427
427,428
429,430
429,431
430,431
431,432
431,433
431,434
431,435
432,433
434,435
436,437
439,440
441,442
442,443
442,444
443,444
443,445
444,445
447,448
449,450
450,451
450,452
451,452
451,453
452,453
455,456
457,458
458,459
458,460
459,460
459,461
460,461
463,464
465,466
466,467
466,468
467,468
467,469
468,469
471,472
473,474
474,475
474,476
475,476
475,477
476,477
479,480
481,482
481,483
481,484
482,483
484,485
485,486
485,487
486,487
486,488
487,488
490,491
492,493
493,494
493,495
494,495
494,496
495,496
498,499
500,501
500,502
500,503
501,502
503,504
504,505
504,506
505,506
505,507
506,507
509,510
511,512
512,513
512,514
513,514
513,515
514,515
517,518
519,520
520,521
520,522
521,522
523,524
525,526
526,527
526,528
527,528
527,529
528,529
531,532
533,534
533,535
534,535
534,536
535,536
537,538
539,540
540,541
540,542
541,542
541,543
542,543
545,546
547,548
547,549
547,550
547,551
548,549
549,550
549,551
550,551
552,553
554,555
555,556
557,558
558,559
560,561
560,562
561,562
562,563
564,565
564,566
564,567
564,568
564,569
564,570
564,571
564,572
564,573
564,574
564,575
564,576
564,577
564,578
564,579
564,580
564,581
564,582
564,583
564,584
564,585
564,586
564,587
564,588
564,589
564,590
564,591
564,592
564,593
564,594
564,595
564,596
565,566
567,568
567,569
568,569
568,570
569,570
571,572
573,574
574,575
574,576
575,576
575,577
576,577
579,580
582,583
585,586
587,588
588,589
588,590
589,590
589,591
590,591
593,594
593,595
594,595
595,596
595,597
596,597
596,598
597,598
600,601
601,602
603,604
606,607
608,609
609,610
609,611
610,611
610,612
611,612
614,615
614,616
615,616
616,617
616,618
617,618
617,619
618,619
621,622
622,623
624,625
627,628
629,630
630,631
630,632
631,632
631,633
632,633
635,636
635,637
636,637
637,638
637,639
638,639
638,640
639,640
642,643
643,644
645,646
648,649
650,651
650,652
651,652
651,653
652,653
654,655
656,657
657,658
657,659
658,659
658,660
659,660
662,663
665,666
667,668
667,669
668,669
668,670
669,670
671,672
673,674
674,675
674,676
675,676
675,677
676,677
679,680
680,681
683,684
685,686
685,687
686,687
686,688
687,688
689,690
691,692
692,693
692,694
693,694
693,695
694,695
697,698
700,701
702,703
702,704
703,704
703,705
704,705
706,707
708,709
709,710
709,711
710,711
710,712
711,712
714,715
715,716
718,719
720,721
721,722
721,723
722,723
722,724
723,724
726,727
729,730
731,732
731,733
732,733
732,734
733,734
735,736
737,738
738,739
738,740
739,740
739,741
740,741
743,744
746,747
746,748
747,748
747,749
748,749
749,750
749,751
750,751
752,753
754,755
755,756
755,757
755,758
755,759
756,757
758,759
760,761
761,762
761,763
762,763
765,766
766,767
766,768
767,768
770,771
770,772
770,773
770,774
770,775
770,776
770,777
770,778
770,779
770,780
770,781
770,782
771,772
771,773
772,773
772,774
773,774
773,775
774,775
777,778
779,780
779,781
780,781
781,782
781,783
781,784
781,785
782,783
784,785
784,786
785,786
788,789
791,792
793,794
794,795
794,796
795,796
795,797
796,797
796,798
797,798
797,799
798,799
803,804
803,805
803,806
804,805
805,806
805,807
806,807
806,808
807,808
810,811
812,813
814,815
816,817
816,818
816,819
817,818
818,819
819,820
819,821
820,821
820,822
821,822
824,825
826,827
826,828
826,829
826,830
827,828
828,829
828,830
829,830
829,831
830,831
830,832
831,832
831,833
832,833
837,838
839,840
840,841
840,842
841,842
841,843
842,843
842,844
843,844
843,845
844,845
850,851
850,852
851,852
851,853
852,853
852,854
853,854
856,857
858,859
859,860
859,861
860,861
862,863
863,864
863,865
864,865
864,866
865,866
865,867
866,867
871,872
872,873
872,874
873,874
873,875
874,875
877,878
878,879
878,880
879,880
882,883
882,884
882,885
882,886
882,887
882,888
883,884
884,885
884,886
885,886
885,887
886,887
886,888
887,888
887,889
888,889
893,894
895,896
896,897
896,898
897,898
897,899
898,899
898,900
899,900
899,901
900,901
906,907
907,908
907,909
908,909
908,910
909,910
909,911
910,911
910,912
911,912
917,918
918,919
918,920
919,920
919,921
920,921
920,922
921,922
921,923
922,923
928,929
928,930
929,930
929,931
930,931
930,932
931,932
934,935
936,937
936,938
937,938
938,939
938,940
939,940
941,942
942,943
942,944
943,944
943,945
944,945
944,946
945,946
950,951
951,952
951,953
952,953
954,955
955,956
955,957
956,957
956,958
957,958
957,959
958,959
963,964
964,965
964,966
965,966
965,967
966,967
969,970
970,971
970,972
971,972
974,975
975,976
975,977
975,978
975,979
976,977
978,979
981,982
983,984
983,985
984,985
985,986
985,987
985,988
985,989
986,987
988,989
990,991
991,992
991,993
992,993
995,996
995,997
996,997
997,998
999,1000
999,1001
1000,1001
1003,1004
1003,1005
1004,1005
1005,1006
1005,1007
1005,1008
1005,1009
1006,1007
1008,1009
1008,1010
1009,1010
1012,1013
1015,1016
1017,1018
1017,1019
1017,1020
1018,1019
1018,1020
1019,1020
1019,1021
1020,1021
1020,1022
1021,1022
1021,1023
1022,1023
1027,1028
1029,1030
1030,1031
1031,1032
1031,1033
1032,1033
1032,1034
1033,1034
1036,1037
1039,1040
1039,1041
1040,1041
1041,1042
1041,1043
1042,1043
1044,1045
1046,1047
1048,1049
1049,1050
1049,1051
1050,1051
1050,1052
1051,1052
1055,1056
1056,1057
1056,1058
1057,1058
1057,1059
1058,1059
1061,1062
1063,1064
1064,1065
1064,1066
1065,1066
1065,1067
1066,1067
1070,1071
1071,1072
1071,1073
1072,1073
1072,1074
1073,1074
1077,1078
1078,1079
1079,1080
1081,1082
1081,1083
1082,1083
1082,1084
1083,1084
1083,1085
1084,1085
1084,1086
1085,1086
1085,1087
1086,1087
1086,1088
1087,1088
1092,1093
1094,1095
1094,1096
1095,1096
1095,1097
1096,1097
1096,1098
1097,1098
1097,1099
1098,1099
1103,1104
1105,1106
1105,1107
1106,1107
1107,1108
1107,1109
1107,1110
1107,1111
1107,1112
1107,1113
1108,1109
1110,1111
1110,1112
1111,1112
1114,1115
1117,1118
1117,1119
1118,1119
1118,1120
1119,1120
1119,1121
1120,1121
1125,1126
1125,1127
1126,1127
1126,1128
1127,1128
1127,1129
1128,1129
1133,1134
1135,1136
1135,1137
1135,1138
1136,1137
1136,1138
1137,1138
1137,1139
1138,1139
1138,1140
1139,1140
1139,1141
1140,1141
1145,1146
1147,1148
1148,1149
1149,1150
1149,1151
1150,1151
1150,1152
1151,1152
1154,1155
1157,1158
1157,1159
1158,1159
1158,1160
1159,1160
1159,1161
1160,1161
1163,1164
1165,1166
1166,1167
1166,1168
1167,1168
1169,1170
1170,1171
1170,1172
1171,1172
1171,1173
1172,1173
1172,1174
1173,1174
1178,1179
1178,1180
1179,1180
1179,1181
1180,1181
1181,1182
1181,1183
1182,1183
1182,1184
1183,1184
1183,1185
1184,1185
1184,1186
1185,1186
1190,1191
1192,1193
1193,1194
1193,1195
1194,1195
1194,1196
1195,1196
1195,1197
1196,1197
1196,1198
1197,1198
1202,1203
1204,1205
1204,1206
1205,1206
1206,1207
1206,1208
1206,1209
1206,1210
1206,1211
1206,1212
1207,1208
1209,1210
1209,1211
1210,1211
1213,1214
1216,1217
1216,1218
1217,1218
1217,1219
1218,1219
1218,1220
1219,1220
1224,1225
1224,1226
1225,1226
1225,1227
1226,1227
1226,1228
1227,1228
1232,1233
1234,1235
1234,1236
1234,1237
1235,1236
1235,1237
1236,1237
1236,1238
1237,1238
1237,1239
1238,1239
1238,1240
1239,1240
1244,1245
1246,1247
1246,1248
1247,1248
1247,1249
1248,1249
1248,1250
1249,1250
1249,1251
1250,1251
1253,1254
1255,1256
1256,1257
1256,1258
1257,1258
1259,1260
1260,1261
1260,1262
1261,1262
1261,1263
1262,1263
1262,1264
1263,1264
1268,1269
1269,1270
1269,1271
1270,1271
1270,1272
1271,1272
1274,1275
1275,1276
1275,1277
1276,1277
1279,1280
1279,1281
1279,1282
1279,1283
1279,1284
1279,1285
1280,1281
1280,1282
1281,1282
1282,1283
1282,1284
1282,1285
1282,1286
1283,1284
1285,1286
1287,1288
1288,1289
1288,1290
1289,1290
1289,1291
1290,1291
1290,1292
1291,1292
1293,1294
1295,1296
1296,1297
1297,1298
1297,1299
1298,1299
1301,1302
1302,1303
1302,1304
1303,1304
1306,1307
1307,1308
1307,1309
1308,1309
1309,1310
1309,1311
1310,1311
1313,1314
1314,1315
1314,1316
1315,1316
1318,1319
1318,1320
1319,1320
1320,1321
1320,1322
1320,1323
1320,1324
1321,1322
1323,1324
1323,1325
1324,1325
1327,1328
1330,1331
1332,1333
1332,1334
1333,1334
1333,1335
1334,1335
1334,1336
1335,1336
1338,1339
1340,1341
1340,1342
1341,1342
1342,1343
1342,1344
1343,1344
1345,1346
1346,1347
1346,1348
1347,1348
1347,1349
1348,1349
1348,1350
1349,1350
1354,1355
1355,1356
1355,1357
1356,1357
1358,1359
1359,1360
1359,1361
1360,1361
1360,1362
1361,1362
1361,1363
1362,1363
1367,1368
1367,1369
1368,1369
1368,1370
1369,1370
1369,1371
1370,1371
1370,1372
1371,1372
1371,1373
1372,1373
1378,1379
1378,1380
1379,1380
1380,1381
1380,1382
1380,1383
1380,1384
1380,1385
1380,1386
1381,1382
1383,1384
1383,1385
1384,1385
1387,1388
1390,1391
1390,1392
1391,1392
1391,1393
1392,1393
1392,1394
1393,1394
1398,1399
1398,1400
1399,1400
1399,1401
1400,1401
1400,1402
1401,1402
1406,1407
1408,1409
1408,1410
1409,1410
1409,1411
1410,1411
1410,1412
1411,1412
1411,1413
1412,1413
1412,1414
1413,1414
1419,1420
1419,1421
1420,1421
1421,1422
1421,1423
1421,1424
1421,1425
1421,1426
1421,1427
1422,1423
1424,1425
1424,1426
1425,1426
1428,1429
1431,1432
1431,1433
1432,1433
1432,1434
1433,1434
1433,1435
1434,1435
1439,1440
1439,1441
1440,1441
1440,1442
1441,1442
1441,1443
1442,1443
1447,1448
1449,1450
1450,1451
1450,1452
1451,1452
1451,1453
1452,1453
1455,1456
1456,1457
1456,1458
1457,1458
1460,1461
1461,1462
1461,1463
1462,1463
1462,1464
1463,1464
1466,1467
1468,1469
1469,1470
1469,1471
1470,1471
1470,1472
1471,1472
1474,1475
1476,1477
1477,1478
1477,1479
1478,1479
1478,1480
1479,1480
1482,1483
1482,1484
1483,1484
1483,1485
1484,1485
1488,1489
1489,1490
1489,1491
1490,1491
1490,1492
1491,1492
1495,1496
1496,1497
1496,1498
1497,1498
1497,1499
1498,1499
1502,1503
1503,1504
1503,1505
1504,1505
1504,1506
1505,1506
1509,1510
1509,1511
1510,1511
1510,1512
1511,1512
1514,1515
1514,1516
1514,1517
1514,1518
1514,1519
1514,1520
1514,1521
1514,1522
1514,1523
1515,1516
1517,1518
1517,1519
1517,1520
1518,1519
1519,1520
1520,1521
1520,1522
1521,1522
1521,1523
1522,1523
1525,1526
1527,1528
1528,1529
1528,1530
1529,1530
1529,1531
1530,1531
1533,1534
1533,1535
1534,1535
1534,1536
1535,1536
1535,1537
1536,1537
1541,1542
1542,1543
1542,1544
1543,1544
1543,1545
1544,1545
1547,1548
1547,1549
1548,1549
1548,1550
1549,1550
1549,1551
1550,1551
1555,1556
1555,1557
1556,1557
1556,1558
1557,1558
1557,1559
1558,1559
1561,1562
1563,1564
1563,1565
1564,1565
1565,1566
1565,1567
1566,1567
1568,1569
1570,1571
1570,1572
1570,1573
1571,1572
1571,1573
1571,1574
1571,1575
1572,1573
1574,1575
1576,1577
1576,1578
1577,1578
1577,1579
1579,1580
1579,1581
1582,1583
1583,1584
1584,1585
1584,1586
1585,1586
1588,1589
1589,1590
1591,1592
1591,1593
1592,1593
1593,1594
1593,1595
1594,1595
1594,1596
1595,1596
1598,1599
1598,1600
1599,1600
1599,1601
1600,1601
1603,1604
1605,1606
1606,1607
1606,1608
1607,1608
1609,1610
1609,1611
1610,1611
1610,1612
1611,1612
1611,1613
1612,1613
1615,1616
1615,1617
1616,1617
1619,1620
1621,1622
1622,1623
1622,1624
1623,1624
1623,1625
1624,1625
1627,1628
1628,1629
1630,1631
1630,1632
1631,1632
1631,1633
1632,1633
1632,1634
1633,1634
1636,1637
1638,1639
1639,1640
1640,1641
1642,1643
1642,1644
1643,1644
1643,1645
1644,1645
1646,1647
1648,1649
1648,1650
1648,1651
1649,1650
1650,1651
1650,1652
1651,1652
1651,1653
1652,1653
1655,1656
1655,1657
1656,1657
1657,1658
1660,1661
1661,1662
1661,1663
1662,1663
1662,1664
1663,1664
1666,1667
1668,1669
1669,1670
1670,1671
1673,1674
1675,1676
1675,1677
1676,1677
1677,1678
1677,1679
1678,1679
1680,1681
1682,1683
1684,1685
1685,1686
1686,1687
1688,1689
1688,1690
1690,1691
1691,1692
1691,1693
1692,1693
1692,1694
1693,1694
1696,1697
1698,1699
1699,1700
1699,1701
1700,1701
1702,1703
1704,1705
1704,1706
1706,1707
1707,1708
1708,1709
1708,1710
1709,1710
1709,1711
1710,1711
1712,1713
-----nextToken-----
3,5,6,8,10,11,13,15,16,19,21,24,26,29,31,34,36,39,41,44,46,49,51,54,56,60,62,63,65,69,71,72,75,77,80,82,83,87,92,93,94,98,103,104,105,109,114,115,116,120,125,126,127,131,136,137,138,142,147,148,149,153,158,159,160,164,169,170,171,175,180,181,184,186,191,194,196,198,201,203,205,206,212,213,214,215,221,222,223,224,228,232,233,234,238,241,243,245,249,251,253,257,261,263,266,270,276,277,280,282,283,287,289,294,296,298,299,301,303,307,309,310,315,320,321,325,327,329,333,334,338,341,342,344,349,350,353,358,360,365,366,370,371,376,377,378,383,384,388,389,394,395,399,400,405,406,408,416,419,422,425,428,433,435,437,438,440,445,446,448,453,454,456,461,462,464,469,470,472,477,478,480,483,488,489,491,496,497,499,502,507,508,510,515,516,518,522,524,529,530,532,536,538,543,544,546,551,553,556,559,563,566,570,572,577,578,580,581,583,584,586,591,592,598,599,602,604,605,607,612,613,619,620,623,625,626,628,633,634,640,641,644,646,647,649,653,655,660,661,663,664,666,670,672,677,678,681,682,684,688,690,695,696,698,699,701,705,707,712,713,716,717,719,724,725,727,728,730,734,736,741,742,744,745,751,753,757,759,763,764,768,769,775,776,778,783,786,787,789,790,792,799,800,801,802,808,809,811,813,815,822,823,825,833,834,835,836,838,845,846,847,848,849,854,855,857,861,867,868,869,870,875,876,880,881,889,890,891,892,894,901,902,903,904,905,912,913,914,915,916,923,924,925,926,927,932,933,935,940,946,947,948,949,953,959,960,961,962,967,968,972,973,977,979,980,982,987,989,993,994,998,1001,1002,1007,1010,1011,1013,1014,1016,1023,1024,1025,1026,1028,1034,1035,1037,1038,1043,1045,1047,1052,1053,1054,1059,1060,1062,1067,1068,1069,1074,1075,1076,1080,1088,1089,1090,1091,1093,1099,1100,1101,1102,1104,1109,1112,1113,1115,1116,1121,1122,1123,1124,1129,1130,1131,1132,1134,1141,1142,1143,1144,1146,1152,1153,1155,1156,1161,1162,1164,1168,1174,1175,1176,1177,1186,1187,1188,1189,1191,1198,1199,1200,1201,1203,1208,1211,1212,1214,1215,1220,1221,1222,1223,1228,1229,1230,1231,1233,1240,1241,1242,1243,1245,1251,1252,1254,1258,1264,1265,1266,1267,1272,1273,1277,1278,1284,1286,1292,1294,1299,1300,1304,1305,1311,1312,1316,1317,1322,1325,1326,1328,1329,1331,1336,1337,1339,1344,1350,1351,1352,1353,1357,1363,1364,1365,1366,1373,1374,1375,1376,1377,1382,1385,1386,1388,1389,1394,1395,1396,1397,1402,1403,1404,1405,1407,1414,1415,1416,1417,1418,1423,1426,1427,1429,1430,1435,1436,1437,1438,1443,1444,1445,1446,1448,1453,1454,1458,1459,1464,1465,1467,1472,1473,1475,1480,1481,1485,1486,1487,1492,1493,1494,1499,1500,1501,1506,1507,1508,1512,1513,1516,1523,1524,1526,1531,1532,1537,1538,1539,1540,1545,1546,1551,1552,1553,1554,1559,1560,1562,1567,1569,1573,1575,1578,1580,1581,1586,1587,1590,1596,1597,1601,1602,1604,1608,1613,1614,1617,1618,1620,1625,1626,1629,1634,1635,1637,1641,1645,1647,1653,1654,1658,1659,1664,1665,1667,1671,1672,1674,1679,1681,1683,1687,1689,1694,1695,1697,1701,1703,1705,1711,1713,1714
-----computeFrom-----
88,89
88,90
99,100
99,101
110,111
110,112
121,122
121,123
132,133
132,134
143,144
143,145
154,155
154,156
165,166
165,167
176,177
176,178
208,209
208,210
217,218
217,219
229,230
229,231
236,237
236,238
247,248
247,249
255,256
255,257
271,272
271,273
272,273
272,274
285,286
285,287
317,318
317,319
322,323
322,324
346,347
346,348
351,352
351,353
356,357
356,358
362,363
362,364
367,368
367,369
373,374
373,375
380,381
380,382
385,386
385,387
391,392
391,393
396,397
396,398
402,403
402,404
410,411
410,412
411,412
411,413
412,413
412,414
413,414
413,415
442,443
442,444
450,451
450,452
458,459
458,460
466,467
466,468
474,475
474,476
485,486
485,487
493,494
493,495
504,505
504,506
512,513
512,514
526,527
526,528
534,535
534,536
540,541
540,542
549,550
549,551
568,569
568,570
574,575
574,576
588,589
588,590
593,594
593,595
595,596
595,597
609,610
609,611
614,615
614,616
616,617
616,618
630,631
630,632
635,636
635,637
637,638
637,639
651,652
651,653
657,658
657,659
668,669
668,670
674,675
674,676
686,687
686,688
692,693
692,694
703,704
703,705
709,710
709,711
721,722
721,723
732,733
732,734
738,739
738,740
747,748
747,749
749,750
749,751
772,773
772,774
794,795
794,796
805,806
805,807
819,820
819,821
828,829
828,830
840,841
840,842
851,852
851,853
872,873
872,874
884,885
884,886
896,897
896,898
907,908
907,909
918,919
918,920
929,930
929,931
964,965
964,966
1018,1019
1018,1020
1031,1032
1031,1033
1049,1050
1049,1051
1056,1057
1056,1058
1064,1065
1064,1066
1071,1072
1071,1073
1082,1083
1082,1084
1083,1084
1083,1085
1094,1095
1094,1096
1136,1137
1136,1138
1149,1150
1149,1151
1158,1159
1158,1160
1179,1180
1179,1181
1181,1182
1181,1183
1193,1194
1193,1195
1235,1236
1235,1237
1248,1249
1248,1250
1269,1270
1269,1271
1288,1289
1288,1290
1307,1308
1307,1309
1333,1334
1333,1335
1368,1369
1368,1370
1409,1410
1409,1411
1450,1451
1450,1452
1461,1462
1461,1463
1469,1470
1469,1471
1477,1478
1477,1479
1482,1483
1482,1484
1489,1490
1489,1491
1496,1497
1496,1498
1503,1504
1503,1505
1520,1521
1520,1522
1528,1529
1528,1530
1542,1543
1542,1544
1556,1557
1556,1558
1593,1594
1593,1595
1609,1610
1609,1611
1622,1623
1622,1624
1631,1632
1631,1633
1650,1651
1650,1652
1655,1656
1655,1657
1661,1662
1661,1663
1691,1692
1691,1693
-----guardedBy-----
763,1080
768,880
764,1024
775,786
854,867
932,959
1023,1034
1099,1129
1101,1131
1102,1132
1100,1130
1141,1152
1161,1174
1198,1228
1200,1230
1201,1231
1199,1229
1240,1272
1241,1265
1251,1264
1336,1363
1373,1402
1375,1404
1374,1403
1376,1405
1414,1443
1416,1445
1417,1446
1415,1444
1559,1625
1560,1626
1562,1629
1634,1641
-----guardedByNegation-----
1240,1464
1241,1444
-----lastLexicalUse-----
1240,1464
1241,1444
-----jump-----
1240,1464
1241,1444
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;CompoundStatement;DeclarationStatement;SimpleDeclaration;CompositeTypeSpecifier;Name;SimpleDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;Declarator;Name;ImplicitName;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;SwitchStatement;UnaryExpression;IdExpression;Name;CompoundStatement;CaseStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;UnaryExpression;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;SwitchStatement;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;CaseStatement;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;Pointer;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;BreakStatement;CaseStatement;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ReturnStatement;UnaryExpression;IdExpression;Name;LabelStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LabelStatement;Name;ReturnStatement;UnaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;LiteralExpression;
-----ast_node-----
TIFF*TIFFClientOpen(	const char* name, const char* mode,	thandle_t clientdata,	TIFFReadWriteProc readproc,	TIFFReadWriteProc writeproc,	TIFFSeekProc seekproc,	TIFFCloseProc closeproc,	TIFFSizeProc sizeproc,	TIFFMapFileProc mapproc,	TIFFUnmapFileProc unmapproc){	static const char module[] = "TIFFClientOpen";	TIFF *tif;	int m;	const char* cp;	/* The following are configuration checks. They should be redundant, but should not	 * compile to any actual code in an optimised release build anyway. If any of them	 * fail, (makefile-based or other) configuration is not correct */	assert(sizeof(uint8)==1);	assert(sizeof(int8)==1);	assert(sizeof(uint16)==2);	assert(sizeof(int16)==2);	assert(sizeof(uint32)==4);	assert(sizeof(int32)==4);	assert(sizeof(uint64)==8);	assert(sizeof(int64)==8);	assert(sizeof(tmsize_t)==sizeof(void*));	{		union{			uint8 a8[2];			uint16 a16;		} n;		n.a8[0]=1;		n.a8[1]=0;		#ifdef WORDS_BIGENDIAN		assert(n.a16==256);		#else		assert(n.a16==1);		#endif	}	m = _TIFFgetMode(mode, module);	if (m == -1)		goto bad2;	tif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));	if (tif == NULL) {		TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);		goto bad2;	}	_TIFFmemset(tif, 0, sizeof (*tif));	tif->tif_name = (char *)tif + sizeof (TIFF);	strcpy(tif->tif_name, name);	tif->tif_mode = m &~ (O_CREAT|O_TRUNC);	tif->tif_curdir = (uint16) -1;		/* non-existent directory */	tif->tif_curoff = 0;	tif->tif_curstrip = (uint32) -1;	/* invalid strip */	tif->tif_row = (uint32) -1;		/* read/write pre-increment */	tif->tif_clientdata = clientdata;	if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {		TIFFErrorExt(clientdata, module,		    "One of the client procedures is NULL pointer.");		goto bad2;	}	tif->tif_readproc = readproc;	tif->tif_writeproc = writeproc;	tif->tif_seekproc = seekproc;	tif->tif_closeproc = closeproc;	tif->tif_sizeproc = sizeproc;	if (mapproc)		tif->tif_mapproc = mapproc;	else		tif->tif_mapproc = _tiffDummyMapProc;	if (unmapproc)		tif->tif_unmapproc = unmapproc;	else		tif->tif_unmapproc = _tiffDummyUnmapProc;	_TIFFSetDefaultCompressionState(tif);    /* setup default state */	/*	 * Default is to return data MSB2LSB and enable the	 * use of memory-mapped files and strip chopping when	 * a file is opened read-only.	 */	tif->tif_flags = FILLORDER_MSB2LSB;	if (m == O_RDONLY )		tif->tif_flags |= TIFF_MAPPED;	#ifdef STRIPCHOP_DEFAULT	if (m == O_RDONLY || m == O_RDWR)		tif->tif_flags |= STRIPCHOP_DEFAULT;	#endif	/*	 * Process library-specific flags in the open mode string.	 * The following flags may be used to control intrinsic library	 * behaviour that may or may not be desirable (usually for	 * compatibility with some application that claims to support	 * TIFF but only supports some brain dead idea of what the	 * vendor thinks TIFF is):	 *	 * 'l' use little-endian byte order for creating a file	 * 'b' use big-endian byte order for creating a file	 * 'L' read/write information using LSB2MSB bit order	 * 'B' read/write information using MSB2LSB bit order	 * 'H' read/write information using host bit order	 * 'M' enable use of memory-mapped files when supported	 * 'm' disable use of memory-mapped files	 * 'C' enable strip chopping support when reading	 * 'c' disable strip chopping support	 * 'h' read TIFF header only, do not load the first IFD	 * '4' ClassicTIFF for creating a file (default)	 * '8' BigTIFF for creating a file	 *	 * The use of the 'l' and 'b' flags is strongly discouraged.	 * These flags are provided solely because numerous vendors,	 * typically on the PC, do not correctly support TIFF; they	 * only support the Intel little-endian byte order.  This	 * support is not configured by default because it supports	 * the violation of the TIFF spec that says that readers *MUST*	 * support both byte orders.  It is strongly recommended that	 * you not use this feature except to deal with busted apps	 * that write invalid TIFF.  And even in those cases you should	 * bang on the vendors to fix their software.	 *	 * The 'L', 'B', and 'H' flags are intended for applications	 * that can optimize operations on data by using a particular	 * bit order.  By default the library returns data in MSB2LSB	 * bit order for compatibility with older versions of this	 * library.  Returning data in the bit order of the native CPU	 * makes the most sense but also requires applications to check	 * the value of the FillOrder tag; something they probably do	 * not do right now.	 *	 * The 'M' and 'm' flags are provided because some virtual memory	 * systems exhibit poor behaviour when large images are mapped.	 * These options permit clients to control the use of memory-mapped	 * files on a per-file basis.	 *	 * The 'C' and 'c' flags are provided because the library support	 * for chopping up large strips into multiple smaller strips is not	 * application-transparent and as such can cause problems.  The 'c'	 * option permits applications that only want to look at the tags,	 * for example, to get the unadulterated TIFF tag information.	 */	for (cp = mode; *cp; cp++)		switch (*cp) {			case 'b':				#ifndef WORDS_BIGENDIAN				if (m&O_CREAT)					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'l':				#ifdef WORDS_BIGENDIAN				if ((m&O_CREAT))					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'B':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB;				break;			case 'L':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB;				break;			case 'H':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER;				break;			case 'M':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_MAPPED;				break;			case 'm':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_MAPPED;				break;			case 'C':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_STRIPCHOP;				break;			case 'c':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_STRIPCHOP;				break;			case 'h':				tif->tif_flags |= TIFF_HEADERONLY;				break;			case '8':				if (m&O_CREAT)					tif->tif_flags |= TIFF_BIGTIFF;				break;		}	/*	 * Read in TIFF header.	 */	if ((m & O_TRUNC) ||	    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {		if (tif->tif_mode == O_RDONLY) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		/*		 * Setup header and write.		 */		#ifdef WORDS_BIGENDIAN		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;		#else		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;		#endif		if (!(tif->tif_flags&TIFF_BIGTIFF))		{			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;			tif->tif_header.classic.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);			tif->tif_header_size = sizeof(TIFFHeaderClassic);		}		else		{			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;			tif->tif_header.big.tiff_offsetsize = 8;			tif->tif_header.big.tiff_unused = 0;			tif->tif_header.big.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}			tif->tif_header_size = sizeof (TIFFHeaderBig);		}		/*		 * The doc for "fopen" for some STD_C_LIBs says that if you		 * open a file for modify ("+"), then you must fseek (or		 * fflush?) between any freads and fwrites.  This is not		 * necessary on most systems, but has been shown to be needed		 * on Solaris.		 */		TIFFSeekFile( tif, 0, SEEK_SET );		if (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");			goto bad;		}		/*		 * Setup the byte order handling.		 */		if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {			#ifndef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		} else {			#ifdef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}		/*		 * Setup default directory.		 */		if (!TIFFDefaultDirectory(tif))			goto bad;		tif->tif_diroff = 0;		tif->tif_dirlist = NULL;		tif->tif_dirlistsize = 0;		tif->tif_dirnumber = 0;		return (tif);	}	/*	 * Setup the byte order handling.	 */	if (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&	    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN	    #if MDI_SUPPORT	    &&	    #if HOST_BIGENDIAN	    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN	    #else	    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN	    #endif	    ) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF or MDI file, bad magic number %d (0x%x)",	    #else	    ) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad magic number %d (0x%x)",	    #endif		    tif->tif_header.common.tiff_magic,		    tif->tif_header.common.tiff_magic);		goto bad;	}	if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {		#ifndef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	} else {		#ifdef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	}	if (tif->tif_flags & TIFF_SWAB) 		TIFFSwabShort(&tif->tif_header.common.tiff_version);	if ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&	    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad version number %d (0x%x)",		    tif->tif_header.common.tiff_version,		    tif->tif_header.common.tiff_version);		goto bad;	}	if (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)	{		if (tif->tif_flags & TIFF_SWAB)			TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);		tif->tif_header_size = sizeof(TIFFHeaderClassic);	}	else	{		if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		if (tif->tif_flags & TIFF_SWAB)		{			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);		}		if (tif->tif_header.big.tiff_offsetsize != 8)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);			goto bad;		}		if (tif->tif_header.big.tiff_unused != 0)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);			goto bad;		}		tif->tif_header_size = sizeof(TIFFHeaderBig);		tif->tif_flags |= TIFF_BIGTIFF;	}	tif->tif_flags |= TIFF_MYBUFFER;	tif->tif_rawcp = tif->tif_rawdata = 0;	tif->tif_rawdatasize = 0;        tif->tif_rawdataoff = 0;        tif->tif_rawdataloaded = 0;	switch (mode[0]) {		case 'r':			if (!(tif->tif_flags&TIFF_BIGTIFF))				tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;			else				tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;			/*			 * Try to use a memory-mapped file if the client			 * has not explicitly suppressed usage with the			 * 'm' flag in the open mode (see above).			 */			if (tif->tif_flags & TIFF_MAPPED)			{				toff_t n;				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;			}			/*			 * Sometimes we do not want to read the first directory (for example,			 * it may be broken) and want to proceed to other directories. I this			 * case we use the TIFF_HEADERONLY flag to open file and return			 * immediately after reading TIFF header.			 */			if (tif->tif_flags & TIFF_HEADERONLY)				return (tif);			/*			 * Setup initial directory.			 */			if (TIFFReadDirectory(tif)) {				tif->tif_rawcc = (tmsize_t)-1;				tif->tif_flags |= TIFF_BUFFERSETUP;				return (tif);			}			break;		case 'a':			/*			 * New directories are automatically append			 * to the end of the directory chain when they			 * are written out (see TIFFWriteDirectory).			 */			if (!TIFFDefaultDirectory(tif))				goto bad;			return (tif);	}bad:	tif->tif_mode = O_RDONLY;	/* XXX avoid flush */        TIFFCleanup(tif);bad2:	return ((TIFF*)0);}
TIFF
TIFF
*TIFFClientOpen(	const char* name, const char* mode,	thandle_t clientdata,	TIFFReadWriteProc readproc,	TIFFReadWriteProc writeproc,	TIFFSeekProc seekproc,	TIFFCloseProc closeproc,	TIFFSizeProc sizeproc,	TIFFMapFileProc mapproc,	TIFFUnmapFileProc unmapproc)
*
TIFFClientOpen
const char* name
const char
* name
*
name
const char* mode
const char
* mode
*
mode
thandle_t clientdata
thandle_t
thandle_t
clientdata
clientdata
TIFFReadWriteProc readproc
TIFFReadWriteProc
TIFFReadWriteProc
readproc
readproc
TIFFReadWriteProc writeproc
TIFFReadWriteProc
TIFFReadWriteProc
writeproc
writeproc
TIFFSeekProc seekproc
TIFFSeekProc
TIFFSeekProc
seekproc
seekproc
TIFFCloseProc closeproc
TIFFCloseProc
TIFFCloseProc
closeproc
closeproc
TIFFSizeProc sizeproc
TIFFSizeProc
TIFFSizeProc
sizeproc
sizeproc
TIFFMapFileProc mapproc
TIFFMapFileProc
TIFFMapFileProc
mapproc
mapproc
TIFFUnmapFileProc unmapproc
TIFFUnmapFileProc
TIFFUnmapFileProc
unmapproc
unmapproc
{	static const char module[] = "TIFFClientOpen";	TIFF *tif;	int m;	const char* cp;	/* The following are configuration checks. They should be redundant, but should not	 * compile to any actual code in an optimised release build anyway. If any of them	 * fail, (makefile-based or other) configuration is not correct */	assert(sizeof(uint8)==1);	assert(sizeof(int8)==1);	assert(sizeof(uint16)==2);	assert(sizeof(int16)==2);	assert(sizeof(uint32)==4);	assert(sizeof(int32)==4);	assert(sizeof(uint64)==8);	assert(sizeof(int64)==8);	assert(sizeof(tmsize_t)==sizeof(void*));	{		union{			uint8 a8[2];			uint16 a16;		} n;		n.a8[0]=1;		n.a8[1]=0;		#ifdef WORDS_BIGENDIAN		assert(n.a16==256);		#else		assert(n.a16==1);		#endif	}	m = _TIFFgetMode(mode, module);	if (m == -1)		goto bad2;	tif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));	if (tif == NULL) {		TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);		goto bad2;	}	_TIFFmemset(tif, 0, sizeof (*tif));	tif->tif_name = (char *)tif + sizeof (TIFF);	strcpy(tif->tif_name, name);	tif->tif_mode = m &~ (O_CREAT|O_TRUNC);	tif->tif_curdir = (uint16) -1;		/* non-existent directory */	tif->tif_curoff = 0;	tif->tif_curstrip = (uint32) -1;	/* invalid strip */	tif->tif_row = (uint32) -1;		/* read/write pre-increment */	tif->tif_clientdata = clientdata;	if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {		TIFFErrorExt(clientdata, module,		    "One of the client procedures is NULL pointer.");		goto bad2;	}	tif->tif_readproc = readproc;	tif->tif_writeproc = writeproc;	tif->tif_seekproc = seekproc;	tif->tif_closeproc = closeproc;	tif->tif_sizeproc = sizeproc;	if (mapproc)		tif->tif_mapproc = mapproc;	else		tif->tif_mapproc = _tiffDummyMapProc;	if (unmapproc)		tif->tif_unmapproc = unmapproc;	else		tif->tif_unmapproc = _tiffDummyUnmapProc;	_TIFFSetDefaultCompressionState(tif);    /* setup default state */	/*	 * Default is to return data MSB2LSB and enable the	 * use of memory-mapped files and strip chopping when	 * a file is opened read-only.	 */	tif->tif_flags = FILLORDER_MSB2LSB;	if (m == O_RDONLY )		tif->tif_flags |= TIFF_MAPPED;	#ifdef STRIPCHOP_DEFAULT	if (m == O_RDONLY || m == O_RDWR)		tif->tif_flags |= STRIPCHOP_DEFAULT;	#endif	/*	 * Process library-specific flags in the open mode string.	 * The following flags may be used to control intrinsic library	 * behaviour that may or may not be desirable (usually for	 * compatibility with some application that claims to support	 * TIFF but only supports some brain dead idea of what the	 * vendor thinks TIFF is):	 *	 * 'l' use little-endian byte order for creating a file	 * 'b' use big-endian byte order for creating a file	 * 'L' read/write information using LSB2MSB bit order	 * 'B' read/write information using MSB2LSB bit order	 * 'H' read/write information using host bit order	 * 'M' enable use of memory-mapped files when supported	 * 'm' disable use of memory-mapped files	 * 'C' enable strip chopping support when reading	 * 'c' disable strip chopping support	 * 'h' read TIFF header only, do not load the first IFD	 * '4' ClassicTIFF for creating a file (default)	 * '8' BigTIFF for creating a file	 *	 * The use of the 'l' and 'b' flags is strongly discouraged.	 * These flags are provided solely because numerous vendors,	 * typically on the PC, do not correctly support TIFF; they	 * only support the Intel little-endian byte order.  This	 * support is not configured by default because it supports	 * the violation of the TIFF spec that says that readers *MUST*	 * support both byte orders.  It is strongly recommended that	 * you not use this feature except to deal with busted apps	 * that write invalid TIFF.  And even in those cases you should	 * bang on the vendors to fix their software.	 *	 * The 'L', 'B', and 'H' flags are intended for applications	 * that can optimize operations on data by using a particular	 * bit order.  By default the library returns data in MSB2LSB	 * bit order for compatibility with older versions of this	 * library.  Returning data in the bit order of the native CPU	 * makes the most sense but also requires applications to check	 * the value of the FillOrder tag; something they probably do	 * not do right now.	 *	 * The 'M' and 'm' flags are provided because some virtual memory	 * systems exhibit poor behaviour when large images are mapped.	 * These options permit clients to control the use of memory-mapped	 * files on a per-file basis.	 *	 * The 'C' and 'c' flags are provided because the library support	 * for chopping up large strips into multiple smaller strips is not	 * application-transparent and as such can cause problems.  The 'c'	 * option permits applications that only want to look at the tags,	 * for example, to get the unadulterated TIFF tag information.	 */	for (cp = mode; *cp; cp++)		switch (*cp) {			case 'b':				#ifndef WORDS_BIGENDIAN				if (m&O_CREAT)					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'l':				#ifdef WORDS_BIGENDIAN				if ((m&O_CREAT))					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'B':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB;				break;			case 'L':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB;				break;			case 'H':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER;				break;			case 'M':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_MAPPED;				break;			case 'm':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_MAPPED;				break;			case 'C':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_STRIPCHOP;				break;			case 'c':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_STRIPCHOP;				break;			case 'h':				tif->tif_flags |= TIFF_HEADERONLY;				break;			case '8':				if (m&O_CREAT)					tif->tif_flags |= TIFF_BIGTIFF;				break;		}	/*	 * Read in TIFF header.	 */	if ((m & O_TRUNC) ||	    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {		if (tif->tif_mode == O_RDONLY) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		/*		 * Setup header and write.		 */		#ifdef WORDS_BIGENDIAN		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;		#else		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;		#endif		if (!(tif->tif_flags&TIFF_BIGTIFF))		{			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;			tif->tif_header.classic.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);			tif->tif_header_size = sizeof(TIFFHeaderClassic);		}		else		{			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;			tif->tif_header.big.tiff_offsetsize = 8;			tif->tif_header.big.tiff_unused = 0;			tif->tif_header.big.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}			tif->tif_header_size = sizeof (TIFFHeaderBig);		}		/*		 * The doc for "fopen" for some STD_C_LIBs says that if you		 * open a file for modify ("+"), then you must fseek (or		 * fflush?) between any freads and fwrites.  This is not		 * necessary on most systems, but has been shown to be needed		 * on Solaris.		 */		TIFFSeekFile( tif, 0, SEEK_SET );		if (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");			goto bad;		}		/*		 * Setup the byte order handling.		 */		if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {			#ifndef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		} else {			#ifdef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}		/*		 * Setup default directory.		 */		if (!TIFFDefaultDirectory(tif))			goto bad;		tif->tif_diroff = 0;		tif->tif_dirlist = NULL;		tif->tif_dirlistsize = 0;		tif->tif_dirnumber = 0;		return (tif);	}	/*	 * Setup the byte order handling.	 */	if (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&	    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN	    #if MDI_SUPPORT	    &&	    #if HOST_BIGENDIAN	    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN	    #else	    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN	    #endif	    ) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF or MDI file, bad magic number %d (0x%x)",	    #else	    ) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad magic number %d (0x%x)",	    #endif		    tif->tif_header.common.tiff_magic,		    tif->tif_header.common.tiff_magic);		goto bad;	}	if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {		#ifndef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	} else {		#ifdef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	}	if (tif->tif_flags & TIFF_SWAB) 		TIFFSwabShort(&tif->tif_header.common.tiff_version);	if ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&	    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad version number %d (0x%x)",		    tif->tif_header.common.tiff_version,		    tif->tif_header.common.tiff_version);		goto bad;	}	if (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)	{		if (tif->tif_flags & TIFF_SWAB)			TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);		tif->tif_header_size = sizeof(TIFFHeaderClassic);	}	else	{		if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		if (tif->tif_flags & TIFF_SWAB)		{			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);		}		if (tif->tif_header.big.tiff_offsetsize != 8)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);			goto bad;		}		if (tif->tif_header.big.tiff_unused != 0)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);			goto bad;		}		tif->tif_header_size = sizeof(TIFFHeaderBig);		tif->tif_flags |= TIFF_BIGTIFF;	}	tif->tif_flags |= TIFF_MYBUFFER;	tif->tif_rawcp = tif->tif_rawdata = 0;	tif->tif_rawdatasize = 0;        tif->tif_rawdataoff = 0;        tif->tif_rawdataloaded = 0;	switch (mode[0]) {		case 'r':			if (!(tif->tif_flags&TIFF_BIGTIFF))				tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;			else				tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;			/*			 * Try to use a memory-mapped file if the client			 * has not explicitly suppressed usage with the			 * 'm' flag in the open mode (see above).			 */			if (tif->tif_flags & TIFF_MAPPED)			{				toff_t n;				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;			}			/*			 * Sometimes we do not want to read the first directory (for example,			 * it may be broken) and want to proceed to other directories. I this			 * case we use the TIFF_HEADERONLY flag to open file and return			 * immediately after reading TIFF header.			 */			if (tif->tif_flags & TIFF_HEADERONLY)				return (tif);			/*			 * Setup initial directory.			 */			if (TIFFReadDirectory(tif)) {				tif->tif_rawcc = (tmsize_t)-1;				tif->tif_flags |= TIFF_BUFFERSETUP;				return (tif);			}			break;		case 'a':			/*			 * New directories are automatically append			 * to the end of the directory chain when they			 * are written out (see TIFFWriteDirectory).			 */			if (!TIFFDefaultDirectory(tif))				goto bad;			return (tif);	}bad:	tif->tif_mode = O_RDONLY;	/* XXX avoid flush */        TIFFCleanup(tif);bad2:	return ((TIFF*)0);}
static const char module[] = "TIFFClientOpen";
static const char module[] = "TIFFClientOpen";
static const char
module[] = "TIFFClientOpen"
module
[]
= "TIFFClientOpen"
"TIFFClientOpen"
TIFF *tif;
TIFF *tif;
TIFF
TIFF
*tif
*
tif
int m;
int m;
int
m
m
const char* cp;
const char* cp;
const char
* cp
*
cp
assert(sizeof(uint8)==1);
assert(sizeof(uint8)==1)
assert
assert
sizeof(uint8)==1
sizeof(uint8)
uint8
uint8
uint8

1
assert(sizeof(int8)==1);
assert(sizeof(int8)==1)
assert
assert
sizeof(int8)==1
sizeof(int8)
int8
int8
int8

1
assert(sizeof(uint16)==2);
assert(sizeof(uint16)==2)
assert
assert
sizeof(uint16)==2
sizeof(uint16)
uint16
uint16
uint16

2
assert(sizeof(int16)==2);
assert(sizeof(int16)==2)
assert
assert
sizeof(int16)==2
sizeof(int16)
int16
int16
int16

2
assert(sizeof(uint32)==4);
assert(sizeof(uint32)==4)
assert
assert
sizeof(uint32)==4
sizeof(uint32)
uint32
uint32
uint32

4
assert(sizeof(int32)==4);
assert(sizeof(int32)==4)
assert
assert
sizeof(int32)==4
sizeof(int32)
int32
int32
int32

4
assert(sizeof(uint64)==8);
assert(sizeof(uint64)==8)
assert
assert
sizeof(uint64)==8
sizeof(uint64)
uint64
uint64
uint64

8
assert(sizeof(int64)==8);
assert(sizeof(int64)==8)
assert
assert
sizeof(int64)==8
sizeof(int64)
int64
int64
int64

8
assert(sizeof(tmsize_t)==sizeof(void*));
assert(sizeof(tmsize_t)==sizeof(void*))
assert
assert
sizeof(tmsize_t)==sizeof(void*)
sizeof(tmsize_t)
tmsize_t
tmsize_t
tmsize_t

sizeof(void*)
void*
void
*
*
{		union{			uint8 a8[2];			uint16 a16;		} n;		n.a8[0]=1;		n.a8[1]=0;		#ifdef WORDS_BIGENDIAN		assert(n.a16==256);		#else		assert(n.a16==1);		#endif	}
union{			uint8 a8[2];			uint16 a16;		} n;
union{			uint8 a8[2];			uint16 a16;		} n;
union{			uint8 a8[2];			uint16 a16;		}

uint8 a8[2];
uint8
uint8
a8[2]
a8
[2]
2
uint16 a16;
uint16
uint16
a16
a16
n
n
n
n.a8[0]=1;
n.a8[0]=1
n.a8[0]
n.a8
n
n
a8
0
1
n.a8[1]=0;
n.a8[1]=0
n.a8[1]
n.a8
n
n
a8
1
0
assert(n.a16==1);
assert(n.a16==1)
assert
assert
n.a16==1
n.a16
n
n
a16
1
m = _TIFFgetMode(mode, module);
m = _TIFFgetMode(mode, module)
m
m
_TIFFgetMode(mode, module)
_TIFFgetMode
_TIFFgetMode
mode
mode
module
module
if (m == -1)		goto bad2;
m == -1
m
m
-1
1
goto bad2;
bad2
tif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));
tif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1))
tif
tif
(TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1))
TIFF *
TIFF
TIFF
*
*
_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1))
_TIFFmalloc
_TIFFmalloc
(tmsize_t)(sizeof (TIFF) + strlen(name) + 1)
(tmsize_t)
tmsize_t
tmsize_t
sizeof (TIFF) + strlen(name) + 1
sizeof (TIFF) + strlen(name)
sizeof (TIFF)
TIFF
TIFF
TIFF

strlen(name)
strlen
strlen
name
name
1
if (tif == NULL) {		TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);		goto bad2;	}
tif == NULL
tif
tif
NULL
NULL
{		TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);		goto bad2;	}
TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name);
TIFFErrorExt(clientdata, module, "%s: Out of memory (TIFF structure)", name)
TIFFErrorExt
TIFFErrorExt
clientdata
clientdata
module
module
"%s: Out of memory (TIFF structure)"
name
name
goto bad2;
bad2
_TIFFmemset(tif, 0, sizeof (*tif));
_TIFFmemset(tif, 0, sizeof (*tif))
_TIFFmemset
_TIFFmemset
tif
tif
0
sizeof (*tif)
(*tif)
*tif
tif
tif
tif->tif_name = (char *)tif + sizeof (TIFF);
tif->tif_name = (char *)tif + sizeof (TIFF)
tif->tif_name
tif
tif
tif_name
(char *)tif + sizeof (TIFF)
(char *)tif
char *
char
*
*
tif
tif
sizeof (TIFF)
TIFF
TIFF
TIFF

strcpy(tif->tif_name, name);
strcpy(tif->tif_name, name)
strcpy
strcpy
tif->tif_name
tif
tif
tif_name
name
name
tif->tif_mode = m &~ (O_CREAT|O_TRUNC);
tif->tif_mode = m &~ (O_CREAT|O_TRUNC)
tif->tif_mode
tif
tif
tif_mode
m &~ (O_CREAT|O_TRUNC)
m
m
~ (O_CREAT|O_TRUNC)
(O_CREAT|O_TRUNC)
O_CREAT|O_TRUNC
O_CREAT
O_CREAT
O_TRUNC
O_TRUNC
tif->tif_curdir = (uint16) -1;
tif->tif_curdir = (uint16) -1
tif->tif_curdir
tif
tif
tif_curdir
(uint16) -1
(uint16)
uint16
uint16
1
tif->tif_curoff = 0;
tif->tif_curoff = 0
tif->tif_curoff
tif
tif
tif_curoff
0
tif->tif_curstrip = (uint32) -1;
tif->tif_curstrip = (uint32) -1
tif->tif_curstrip
tif
tif
tif_curstrip
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_row = (uint32) -1;
tif->tif_row = (uint32) -1
tif->tif_row
tif
tif
tif_row
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_clientdata = clientdata;
tif->tif_clientdata = clientdata
tif->tif_clientdata
tif
tif
tif_clientdata
clientdata
clientdata
if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {		TIFFErrorExt(clientdata, module,		    "One of the client procedures is NULL pointer.");		goto bad2;	}
!readproc || !writeproc || !seekproc || !closeproc || !sizeproc
!readproc || !writeproc || !seekproc || !closeproc
!readproc || !writeproc || !seekproc
!readproc || !writeproc
!readproc
readproc
readproc
!writeproc
writeproc
writeproc
!seekproc
seekproc
seekproc
!closeproc
closeproc
closeproc
!sizeproc
sizeproc
sizeproc
{		TIFFErrorExt(clientdata, module,		    "One of the client procedures is NULL pointer.");		goto bad2;	}
TIFFErrorExt(clientdata, module,		    "One of the client procedures is NULL pointer.");
TIFFErrorExt(clientdata, module,		    "One of the client procedures is NULL pointer.")
TIFFErrorExt
TIFFErrorExt
clientdata
clientdata
module
module
"One of the client procedures is NULL pointer."
goto bad2;
bad2
tif->tif_readproc = readproc;
tif->tif_readproc = readproc
tif->tif_readproc
tif
tif
tif_readproc
readproc
readproc
tif->tif_writeproc = writeproc;
tif->tif_writeproc = writeproc
tif->tif_writeproc
tif
tif
tif_writeproc
writeproc
writeproc
tif->tif_seekproc = seekproc;
tif->tif_seekproc = seekproc
tif->tif_seekproc
tif
tif
tif_seekproc
seekproc
seekproc
tif->tif_closeproc = closeproc;
tif->tif_closeproc = closeproc
tif->tif_closeproc
tif
tif
tif_closeproc
closeproc
closeproc
tif->tif_sizeproc = sizeproc;
tif->tif_sizeproc = sizeproc
tif->tif_sizeproc
tif
tif
tif_sizeproc
sizeproc
sizeproc
if (mapproc)		tif->tif_mapproc = mapproc;	else		tif->tif_mapproc = _tiffDummyMapProc;
mapproc
mapproc
tif->tif_mapproc = mapproc;
tif->tif_mapproc = mapproc
tif->tif_mapproc
tif
tif
tif_mapproc
mapproc
mapproc
tif->tif_mapproc = _tiffDummyMapProc;
tif->tif_mapproc = _tiffDummyMapProc
tif->tif_mapproc
tif
tif
tif_mapproc
_tiffDummyMapProc
_tiffDummyMapProc
if (unmapproc)		tif->tif_unmapproc = unmapproc;	else		tif->tif_unmapproc = _tiffDummyUnmapProc;
unmapproc
unmapproc
tif->tif_unmapproc = unmapproc;
tif->tif_unmapproc = unmapproc
tif->tif_unmapproc
tif
tif
tif_unmapproc
unmapproc
unmapproc
tif->tif_unmapproc = _tiffDummyUnmapProc;
tif->tif_unmapproc = _tiffDummyUnmapProc
tif->tif_unmapproc
tif
tif
tif_unmapproc
_tiffDummyUnmapProc
_tiffDummyUnmapProc
_TIFFSetDefaultCompressionState(tif);
_TIFFSetDefaultCompressionState(tif)
_TIFFSetDefaultCompressionState
_TIFFSetDefaultCompressionState
tif
tif
tif->tif_flags = FILLORDER_MSB2LSB;
tif->tif_flags = FILLORDER_MSB2LSB
tif->tif_flags
tif
tif
tif_flags
FILLORDER_MSB2LSB
FILLORDER_MSB2LSB
if (m == O_RDONLY )		tif->tif_flags |= TIFF_MAPPED;
m == O_RDONLY
m
m
O_RDONLY
O_RDONLY
tif->tif_flags |= TIFF_MAPPED;
tif->tif_flags |= TIFF_MAPPED
tif->tif_flags
tif
tif
tif_flags
TIFF_MAPPED
TIFF_MAPPED
for (cp = mode; *cp; cp++)		switch (*cp) {			case 'b':				#ifndef WORDS_BIGENDIAN				if (m&O_CREAT)					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'l':				#ifdef WORDS_BIGENDIAN				if ((m&O_CREAT))					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'B':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB;				break;			case 'L':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB;				break;			case 'H':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER;				break;			case 'M':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_MAPPED;				break;			case 'm':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_MAPPED;				break;			case 'C':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_STRIPCHOP;				break;			case 'c':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_STRIPCHOP;				break;			case 'h':				tif->tif_flags |= TIFF_HEADERONLY;				break;			case '8':				if (m&O_CREAT)					tif->tif_flags |= TIFF_BIGTIFF;				break;		}
cp = mode;
cp = mode
cp
cp
mode
mode
*cp
cp
cp
cp++
cp
cp
switch (*cp) {			case 'b':				#ifndef WORDS_BIGENDIAN				if (m&O_CREAT)					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'l':				#ifdef WORDS_BIGENDIAN				if ((m&O_CREAT))					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'B':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB;				break;			case 'L':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB;				break;			case 'H':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER;				break;			case 'M':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_MAPPED;				break;			case 'm':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_MAPPED;				break;			case 'C':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_STRIPCHOP;				break;			case 'c':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_STRIPCHOP;				break;			case 'h':				tif->tif_flags |= TIFF_HEADERONLY;				break;			case '8':				if (m&O_CREAT)					tif->tif_flags |= TIFF_BIGTIFF;				break;		}
*cp
cp
cp
{			case 'b':				#ifndef WORDS_BIGENDIAN				if (m&O_CREAT)					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'l':				#ifdef WORDS_BIGENDIAN				if ((m&O_CREAT))					tif->tif_flags |= TIFF_SWAB;				#endif				break;			case 'B':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB;				break;			case 'L':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB;				break;			case 'H':				tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER;				break;			case 'M':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_MAPPED;				break;			case 'm':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_MAPPED;				break;			case 'C':				if (m == O_RDONLY)					tif->tif_flags |= TIFF_STRIPCHOP;				break;			case 'c':				if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_STRIPCHOP;				break;			case 'h':				tif->tif_flags |= TIFF_HEADERONLY;				break;			case '8':				if (m&O_CREAT)					tif->tif_flags |= TIFF_BIGTIFF;				break;		}
case 'b':
'b'
if (m&O_CREAT)					tif->tif_flags |= TIFF_SWAB;
m&O_CREAT
m
m
O_CREAT
O_CREAT
tif->tif_flags |= TIFF_SWAB;
tif->tif_flags |= TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
break;
case 'l':
'l'
break;
case 'B':
'B'
tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB;
tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB
tif->tif_flags
tif
tif
tif_flags
(tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_MSB2LSB
(tif->tif_flags &~ TIFF_FILLORDER)
tif->tif_flags &~ TIFF_FILLORDER
tif->tif_flags
tif
tif
tif_flags
~ TIFF_FILLORDER
TIFF_FILLORDER
TIFF_FILLORDER
FILLORDER_MSB2LSB
FILLORDER_MSB2LSB
break;
case 'L':
'L'
tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB;
tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB
tif->tif_flags
tif
tif
tif_flags
(tif->tif_flags &~ TIFF_FILLORDER) |				    FILLORDER_LSB2MSB
(tif->tif_flags &~ TIFF_FILLORDER)
tif->tif_flags &~ TIFF_FILLORDER
tif->tif_flags
tif
tif
tif_flags
~ TIFF_FILLORDER
TIFF_FILLORDER
TIFF_FILLORDER
FILLORDER_LSB2MSB
FILLORDER_LSB2MSB
break;
case 'H':
'H'
tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER;
tif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER
tif->tif_flags
tif
tif
tif_flags
(tif->tif_flags &~ TIFF_FILLORDER) |				    HOST_FILLORDER
(tif->tif_flags &~ TIFF_FILLORDER)
tif->tif_flags &~ TIFF_FILLORDER
tif->tif_flags
tif
tif
tif_flags
~ TIFF_FILLORDER
TIFF_FILLORDER
TIFF_FILLORDER
HOST_FILLORDER
HOST_FILLORDER
break;
case 'M':
'M'
if (m == O_RDONLY)					tif->tif_flags |= TIFF_MAPPED;
m == O_RDONLY
m
m
O_RDONLY
O_RDONLY
tif->tif_flags |= TIFF_MAPPED;
tif->tif_flags |= TIFF_MAPPED
tif->tif_flags
tif
tif
tif_flags
TIFF_MAPPED
TIFF_MAPPED
break;
case 'm':
'm'
if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_MAPPED;
m == O_RDONLY
m
m
O_RDONLY
O_RDONLY
tif->tif_flags &= ~TIFF_MAPPED;
tif->tif_flags &= ~TIFF_MAPPED
tif->tif_flags
tif
tif
tif_flags
~TIFF_MAPPED
TIFF_MAPPED
TIFF_MAPPED
break;
case 'C':
'C'
if (m == O_RDONLY)					tif->tif_flags |= TIFF_STRIPCHOP;
m == O_RDONLY
m
m
O_RDONLY
O_RDONLY
tif->tif_flags |= TIFF_STRIPCHOP;
tif->tif_flags |= TIFF_STRIPCHOP
tif->tif_flags
tif
tif
tif_flags
TIFF_STRIPCHOP
TIFF_STRIPCHOP
break;
case 'c':
'c'
if (m == O_RDONLY)					tif->tif_flags &= ~TIFF_STRIPCHOP;
m == O_RDONLY
m
m
O_RDONLY
O_RDONLY
tif->tif_flags &= ~TIFF_STRIPCHOP;
tif->tif_flags &= ~TIFF_STRIPCHOP
tif->tif_flags
tif
tif
tif_flags
~TIFF_STRIPCHOP
TIFF_STRIPCHOP
TIFF_STRIPCHOP
break;
case 'h':
'h'
tif->tif_flags |= TIFF_HEADERONLY;
tif->tif_flags |= TIFF_HEADERONLY
tif->tif_flags
tif
tif
tif_flags
TIFF_HEADERONLY
TIFF_HEADERONLY
break;
case '8':
'8'
if (m&O_CREAT)					tif->tif_flags |= TIFF_BIGTIFF;
m&O_CREAT
m
m
O_CREAT
O_CREAT
tif->tif_flags |= TIFF_BIGTIFF;
tif->tif_flags |= TIFF_BIGTIFF
tif->tif_flags
tif
tif
tif_flags
TIFF_BIGTIFF
TIFF_BIGTIFF
break;
if ((m & O_TRUNC) ||	    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {		if (tif->tif_mode == O_RDONLY) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		/*		 * Setup header and write.		 */		#ifdef WORDS_BIGENDIAN		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;		#else		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;		#endif		if (!(tif->tif_flags&TIFF_BIGTIFF))		{			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;			tif->tif_header.classic.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);			tif->tif_header_size = sizeof(TIFFHeaderClassic);		}		else		{			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;			tif->tif_header.big.tiff_offsetsize = 8;			tif->tif_header.big.tiff_unused = 0;			tif->tif_header.big.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}			tif->tif_header_size = sizeof (TIFFHeaderBig);		}		/*		 * The doc for "fopen" for some STD_C_LIBs says that if you		 * open a file for modify ("+"), then you must fseek (or		 * fflush?) between any freads and fwrites.  This is not		 * necessary on most systems, but has been shown to be needed		 * on Solaris.		 */		TIFFSeekFile( tif, 0, SEEK_SET );		if (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");			goto bad;		}		/*		 * Setup the byte order handling.		 */		if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {			#ifndef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		} else {			#ifdef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}		/*		 * Setup default directory.		 */		if (!TIFFDefaultDirectory(tif))			goto bad;		tif->tif_diroff = 0;		tif->tif_dirlist = NULL;		tif->tif_dirlistsize = 0;		tif->tif_dirnumber = 0;		return (tif);	}
(m & O_TRUNC) ||	    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))
(m & O_TRUNC)
m & O_TRUNC
m
m
O_TRUNC
O_TRUNC
!ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))
ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))
ReadOK
ReadOK
tif
tif
&tif->tif_header
tif->tif_header
tif
tif
tif_header
sizeof (TIFFHeaderClassic)
TIFFHeaderClassic
TIFFHeaderClassic
TIFFHeaderClassic

{		if (tif->tif_mode == O_RDONLY) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		/*		 * Setup header and write.		 */		#ifdef WORDS_BIGENDIAN		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;		#else		tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;		#endif		if (!(tif->tif_flags&TIFF_BIGTIFF))		{			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;			tif->tif_header.classic.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);			tif->tif_header_size = sizeof(TIFFHeaderClassic);		}		else		{			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;			tif->tif_header.big.tiff_offsetsize = 8;			tif->tif_header.big.tiff_unused = 0;			tif->tif_header.big.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}			tif->tif_header_size = sizeof (TIFFHeaderBig);		}		/*		 * The doc for "fopen" for some STD_C_LIBs says that if you		 * open a file for modify ("+"), then you must fseek (or		 * fflush?) between any freads and fwrites.  This is not		 * necessary on most systems, but has been shown to be needed		 * on Solaris.		 */		TIFFSeekFile( tif, 0, SEEK_SET );		if (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");			goto bad;		}		/*		 * Setup the byte order handling.		 */		if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {			#ifndef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		} else {			#ifdef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}		/*		 * Setup default directory.		 */		if (!TIFFDefaultDirectory(tif))			goto bad;		tif->tif_diroff = 0;		tif->tif_dirlist = NULL;		tif->tif_dirlistsize = 0;		tif->tif_dirnumber = 0;		return (tif);	}
if (tif->tif_mode == O_RDONLY) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}
tif->tif_mode == O_RDONLY
tif->tif_mode
tif
tif
tif_mode
O_RDONLY
O_RDONLY
{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}
TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");
TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Cannot read TIFF header"
goto bad;
bad
tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;
tif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
(tif->tif_flags & TIFF_SWAB)		    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN
(tif->tif_flags & TIFF_SWAB)
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
TIFF_BIGENDIAN
TIFF_BIGENDIAN
TIFF_LITTLEENDIAN
TIFF_LITTLEENDIAN
if (!(tif->tif_flags&TIFF_BIGTIFF))		{			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;			tif->tif_header.classic.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);			tif->tif_header_size = sizeof(TIFFHeaderClassic);		}		else		{			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;			tif->tif_header.big.tiff_offsetsize = 8;			tif->tif_header.big.tiff_unused = 0;			tif->tif_header.big.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}			tif->tif_header_size = sizeof (TIFFHeaderBig);		}
!(tif->tif_flags&TIFF_BIGTIFF)
(tif->tif_flags&TIFF_BIGTIFF)
tif->tif_flags&TIFF_BIGTIFF
tif->tif_flags
tif
tif
tif_flags
TIFF_BIGTIFF
TIFF_BIGTIFF
{			tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;			tif->tif_header.classic.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);			tif->tif_header_size = sizeof(TIFFHeaderClassic);		}
tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;
tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
TIFF_VERSION_CLASSIC
TIFF_VERSION_CLASSIC
tif->tif_header.classic.tiff_diroff = 0;
tif->tif_header.classic.tiff_diroff = 0
tif->tif_header.classic.tiff_diroff
tif->tif_header.classic
tif->tif_header
tif
tif
tif_header
classic
tiff_diroff
0
if (tif->tif_flags & TIFF_SWAB)				TIFFSwabShort(&tif->tif_header.common.tiff_version);
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
TIFFSwabShort(&tif->tif_header.common.tiff_version);
TIFFSwabShort(&tif->tif_header.common.tiff_version)
TIFFSwabShort
TIFFSwabShort
&tif->tif_header.common.tiff_version
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
tif->tif_header_size = sizeof(TIFFHeaderClassic);
tif->tif_header_size = sizeof(TIFFHeaderClassic)
tif->tif_header_size
tif
tif
tif_header_size
sizeof(TIFFHeaderClassic)
TIFFHeaderClassic
TIFFHeaderClassic
TIFFHeaderClassic

{			tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;			tif->tif_header.big.tiff_offsetsize = 8;			tif->tif_header.big.tiff_unused = 0;			tif->tif_header.big.tiff_diroff = 0;			if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}			tif->tif_header_size = sizeof (TIFFHeaderBig);		}
tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;
tif->tif_header.common.tiff_version = TIFF_VERSION_BIG
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
TIFF_VERSION_BIG
TIFF_VERSION_BIG
tif->tif_header.big.tiff_offsetsize = 8;
tif->tif_header.big.tiff_offsetsize = 8
tif->tif_header.big.tiff_offsetsize
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_offsetsize
8
tif->tif_header.big.tiff_unused = 0;
tif->tif_header.big.tiff_unused = 0
tif->tif_header.big.tiff_unused
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_unused
0
tif->tif_header.big.tiff_diroff = 0;
tif->tif_header.big.tiff_diroff = 0
tif->tif_header.big.tiff_diroff
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_diroff
0
if (tif->tif_flags & TIFF_SWAB)			{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
{				TIFFSwabShort(&tif->tif_header.common.tiff_version);				TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			}
TIFFSwabShort(&tif->tif_header.common.tiff_version);
TIFFSwabShort(&tif->tif_header.common.tiff_version)
TIFFSwabShort
TIFFSwabShort
&tif->tif_header.common.tiff_version
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);
TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize)
TIFFSwabShort
TIFFSwabShort
&tif->tif_header.big.tiff_offsetsize
tif->tif_header.big.tiff_offsetsize
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_offsetsize
tif->tif_header_size = sizeof (TIFFHeaderBig);
tif->tif_header_size = sizeof (TIFFHeaderBig)
tif->tif_header_size
tif
tif
tif_header_size
sizeof (TIFFHeaderBig)
TIFFHeaderBig
TIFFHeaderBig
TIFFHeaderBig

TIFFSeekFile( tif, 0, SEEK_SET );
TIFFSeekFile( tif, 0, SEEK_SET )
TIFFSeekFile
TIFFSeekFile
tif
tif
0
SEEK_SET
SEEK_SET
if (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {			TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");			goto bad;		}
!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))
WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))
WriteOK
WriteOK
tif
tif
&tif->tif_header
tif->tif_header
tif
tif
tif_header
(tmsize_t)(tif->tif_header_size)
(tmsize_t)
tmsize_t
tmsize_t
tif->tif_header_size
tif
tif
tif_header_size
{			TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");			goto bad;		}
TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header");
TIFFErrorExt(tif->tif_clientdata, name,			    "Error writing TIFF header")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Error writing TIFF header"
goto bad;
bad
if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {			#ifndef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		} else {			#ifdef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}
tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
TIFF_BIGENDIAN
TIFF_BIGENDIAN
{			#ifndef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}
tif->tif_flags |= TIFF_SWAB;
tif->tif_flags |= TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
{			#ifdef WORDS_BIGENDIAN			tif->tif_flags |= TIFF_SWAB;			#endif		}
if (!TIFFDefaultDirectory(tif))			goto bad;
!TIFFDefaultDirectory(tif)
TIFFDefaultDirectory(tif)
TIFFDefaultDirectory
TIFFDefaultDirectory
tif
tif
goto bad;
bad
tif->tif_diroff = 0;
tif->tif_diroff = 0
tif->tif_diroff
tif
tif
tif_diroff
0
tif->tif_dirlist = NULL;
tif->tif_dirlist = NULL
tif->tif_dirlist
tif
tif
tif_dirlist
NULL
NULL
tif->tif_dirlistsize = 0;
tif->tif_dirlistsize = 0
tif->tif_dirlistsize
tif
tif
tif_dirlistsize
0
tif->tif_dirnumber = 0;
tif->tif_dirnumber = 0
tif->tif_dirnumber
tif
tif
tif_dirnumber
0
return (tif);
(tif)
tif
tif
if (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&	    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN	    #if MDI_SUPPORT	    &&	    #if HOST_BIGENDIAN	    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN	    #else	    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN	    #endif	    ) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF or MDI file, bad magic number %d (0x%x)",	    #else	    ) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad magic number %d (0x%x)",	    #endif		    tif->tif_header.common.tiff_magic,		    tif->tif_header.common.tiff_magic);		goto bad;	}
tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&	    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN
tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
TIFF_BIGENDIAN
TIFF_BIGENDIAN
tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
TIFF_LITTLEENDIAN
TIFF_LITTLEENDIAN
{		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad magic number %d (0x%x)",	    #endif		    tif->tif_header.common.tiff_magic,		    tif->tif_header.common.tiff_magic);		goto bad;	}
TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad magic number %d (0x%x)",	    #endif		    tif->tif_header.common.tiff_magic,		    tif->tif_header.common.tiff_magic);
TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad magic number %d (0x%x)",	    #endif		    tif->tif_header.common.tiff_magic,		    tif->tif_header.common.tiff_magic)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Not a TIFF file, bad magic number %d (0x%x)"
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
goto bad;
bad
if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {		#ifndef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	} else {		#ifdef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	}
tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN
tif->tif_header.common.tiff_magic
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_magic
TIFF_BIGENDIAN
TIFF_BIGENDIAN
{		#ifndef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	}
tif->tif_flags |= TIFF_SWAB;
tif->tif_flags |= TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
{		#ifdef WORDS_BIGENDIAN		tif->tif_flags |= TIFF_SWAB;		#endif	}
if (tif->tif_flags & TIFF_SWAB) 		TIFFSwabShort(&tif->tif_header.common.tiff_version);
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
TIFFSwabShort(&tif->tif_header.common.tiff_version);
TIFFSwabShort(&tif->tif_header.common.tiff_version)
TIFFSwabShort
TIFFSwabShort
&tif->tif_header.common.tiff_version
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
if ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&	    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)) {		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad version number %d (0x%x)",		    tif->tif_header.common.tiff_version,		    tif->tif_header.common.tiff_version);		goto bad;	}
(tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)&&	    (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)
(tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC)
tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
TIFF_VERSION_CLASSIC
TIFF_VERSION_CLASSIC
(tif->tif_header.common.tiff_version != TIFF_VERSION_BIG)
tif->tif_header.common.tiff_version != TIFF_VERSION_BIG
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
TIFF_VERSION_BIG
TIFF_VERSION_BIG
{		TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad version number %d (0x%x)",		    tif->tif_header.common.tiff_version,		    tif->tif_header.common.tiff_version);		goto bad;	}
TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad version number %d (0x%x)",		    tif->tif_header.common.tiff_version,		    tif->tif_header.common.tiff_version);
TIFFErrorExt(tif->tif_clientdata, name,		    "Not a TIFF file, bad version number %d (0x%x)",		    tif->tif_header.common.tiff_version,		    tif->tif_header.common.tiff_version)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Not a TIFF file, bad version number %d (0x%x)"
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
goto bad;
bad
if (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)	{		if (tif->tif_flags & TIFF_SWAB)			TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);		tif->tif_header_size = sizeof(TIFFHeaderClassic);	}	else	{		if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		if (tif->tif_flags & TIFF_SWAB)		{			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);		}		if (tif->tif_header.big.tiff_offsetsize != 8)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);			goto bad;		}		if (tif->tif_header.big.tiff_unused != 0)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);			goto bad;		}		tif->tif_header_size = sizeof(TIFFHeaderBig);		tif->tif_flags |= TIFF_BIGTIFF;	}
tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC
tif->tif_header.common.tiff_version
tif->tif_header.common
tif->tif_header
tif
tif
tif_header
common
tiff_version
TIFF_VERSION_CLASSIC
TIFF_VERSION_CLASSIC
{		if (tif->tif_flags & TIFF_SWAB)			TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);		tif->tif_header_size = sizeof(TIFFHeaderClassic);	}
if (tif->tif_flags & TIFF_SWAB)			TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);
TIFFSwabLong(&tif->tif_header.classic.tiff_diroff)
TIFFSwabLong
TIFFSwabLong
&tif->tif_header.classic.tiff_diroff
tif->tif_header.classic.tiff_diroff
tif->tif_header.classic
tif->tif_header
tif
tif
tif_header
classic
tiff_diroff
tif->tif_header_size = sizeof(TIFFHeaderClassic);
tif->tif_header_size = sizeof(TIFFHeaderClassic)
tif->tif_header_size
tif
tif
tif_header_size
sizeof(TIFFHeaderClassic)
TIFFHeaderClassic
TIFFHeaderClassic
TIFFHeaderClassic

{		if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}		if (tif->tif_flags & TIFF_SWAB)		{			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);		}		if (tif->tif_header.big.tiff_offsetsize != 8)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);			goto bad;		}		if (tif->tif_header.big.tiff_unused != 0)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);			goto bad;		}		tif->tif_header_size = sizeof(TIFFHeaderBig);		tif->tif_flags |= TIFF_BIGTIFF;	}
if (!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))))		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}
!ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic)))
ReadOK(tif, ((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)), (sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic)))
ReadOK
ReadOK
tif
tif
((uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic))
(uint8*)(&tif->tif_header) + sizeof(TIFFHeaderClassic)
(uint8*)(&tif->tif_header)
uint8*
uint8
uint8
*
*
(&tif->tif_header)
&tif->tif_header
tif->tif_header
tif
tif
tif_header
sizeof(TIFFHeaderClassic)
TIFFHeaderClassic
TIFFHeaderClassic
TIFFHeaderClassic

(sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic))
sizeof(TIFFHeaderBig)-sizeof(TIFFHeaderClassic)
sizeof(TIFFHeaderBig)
TIFFHeaderBig
TIFFHeaderBig
TIFFHeaderBig

sizeof(TIFFHeaderClassic)
TIFFHeaderClassic
TIFFHeaderClassic
TIFFHeaderClassic

{			TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");			goto bad;		}
TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header");
TIFFErrorExt(tif->tif_clientdata, name,			    "Cannot read TIFF header")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Cannot read TIFF header"
goto bad;
bad
if (tif->tif_flags & TIFF_SWAB)		{			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);		}
tif->tif_flags & TIFF_SWAB
tif->tif_flags
tif
tif
tif_flags
TIFF_SWAB
TIFF_SWAB
{			TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);			TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);		}
TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);
TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize)
TIFFSwabShort
TIFFSwabShort
&tif->tif_header.big.tiff_offsetsize
tif->tif_header.big.tiff_offsetsize
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_offsetsize
TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);
TIFFSwabLong8(&tif->tif_header.big.tiff_diroff)
TIFFSwabLong8
TIFFSwabLong8
&tif->tif_header.big.tiff_diroff
tif->tif_header.big.tiff_diroff
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_diroff
if (tif->tif_header.big.tiff_offsetsize != 8)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);			goto bad;		}
tif->tif_header.big.tiff_offsetsize != 8
tif->tif_header.big.tiff_offsetsize
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_offsetsize
8
{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);			goto bad;		}
TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize);
TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)",			    tif->tif_header.big.tiff_offsetsize,			    tif->tif_header.big.tiff_offsetsize)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Not a TIFF file, bad BigTIFF offsetsize %d (0x%x)"
tif->tif_header.big.tiff_offsetsize
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_offsetsize
tif->tif_header.big.tiff_offsetsize
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_offsetsize
goto bad;
bad
if (tif->tif_header.big.tiff_unused != 0)		{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);			goto bad;		}
tif->tif_header.big.tiff_unused != 0
tif->tif_header.big.tiff_unused
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_unused
0
{			TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);			goto bad;		}
TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused);
TIFFErrorExt(tif->tif_clientdata, name,			    "Not a TIFF file, bad BigTIFF unused %d (0x%x)",			    tif->tif_header.big.tiff_unused,			    tif->tif_header.big.tiff_unused)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
name
name
"Not a TIFF file, bad BigTIFF unused %d (0x%x)"
tif->tif_header.big.tiff_unused
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_unused
tif->tif_header.big.tiff_unused
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_unused
goto bad;
bad
tif->tif_header_size = sizeof(TIFFHeaderBig);
tif->tif_header_size = sizeof(TIFFHeaderBig)
tif->tif_header_size
tif
tif
tif_header_size
sizeof(TIFFHeaderBig)
TIFFHeaderBig
TIFFHeaderBig
TIFFHeaderBig

tif->tif_flags |= TIFF_BIGTIFF;
tif->tif_flags |= TIFF_BIGTIFF
tif->tif_flags
tif
tif
tif_flags
TIFF_BIGTIFF
TIFF_BIGTIFF
tif->tif_flags |= TIFF_MYBUFFER;
tif->tif_flags |= TIFF_MYBUFFER
tif->tif_flags
tif
tif
tif_flags
TIFF_MYBUFFER
TIFF_MYBUFFER
tif->tif_rawcp = tif->tif_rawdata = 0;
tif->tif_rawcp = tif->tif_rawdata = 0
tif->tif_rawcp
tif
tif
tif_rawcp
tif->tif_rawdata = 0
tif->tif_rawdata
tif
tif
tif_rawdata
0
tif->tif_rawdatasize = 0;
tif->tif_rawdatasize = 0
tif->tif_rawdatasize
tif
tif
tif_rawdatasize
0
tif->tif_rawdataoff = 0;
tif->tif_rawdataoff = 0
tif->tif_rawdataoff
tif
tif
tif_rawdataoff
0
tif->tif_rawdataloaded = 0;
tif->tif_rawdataloaded = 0
tif->tif_rawdataloaded
tif
tif
tif_rawdataloaded
0
switch (mode[0]) {		case 'r':			if (!(tif->tif_flags&TIFF_BIGTIFF))				tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;			else				tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;			/*			 * Try to use a memory-mapped file if the client			 * has not explicitly suppressed usage with the			 * 'm' flag in the open mode (see above).			 */			if (tif->tif_flags & TIFF_MAPPED)			{				toff_t n;				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;			}			/*			 * Sometimes we do not want to read the first directory (for example,			 * it may be broken) and want to proceed to other directories. I this			 * case we use the TIFF_HEADERONLY flag to open file and return			 * immediately after reading TIFF header.			 */			if (tif->tif_flags & TIFF_HEADERONLY)				return (tif);			/*			 * Setup initial directory.			 */			if (TIFFReadDirectory(tif)) {				tif->tif_rawcc = (tmsize_t)-1;				tif->tif_flags |= TIFF_BUFFERSETUP;				return (tif);			}			break;		case 'a':			/*			 * New directories are automatically append			 * to the end of the directory chain when they			 * are written out (see TIFFWriteDirectory).			 */			if (!TIFFDefaultDirectory(tif))				goto bad;			return (tif);	}
mode[0]
mode
mode
0
{		case 'r':			if (!(tif->tif_flags&TIFF_BIGTIFF))				tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;			else				tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;			/*			 * Try to use a memory-mapped file if the client			 * has not explicitly suppressed usage with the			 * 'm' flag in the open mode (see above).			 */			if (tif->tif_flags & TIFF_MAPPED)			{				toff_t n;				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;			}			/*			 * Sometimes we do not want to read the first directory (for example,			 * it may be broken) and want to proceed to other directories. I this			 * case we use the TIFF_HEADERONLY flag to open file and return			 * immediately after reading TIFF header.			 */			if (tif->tif_flags & TIFF_HEADERONLY)				return (tif);			/*			 * Setup initial directory.			 */			if (TIFFReadDirectory(tif)) {				tif->tif_rawcc = (tmsize_t)-1;				tif->tif_flags |= TIFF_BUFFERSETUP;				return (tif);			}			break;		case 'a':			/*			 * New directories are automatically append			 * to the end of the directory chain when they			 * are written out (see TIFFWriteDirectory).			 */			if (!TIFFDefaultDirectory(tif))				goto bad;			return (tif);	}
case 'r':
'r'
if (!(tif->tif_flags&TIFF_BIGTIFF))				tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;			else				tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;
!(tif->tif_flags&TIFF_BIGTIFF)
(tif->tif_flags&TIFF_BIGTIFF)
tif->tif_flags&TIFF_BIGTIFF
tif->tif_flags
tif
tif
tif_flags
TIFF_BIGTIFF
TIFF_BIGTIFF
tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;
tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
tif->tif_header.classic.tiff_diroff
tif->tif_header.classic
tif->tif_header
tif
tif
tif_header
classic
tiff_diroff
tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;
tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
tif->tif_header.big.tiff_diroff
tif->tif_header.big
tif->tif_header
tif
tif
tif_header
big
tiff_diroff
if (tif->tif_flags & TIFF_MAPPED)			{				toff_t n;				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;			}
tif->tif_flags & TIFF_MAPPED
tif->tif_flags
tif
tif
tif_flags
TIFF_MAPPED
TIFF_MAPPED
{				toff_t n;				if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;			}
toff_t n;
toff_t n;
toff_t
toff_t
n
n
if (TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))				{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}				else					tif->tif_flags &= ~TIFF_MAPPED;
TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n)
TIFFMapFileContents
TIFFMapFileContents
tif
tif
(void**)(&tif->tif_base)
void**
void
**
*
*
(&tif->tif_base)
&tif->tif_base
tif->tif_base
tif
tif
tif_base
&n
n
n
{					tif->tif_size=(tmsize_t)n;					assert((toff_t)tif->tif_size==n);				}
tif->tif_size=(tmsize_t)n;
tif->tif_size=(tmsize_t)n
tif->tif_size
tif
tif
tif_size
(tmsize_t)n
tmsize_t
tmsize_t
tmsize_t

n
n
assert((toff_t)tif->tif_size==n);
assert((toff_t)tif->tif_size==n)
assert
assert
(toff_t)tif->tif_size==n
(toff_t)tif->tif_size
toff_t
toff_t
toff_t

tif->tif_size
tif
tif
tif_size
n
n
tif->tif_flags &= ~TIFF_MAPPED;
tif->tif_flags &= ~TIFF_MAPPED
tif->tif_flags
tif
tif
tif_flags
~TIFF_MAPPED
TIFF_MAPPED
TIFF_MAPPED
if (tif->tif_flags & TIFF_HEADERONLY)				return (tif);
tif->tif_flags & TIFF_HEADERONLY
tif->tif_flags
tif
tif
tif_flags
TIFF_HEADERONLY
TIFF_HEADERONLY
return (tif);
(tif)
tif
tif
if (TIFFReadDirectory(tif)) {				tif->tif_rawcc = (tmsize_t)-1;				tif->tif_flags |= TIFF_BUFFERSETUP;				return (tif);			}
TIFFReadDirectory(tif)
TIFFReadDirectory
TIFFReadDirectory
tif
tif
{				tif->tif_rawcc = (tmsize_t)-1;				tif->tif_flags |= TIFF_BUFFERSETUP;				return (tif);			}
tif->tif_rawcc = (tmsize_t)-1;
tif->tif_rawcc = (tmsize_t)-1
tif->tif_rawcc
tif
tif
tif_rawcc
(tmsize_t)-1
(tmsize_t)
tmsize_t
tmsize_t
1
tif->tif_flags |= TIFF_BUFFERSETUP;
tif->tif_flags |= TIFF_BUFFERSETUP
tif->tif_flags
tif
tif
tif_flags
TIFF_BUFFERSETUP
TIFF_BUFFERSETUP
return (tif);
(tif)
tif
tif
break;
case 'a':
'a'
if (!TIFFDefaultDirectory(tif))				goto bad;
!TIFFDefaultDirectory(tif)
TIFFDefaultDirectory(tif)
TIFFDefaultDirectory
TIFFDefaultDirectory
tif
tif
goto bad;
bad
return (tif);
(tif)
tif
tif
bad:	tif->tif_mode = O_RDONLY;
bad
tif->tif_mode = O_RDONLY;
tif->tif_mode = O_RDONLY
tif->tif_mode
tif
tif
tif_mode
O_RDONLY
O_RDONLY
TIFFCleanup(tif);
TIFFCleanup(tif)
TIFFCleanup
TIFFCleanup
tif
tif
bad2:	return ((TIFF*)0);
bad2
return ((TIFF*)0);
((TIFF*)0)
(TIFF*)0
TIFF*
TIFF
TIFF
*
*
0
-----joern-----
(2,4,0)
(5,1,0)
(1,0,0)
(4,6,0)
(3,4,0)
(4,1,0)
(3,2,1)
(1,4,1)
(5,1,1)
(4,3,1)
(4,6,1)
(5,1,2)
(4,6,2)
-----------------------------------
(0,)
(1,return (isFillOrder(tif, FILLORDER_MSB2LSB)
(2,tif)
(3,FILLORDER_MSB2LSB)
(4,isFillOrder(tif, FILLORDER_MSB2LSB)
(5,RET)
(6,TIFF* tif)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
----------------dynamic----------------
=======testcase========
model_version:0x01000000
A-data-stat:0x000800000000000001000000000000000100000000000000a4810000e8030000e9030000ffffffff0000000000000000ffffffffffffffff0010000000000000ffffffffffffffff85f6b26300000000ffffffffffffffff7ff6b26300000000ffffffffffffffff7ff6b26300000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
A-data:0x4d4d002b000800000000000000000015ffffffffff0100000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
=========trace=========
TIFF* TIFFClientOpen( 	const char* name, const char* mode, 	thandle_t clientdata, 	TIFFReadWriteProc readproc, 	TIFFReadWriteProc writeproc, 	TIFFSeekProc seekproc, 	TIFFCloseProc closeproc, 	TIFFSizeProc sizeproc, 	TIFFMapFileProc mapproc, 	TIFFUnmapFileProc unmapproc ) {
static const char module[] = 'TIFFClientOpen';
TIFF *tif;
int m;
const char* cp;
assert(sizeof(uint8)==1);
assert(sizeof(int8)==1);
assert(sizeof(uint16)==2);
assert(sizeof(int16)==2);
assert(sizeof(uint32)==4);
assert(sizeof(int32)==4);
assert(sizeof(uint64)==8);
assert(sizeof(int64)==8);
assert(sizeof(tmsize_t)==sizeof(void*));
{ 		union{ 			uint8 a8[2]; 			uint16 a16; 		} n; 		n.a8[0]=1; 		n.a8[1]=0; 		#ifdef WORDS_BIGENDIAN 		assert(n.a16==256); 		#else 		assert(n.a16==1); 		#endif 	};
union{ 			uint8 a8[2]; 			uint16 a16; 		} n;
n.a8[0]=1;
n.a8[1]=0;
assert(n.a16==1);
m = _TIFFgetMode(mode, module);
tif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));
_TIFFmemset(tif, 0, sizeof (*tif));
tif->tif_name = (char *)tif + sizeof (TIFF);
strcpy(tif->tif_name, name);
tif->tif_mode = m &~ (O_CREAT|O_TRUNC);
tif->tif_curdir = (uint16) -1;
tif->tif_curoff = 0;
tif->tif_curstrip = (uint32) -1;
tif->tif_row = (uint32) -1;
tif->tif_clientdata = clientdata;
tif->tif_readproc = readproc;
tif->tif_writeproc = writeproc;
tif->tif_seekproc = seekproc;
tif->tif_closeproc = closeproc;
tif->tif_sizeproc = sizeproc;
if(mapproc)
tif->tif_mapproc = mapproc;
if(unmapproc)
tif->tif_unmapproc = unmapproc;
_TIFFSetDefaultCompressionState(tif);
tif->tif_flags = FILLORDER_MSB2LSB;
if(m == O_RDONLY)
tif->tif_flags |= TIFF_MAPPED;
if(m == O_RDONLY || m == O_RDWR)
tif->tif_flags |= STRIPCHOP_DEFAULT;
if(tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN)
tif->tif_flags |= TIFF_SWAB;
if(tif->tif_flags & TIFF_SWAB)
TIFFSwabShort(&tif->tif_header.common.tiff_version);
if(tif->tif_flags & TIFF_SWAB)
TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);
TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);
tif->tif_header_size = sizeof(TIFFHeaderBig);
tif->tif_flags |= TIFF_BIGTIFF;
tif->tif_flags |= TIFF_MYBUFFER;
tif->tif_rawcp = tif->tif_rawdata = 0;
tif->tif_rawdatasize = 0;
tif->tif_rawdataoff = 0;
tif->tif_rawdataloaded = 0;
switch(mode[0])
tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;
if(tif->tif_flags & TIFF_MAPPED)
toff_t n;
if(TIFFMapFileContents(tif,(void**)(&tif->tif_base),&n))
tif->tif_size=(tmsize_t)n;
assert((toff_t)tif->tif_size==n);
TIFFCleanup(tif);
return (tif);
=======================
