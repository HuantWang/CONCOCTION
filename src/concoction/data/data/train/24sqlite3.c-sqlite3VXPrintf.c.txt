-----label-----
1
-----code-----
void sqlite3VXPrintf(
  StrAccum *pAccum,                  /* Accumulate results here */
  int useExtended,                   /* Allow extended %-conversions */
  const char *fmt,                   /* Format string */
  va_list ap                         /* arguments */
){
printf("\nfile_name:%s\n",__FILE__);
printf("function_name:%s\n",__func__);
printf("------function start!------\n");
printf("void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){\n");
  printf("int c;\n");
  int c;                     /* Next character in the format string */
  printf("char *bufpt;\n");
  char *bufpt;               /* Pointer to the conversion buffer */
  printf("int precision;\n");
  int precision;             /* Precision of the current field */
  printf("int length;\n");
  int length;                /* Length of the field */
  printf("int idx;\n");
  int idx;                   /* A general purpose loop counter */
  printf("int width;\n");
  int width;                 /* Width of the current field */
  printf("etByte flag_leftjustify;\n");
  etByte flag_leftjustify;   /* True if "-" flag is present */
  printf("etByte flag_plussign;\n");
  etByte flag_plussign;      /* True if "+" flag is present */
  printf("etByte flag_blanksign;\n");
  etByte flag_blanksign;     /* True if " " flag is present */
  printf("etByte flag_alternateform;\n");
  etByte flag_alternateform; /* True if "#" flag is present */
  printf("etByte flag_altform2;\n");
  etByte flag_altform2;      /* True if "!" flag is present */
  printf("etByte flag_zeropad;\n");
  etByte flag_zeropad;       /* True if field width constant starts with zero */
  printf("etByte flag_long;\n");
  etByte flag_long;          /* True if "l" flag is present */
  printf("etByte flag_longlong;\n");
  etByte flag_longlong;      /* True if the "ll" flag is present */
  printf("etByte done;\n");
  etByte done;               /* Loop termination flag */
  printf("etByte xtype = 0;\n");
  etByte xtype = 0;          /* Conversion paradigm */
  printf("char prefix;\n");
  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */
  sqlite_uint64 longvalue;   /* Value for integer types */
  printf("LONGDOUBLE_TYPE realvalue;\n");
  LONGDOUBLE_TYPE realvalue; /* Value for real types */
  printf("const et_info *infop;\n");
  const et_info *infop;      /* Pointer to the appropriate info structure */
  printf("char *zOut;\n");
  char *zOut;                /* Rendering buffer */
  printf("int nOut;\n");
  int nOut;                  /* Size of the rendering buffer */
  printf("char *zExtra;\n");
  char *zExtra;              /* Malloced memory used by some conversion */
#ifndef SQLITE_OMIT_FLOATING_POINT
  printf("int  exp, e2;\n");
  int  exp, e2;              /* exponent of real numbers */
  printf("int nsd;\n");
  int nsd;                   /* Number of significant digits returned */
  printf("double rounder;\n");
  double rounder;            /* Used for rounding floating point values */
  printf("etByte flag_dp;\n");
  etByte flag_dp;            /* True if decimal point should be shown */
  printf("etByte flag_rtz;\n");
  etByte flag_rtz;           /* True if trailing zeros should be removed */
#endif
  printf("char buf[etBUFSIZE];\n");
  char buf[etBUFSIZE];       /* Conversion buffer */

  printf("bufpt = 0;\n");
bufpt = 0;
  for(; (c=(*fmt))!=0; ++fmt){
    if( c!='%' ){printf("if(c!='_')\n");
    
      printf("int amt;\n");
      int amt;
      printf("bufpt = (char *)fmt;\n");
bufpt = (char *)fmt;
      printf("amt = 1;\n");
amt = 1;
      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");
      printf("amt++;\n");
amt++;}
      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");
      sqlite3StrAccumAppend(pAccum, bufpt, amt);
      if( c==0 ) {printf("if(c==0)\n");
      break;}
    }
    if( (c=(*++fmt))==0 ){printf("if((c=(*++fmt))==0)\n");
    
      printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");
      sqlite3StrAccumAppend(pAccum, "%", 1);
      break;
    }
    /* Find out what flags are present */
    printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n");
flag_leftjustify = flag_plussign = flag_blanksign = 
     flag_alternateform = flag_altform2 = flag_zeropad = 0;
    printf("done = 0;\n");
done = 0;
    do{
      printf("switch(c)\n");
      switch( c ){
        case '-':   printf("flag_leftjustify = 1;\n");
flag_leftjustify = 1;     break;
        case '+':   printf("flag_plussign = 1;\n");
flag_plussign = 1;        break;
        case ' ':   printf("flag_blanksign = 1;\n");
flag_blanksign = 1;       break;
        case '#':   printf("flag_alternateform = 1;\n");
flag_alternateform = 1;   break;
        case '!':   printf("flag_altform2 = 1;\n");
flag_altform2 = 1;        break;
        case '0':   printf("flag_zeropad = 1;\n");
flag_zeropad = 1;         break;
        default:    printf("done = 1;\n");
done = 1;                 break;
      }
    }while( !done && (c=(*++fmt))!=0 );
    /* Get the field width */
    printf("width = 0;\n");
width = 0;
    if( c=='*' ){printf("if(c=='*')\n");
    
      printf("width = va_arg(ap,int);\n");
width = va_arg(ap,int);
      if( width<0 ){printf("if(width<0)\n");
      
        printf("flag_leftjustify = 1;\n");
flag_leftjustify = 1;
        printf("width = -width;\n");
width = -width;
      }
      printf("c = *++fmt;\n");
c = *++fmt;
    }else{
      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");
      
        printf("width = width*10 + c - '0';\n");
width = width*10 + c - '0';
        printf("c = *++fmt;\n");
c = *++fmt;
      }
    }
    /* Get the precision */
    if( c=='.' ){printf("if(c=='.')\n");
    
      printf("precision = 0;\n");
precision = 0;
      printf("c = *++fmt;\n");
c = *++fmt;
      if( c=='*' ){printf("if(c=='*')\n");
      
        printf("precision = va_arg(ap,int);\n");
precision = va_arg(ap,int);
        if( precision<0 ) {printf("if(precision<0)\n");
        printf("precision = -precision;\n");
precision = -precision;}
        printf("c = *++fmt;\n");
c = *++fmt;
      }else{
        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");
        
          printf("precision = precision*10 + c - '0';\n");
precision = precision*10 + c - '0';
          printf("c = *++fmt;\n");
c = *++fmt;
        }
      }
    }else{
      printf("precision = -1;\n");
precision = -1;
    }
    /* Get the conversion type modifier */
    if( c=='l' ){printf("if(c=='l')\n");
    
      printf("flag_long = 1;\n");
flag_long = 1;
      printf("c = *++fmt;\n");
c = *++fmt;
      if( c=='l' ){printf("if(c=='l')\n");
      
        printf("flag_longlong = 1;\n");
flag_longlong = 1;
        printf("c = *++fmt;\n");
c = *++fmt;
      }else{
        printf("flag_longlong = 0;\n");
flag_longlong = 0;
      }
    }else{
      printf("flag_long = flag_longlong = 0;\n");
flag_long = flag_longlong = 0;
    }
    /* Fetch the info entry for the field */
    printf("infop = &fmtinfo[0];\n");
infop = &fmtinfo[0];
    printf("xtype = etINVALID;\n");
xtype = etINVALID;
    for(idx=0; idx<ArraySize(fmtinfo); idx++){printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");
    
      if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");
      
        printf("infop = &fmtinfo[idx];\n");
infop = &fmtinfo[idx];
        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");
        
          printf("xtype = infop->type;\n");
xtype = infop->type;
        }else{
          printf("return;\n");
          printf("------function end!------\n");
          return;
        }
        break;
      }
    }
    printf("zExtra = 0;\n");
zExtra = 0;

    /*
    ** At this point, variables are initialized as follows:
    **
    **   flag_alternateform          TRUE if a '#' is present.
    **   flag_altform2               TRUE if a '!' is present.
    **   flag_plussign               TRUE if a '+' is present.
    **   flag_leftjustify            TRUE if a '-' is present or if the
    **                               field width was negative.
    **   flag_zeropad                TRUE if the width began with 0.
    **   flag_long                   TRUE if the letter 'l' (ell) prefixed
    **                               the conversion character.
    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed
    **                               the conversion character.
    **   flag_blanksign              TRUE if a ' ' is present.
    **   width                       The specified field width.  This is
    **                               always non-negative.  Zero is the default.
    **   precision                   The specified precision.  The default
    **                               is -1.
    **   xtype                       The class of the conversion.
    **   infop                       Pointer to the appropriate info struct.
    */
    printf("switch(xtype)\n");
    switch( xtype ){
      case etPOINTER:
        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");
flag_longlong = sizeof(char*)==sizeof(i64);
        printf("flag_long = sizeof(char*)==sizeof(long int);\n");
flag_long = sizeof(char*)==sizeof(long int);
        /* Fall through into the next case */
      case etORDINAL:
      case etRADIX:
        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");
        
          printf("i64 v;\n");
          i64 v;
          if( flag_longlong ){printf("if(flag_longlong)\n");
          
            printf("v = va_arg(ap,i64);\n");
v = va_arg(ap,i64);
          }else if( flag_long ){printf("if(flag_long)\n");
          
            printf("v = va_arg(ap,long int);\n");
v = va_arg(ap,long int);
          }else{
            printf("v = va_arg(ap,int);\n");
v = va_arg(ap,int);
          }
          if( v<0 ){printf("if(v<0)\n");
          
            if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");
            
              longvalue = ((u64)1)<<63;
            }else{
              longvalue = -v;
            }
            printf("prefix = '-';\n");
prefix = '-';
          }else{
            longvalue = v;
            if( flag_plussign )        {printf("if(flag_plussign)\n");
            printf("prefix = '+';\n");
prefix = '+';}
            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");
            printf("prefix = ' ';\n");
prefix = ' ';}
            else                       {printf("prefix = 0;\n");
prefix = 0;}
          }
        }else{
          if( flag_longlong ){printf("if(flag_longlong)\n");
          
            longvalue = va_arg(ap,u64);
          }else if( flag_long ){printf("if(flag_long)\n");
          
            longvalue = va_arg(ap,unsigned long int);
          }else{
            longvalue = va_arg(ap,unsigned int);
          }
          printf("prefix = 0;\n");
prefix = 0;
        }
        if( longvalue==0 ) {printf("if()\n");
        printf("flag_alternateform = 0;\n");
flag_alternateform = 0;}
        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");
        
          printf("precision = width-(prefix!=0);\n");
precision = width-(prefix!=0);
        }
        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");
        
          printf("nOut = etBUFSIZE;\n");
nOut = etBUFSIZE;
          printf("zOut = buf;\n");
zOut = buf;
        }else{
          printf("nOut = precision + 10;\n");
nOut = precision + 10;
          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");
zOut = zExtra = sqlite3Malloc( nOut );
          if( zOut==0 ){printf("if(zOut==0)\n");
          
            printf("pAccum->accError = STRACCUM_NOMEM;\n");
pAccum->accError = STRACCUM_NOMEM;
            printf("return;\n");
            printf("------function end!------\n");
            return;
          }
        }
        printf("bufpt = &zOut[nOut-1];\n");
bufpt = &zOut[nOut-1];
        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");
        
          printf("static const char zOrd[] = 'thstndrd';\n");
          static const char zOrd[] = "thstndrd";
          printf("int x = (int)(longvalue _ 10);\n");
          int x = (int)(longvalue % 10);
          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");
          
            printf("x = 0;\n");
x = 0;
          }
          printf("*(--bufpt) = zOrd[x*2+1];\n");
*(--bufpt) = zOrd[x*2+1];
          printf("*(--bufpt) = zOrd[x*2];\n");
*(--bufpt) = zOrd[x*2];
        }
        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");
        {
          printf("register const char *cset;\n");
          register const char *cset;      /* Use registers for speed */
          printf("register int base;\n");
          register int base;
          printf("cset = &aDigits[infop->charset];\n");
cset = &aDigits[infop->charset];
          printf("base = infop->base;\n");
base = infop->base;
          do{                                           /* Convert to ascii */
            *(--bufpt) = cset[longvalue%base];
            longvalue = longvalue/base;
          }while( longvalue>0 );
        }
        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");
length = (int)(&zOut[nOut-1]-bufpt);
        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");
        
          printf("*(--bufpt) = '0';\n");
*(--bufpt) = '0';                             /* Zero pad */
        }
        if( prefix ) {printf("if(prefix)\n");
        printf("*(--bufpt) = prefix;\n");
*(--bufpt) = prefix;}               /* Add sign */
        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");
              /* Add "0" or "0x" */
          printf("const char *pre;\n");
          const char *pre;
          printf("char x;\n");
          char x;
          printf("pre = &aPrefix[infop->prefix];\n");
pre = &aPrefix[infop->prefix];
          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");
*(--bufpt) = x;}
        }
        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");
length = (int)(&zOut[nOut-1]-bufpt);
        break;
      case etFLOAT:
      case etEXP:
      case etGENERIC:
        printf("realvalue = va_arg(ap,double);\n");
realvalue = va_arg(ap,double);
#ifdef SQLITE_OMIT_FLOATING_POINT
        printf("length = 0;\n");
length = 0;
#else
        if( precision<0 ) precision = 6;         /* Set default precision */
        if( realvalue<0.0 ){
          realvalue = -realvalue;
          prefix = '-';
        }else{
          if( flag_plussign )          prefix = '+';
          else if( flag_blanksign )    prefix = ' ';
          else                         prefix = 0;
        }
        if( xtype==etGENERIC && precision>0 ) precision--;
        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}
        if( xtype==etFLOAT ) realvalue += rounder;
        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */
        exp = 0;
        if( sqlite3IsNaN((double)realvalue) ){
          bufpt = "NaN";
          length = 3;
          break;
        }
        if( realvalue>0.0 ){
          LONGDOUBLE_TYPE scale = 1.0;
          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}
          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }
          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }
          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }
          realvalue /= scale;
          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }
          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }
          if( exp>350 ){
            if( prefix=='-' ){
              bufpt = "-Inf";
            }else if( prefix=='+' ){
              bufpt = "+Inf";
            }else{
              bufpt = "Inf";
            }
            length = sqlite3Strlen30(bufpt);
            break;
          }
        }
        bufpt = buf;
        /*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */
        if( xtype!=etFLOAT ){
          realvalue += rounder;
          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }
        }
        if( xtype==etGENERIC ){
          flag_rtz = !flag_alternateform;
          if( exp<-4 || exp>precision ){
            xtype = etEXP;
          }else{
            precision = precision - exp;
            xtype = etFLOAT;
          }
        }else{
          flag_rtz = flag_altform2;
        }
        if( xtype==etEXP ){
          e2 = 0;
        }else{
          e2 = exp;
        }
        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){
          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );
          if( bufpt==0 ){
            pAccum->accError = STRACCUM_NOMEM;
            return;
          }
        }
        zOut = bufpt;
        nsd = 16 + flag_altform2*10;
        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;
        /* The sign in front of the number */
        if( prefix ){
          *(bufpt++) = prefix;
        }
        /* Digits prior to the decimal point */
        if( e2<0 ){
          *(bufpt++) = '0';
        }else{
          for(; e2>=0; e2--){
            *(bufpt++) = et_getdigit(&realvalue,&nsd);
          }
        }
        /* The decimal point */
        if( flag_dp ){
          *(bufpt++) = '.';
        }
        /* "0" digits after the decimal point but before the first
        ** significant digit of the number */
        for(e2++; e2<0; precision--, e2++){
          assert( precision>0 );
          *(bufpt++) = '0';
        }
        /* Significant digits after the decimal point */
        while( (precision--)>0 ){
          *(bufpt++) = et_getdigit(&realvalue,&nsd);
        }
        /* Remove trailing zeros and the "." if no digits follow the "." */
        if( flag_rtz && flag_dp ){
          while( bufpt[-1]=='0' ) *(--bufpt) = 0;
          assert( bufpt>zOut );
          if( bufpt[-1]=='.' ){
            if( flag_altform2 ){
              *(bufpt++) = '0';
            }else{
              *(--bufpt) = 0;
            }
          }
        }
        /* Add the "eNNN" suffix */
        if( xtype==etEXP ){
          *(bufpt++) = aDigits[infop->charset];
          if( exp<0 ){
            *(bufpt++) = '-'; exp = -exp;
          }else{
            *(bufpt++) = '+';
          }
          if( exp>=100 ){
            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */
            exp %= 100;
          }
          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */
          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */
        }
        *bufpt = 0;

        /* The converted number is in buf[] and zero terminated. Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions. */
        length = (int)(bufpt-zOut);
        bufpt = zOut;

        /* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */
        if( flag_zeropad && !flag_leftjustify && length < width){
          int i;
          int nPad = width - length;
          for(i=width; i>=nPad; i--){
            bufpt[i] = bufpt[i-nPad];
          }
          i = prefix!=0;
          while( nPad-- ) bufpt[i++] = '0';
          length = width;
        }
#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */
        break;
      case etSIZE:
        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");
*(va_arg(ap,int*)) = pAccum->nChar;
        printf("length = width = 0;\n");
length = width = 0;
        break;
      case etPERCENT:
        printf("buf[0] = '_';\n");
buf[0] = '%';
        printf("bufpt = buf;\n");
bufpt = buf;
        printf("length = 1;\n");
length = 1;
        break;
      case etCHARX:
        printf("c = va_arg(ap,int);\n");
c = va_arg(ap,int);
        printf("buf[0] = (char)c;\n");
buf[0] = (char)c;
        if( precision>=0 ){printf("if(precision>=0)\n");
        
          for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");
          printf("buf[idx] = (char)c;\n");
buf[idx] = (char)c;}
          printf("length = precision;\n");
length = precision;
        }else{
          printf("length =1;\n");
length =1;
        }
        printf("bufpt = buf;\n");
bufpt = buf;
        break;
      case etSTRING:
      case etDYNSTRING:
        printf("bufpt = va_arg(ap,char*);\n");
bufpt = va_arg(ap,char*);
        if( bufpt==0 ){printf("if(bufpt==0)\n");
        
          printf("bufpt = '';\n");
bufpt = "";
        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");
        
          printf("zExtra = bufpt;\n");
zExtra = bufpt;
        }
        if( precision>=0 ){printf("if(precision>=0)\n");
        
          for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");
          }
        }else{
          printf("length = sqlite3Strlen30(bufpt);\n");
length = sqlite3Strlen30(bufpt);
        }
        break;
      case etSQLESCAPE:
      case etSQLESCAPE2:
      case etSQLESCAPE3: {
        printf("int i, j, k, n, isnull;\n");
        int i, j, k, n, isnull;
        printf("int needQuote;\n");
        int needQuote;
        printf("char ch;\n");
        char ch;
        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");
        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */
        printf("char *escarg = va_arg(ap,char*);\n");
        char *escarg = va_arg(ap,char*);
        printf("isnull = escarg==0;\n");
isnull = escarg==0;
        if( isnull ) {printf("if(isnull)\n");
        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");
escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}
        printf("k = precision;\n");
k = precision;
        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");
        
          if( ch==q )  {printf("if(ch==q)\n");
          printf("n++;\n");
n++;}
        }
        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");
needQuote = !isnull && xtype==etSQLESCAPE2;
        printf("n += i + 1 + needQuote*2;\n");
n += i + 1 + needQuote*2;
        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");
        
          printf("bufpt = zExtra = sqlite3Malloc( n );\n");
bufpt = zExtra = sqlite3Malloc( n );
          if( bufpt==0 ){printf("if(bufpt==0)\n");
          
            printf("pAccum->accError = STRACCUM_NOMEM;\n");
pAccum->accError = STRACCUM_NOMEM;
            printf("return;\n");
            printf("------function end!------\n");
            return;
          }
        }else{
          printf("bufpt = buf;\n");
bufpt = buf;
        }
        printf("j = 0;\n");
j = 0;
        if( needQuote ) {printf("if(needQuote)\n");
        printf("bufpt[j++] = q;\n");
bufpt[j++] = q;}
        printf("k = i;\n");
k = i;
        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");
        
          printf("bufpt[j++] = ch = escarg[i];\n");
bufpt[j++] = ch = escarg[i];
          if( ch==q ) {printf("if(ch==q)\n");
          printf("bufpt[j++] = ch;\n");
bufpt[j++] = ch;}
        }
        if( needQuote ) {printf("if(needQuote)\n");
        printf("bufpt[j++] = q;\n");
bufpt[j++] = q;}
        printf("bufpt[j] = 0;\n");
bufpt[j] = 0;
        printf("length = j;\n");
length = j;
        /* The precision in %q and %Q means how many input characters to
        ** consume, not the length of the output...
        ** if( precision>=0 && precision<length ) length = precision; */
        break;
      }
      case etTOKEN: {
        printf("Token *pToken = va_arg(ap, Token*);\n");
        Token *pToken = va_arg(ap, Token*);
        if( pToken ){printf("if(pToken)\n");
        
          printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");
          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);
        }
        printf("length = width = 0;\n");
length = width = 0;
        break;
      }
      case etSRCLIST: {
        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");
        SrcList *pSrc = va_arg(ap, SrcList*);
        printf("int k = va_arg(ap, int);\n");
        int k = va_arg(ap, int);
        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");
        struct SrcList_item *pItem = &pSrc->a[k];
        printf("assert( k>=0 && k<pSrc->nSrc );\n");
        assert( k>=0 && k<pSrc->nSrc );
        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");
        
          printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");
          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);
          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");
          sqlite3StrAccumAppend(pAccum, ".", 1);
        }
        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");
        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);
        printf("length = width = 0;\n");
length = width = 0;
        break;
      }
      default: {
        printf("assert( xtype==etINVALID );\n");
        assert( xtype==etINVALID );
        printf("return;\n");
        printf("------function end!------\n");
        return;
      }
    }/* End switch over the format type */
    /*
    ** The text of the conversion is pointed to by "bufpt" and is
    ** "length" characters long.  The field width is "width".  Do
    ** the output.
    */
    if( !flag_leftjustify ){printf("if(!flag_leftjustify)\n");
    
      printf("register int nspace;\n");
      register int nspace;
      printf("nspace = width-length;\n");
nspace = width-length;
      if( nspace>0 ){printf("if(nspace>0)\n");
      
        printf("sqlite3AppendSpace(pAccum, nspace);\n");
        sqlite3AppendSpace(pAccum, nspace);
      }
    }
    if( length>0 ){printf("if(length>0)\n");
    
      printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");
      sqlite3StrAccumAppend(pAccum, bufpt, length);
    }
    if( flag_leftjustify ){printf("if(flag_leftjustify)\n");
    
      printf("register int nspace;\n");
      register int nspace;
      printf("nspace = width-length;\n");
nspace = width-length;
      if( nspace>0 ){printf("if(nspace>0)\n");
      
        printf("sqlite3AppendSpace(pAccum, nspace);\n");
        sqlite3AppendSpace(pAccum, nspace);
      }
    }
    printf("sqlite3_free(zExtra);\n");
    sqlite3_free(zExtra);
  }/* End for loop over the format string */
printf("------function end!------\n");
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
17,19
20,21
20,22
21,22
23,24
25,26
25,27
25,28
25,29
25,30
25,31
25,32
25,33
25,34
25,35
25,36
25,37
25,38
25,39
25,40
25,41
25,42
25,43
25,44
25,45
25,46
25,47
25,48
25,49
25,50
25,51
25,52
25,53
25,54
25,55
25,56
25,57
25,58
25,59
25,60
25,61
25,62
25,63
25,64
25,65
25,66
25,67
25,68
25,69
25,70
25,71
25,72
25,73
25,74
25,75
25,76
25,77
25,78
25,79
25,80
25,81
25,82
25,83
25,84
25,85
25,86
25,87
25,88
25,89
25,90
26,27
27,28
27,29
27,30
28,29
32,33
33,34
33,35
33,36
34,35
37,38
39,40
40,41
40,42
41,42
44,45
45,46
45,47
46,47
49,50
50,51
50,52
51,52
54,55
55,56
55,57
57,58
59,60
60,61
60,62
61,62
64,65
65,66
65,67
67,68
67,69
70,71
71,72
71,73
72,73
75,76
76,77
76,78
78,79
80,81
81,82
81,83
82,83
85,86
86,87
86,88
88,89
90,91
91,92
91,93
92,93
95,96
96,97
96,98
98,99
100,101
101,102
101,103
102,103
105,106
106,107
106,108
108,109
110,111
111,112
111,113
112,113
115,116
116,117
116,118
117,118
119,120
121,122
122,123
122,124
123,124
126,127
127,128
127,129
128,129
130,131
132,133
133,134
133,135
134,135
137,138
138,139
138,140
139,140
141,142
143,144
144,145
144,146
145,146
148,149
149,150
149,151
150,151
152,153
154,155
155,156
155,157
156,157
159,160
160,161
160,162
161,162
163,164
165,166
166,167
166,168
167,168
170,171
171,172
171,173
172,173
174,175
176,177
177,178
177,179
178,179
181,182
182,183
182,184
183,184
185,186
187,188
188,189
188,190
189,190
192,193
193,194
193,195
194,195
196,197
198,199
199,200
199,201
200,201
203,204
204,205
204,206
205,206
207,208
209,210
210,211
210,212
211,212
214,215
215,216
215,217
216,217
218,219
218,220
220,221
222,223
223,224
223,225
224,225
227,228
228,229
228,230
230,231
232,233
233,234
233,235
234,235
236,237
238,239
239,240
239,241
240,241
243,244
244,245
244,246
245,246
247,248
249,250
250,251
250,252
251,252
254,255
255,256
255,257
256,257
258,259
258,260
261,262
262,263
262,264
263,264
266,267
267,268
267,269
269,270
269,271
272,273
273,274
273,275
274,275
277,278
278,279
278,280
280,281
282,283
283,284
283,285
284,285
287,288
288,289
288,290
290,291
290,292
293,294
294,295
294,296
295,296
298,299
299,300
299,301
299,302
301,302
303,304
305,306
306,307
306,308
307,308
310,311
311,312
311,313
313,314
315,316
316,317
316,318
317,318
320,321
321,322
321,323
323,324
325,326
326,327
326,328
327,328
330,331
331,332
331,333
332,333
334,335
336,337
337,338
337,339
338,339
341,342
342,343
342,344
343,344
345,346
347,348
348,349
348,350
349,350
352,353
353,354
353,355
355,356
355,357
357,358
358,359
360,361
361,362
361,363
362,363
365,366
366,367
366,368
367,368
370,371
370,372
370,373
370,374
372,373
372,374
373,374
374,375
374,376
375,376
377,378
378,379
379,380
382,383
383,384
385,386
385,387
385,388
385,389
385,390
385,391
385,392
385,393
385,394
385,395
385,396
385,397
385,398
385,399
385,400
385,401
385,402
385,403
385,404
385,405
385,406
385,407
385,408
385,409
385,410
385,411
386,387
386,388
387,388
387,389
388,389
391,392
391,393
391,394
391,395
391,396
391,397
391,398
391,399
391,400
391,401
391,402
392,393
393,394
393,395
394,395
397,398
398,399
398,400
399,400
402,403
403,404
403,405
405,406
407,408
408,409
408,410
409,410
412,413
413,414
413,415
414,415
416,417
416,418
417,418
417,419
419,420
421,422
423,424
424,425
424,426
425,426
428,429
429,430
429,431
430,431
433,434
433,435
434,435
434,436
435,436
435,437
436,437
437,438
437,439
438,439
440,441
441,442
442,443
443,444
446,447
446,448
447,448
450,451
450,452
450,453
451,452
452,453
452,454
453,454
456,457
457,458
457,459
458,459
461,462
462,463
463,464
465,466
466,467
466,468
467,468
470,471
471,472
471,473
471,474
471,475
472,473
474,475
476,477
478,479
480,481
480,482
481,482
481,483
482,483
485,486
485,487
486,487
487,488
487,489
488,489
492,493
492,494
493,494
493,495
494,495
495,496
495,497
496,497
498,499
499,500
500,501
501,502
504,505
504,506
504,507
504,508
505,506
506,507
506,508
507,508
510,511
511,512
511,513
512,513
515,516
516,517
516,518
516,519
516,520
517,518
519,520
524,525
525,526
525,527
526,527
529,530
530,531
530,532
531,532
533,534
533,535
534,535
536,537
536,538
537,538
539,540
539,541
540,541
542,543
542,544
543,544
545,546
545,547
546,547
549,550
550,551
550,552
551,552
554,555
555,556
555,557
556,557
559,560
559,561
560,561
560,562
561,562
562,563
562,564
563,564
566,567
566,568
567,568
569,570
569,571
569,572
569,573
569,574
569,575
569,576
569,577
569,578
569,579
569,580
569,581
569,582
569,583
569,584
569,585
569,586
569,587
569,588
569,589
569,590
569,591
569,592
569,593
569,594
569,595
569,596
569,597
570,571
572,573
573,574
573,575
574,575
577,578
578,579
578,580
579,580
583,584
585,586
586,587
586,588
587,588
590,591
591,592
591,593
592,593
596,597
598,599
599,600
599,601
600,601
603,604
604,605
604,606
605,606
609,610
611,612
612,613
612,614
613,614
616,617
617,618
617,619
618,619
622,623
624,625
625,626
625,627
626,627
629,630
630,631
630,632
631,632
635,636
637,638
638,639
638,640
639,640
642,643
643,644
643,645
644,645
649,650
650,651
650,652
651,652
654,655
655,656
655,657
656,657
660,661
660,662
661,662
662,663
664,665
664,666
665,666
666,667
666,668
667,668
669,670
670,671
671,672
672,673
675,676
676,677
676,678
677,678
680,681
681,682
681,683
682,683
685,686
685,687
685,688
686,687
686,688
687,688
690,691
690,692
690,693
690,694
690,695
690,696
691,692
692,693
692,694
693,694
696,697
697,698
697,699
698,699
701,702
702,703
702,704
703,704
703,705
704,705
707,708
707,709
707,710
707,711
707,712
708,709
709,710
709,711
710,711
713,714
714,715
714,716
715,716
718,719
719,720
719,721
720,721
723,724
724,725
724,726
725,726
728,729
729,730
729,731
730,731
732,733
733,734
735,736
736,737
736,738
737,738
740,741
741,742
741,743
742,743
744,745
745,746
746,747
748,749
749,750
749,751
750,751
750,752
751,752
751,753
752,753
755,756
755,757
756,757
759,760
759,761
759,762
759,763
759,764
760,761
761,762
761,763
762,763
765,766
766,767
766,768
767,768
770,771
771,772
771,773
772,773
774,775
774,776
775,776
775,777
776,777
776,778
777,778
780,781
783,784
784,785
784,786
785,786
788,789
789,790
789,791
790,791
792,793
793,794
794,795
796,797
796,798
796,799
797,798
797,799
798,799
801,802
801,803
801,804
801,805
801,806
801,807
802,803
803,804
803,805
804,805
807,808
808,809
808,810
809,810
812,813
813,814
813,815
814,815
817,818
818,819
818,820
819,820
822,823
823,824
823,825
824,825
826,827
827,828
828,829
830,831
830,832
830,833
831,832
831,833
832,833
835,836
835,837
835,838
835,839
835,840
835,841
836,837
837,838
837,839
838,839
841,842
842,843
842,844
843,844
846,847
847,848
847,849
848,849
848,850
849,850
852,853
852,854
852,855
853,854
854,855
854,856
855,856
858,859
859,860
859,861
860,861
863,864
864,865
864,866
865,866
867,868
868,869
870,871
871,872
871,873
872,873
875,876
876,877
876,878
877,878
879,880
880,881
881,882
883,884
884,885
884,886
885,886
885,887
886,887
886,888
887,888
890,891
890,892
891,892
894,895
894,896
894,897
894,898
894,899
895,896
896,897
896,898
897,898
900,901
901,902
901,903
902,903
905,906
906,907
906,908
907,908
909,910
909,911
910,911
910,912
911,912
911,913
912,913
915,916
918,919
919,920
919,921
920,921
923,924
924,925
924,926
925,926
927,928
928,929
929,930
931,932
931,933
932,933
933,934
933,935
934,935
937,938
938,939
938,940
939,940
941,942
943,944
943,945
943,946
944,945
944,946
945,946
948,949
948,950
948,951
948,952
948,953
948,954
949,950
950,951
950,952
951,952
954,955
955,956
955,957
956,957
959,960
960,961
960,962
961,962
964,965
965,966
965,967
966,967
969,970
970,971
970,972
971,972
973,974
974,975
975,976
977,978
977,979
977,980
978,979
978,980
979,980
982,983
982,984
982,985
982,986
982,987
983,984
984,985
984,986
985,986
988,989
989,990
989,991
990,991
993,994
994,995
994,996
995,996
998,999
999,1000
999,1001
1000,1001
1003,1004
1004,1005
1004,1006
1005,1006
1007,1008
1008,1009
1009,1010
1011,1012
1011,1013
1012,1013
1013,1014
1013,1015
1014,1015
1017,1018
1018,1019
1018,1020
1019,1020
1022,1023
1022,1024
1023,1024
1024,1025
1024,1026
1025,1026
1028,1029
1029,1030
1029,1031
1030,1031
1032,1033
1032,1034
1033,1034
1036,1037
1037,1038
1037,1039
1038,1039
1041,1042
1042,1043
1042,1044
1043,1044
1045,1046
1046,1047
1046,1048
1047,1048
1050,1051
1051,1052
1051,1053
1052,1053
1055,1056
1056,1057
1056,1058
1057,1058
1059,1060
1061,1062
1061,1063
1061,1064
1061,1065
1062,1063
1063,1064
1063,1065
1064,1065
1067,1068
1067,1069
1068,1069
1070,1071
1070,1072
1071,1072
1073,1074
1075,1076
1076,1077
1078,1079
1078,1080
1079,1080
1080,1081
1080,1082
1081,1082
1084,1085
1084,1086
1085,1086
1085,1087
1086,1087
1088,1089
1088,1090
1089,1090
1089,1091
1090,1091
1092,1093
1095,1096
1095,1097
1095,1098
1095,1099
1095,1100
1096,1097
1097,1098
1097,1099
1098,1099
1101,1102
1102,1103
1102,1104
1103,1104
1106,1107
1107,1108
1107,1109
1108,1109
1110,1111
1111,1112
1111,1113
1112,1113
1114,1115
1116,1117
1116,1118
1116,1119
1117,1118
1117,1119
1118,1119
1120,1121
1120,1122
1121,1122
1122,1123
1122,1124
1123,1124
1123,1125
1124,1125
1127,1128
1130,1131
1130,1132
1130,1133
1131,1132
1132,1133
1132,1134
1133,1134
1136,1137
1137,1138
1137,1139
1138,1139
1141,1142
1142,1143
1142,1144
1143,1144
1145,1146
1145,1147
1146,1147
1149,1150
1149,1151
1149,1152
1150,1151
1151,1152
1151,1153
1152,1153
1155,1156
1156,1157
1156,1158
1157,1158
1162,1163
1163,1164
1163,1165
1164,1165
1167,1168
1168,1169
1168,1170
1169,1170
1172,1173
1173,1174
1173,1175
1174,1175
1177,1178
1177,1179
1178,1179
1180,1181
1180,1182
1180,1183
1180,1184
1180,1185
1180,1186
1180,1187
1180,1188
1180,1189
1180,1190
1180,1191
1180,1192
1180,1193
1180,1194
1180,1195
1180,1196
1180,1197
1180,1198
1180,1199
1180,1200
1180,1201
1180,1202
1180,1203
1180,1204
1180,1205
1180,1206
1180,1207
1180,1208
1180,1209
1180,1210
1180,1211
1180,1212
1180,1213
1180,1214
1180,1215
1180,1216
1180,1217
1180,1218
1180,1219
1180,1220
1180,1221
1180,1222
1180,1223
1180,1224
1180,1225
1180,1226
1180,1227
1180,1228
1180,1229
1180,1230
1180,1231
1180,1232
1180,1233
1180,1234
1180,1235
1180,1236
1180,1237
1180,1238
1180,1239
1180,1240
1180,1241
1180,1242
1180,1243
1180,1244
1180,1245
1180,1246
1180,1247
1180,1248
1180,1249
1180,1250
1180,1251
1180,1252
1180,1253
1180,1254
1180,1255
1180,1256
1180,1257
1180,1258
1180,1259
1180,1260
1180,1261
1180,1262
1180,1263
1180,1264
1180,1265
1180,1266
1180,1267
1180,1268
1180,1269
1180,1270
1180,1271
1180,1272
1180,1273
1180,1274
1180,1275
1180,1276
1180,1277
1181,1182
1182,1183
1184,1185
1185,1186
1185,1187
1186,1187
1189,1190
1190,1191
1190,1192
1191,1192
1193,1194
1193,1195
1194,1195
1195,1196
1195,1197
1197,1198
1199,1200
1200,1201
1200,1202
1201,1202
1204,1205
1205,1206
1205,1207
1206,1207
1209,1210
1210,1211
1210,1212
1211,1212
1213,1214
1213,1215
1214,1215
1215,1216
1215,1217
1217,1218
1219,1220
1220,1221
1220,1222
1223,1224
1224,1225
1226,1227
1227,1228
1229,1230
1229,1231
1229,1232
1230,1231
1230,1232
1231,1232
1231,1233
1232,1233
1235,1236
1237,1238
1237,1239
1237,1240
1237,1241
1237,1242
1238,1239
1239,1240
1239,1241
1240,1241
1243,1244
1244,1245
1244,1246
1245,1246
1248,1249
1249,1250
1249,1251
1250,1251
1252,1253
1254,1255
1254,1256
1254,1257
1255,1256
1257,1258
1257,1259
1257,1260
1258,1259
1259,1260
1259,1261
1260,1261
1263,1264
1264,1265
1264,1266
1265,1266
1268,1269
1269,1270
1269,1271
1270,1271
1272,1273
1272,1274
1272,1275
1273,1274
1275,1276
1277,1278
1279,1280
1279,1281
1279,1282
1280,1281
1282,1283
1282,1284
1282,1285
1283,1284
1284,1285
1284,1286
1285,1286
1288,1289
1289,1290
1289,1291
1290,1291
1293,1294
1294,1295
1294,1296
1295,1296
1296,1297
1296,1298
1297,1298
1300,1301
1301,1302
1301,1303
1301,1304
1302,1303
1302,1304
1303,1304
1306,1307
1306,1308
1306,1309
1306,1310
1307,1308
1308,1309
1308,1310
1309,1310
1312,1313
1312,1314
1312,1315
1313,1314
1313,1315
1314,1315
1316,1317
1318,1319
1318,1320
1319,1320
1320,1321
1320,1322
1321,1322
1324,1325
1325,1326
1325,1327
1326,1327
1328,1329
1328,1330
1329,1330
1330,1331
1330,1332
1331,1332
1331,1333
1332,1333
1337,1338
1338,1339
1339,1340
1339,1341
1340,1341
1342,1343
1343,1344
1345,1346
1346,1347
1346,1348
1347,1348
1350,1351
1351,1352
1351,1353
1352,1353
1355,1356
1355,1357
1356,1357
1357,1358
1357,1359
1358,1359
1360,1361
1362,1363
1362,1364
1362,1365
1363,1364
1365,1366
1365,1367
1365,1368
1366,1367
1367,1368
1367,1369
1368,1369
1371,1372
1372,1373
1372,1374
1373,1374
1376,1377
1377,1378
1377,1379
1378,1379
1381,1382
1381,1383
1381,1384
1382,1383
1384,1385
1384,1386
1384,1387
1385,1386
1386,1387
1386,1388
1387,1388
1390,1391
1391,1392
1391,1393
1392,1393
1395,1396
1396,1397
1396,1398
1397,1398
1400,1401
1400,1402
1401,1402
1402,1403
1402,1404
1403,1404
1406,1407
1407,1408
1407,1409
1408,1409
1411,1412
1411,1413
1411,1414
1412,1413
1412,1414
1412,1415
1413,1414
1415,1416
1415,1417
1416,1417
1417,1418
1417,1419
1418,1419
1421,1422
1422,1423
1422,1424
1423,1424
1425,1426
1425,1427
1425,1428
1426,1427
1428,1429
1430,1431
1432,1433
1432,1434
1432,1435
1433,1434
1435,1436
1435,1437
1436,1437
1437,1438
1437,1439
1438,1439
1441,1442
1442,1443
1443,1444
1444,1445
1445,1446
1445,1447
1446,1447
1449,1450
1450,1451
1450,1452
1451,1452
1454,1455
1454,1456
1455,1456
1455,1457
1456,1457
1459,1460
1459,1461
1459,1462
1460,1461
1461,1462
1461,1463
1462,1463
1465,1466
1466,1467
1466,1468
1467,1468
1470,1471
1471,1472
1471,1473
1472,1473
1475,1476
1475,1477
1476,1477
1476,1478
1477,1478
1479,1480
1479,1481
1480,1481
1482,1483
1482,1484
1483,1484
1485,1486
1486,1487
1486,1488
1487,1488
1490,1491
1490,1492
1490,1493
1491,1492
1492,1493
1492,1494
1493,1494
1496,1497
1497,1498
1497,1499
1498,1499
1501,1502
1502,1503
1502,1504
1503,1504
1505,1506
1505,1507
1506,1507
1508,1509
1509,1510
1509,1511
1510,1511
1513,1514
1513,1515
1513,1516
1514,1515
1514,1516
1515,1516
1517,1518
1517,1519
1518,1519
1521,1522
1521,1523
1521,1524
1521,1525
1521,1526
1522,1523
1523,1524
1523,1525
1524,1525
1527,1528
1528,1529
1528,1530
1529,1530
1532,1533
1533,1534
1533,1535
1534,1535
1536,1537
1538,1539
1539,1540
1539,1541
1540,1541
1543,1544
1544,1545
1544,1546
1545,1546
1547,1548
1549,1550
1549,1551
1549,1552
1549,1553
1549,1554
1550,1551
1551,1552
1551,1553
1552,1553
1555,1556
1556,1557
1556,1558
1557,1558
1559,1560
1559,1561
1560,1561
1563,1564
1564,1565
1564,1566
1565,1566
1568,1569
1569,1570
1569,1571
1570,1571
1572,1573
1572,1574
1573,1574
1575,1576
1575,1577
1576,1577
1578,1579
1580,1581
1580,1582
1581,1582
1581,1583
1582,1583
1585,1586
1585,1587
1585,1588
1585,1589
1585,1590
1585,1591
1586,1587
1587,1588
1587,1589
1588,1589
1591,1592
1592,1593
1592,1594
1593,1594
1596,1597
1597,1598
1597,1599
1598,1599
1598,1600
1599,1600
1602,1603
1604,1605
1605,1606
1605,1607
1606,1607
1609,1610
1610,1611
1610,1612
1611,1612
1615,1616
1616,1617
1616,1618
1617,1618
1620,1621
1621,1622
1621,1623
1622,1623
1624,1625
1625,1626
1625,1627
1626,1627
1628,1629
1628,1630
1629,1630
1632,1633
1632,1634
1633,1634
1633,1635
1634,1635
1636,1637
1638,1639
1638,1640
1638,1641
1638,1642
1638,1643
1638,1644
1638,1645
1638,1646
1638,1647
1638,1648
1639,1640
1640,1641
1640,1642
1641,1642
1644,1645
1645,1646
1645,1647
1646,1647
1649,1650
1650,1651
1650,1652
1652,1653
1652,1654
1652,1655
1655,1656
1657,1658
1658,1659
1658,1660
1659,1660
1662,1663
1663,1664
1663,1665
1665,1666
1665,1667
1667,1668
1668,1669
1668,1670
1669,1670
1669,1671
1672,1673
1673,1674
1673,1675
1674,1675
1677,1678
1677,1679
1678,1679
1678,1680
1679,1680
1679,1681
1680,1681
1683,1684
1683,1685
1684,1685
1684,1686
1685,1686
1686,1687
1686,1688
1687,1688
1692,1693
1692,1694
1692,1695
1693,1694
1694,1695
1694,1696
1695,1696
1698,1699
1699,1700
1699,1701
1700,1701
1703,1704
1704,1705
1704,1706
1705,1706
1708,1709
1709,1710
1709,1711
1710,1711
1713,1714
1714,1715
1714,1716
1715,1716
1716,1717
1717,1718
1718,1719
1720,1721
1720,1722
1721,1722
1723,1724
1723,1725
1724,1725
1724,1726
1725,1726
1729,1730
1730,1731
1730,1732
1731,1732
1734,1735
1735,1736
1735,1737
1736,1737
1737,1738
1738,1739
1739,1740
1741,1742
1741,1743
1742,1743
1744,1745
1744,1746
1745,1746
1748,1749
1749,1750
1749,1751
1750,1751
1753,1754
1753,1755
1753,1756
1753,1757
1753,1758
1753,1759
1753,1760
1753,1761
1753,1762
1754,1755
1755,1756
1755,1757
1756,1757
1759,1760
1760,1761
1760,1762
1762,1763
1762,1764
1765,1766
1766,1767
1766,1768
1767,1768
1770,1771
1771,1772
1771,1773
1773,1774
1775,1776
1776,1777
1776,1778
1777,1778
1780,1781
1781,1782
1781,1783
1782,1783
1784,1785
1785,1786
1785,1787
1786,1787
1788,1789
1788,1790
1789,1790
1792,1793
1793,1794
1793,1795
1794,1795
1797,1798
1798,1799
1798,1800
1799,1800
1801,1802
1801,1803
1802,1803
1805,1806
1805,1807
1806,1807
1806,1808
1807,1808
1808,1809
1808,1810
1809,1810
1810,1811
1811,1812
1812,1813
1814,1815
1814,1816
1815,1816
1817,1818
1817,1819
1818,1819
1820,1821
1822,1823
1823,1824
1823,1825
1824,1825
1826,1827
1826,1828
1827,1828
1829,1830
1831,1832
1831,1833
1832,1833
1835,1836
1836,1837
1836,1838
1837,1838
1840,1841
1841,1842
1841,1843
1842,1843
1844,1845
1844,1846
1845,1846
1845,1847
1848,1849
1849,1850
1849,1851
1850,1851
1851,1852
1851,1853
1852,1853
1854,1855
1854,1856
1855,1856
1858,1859
1860,1861
1860,1862
1860,1863
1860,1864
1861,1862
1862,1863
1862,1864
1863,1864
1865,1866
1865,1867
1866,1867
1868,1869
1870,1871
1870,1872
1871,1872
1874,1875
1875,1876
1877,1878
1877,1879
1877,1880
1878,1879
1879,1880
1879,1881
1880,1881
1883,1884
1884,1885
1884,1886
1885,1886
1888,1889
1889,1890
1889,1891
1890,1891
1891,1892
1892,1893
1893,1894
1896,1897
1896,1898
1897,1898
1899,1900
1899,1901
1899,1902
1900,1901
1901,1902
1901,1903
1902,1903
1905,1906
1906,1907
1906,1908
1907,1908
1910,1911
1911,1912
1911,1913
1912,1913
1913,1914
1914,1915
1915,1916
1917,1918
1919,1920
1919,1921
1920,1921
1920,1922
1921,1922
1923,1924
1923,1925
1924,1925
1927,1928
1927,1929
1927,1930
1927,1931
1927,1932
1927,1933
1927,1934
1927,1935
1928,1929
1929,1930
1929,1931
1930,1931
1933,1934
1934,1935
1934,1936
1935,1936
1938,1939
1939,1940
1939,1941
1941,1942
1941,1943
1944,1945
1945,1946
1945,1947
1946,1947
1949,1950
1950,1951
1950,1952
1952,1953
1954,1955
1955,1956
1955,1957
1956,1957
1959,1960
1960,1961
1960,1962
1961,1962
1963,1964
1964,1965
1964,1966
1965,1966
1967,1968
1967,1969
1968,1969
1971,1972
1971,1973
1971,1974
1971,1975
1973,1974
1973,1975
1974,1975
1975,1976
1975,1977
1976,1977
1978,1979
1979,1980
1980,1981
1983,1984
1984,1985
1986,1987
1986,1988
1987,1988
1988,1989
1988,1990
1989,1990
1992,1993
1993,1994
1993,1995
1994,1995
1995,1996
1996,1997
1997,1998
1999,2000
2001,2002
2002,2003
2002,2004
2003,2004
2006,2007
2007,2008
2007,2009
2008,2009
2010,2011
2010,2012
2011,2012
2011,2013
2014,2015
2015,2016
2015,2017
2016,2017
2017,2018
2017,2019
2018,2019
2020,2021
2020,2022
2021,2022
2024,2025
2027,2028
2028,2029
2030,2031
2031,2032
2033,2034
2034,2035
2036,2037
2037,2038
2037,2039
2038,2039
2041,2042
2042,2043
2042,2044
2043,2044
2043,2045
2044,2045
2047,2048
2048,2049
2048,2050
2049,2050
2052,2053
2052,2054
2052,2055
2053,2054
2053,2055
2054,2055
2057,2058
2057,2059
2058,2059
2059,2060
2059,2061
2060,2061
2062,2063
2063,2064
2065,2066
2066,2067
2066,2068
2067,2068
2070,2071
2071,2072
2071,2073
2071,2074
2072,2073
2074,2075
2075,2076
2075,2077
2076,2077
2079,2080
2079,2081
2079,2082
2080,2081
2082,2083
2083,2084
2083,2085
2084,2085
2087,2088
2088,2089
2088,2090
2089,2090
2092,2093
2092,2094
2093,2094
2093,2095
2094,2095
2094,2096
2095,2096
2097,2098
2099,2100
2099,2101
2100,2101
2103,2104
2104,2105
2105,2106
2107,2108
2107,2109
2107,2110
2107,2111
2108,2109
2109,2110
2109,2111
2110,2111
2110,2112
2111,2112
2113,2114
2115,2116
2115,2117
2116,2117
2119,2120
2119,2121
2120,2121
2123,2124
2123,2125
2124,2125
2125,2126
2127,2128
2127,2129
2128,2129
2132,2133
2132,2134
2133,2134
2133,2135
2134,2135
2136,2137
2138,2139
2139,2140
2139,2141
2140,2141
2142,2143
2144,2145
2145,2146
2145,2147
2146,2147
2149,2150
2149,2151
2150,2151
2150,2152
2151,2152
2153,2154
2153,2155
2154,2155
2154,2156
2157,2158
2159,2160
2159,2161
2159,2162
2160,2161
2161,2162
2161,2163
2162,2163
2165,2166
2166,2167
2166,2168
2167,2168
2171,2172
2171,2173
2172,2173
2172,2174
2173,2174
2176,2177
2176,2178
2176,2179
2176,2180
2176,2181
2176,2182
2176,2183
2176,2184
2176,2185
2177,2178
2178,2179
2178,2180
2179,2180
2181,2182
2181,2183
2183,2184
2185,2186
2185,2187
2186,2187
2186,2188
2187,2188
2187,2189
2188,2189
2190,2191
2190,2192
2192,2193
2194,2195
2194,2196
2195,2196
2198,2199
2198,2200
2199,2200
2200,2201
2200,2202
2201,2202
2204,2205
2205,2206
2205,2207
2206,2207
2209,2210
2209,2211
2210,2211
2210,2212
2211,2212
2211,2213
2212,2213
2214,2215
2214,2216
2216,2217
2218,2219
2218,2220
2219,2220
2222,2223
2222,2224
2223,2224
2224,2225
2224,2226
2225,2226
2228,2229
2229,2230
2229,2231
2230,2231
2233,2234
2233,2235
2234,2235
2234,2236
2235,2236
2235,2237
2236,2237
2238,2239
2238,2240
2240,2241
2242,2243
2242,2244
2243,2244
2246,2247
2246,2248
2247,2248
2248,2249
2248,2250
2249,2250
2252,2253
2253,2254
2253,2255
2254,2255
2257,2258
2257,2259
2258,2259
2258,2260
2259,2260
2259,2261
2260,2261
2262,2263
2262,2264
2264,2265
2266,2267
2266,2268
2267,2268
2270,2271
2270,2272
2271,2272
2272,2273
2272,2274
2273,2274
2276,2277
2277,2278
2278,2279
2280,2281
2281,2282
2281,2283
2282,2283
2284,2285
2286,2287
2286,2288
2287,2288
2287,2289
2288,2289
2291,2292
2291,2293
2292,2293
2293,2294
2293,2295
2294,2295
2297,2298
2298,2299
2298,2300
2299,2300
2302,2303
2302,2304
2303,2304
2303,2305
2304,2305
2307,2308
2307,2309
2308,2309
2309,2310
2309,2311
2310,2311
2313,2314
2314,2315
2315,2316
2317,2318
2317,2319
2318,2319
2318,2320
2319,2320
2322,2323
2322,2324
2322,2325
2323,2324
2323,2325
2323,2326
2324,2325
2324,2326
2325,2326
2328,2329
2329,2330
2330,2331
2330,2332
2331,2332
2334,2335
2334,2336
2334,2337
2335,2336
2335,2337
2336,2337
2339,2340
2340,2341
2341,2342
2341,2343
2342,2343
2345,2346
2346,2347
2347,2348
2347,2349
2348,2349
2351,2352
2352,2353
2352,2354
2353,2354
2355,2356
2355,2357
2356,2357
2358,2359
2361,2362
2362,2363
2362,2364
2363,2364
2365,2366
2367,2368
2367,2369
2368,2369
2368,2370
2369,2370
2371,2372
2373,2374
2373,2375
2374,2375
2375,2376
2375,2377
2376,2377
2378,2379
2380,2381
2380,2382
2381,2382
2381,2383
2382,2383
2385,2386
2385,2387
2386,2387
2387,2388
2387,2389
2388,2389
2391,2392
2392,2393
2393,2394
2395,2396
2395,2397
2395,2398
2396,2397
2396,2398
2397,2398
2399,2400
2401,2402
2401,2403
2402,2403
2403,2404
2403,2405
2404,2405
2406,2407
2407,2408
2409,2410
2409,2411
2409,2412
2410,2411
2410,2412
2411,2412
2411,2413
2412,2413
2414,2415
2416,2417
2416,2418
2417,2418
2419,2420
2421,2422
2422,2423
2423,2424
2423,2425
2424,2425
2426,2427
2428,2429
2428,2430
2429,2430
2430,2431
2430,2432
2431,2432
2433,2434
2433,2435
2434,2435
2436,2437
2438,2439
2439,2440
2439,2441
2440,2441
2442,2443
2444,2445
2445,2446
2446,2447
2446,2448
2447,2448
2449,2450
2451,2452
2451,2453
2451,2454
2452,2453
2452,2454
2453,2454
2455,2456
2457,2458
2458,2459
2459,2460
2459,2461
2460,2461
2463,2464
2464,2465
2465,2466
2465,2467
2466,2467
2468,2469
2470,2471
2470,2472
2471,2472
2471,2473
2472,2473
2472,2474
2473,2474
2473,2475
2474,2475
2474,2476
2474,2477
2475,2476
2477,2478
2480,2481
2482,2483
2484,2485
2484,2486
2485,2486
2488,2489
2488,2490
2489,2490
2490,2491
2490,2492
2491,2492
2493,2494
2493,2495
2494,2495
2496,2497
2496,2498
2497,2498
2499,2500
2499,2501
2500,2501
2500,2502
2501,2502
2501,2503
2502,2503
2502,2504
2502,2505
2503,2504
2505,2506
2508,2509
2510,2511
2513,2514
2513,2515
2514,2515
2514,2516
2515,2516
2518,2519
2518,2520
2519,2520
2520,2521
2520,2522
2521,2522
2521,2523
2522,2523
2525,2526
2528,2529
2529,2530
2529,2531
2530,2531
2532,2533
2534,2535
2535,2536
2535,2537
2536,2537
2538,2539
2538,2540
2540,2541
2540,2542
2541,2542
2544,2545
2545,2546
2545,2547
2546,2547
2548,2549
2548,2550
2549,2550
2549,2551
2550,2551
2551,2552
2551,2553
2551,2554
2552,2553
2552,2554
2553,2554
2558,2559
2560,2561
2562,2563
2562,2564
2563,2564
2565,2566
2566,2567
2567,2568
2567,2569
2568,2569
2569,2570
2570,2571
2571,2572
2573,2574
2575,2576
2575,2577
2575,2578
2576,2577
2576,2578
2577,2578
2580,2581
2581,2582
2582,2583
2582,2584
2583,2584
2584,2585
2585,2586
2586,2587
2589,2590
2590,2591
2590,2592
2590,2593
2590,2594
2592,2593
2592,2594
2593,2594
2596,2597
2597,2598
2599,2600
2600,2601
2601,2602
2601,2603
2602,2603
2603,2604
2604,2605
2605,2606
2607,2608
2607,2609
2607,2610
2608,2609
2610,2611
2611,2612
2613,2614
2614,2615
2616,2617
2616,2618
2617,2618
2619,2620
2620,2621
2621,2622
2621,2623
2622,2623
2623,2624
2624,2625
2625,2626
2628,2629
2628,2630
2628,2631
2628,2632
2629,2630
2630,2631
2631,2632
2633,2634
2633,2635
2634,2635
2637,2638
2637,2639
2638,2639
2639,2640
2641,2642
2642,2643
2644,2645
2644,2646
2645,2646
2646,2647
2646,2648
2647,2648
2649,2650
2649,2651
2650,2651
2653,2654
2654,2655
2654,2656
2655,2656
2656,2657
2657,2658
2658,2659
2661,2662
2661,2663
2662,2663
2662,2664
2663,2664
2664,2665
2665,2666
2668,2669
2669,2670
2670,2671
2670,2672
2671,2672
2672,2673
2673,2674
2674,2675
2676,2677
2676,2678
2676,2679
2677,2678
2679,2680
2680,2681
2682,2683
2683,2684
2685,2686
2685,2687
2686,2687
2686,2688
2687,2688
2689,2690
2691,2692
2691,2693
2691,2694
2692,2693
2692,2694
2693,2694
2693,2695
2694,2695
2694,2696
2695,2696
2697,2698
2700,2701
2701,2702
2701,2703
2702,2703
2703,2704
2704,2705
2705,2706
2708,2709
2709,2710
2709,2711
2710,2711
2712,2713
2712,2714
2713,2714
2715,2716
2717,2718
2717,2719
2718,2719
2718,2720
2719,2720
2719,2721
2720,2721
2722,2723
2725,2726
2726,2727
2726,2728
2726,2729
2727,2728
2729,2730
2730,2731
2731,2732
2731,2733
2732,2733
2733,2734
2734,2735
2735,2736
2738,2739
2739,2740
2740,2741
2740,2742
2741,2742
2742,2743
2743,2744
2744,2745
2747,2748
2747,2749
2748,2749
2748,2750
2749,2750
2751,2752
2753,2754
2753,2755
2753,2756
2753,2757
2753,2758
2754,2755
2755,2756
2755,2757
2756,2757
2757,2758
2758,2759
2759,2760
2761,2762
2761,2763
2762,2763
2764,2765
2764,2766
2765,2766
2768,2769
2768,2770
2768,2771
2769,2770
2769,2771
2770,2771
2773,2774
2773,2775
2774,2775
2775,2776
2775,2777
2776,2777
2777,2778
2778,2779
2779,2780
2782,2783
2783,2784
2783,2785
2784,2785
2786,2787
2787,2788
2789,2790
2790,2791
2791,2792
2791,2793
2792,2793
2793,2794
2794,2795
2795,2796
2798,2799
2798,2800
2799,2800
2799,2801
2800,2801
2803,2804
2803,2805
2804,2805
2805,2806
2805,2807
2806,2807
2807,2808
2808,2809
2809,2810
2811,2812
2811,2813
2812,2813
2812,2814
2815,2816
2816,2817
2816,2818
2817,2818
2818,2819
2818,2820
2819,2820
2823,2824
2824,2825
2824,2826
2825,2826
2828,2829
2829,2830
2829,2831
2830,2831
2831,2832
2832,2833
2833,2834
2835,2836
2835,2837
2836,2837
2836,2838
2839,2840
2840,2841
2840,2842
2841,2842
2841,2843
2842,2843
2846,2847
2847,2848
2847,2849
2848,2849
2849,2850
2850,2851
2851,2852
2853,2854
2853,2855
2854,2855
2854,2856
2857,2858
2858,2859
2858,2860
2859,2860
2859,2861
2860,2861
2864,2865
2865,2866
2865,2867
2866,2867
2867,2868
2870,2871
2871,2872
2871,2873
2872,2873
2874,2875
2874,2876
2875,2876
2875,2877
2878,2879
2879,2880
2879,2881
2880,2881
2882,2883
2884,2885
2885,2886
2885,2887
2886,2887
2888,2889
2890,2891
2890,2892
2891,2892
2891,2893
2892,2893
2892,2894
2893,2894
2895,2896
2896,2897
2898,2899
2898,2900
2899,2900
2901,2902
2903,2904
2903,2905
2903,2906
2903,2907
2903,2908
2903,2909
2904,2905
2905,2906
2905,2907
2907,2908
2909,2910
2910,2911
2910,2912
2912,2913
2912,2914
2914,2915
2915,2916
2915,2917
2916,2917
2918,2919
2920,2921
2920,2922
2920,2923
2920,2924
2921,2922
2922,2923
2922,2924
2923,2924
2925,2926
2927,2928
2927,2929
2928,2929
2930,2931
2932,2933
2933,2934
2935,2936
2936,2937
2937,2938
2937,2939
2938,2939
2938,2940
2939,2940
2941,2942
2943,2944
2943,2945
2944,2945
2946,2947
2946,2948
2947,2948
2949,2950
2951,2952
2952,2953
2952,2954
2953,2954
2955,2956
2955,2957
2956,2957
2959,2960
2959,2961
2960,2961
2961,2962
2963,2964
2964,2965
2964,2966
2965,2966
2965,2967
2966,2967
2968,2969
2969,2970
2972,2973
2973,2974
2973,2975
2974,2975
2976,2977
2979,2980
2980,2981
2982,2983
2983,2984
2983,2985
2984,2985
2987,2988
2988,2989
2989,2990
2989,2991
2990,2991
2993,2994
2994,2995
2994,2996
2995,2996
2997,2998
2997,2999
2998,2999
3002,3003
3003,3004
3005,3006
3006,3007
3006,3008
3007,3008
3010,3011
3011,3012
3011,3013
3012,3013
3012,3014
3013,3014
3017,3018
3018,3019
3018,3020
3019,3020
3022,3023
3023,3024
3023,3025
3024,3025
3026,3027
3028,3029
3029,3030
3029,3031
3030,3031
3033,3034
3034,3035
3034,3036
3035,3036
3039,3040
3040,3041
3042,3043
3043,3044
3043,3045
3044,3045
3047,3048
3048,3049
3049,3050
3049,3051
3050,3051
3053,3054
3054,3055
3054,3056
3055,3056
3055,3057
3056,3057
3059,3060
3059,3061
3060,3061
3060,3062
3063,3064
3065,3066
3065,3067
3065,3068
3066,3067
3066,3068
3067,3068
3070,3071
3070,3072
3070,3073
3070,3074
3071,3072
3072,3073
3072,3074
3073,3074
3076,3077
3076,3078
3076,3079
3076,3080
3077,3078
3078,3079
3078,3080
3079,3080
3082,3083
3082,3084
3083,3084
3085,3086
3087,3088
3088,3089
3090,3091
3090,3092
3090,3093
3091,3092
3092,3093
3092,3094
3093,3094
3096,3097
3097,3098
3097,3099
3098,3099
3101,3102
3102,3103
3102,3104
3103,3104
3103,3105
3104,3105
3106,3107
3108,3109
3108,3110
3109,3110
3109,3111
3112,3113
3114,3115
3115,3116
3115,3117
3116,3117
3119,3120
3120,3121
3120,3122
3121,3122
3123,3124
3125,3126
3125,3127
3126,3127
3127,3128
3127,3129
3128,3129
3131,3132
3132,3133
3132,3134
3133,3134
3136,3137
3137,3138
3137,3139
3138,3139
3141,3142
3142,3143
3142,3144
3143,3144
3145,3146
3148,3149
3149,3150
3151,3152
3152,3153
3154,3155
3155,3156
3155,3157
3156,3157
3159,3160
3160,3161
3160,3162
3160,3163
3161,3162
3161,3163
3162,3163
3165,3166
3165,3167
3165,3168
3166,3167
3167,3168
3167,3169
3168,3169
3171,3172
3172,3173
3172,3174
3173,3174
3176,3177
3177,3178
3177,3179
3178,3179
3181,3182
3181,3183
3182,3183
3182,3184
3183,3184
3185,3186
3187,3188
3187,3189
3187,3190
3188,3189
3189,3190
3189,3191
3190,3191
3193,3194
3194,3195
3194,3196
3195,3196
3198,3199
3199,3200
3199,3201
3200,3201
3202,3203
3204,3205
3204,3206
3204,3207
3205,3206
3205,3207
3206,3207
3209,3210
3209,3211
3210,3211
3211,3212
3211,3213
3212,3213
3215,3216
3215,3217
3215,3218
3215,3219
3216,3217
3217,3218
3217,3219
3218,3219
3221,3222
3221,3223
3222,3223
3222,3224
3223,3224
3225,3226
3227,3228
3227,3229
3228,3229
3230,3231
3232,3233
3233,3234
3235,3236
3236,3237
3237,3238
3237,3239
3238,3239
3241,3242
3241,3243
3242,3243
3243,3244
3243,3245
3244,3245
3247,3248
3248,3249
3248,3250
3249,3250
3251,3252
3251,3253
3252,3253
3254,3255
3257,3258
3258,3259
3260,3261
3261,3262
3263,3264
3264,3265
3266,3267
3266,3268
3266,3269
3266,3270
3266,3271
3266,3272
3266,3273
3266,3274
3266,3275
3266,3276
3266,3277
3266,3278
3266,3279
3266,3280
3266,3281
3266,3282
3266,3283
3266,3284
3266,3285
3266,3286
3266,3287
3266,3288
3266,3289
3266,3290
3266,3291
3266,3292
3266,3293
3266,3294
3266,3295
3266,3296
3266,3297
3266,3298
3266,3299
3267,3268
3268,3269
3268,3270
3269,3270
3272,3273
3273,3274
3273,3275
3273,3276
3273,3277
3273,3278
3273,3279
3275,3276
3277,3278
3279,3280
3281,3282
3283,3284
3285,3286
3286,3287
3286,3288
3287,3288
3290,3291
3291,3292
3291,3293
3293,3294
3295,3296
3296,3297
3296,3298
3297,3298
3300,3301
3301,3302
3301,3303
3303,3304
3305,3306
3306,3307
3306,3308
3307,3308
3310,3311
3311,3312
3311,3313
3313,3314
3313,3315
3315,3316
3316,3317
3317,3318
3317,3319
3317,3320
3318,3319
3319,3320
3319,3321
3320,3321
3322,3323
3326,3327
3327,3328
3327,3329
3328,3329
3331,3332
3332,3333
3333,3334
3333,3335
3334,3335
3337,3338
3338,3339
3338,3340
3339,3340
3341,3342
3341,3343
3342,3343
3345,3346
3345,3347
3346,3347
3348,3349
3348,3350
3348,3351
3349,3350
3350,3351
3350,3352
3351,3352
3354,3355
3355,3356
3355,3357
3356,3357
3359,3360
3360,3361
3360,3362
3361,3362
3363,3364
3364,3365
3364,3366
3364,3367
3365,3366
3365,3367
3366,3367
3368,3369
3372,3373
3373,3374
3373,3375
3374,3375
3377,3378
3378,3379
3378,3380
3379,3380
3381,3382
3383,3384
3383,3385
3383,3386
3383,3387
3384,3385
3385,3386
3385,3387
3386,3387
3388,3389
3388,3390
3389,3390
3392,3393
3392,3394
3393,3394
3393,3395
3394,3395
3397,3398
3397,3399
3398,3399
3399,3400
3399,3401
3400,3401
3402,3403
3402,3404
3403,3404
3405,3406
3408,3409
3408,3410
3409,3410
3410,3411
3412,3413
3413,3414
3415,3416
3415,3417
3416,3417
3417,3418
3417,3419
3418,3419
3421,3422
3421,3423
3422,3423
3422,3424
3423,3424
3425,3426
3427,3428
3427,3429
3427,3430
3428,3429
3429,3430
3429,3431
3430,3431
3433,3434
3434,3435
3434,3436
3435,3436
3438,3439
3439,3440
3440,3441
3442,3443
3443,3444
3443,3445
3444,3445
3447,3448
3448,3449
3448,3450
3449,3450
3451,3452
3451,3453
3452,3453
3453,3454
3455,3456
3455,3457
3456,3457
3458,3459
3460,3461
3461,3462
3461,3463
3462,3463
3465,3466
3466,3467
3466,3468
3467,3468
3469,3470
3469,3471
3470,3471
3470,3472
3471,3472
3474,3475
3474,3476
3475,3476
3478,3479
3478,3480
3478,3481
3479,3480
3479,3481
3480,3481
3482,3483
3484,3485
3484,3486
3484,3487
3484,3488
3485,3486
3486,3487
3486,3488
3487,3488
3490,3491
3491,3492
3491,3493
3492,3493
3495,3496
3496,3497
3496,3498
3497,3498
3499,3500
3499,3501
3500,3501
3502,3503
3502,3504
3503,3504
3505,3506
3507,3508
3507,3509
3508,3509
3508,3510
3509,3510
3512,3513
3512,3514
3512,3515
3512,3516
3512,3517
3512,3518
3513,3514
3514,3515
3514,3516
3515,3516
3518,3519
3519,3520
3519,3521
3520,3521
3523,3524
3524,3525
3524,3526
3525,3526
3525,3527
3526,3527
3529,3530
3531,3532
3532,3533
3532,3534
3533,3534
3536,3537
3537,3538
3537,3539
3538,3539
3542,3543
3542,3544
3543,3544
3544,3545
3544,3546
3545,3546
3548,3549
3549,3550
3549,3551
3550,3551
3552,3553
3554,3555
3555,3556
3555,3557
3556,3557
3559,3560
3560,3561
3560,3562
3561,3562
3564,3565
3564,3566
3565,3566
3567,3568
3567,3569
3567,3570
3568,3569
3569,3570
3569,3571
3570,3571
3573,3574
3574,3575
3574,3576
3575,3576
3578,3579
3579,3580
3579,3581
3580,3581
3580,3582
3581,3582
3583,3584
3584,3585
3586,3587
3588,3589
3589,3590
3589,3591
3590,3591
3593,3594
3594,3595
3594,3596
3595,3596
3597,3598
3599,3600
3599,3601
3599,3602
3599,3603
3600,3601
3601,3602
3601,3603
3602,3603
3605,3606
3605,3607
3606,3607
3608,3609
3610,3611
3611,3612
3613,3614
3613,3615
3613,3616
3613,3617
3614,3615
3615,3616
3615,3617
3616,3617
3619,3620
3620,3621
3620,3622
3621,3622
3624,3625
3625,3626
3625,3627
3626,3627
3626,3628
3627,3628
3629,3630
3630,3631
3632,3633
3632,3634
3633,3634
3635,3636
3635,3637
3636,3637
3638,3639
3640,3641
3640,3642
3641,3642
3641,3643
3642,3643
3644,3645
3646,3647
3646,3648
3646,3649
3647,3648
3648,3649
3648,3650
3649,3650
3652,3653
3653,3654
3653,3655
3654,3655
3657,3658
3658,3659
3658,3660
3659,3660
3659,3661
3660,3661
3662,3663
3663,3664
3665,3666
3667,3668
3667,3669
3668,3669
3670,3671
3670,3672
3670,3673
3671,3672
3672,3673
3672,3674
3673,3674
3676,3677
3677,3678
3677,3679
3678,3679
3681,3682
3682,3683
3682,3684
3683,3684
3683,3685
3684,3685
3686,3687
3687,3688
3689,3690
3691,3692
3692,3693
3692,3694
3693,3694
3696,3697
3697,3698
3697,3699
3698,3699
3698,3700
3699,3700
3701,3702
3704,3705
3705,3706
3705,3707
3706,3707
3709,3710
3710,3711
3710,3712
3711,3712
3713,3714
3716,3717
3717,3718
3719,3720
3719,3721
3719,3722
3719,3723
3719,3724
3719,3725
3720,3721
3721,3722
3721,3723
3722,3723
3725,3726
3726,3727
3726,3728
3727,3728
3729,3730
3729,3731
3729,3732
3730,3731
3731,3732
3731,3733
3732,3733
3735,3736
3736,3737
3736,3738
3737,3738
3740,3741
3741,3742
3741,3743
3741,3744
3741,3745
3742,3743
3744,3745
3746,3747
3746,3748
3747,3748
3747,3749
3749,3750
3751,3752
3751,3753
3752,3753
3755,3756
3755,3757
3756,3757
3759,3760
3760,3761
3760,3762
3761,3762
3764,3765
3765,3766
3765,3767
3766,3767
3768,3769
3768,3770
3769,3770
3773,3774
3774,3775
3776,3777
3776,3778
3776,3779
3776,3780
3776,3781
3776,3782
3776,3783
3776,3784
3776,3785
3776,3786
3776,3787
3776,3788
3776,3789
3776,3790
3777,3778
3778,3779
3778,3780
3779,3780
3782,3783
3783,3784
3784,3785
3784,3786
3785,3786
3788,3789
3789,3790
3790,3791
3790,3792
3791,3792
3794,3795
3795,3796
3795,3797
3796,3797
3798,3799
3798,3800
3798,3801
3801,3802
3802,3803
3803,3804
3803,3805
3804,3805
3804,3806
3805,3806
3808,3809
3810,3811
3811,3812
3811,3813
3812,3813
3815,3816
3816,3817
3816,3818
3817,3818
3819,3820
3819,3821
3820,3821
3820,3822
3821,3822
3824,3825
3824,3826
3825,3826
3827,3828
3827,3829
3828,3829
3831,3832
3831,3833
3832,3833
3832,3834
3833,3834
3836,3837
3836,3838
3836,3839
3836,3840
3836,3841
3837,3838
3838,3839
3838,3840
3839,3840
3842,3843
3843,3844
3843,3845
3844,3845
3847,3848
3848,3849
3848,3850
3848,3851
3848,3852
3849,3850
3851,3852
3853,3854
3853,3855
3854,3855
3857,3858
3859,3860
3860,3861
3860,3862
3861,3862
3864,3865
3865,3866
3865,3867
3865,3868
3865,3869
3866,3867
3868,3869
3872,3873
3873,3874
3873,3875
3874,3875
3877,3878
3878,3879
3878,3880
3878,3881
3878,3882
3879,3880
3881,3882
3883,3884
3883,3885
3884,3885
3887,3888
3889,3890
3890,3891
3890,3892
3891,3892
3894,3895
3895,3896
3895,3897
3896,3897
3898,3899
3898,3900
3899,3900
3904,3905
3904,3906
3904,3907
3904,3908
3904,3909
3905,3906
3906,3907
3906,3908
3907,3908
3910,3911
3911,3912
3911,3913
3912,3913
3914,3915
3914,3916
3915,3916
3917,3918
3919,3920
3920,3921
3920,3922
3921,3922
3924,3925
3925,3926
3925,3927
3926,3927
3930,3931
3930,3932
3931,3932
3932,3933
3934,3935
3934,3936
3934,3937
3934,3938
3934,3939
3934,3940
3935,3936
3936,3937
3936,3938
3937,3938
3940,3941
3941,3942
3941,3943
3942,3943
3945,3946
3946,3947
3946,3948
3948,3949
3950,3951
3951,3952
3951,3953
3952,3953
3955,3956
3956,3957
3956,3958
3957,3958
3959,3960
3959,3961
3960,3961
3962,3963
3964,3965
3964,3966
3965,3966
3965,3967
3966,3967
3969,3970
3969,3971
3969,3972
3970,3971
3971,3972
3971,3973
3972,3973
3975,3976
3976,3977
3976,3978
3977,3978
3980,3981
3981,3982
3981,3983
3981,3984
3982,3983
3984,3985
3986,3987
3988,3989
3988,3990
3989,3990
3989,3991
3990,3991
3993,3994
3993,3995
3993,3996
3994,3995
3995,3996
3995,3997
3996,3997
3999,4000
4000,4001
4000,4002
4001,4002
4004,4005
4005,4006
4005,4007
4005,4008
4005,4009
4006,4007
4008,4009
4010,4011
4012,4013
4014,4015
4014,4016
4015,4016
4017,4018
4017,4019
4017,4020
4017,4021
4017,4022
4017,4023
4018,4019
4019,4020
4019,4021
4020,4021
4023,4024
4024,4025
4024,4026
4025,4026
4028,4029
4029,4030
4029,4031
4031,4032
4033,4034
4034,4035
4034,4036
4035,4036
4038,4039
4039,4040
4039,4041
4040,4041
4042,4043
4042,4044
4043,4044
4045,4046
4047,4048
4047,4049
4048,4049
4048,4050
4049,4050
4052,4053
4052,4054
4052,4055
4053,4054
4054,4055
4054,4056
4055,4056
4058,4059
4059,4060
4059,4061
4060,4061
4063,4064
4064,4065
4064,4066
4064,4067
4065,4066
4067,4068
4069,4070
4071,4072
4072,4073
4072,4074
4073,4074
4076,4077
4077,4078
4077,4079
4078,4079
4080,4081
4082,4083
4083,4084
4083,4085
4084,4085
-----nextToken-----
2,4,7,9,10,12,14,16,18,19,22,24,29,30,31,35,36,38,42,43,47,48,52,53,56,58,62,63,66,68,69,73,74,77,79,83,84,87,89,93,94,97,99,103,104,107,109,113,114,118,120,124,125,129,131,135,136,140,142,146,147,151,153,157,158,162,164,168,169,173,175,179,180,184,186,190,191,195,197,201,202,206,208,212,213,217,219,221,225,226,229,231,235,237,241,242,246,248,252,253,257,259,260,264,265,268,270,271,275,276,279,281,285,286,289,291,292,296,297,300,302,304,308,309,312,314,318,319,322,324,328,329,333,335,339,340,344,346,350,351,354,356,359,363,364,368,369,371,376,380,381,384,389,390,395,396,400,401,404,406,410,411,415,418,420,422,426,427,431,432,439,444,445,448,449,454,455,459,460,464,468,469,473,475,477,479,483,484,489,490,491,497,502,503,508,509,513,514,518,520,521,522,523,527,528,532,535,538,541,544,547,548,552,553,557,558,564,565,568,571,575,576,580,581,582,584,588,589,593,594,595,597,601,602,606,607,608,610,614,615,619,620,621,623,627,628,632,633,634,636,640,641,645,646,647,648,652,653,657,658,659,663,668,673,674,678,679,683,684,688,689,694,695,699,700,705,706,711,712,716,717,721,722,726,727,731,734,738,739,743,747,753,754,757,758,763,764,768,769,773,778,779,781,782,786,787,791,795,799,800,805,806,810,811,815,816,820,821,825,829,833,834,839,840,844,845,850,851,856,857,861,862,866,869,873,874,878,882,888,889,892,893,898,899,903,904,908,913,914,916,917,921,922,926,930,935,936,940,942,946,947,952,953,957,958,962,963,967,968,972,976,980,981,986,987,991,992,996,997,1001,1002,1006,1010,1015,1016,1020,1021,1026,1027,1031,1034,1035,1039,1040,1044,1048,1049,1053,1054,1058,1060,1065,1066,1069,1072,1074,1077,1082,1083,1087,1091,1093,1094,1099,1100,1104,1105,1109,1113,1115,1119,1125,1126,1128,1129,1134,1135,1139,1140,1144,1147,1148,1153,1154,1158,1159,1160,1161,1165,1166,1170,1171,1175,1176,1179,1183,1187,1188,1192,1196,1198,1202,1203,1207,1208,1212,1216,1218,1221,1222,1225,1228,1233,1234,1236,1241,1242,1246,1247,1251,1253,1256,1261,1262,1266,1267,1271,1274,1276,1278,1281,1286,1287,1291,1292,1298,1299,1304,1305,1310,1311,1315,1317,1322,1323,1327,1333,1334,1335,1336,1341,1344,1348,1349,1353,1354,1359,1361,1364,1369,1370,1374,1375,1379,1380,1383,1388,1389,1393,1394,1398,1399,1404,1405,1409,1410,1414,1419,1420,1424,1427,1429,1431,1434,1439,1440,1447,1448,1452,1453,1457,1458,1463,1464,1468,1469,1473,1474,1478,1481,1484,1488,1489,1494,1495,1499,1500,1504,1507,1511,1512,1516,1519,1520,1525,1526,1530,1531,1535,1537,1541,1542,1546,1548,1553,1554,1558,1561,1562,1566,1567,1571,1574,1577,1579,1583,1584,1589,1590,1594,1595,1600,1601,1603,1607,1608,1612,1613,1614,1618,1619,1623,1627,1630,1631,1635,1637,1642,1643,1647,1648,1651,1653,1654,1656,1660,1661,1664,1666,1670,1671,1675,1676,1681,1682,1688,1689,1690,1691,1696,1697,1701,1702,1706,1707,1711,1712,1719,1722,1726,1727,1728,1732,1733,1740,1743,1746,1747,1751,1752,1757,1758,1761,1763,1764,1768,1769,1772,1774,1778,1779,1783,1787,1790,1791,1795,1796,1800,1803,1804,1813,1816,1819,1821,1825,1828,1830,1833,1834,1838,1839,1843,1846,1847,1853,1856,1857,1859,1864,1867,1869,1872,1873,1876,1881,1882,1886,1887,1894,1895,1898,1903,1904,1908,1909,1916,1918,1922,1925,1926,1931,1932,1936,1937,1940,1942,1943,1947,1948,1951,1953,1957,1958,1962,1966,1969,1970,1972,1977,1981,1982,1985,1990,1991,1998,2000,2004,2005,2009,2012,2013,2019,2022,2023,2025,2026,2029,2032,2035,2039,2040,2045,2046,2050,2051,2055,2056,2061,2064,2068,2069,2073,2077,2078,2081,2085,2086,2090,2091,2096,2098,2101,2102,2106,2112,2114,2117,2118,2121,2122,2126,2129,2130,2131,2135,2137,2141,2143,2147,2148,2152,2155,2156,2158,2163,2164,2168,2169,2170,2174,2175,2180,2182,2184,2189,2191,2193,2196,2197,2202,2203,2207,2208,2213,2215,2217,2220,2221,2226,2227,2231,2232,2237,2239,2241,2244,2245,2250,2251,2255,2256,2261,2263,2265,2268,2269,2274,2275,2279,2283,2285,2289,2290,2295,2296,2300,2301,2305,2306,2311,2312,2316,2320,2321,2326,2327,2332,2333,2337,2338,2343,2344,2349,2350,2354,2357,2359,2360,2364,2366,2370,2372,2377,2379,2383,2384,2389,2390,2394,2398,2400,2405,2408,2413,2415,2418,2420,2425,2427,2432,2435,2437,2441,2443,2448,2450,2454,2456,2461,2462,2467,2469,2476,2478,2479,2481,2483,2486,2487,2492,2495,2498,2504,2506,2507,2509,2511,2512,2516,2517,2523,2524,2526,2527,2531,2533,2537,2539,2542,2543,2547,2554,2555,2556,2557,2559,2561,2564,2572,2574,2578,2579,2587,2588,2591,2594,2595,2598,2606,2609,2612,2615,2618,2626,2627,2632,2635,2636,2640,2643,2648,2651,2652,2659,2660,2666,2667,2675,2678,2681,2684,2688,2690,2696,2698,2699,2706,2707,2711,2714,2716,2721,2723,2724,2728,2736,2737,2745,2746,2750,2752,2760,2763,2766,2767,2771,2772,2780,2781,2785,2788,2796,2797,2801,2802,2810,2813,2814,2820,2821,2822,2826,2827,2834,2837,2838,2843,2844,2845,2852,2855,2856,2861,2862,2863,2868,2869,2873,2876,2877,2881,2883,2887,2889,2894,2897,2900,2902,2906,2908,2911,2913,2917,2919,2924,2926,2929,2931,2934,2940,2942,2945,2948,2950,2954,2957,2958,2962,2967,2970,2971,2975,2977,2978,2981,2985,2986,2991,2992,2996,2999,3000,3001,3004,3008,3009,3014,3015,3016,3020,3021,3025,3027,3031,3032,3036,3037,3038,3041,3045,3046,3051,3052,3057,3058,3061,3062,3064,3068,3069,3074,3075,3080,3081,3084,3086,3089,3094,3095,3099,3100,3105,3107,3110,3111,3113,3117,3118,3122,3124,3129,3130,3134,3135,3139,3140,3144,3146,3147,3150,3153,3157,3158,3163,3164,3169,3170,3174,3175,3179,3180,3184,3186,3191,3192,3196,3197,3201,3203,3207,3208,3213,3214,3219,3220,3224,3226,3229,3231,3234,3239,3240,3245,3246,3250,3253,3255,3256,3259,3262,3265,3270,3271,3274,3276,3278,3280,3282,3284,3288,3289,3292,3294,3298,3299,3302,3304,3308,3309,3312,3314,3321,3323,3324,3325,3329,3330,3335,3336,3340,3343,3344,3347,3352,3353,3357,3358,3362,3367,3369,3370,3371,3375,3376,3380,3382,3387,3390,3391,3395,3396,3401,3404,3406,3407,3411,3414,3419,3420,3424,3426,3431,3432,3436,3437,3441,3445,3446,3450,3454,3457,3459,3463,3464,3468,3472,3473,3476,3477,3481,3483,3488,3489,3493,3494,3498,3501,3504,3506,3510,3511,3516,3517,3521,3522,3527,3528,3530,3534,3535,3539,3540,3541,3546,3547,3551,3553,3557,3558,3562,3563,3566,3571,3572,3576,3577,3582,3585,3587,3591,3592,3596,3598,3603,3604,3607,3609,3612,3617,3618,3622,3623,3628,3631,3634,3637,3639,3643,3645,3650,3651,3655,3656,3661,3664,3666,3669,3674,3675,3679,3680,3685,3688,3690,3694,3695,3700,3702,3703,3707,3708,3712,3714,3715,3718,3723,3724,3728,3733,3734,3738,3739,3743,3745,3748,3750,3753,3754,3757,3758,3762,3763,3767,3770,3771,3772,3775,3780,3781,3786,3787,3792,3793,3797,3799,3800,3806,3807,3809,3813,3814,3818,3822,3823,3826,3829,3830,3834,3835,3840,3841,3845,3846,3850,3852,3855,3856,3858,3862,3863,3867,3869,3870,3871,3875,3876,3880,3882,3885,3886,3888,3892,3893,3897,3900,3901,3902,3903,3908,3909,3913,3916,3918,3922,3923,3927,3928,3929,3933,3938,3939,3943,3944,3947,3949,3953,3954,3958,3961,3963,3967,3968,3973,3974,3978,3979,3983,3985,3987,3991,3992,3997,3998,4002,4003,4007,4009,4011,4013,4016,4021,4022,4026,4027,4030,4032,4036,4037,4041,4044,4046,4050,4051,4056,4057,4061,4062,4066,4068,4070,4074,4075,4079,4081,4085,4086
-----computeFrom-----
366,367
366,368
372,373
372,374
374,375
374,376
387,388
387,389
413,414
413,415
429,430
429,431
434,435
434,436
435,436
435,437
437,438
437,439
446,447
446,448
481,482
481,483
493,494
493,495
495,496
495,497
530,531
530,532
533,534
533,535
536,537
536,538
539,540
539,541
542,543
542,544
545,546
545,547
555,556
555,557
578,579
578,580
591,592
591,593
604,605
604,606
617,618
617,619
630,631
630,632
643,644
643,645
655,656
655,657
660,661
660,662
664,665
664,666
666,667
666,668
681,682
681,683
686,687
686,688
703,704
703,705
719,720
719,721
729,730
729,731
741,742
741,743
750,751
750,752
751,752
751,753
755,756
755,757
771,772
771,773
774,775
774,776
775,776
775,777
776,777
776,778
789,790
789,791
797,798
797,799
813,814
813,815
823,824
823,825
831,832
831,833
848,849
848,850
864,865
864,866
876,877
876,878
885,886
885,887
886,887
886,888
890,891
890,892
906,907
906,908
909,910
909,911
910,911
910,912
911,912
911,913
924,925
924,926
938,939
938,940
944,945
944,946
960,961
960,962
970,971
970,972
978,979
978,980
994,995
994,996
1004,1005
1004,1006
1018,1019
1018,1020
1029,1030
1029,1031
1032,1033
1032,1034
1042,1043
1042,1044
1056,1057
1056,1058
1063,1064
1063,1065
1067,1068
1067,1069
1085,1086
1085,1087
1107,1108
1107,1109
1117,1118
1117,1119
1120,1121
1120,1122
1122,1123
1122,1124
1142,1143
1142,1144
1168,1169
1168,1170
1190,1191
1190,1192
1193,1194
1193,1195
1210,1211
1210,1212
1213,1214
1213,1215
1230,1231
1230,1232
1269,1270
1269,1271
1302,1303
1302,1304
1313,1314
1313,1315
1325,1326
1325,1327
1328,1329
1328,1330
1339,1340
1339,1341
1351,1352
1351,1353
1357,1358
1357,1359
1377,1378
1377,1379
1396,1397
1396,1398
1407,1408
1407,1409
1422,1423
1422,1424
1450,1451
1450,1452
1455,1456
1455,1457
1471,1472
1471,1473
1476,1477
1476,1478
1479,1480
1479,1481
1482,1483
1482,1484
1486,1487
1486,1488
1502,1503
1502,1504
1505,1506
1505,1507
1509,1510
1509,1511
1514,1515
1514,1516
1517,1518
1517,1519
1533,1534
1533,1535
1544,1545
1544,1546
1556,1557
1556,1558
1559,1560
1559,1561
1569,1570
1569,1571
1572,1573
1572,1574
1581,1582
1581,1583
1597,1598
1597,1599
1621,1622
1621,1623
1628,1629
1628,1630
1633,1634
1633,1635
1673,1674
1673,1675
1678,1679
1678,1680
1679,1680
1679,1681
1683,1684
1683,1685
1684,1685
1684,1686
1686,1687
1686,1688
1704,1705
1704,1706
1714,1715
1714,1716
1723,1724
1723,1725
1724,1725
1724,1726
1735,1736
1735,1737
1744,1745
1744,1746
1781,1782
1781,1783
1798,1799
1798,1800
1808,1809
1808,1810
1817,1818
1817,1819
1823,1824
1823,1825
1826,1827
1826,1828
1831,1832
1831,1833
1841,1842
1841,1843
1849,1850
1849,1851
1854,1855
1854,1856
1862,1863
1862,1864
1865,1866
1865,1867
1870,1871
1870,1872
1889,1890
1889,1891
1911,1912
1911,1913
1920,1921
1920,1922
1960,1961
1960,1962
1973,1974
1973,1975
1975,1976
1975,1977
1993,1994
1993,1995
2007,2008
2007,2009
2015,2016
2015,2017
2020,2021
2020,2022
2043,2044
2043,2045
2048,2049
2048,2050
2053,2054
2053,2055
2059,2060
2059,2061
2066,2067
2066,2068
2075,2076
2075,2077
2083,2084
2083,2085
2088,2089
2088,2090
2093,2094
2093,2095
2094,2095
2094,2096
2099,2100
2099,2101
2110,2111
2110,2112
2115,2116
2115,2117
2119,2120
2119,2121
2127,2128
2127,2129
2133,2134
2133,2135
2139,2140
2139,2141
2145,2146
2145,2147
2161,2162
2161,2163
2166,2167
2166,2168
2172,2173
2172,2174
2186,2187
2186,2188
2187,2188
2187,2189
2190,2191
2190,2192
2194,2195
2194,2196
2200,2201
2200,2202
2205,2206
2205,2207
2210,2211
2210,2212
2211,2212
2211,2213
2214,2215
2214,2216
2218,2219
2218,2220
2224,2225
2224,2226
2229,2230
2229,2231
2234,2235
2234,2236
2235,2236
2235,2237
2238,2239
2238,2240
2242,2243
2242,2244
2248,2249
2248,2250
2253,2254
2253,2255
2258,2259
2258,2260
2259,2260
2259,2261
2262,2263
2262,2264
2266,2267
2266,2268
2272,2273
2272,2274
2281,2282
2281,2283
2287,2288
2287,2289
2293,2294
2293,2295
2298,2299
2298,2300
2303,2304
2303,2305
2309,2310
2309,2311
2318,2319
2318,2320
2324,2325
2324,2326
2330,2331
2330,2332
2335,2336
2335,2337
2341,2342
2341,2343
2347,2348
2347,2349
2352,2353
2352,2354
2362,2363
2362,2364
2368,2369
2368,2370
2375,2376
2375,2377
2381,2382
2381,2383
2387,2388
2387,2389
2396,2397
2396,2398
2403,2404
2403,2405
2410,2411
2410,2412
2411,2412
2411,2413
2416,2417
2416,2418
2423,2424
2423,2425
2430,2431
2430,2432
2433,2434
2433,2435
2439,2440
2439,2441
2446,2447
2446,2448
2452,2453
2452,2454
2459,2460
2459,2461
2465,2466
2465,2467
2471,2472
2471,2473
2472,2473
2472,2474
2473,2474
2473,2475
2484,2485
2484,2486
2490,2491
2490,2492
2493,2494
2493,2495
2499,2500
2499,2501
2500,2501
2500,2502
2501,2502
2501,2503
2514,2515
2514,2516
2520,2521
2520,2522
2529,2530
2529,2531
2535,2536
2535,2537
2538,2539
2538,2540
2540,2541
2540,2542
2545,2546
2545,2547
2548,2549
2548,2550
2549,2550
2549,2551
2552,2553
2552,2554
2567,2568
2567,2569
2576,2577
2576,2578
2582,2583
2582,2584
2592,2593
2592,2594
2601,2602
2601,2603
2621,2622
2621,2623
2633,2634
2633,2635
2649,2650
2649,2651
2654,2655
2654,2656
2662,2663
2662,2664
2670,2671
2670,2672
2686,2687
2686,2688
2693,2694
2693,2695
2701,2702
2701,2703
2712,2713
2712,2714
2718,2719
2718,2720
2731,2732
2731,2733
2740,2741
2740,2742
2748,2749
2748,2750
2755,2756
2755,2757
2769,2770
2769,2771
2775,2776
2775,2777
2783,2784
2783,2785
2791,2792
2791,2793
2799,2800
2799,2801
2805,2806
2805,2807
2816,2817
2816,2818
2818,2819
2818,2820
2824,2825
2824,2826
2829,2830
2829,2831
2840,2841
2840,2842
2841,2842
2841,2843
2847,2848
2847,2849
2858,2859
2858,2860
2859,2860
2859,2861
2865,2866
2865,2867
2871,2872
2871,2873
2879,2880
2879,2881
2885,2886
2885,2887
2891,2892
2891,2893
2892,2893
2892,2894
2898,2899
2898,2900
2915,2916
2915,2917
2922,2923
2922,2924
2927,2928
2927,2929
2937,2938
2937,2939
2946,2947
2946,2948
2952,2953
2952,2954
2955,2956
2955,2957
2964,2965
2964,2966
2973,2974
2973,2975
2994,2995
2994,2996
2997,2998
2997,2999
3011,3012
3011,3013
3023,3024
3023,3025
3034,3035
3034,3036
3054,3055
3054,3056
3066,3067
3066,3068
3078,3079
3078,3080
3082,3083
3082,3084
3102,3103
3102,3104
3120,3121
3120,3122
3132,3133
3132,3134
3142,3143
3142,3144
3161,3162
3161,3163
3177,3178
3177,3179
3182,3183
3182,3184
3199,3200
3199,3201
3205,3206
3205,3207
3217,3218
3217,3219
3221,3222
3221,3223
3222,3223
3222,3224
3248,3249
3248,3250
3319,3320
3319,3321
3338,3339
3338,3340
3341,3342
3341,3343
3360,3361
3360,3362
3365,3366
3365,3367
3378,3379
3378,3380
3385,3386
3385,3387
3388,3389
3388,3390
3392,3393
3392,3394
3393,3394
3393,3395
3397,3398
3397,3399
3399,3400
3399,3401
3422,3423
3422,3424
3448,3449
3448,3450
3451,3452
3451,3453
3455,3456
3455,3457
3466,3467
3466,3468
3469,3470
3469,3471
3470,3471
3470,3472
3474,3475
3474,3476
3479,3480
3479,3481
3496,3497
3496,3498
3499,3500
3499,3501
3508,3509
3508,3510
3524,3525
3524,3526
3549,3550
3549,3551
3560,3561
3560,3562
3579,3580
3579,3581
3594,3595
3594,3596
3601,3602
3601,3603
3605,3606
3605,3607
3625,3626
3625,3627
3632,3633
3632,3634
3641,3642
3641,3643
3658,3659
3658,3660
3682,3683
3682,3684
3697,3698
3697,3699
3710,3711
3710,3712
3765,3766
3765,3767
3768,3769
3768,3770
3819,3820
3819,3821
3820,3821
3820,3822
3824,3825
3824,3826
3895,3896
3895,3897
3898,3899
3898,3900
3914,3915
3914,3916
3956,3957
3956,3958
3959,3960
3959,3961
3965,3966
3965,3967
3989,3990
3989,3991
4039,4040
4039,4041
4042,4043
4042,4044
4048,4049
4048,4050
-----guardedBy-----
389,483
688,743
705,734
799,926
833,878
850,869
946,1006
980,1006
1091,1113
1093,1115
1125,1147
1304,1344
1488,1511
1481,1504
1484,1507
1519,1537
1681,1706
1926,1970
1925,1969
2045,2050
2055,2064
2101,2106
2174,2311
2383,2389
2398,2441
2476,2504
2481,2509
2483,2511
2478,2506
2721,2745
2771,2788
2801,2826
2900,2975
2902,2977
3068,3124
3163,3179
3207,3226
3481,3506
3643,3666
3967,3987
3991,4013
4050,4070
-----guardedByNegation-----
688,791
833,926
1304,1361
1315,1344
1516,1561
2326,2337
2420,2435
2418,2437
2578,2598
3163,3203
-----lastLexicalUse-----
688,791
833,926
1304,1361
3163,3203
-----jump-----
688,791
833,926
1304,1361
3163,3203
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ForStatement;NullStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;DoStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;CompoundStatement;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ForStatement;NullStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;UnaryExpression;ConditionalExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ForStatement;NullStatement;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;WhileStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;LiteralExpression;LiteralExpression;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;ConditionalExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ConditionalExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
void sqlite3VXPrintf(  StrAccum *pAccum,                  /* Accumulate results here */  int useExtended,                   /* Allow extended %-conversions */  const char *fmt,                   /* Format string */  va_list ap                         /* arguments */){printf("\nfile_name:%s\n",__FILE__);printf("function_name:%s\n",__func__);printf("------function start!------\n");printf("void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){\n");  printf("int c;\n");  int c;                     /* Next character in the format string */  printf("char *bufpt;\n");  char *bufpt;               /* Pointer to the conversion buffer */  printf("int precision;\n");  int precision;             /* Precision of the current field */  printf("int length;\n");  int length;                /* Length of the field */  printf("int idx;\n");  int idx;                   /* A general purpose loop counter */  printf("int width;\n");  int width;                 /* Width of the current field */  printf("etByte flag_leftjustify;\n");  etByte flag_leftjustify;   /* True if "-" flag is present */  printf("etByte flag_plussign;\n");  etByte flag_plussign;      /* True if "+" flag is present */  printf("etByte flag_blanksign;\n");  etByte flag_blanksign;     /* True if " " flag is present */  printf("etByte flag_alternateform;\n");  etByte flag_alternateform; /* True if "#" flag is present */  printf("etByte flag_altform2;\n");  etByte flag_altform2;      /* True if "!" flag is present */  printf("etByte flag_zeropad;\n");  etByte flag_zeropad;       /* True if field width constant starts with zero */  printf("etByte flag_long;\n");  etByte flag_long;          /* True if "l" flag is present */  printf("etByte flag_longlong;\n");  etByte flag_longlong;      /* True if the "ll" flag is present */  printf("etByte done;\n");  etByte done;               /* Loop termination flag */  printf("etByte xtype = 0;\n");  etByte xtype = 0;          /* Conversion paradigm */  printf("char prefix;\n");  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */  sqlite_uint64 longvalue;   /* Value for integer types */  printf("LONGDOUBLE_TYPE realvalue;\n");  LONGDOUBLE_TYPE realvalue; /* Value for real types */  printf("const et_info *infop;\n");  const et_info *infop;      /* Pointer to the appropriate info structure */  printf("char *zOut;\n");  char *zOut;                /* Rendering buffer */  printf("int nOut;\n");  int nOut;                  /* Size of the rendering buffer */  printf("char *zExtra;\n");  char *zExtra;              /* Malloced memory used by some conversion */#ifndef SQLITE_OMIT_FLOATING_POINT  printf("int  exp, e2;\n");  int  exp, e2;              /* exponent of real numbers */  printf("int nsd;\n");  int nsd;                   /* Number of significant digits returned */  printf("double rounder;\n");  double rounder;            /* Used for rounding floating point values */  printf("etByte flag_dp;\n");  etByte flag_dp;            /* True if decimal point should be shown */  printf("etByte flag_rtz;\n");  etByte flag_rtz;           /* True if trailing zeros should be removed */#endif  printf("char buf[etBUFSIZE];\n");  char buf[etBUFSIZE];       /* Conversion buffer */  printf("bufpt = 0;\n");bufpt = 0;  for(; (c=(*fmt))!=0; ++fmt){    if( c!='%' ){printf("if(c!='_')\n");          printf("int amt;\n");      int amt;      printf("bufpt = (char *)fmt;\n");bufpt = (char *)fmt;      printf("amt = 1;\n");amt = 1;      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");      sqlite3StrAccumAppend(pAccum, bufpt, amt);      if( c==0 ) {printf("if(c==0)\n");      break;}    }    if( (c=(*++fmt))==0 ){printf("if((c=(*++fmt))==0)\n");          printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");      sqlite3StrAccumAppend(pAccum, "%", 1);      break;    }    /* Find out what flags are present */    printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n");flag_leftjustify = flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0;    printf("done = 0;\n");done = 0;    do{      printf("switch(c)\n");      switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }    }while( !done && (c=(*++fmt))!=0 );    /* Get the field width */    printf("width = 0;\n");width = 0;    if( c=='*' ){printf("if(c=='*')\n");          printf("width = va_arg(ap,int);\n");width = va_arg(ap,int);      if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }      printf("c = *++fmt;\n");c = *++fmt;    }else{      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }    }    /* Get the precision */    if( c=='.' ){printf("if(c=='.')\n");          printf("precision = 0;\n");precision = 0;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }    }else{      printf("precision = -1;\n");precision = -1;    }    /* Get the conversion type modifier */    if( c=='l' ){printf("if(c=='l')\n");          printf("flag_long = 1;\n");flag_long = 1;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }    }else{      printf("flag_long = flag_longlong = 0;\n");flag_long = flag_longlong = 0;    }    /* Fetch the info entry for the field */    printf("infop = &fmtinfo[0];\n");infop = &fmtinfo[0];    printf("xtype = etINVALID;\n");xtype = etINVALID;    for(idx=0; idx<ArraySize(fmtinfo); idx++){printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");          if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }    }    printf("zExtra = 0;\n");zExtra = 0;    /*    ** At this point, variables are initialized as follows:    **    **   flag_alternateform          TRUE if a '#' is present.    **   flag_altform2               TRUE if a '!' is present.    **   flag_plussign               TRUE if a '+' is present.    **   flag_leftjustify            TRUE if a '-' is present or if the    **                               field width was negative.    **   flag_zeropad                TRUE if the width began with 0.    **   flag_long                   TRUE if the letter 'l' (ell) prefixed    **                               the conversion character.    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed    **                               the conversion character.    **   flag_blanksign              TRUE if a ' ' is present.    **   width                       The specified field width.  This is    **                               always non-negative.  Zero is the default.    **   precision                   The specified precision.  The default    **                               is -1.    **   xtype                       The class of the conversion.    **   infop                       Pointer to the appropriate info struct.    */    printf("switch(xtype)\n");    switch( xtype ){      case etPOINTER:        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");flag_longlong = sizeof(char*)==sizeof(i64);        printf("flag_long = sizeof(char*)==sizeof(long int);\n");flag_long = sizeof(char*)==sizeof(long int);        /* Fall through into the next case */      case etORDINAL:      case etRADIX:        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }        if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }        printf("bufpt = &zOut[nOut-1];\n");bufpt = &zOut[nOut-1];        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");        {          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }        if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}               /* Add sign */        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        break;      case etFLOAT:      case etEXP:      case etGENERIC:        printf("realvalue = va_arg(ap,double);\n");realvalue = va_arg(ap,double);#ifdef SQLITE_OMIT_FLOATING_POINT        printf("length = 0;\n");length = 0;#else        if( precision<0 ) precision = 6;         /* Set default precision */        if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }        if( xtype==etGENERIC && precision>0 ) precision--;        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}        if( xtype==etFLOAT ) realvalue += rounder;        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */        exp = 0;        if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }        if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }        bufpt = buf;        /*        ** If the field type is etGENERIC, then convert to either etEXP        ** or etFLOAT, as appropriate.        */        if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }        if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }        if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }        zOut = bufpt;        nsd = 16 + flag_altform2*10;        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;        /* The sign in front of the number */        if( prefix ){          *(bufpt++) = prefix;        }        /* Digits prior to the decimal point */        if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }        /* The decimal point */        if( flag_dp ){          *(bufpt++) = '.';        }        /* "0" digits after the decimal point but before the first        ** significant digit of the number */        for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }        /* Significant digits after the decimal point */        while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }        /* Remove trailing zeros and the "." if no digits follow the "." */        if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }        /* Add the "eNNN" suffix */        if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }        *bufpt = 0;        /* The converted number is in buf[] and zero terminated. Output it.        ** Note that the number is in the usual order, not reversed as with        ** integer conversions. */        length = (int)(bufpt-zOut);        bufpt = zOut;        /* Special case:  Add leading zeros if the flag_zeropad flag is        ** set and we are not left justified */        if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */        break;      case etSIZE:        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");*(va_arg(ap,int*)) = pAccum->nChar;        printf("length = width = 0;\n");length = width = 0;        break;      case etPERCENT:        printf("buf[0] = '_';\n");buf[0] = '%';        printf("bufpt = buf;\n");bufpt = buf;        printf("length = 1;\n");length = 1;        break;      case etCHARX:        printf("c = va_arg(ap,int);\n");c = va_arg(ap,int);        printf("buf[0] = (char)c;\n");buf[0] = (char)c;        if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }        printf("bufpt = buf;\n");bufpt = buf;        break;      case etSTRING:      case etDYNSTRING:        printf("bufpt = va_arg(ap,char*);\n");bufpt = va_arg(ap,char*);        if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }        if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }        break;      case etSQLESCAPE:      case etSQLESCAPE2:      case etSQLESCAPE3: {        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }      case etTOKEN: {        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }      case etSRCLIST: {        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }      default: {        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }    }/* End switch over the format type */    /*    ** The text of the conversion is pointed to by "bufpt" and is    ** "length" characters long.  The field width is "width".  Do    ** the output.    */    if( !flag_leftjustify ){printf("if(!flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    if( length>0 ){printf("if(length>0)\n");          printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");      sqlite3StrAccumAppend(pAccum, bufpt, length);    }    if( flag_leftjustify ){printf("if(flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    printf("sqlite3_free(zExtra);\n");    sqlite3_free(zExtra);  }/* End for loop over the format string */printf("------function end!------\n");}
void
sqlite3VXPrintf(  StrAccum *pAccum,                  /* Accumulate results here */  int useExtended,                   /* Allow extended %-conversions */  const char *fmt,                   /* Format string */  va_list ap                         /* arguments */)
sqlite3VXPrintf
StrAccum *pAccum
StrAccum
StrAccum
*pAccum
*
pAccum
int useExtended
int
useExtended
useExtended
const char *fmt
const char
*fmt
*
fmt
va_list ap
va_list
va_list
ap
ap
{printf("\nfile_name:%s\n",__FILE__);printf("function_name:%s\n",__func__);printf("------function start!------\n");printf("void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){\n");  printf("int c;\n");  int c;                     /* Next character in the format string */  printf("char *bufpt;\n");  char *bufpt;               /* Pointer to the conversion buffer */  printf("int precision;\n");  int precision;             /* Precision of the current field */  printf("int length;\n");  int length;                /* Length of the field */  printf("int idx;\n");  int idx;                   /* A general purpose loop counter */  printf("int width;\n");  int width;                 /* Width of the current field */  printf("etByte flag_leftjustify;\n");  etByte flag_leftjustify;   /* True if "-" flag is present */  printf("etByte flag_plussign;\n");  etByte flag_plussign;      /* True if "+" flag is present */  printf("etByte flag_blanksign;\n");  etByte flag_blanksign;     /* True if " " flag is present */  printf("etByte flag_alternateform;\n");  etByte flag_alternateform; /* True if "#" flag is present */  printf("etByte flag_altform2;\n");  etByte flag_altform2;      /* True if "!" flag is present */  printf("etByte flag_zeropad;\n");  etByte flag_zeropad;       /* True if field width constant starts with zero */  printf("etByte flag_long;\n");  etByte flag_long;          /* True if "l" flag is present */  printf("etByte flag_longlong;\n");  etByte flag_longlong;      /* True if the "ll" flag is present */  printf("etByte done;\n");  etByte done;               /* Loop termination flag */  printf("etByte xtype = 0;\n");  etByte xtype = 0;          /* Conversion paradigm */  printf("char prefix;\n");  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */  sqlite_uint64 longvalue;   /* Value for integer types */  printf("LONGDOUBLE_TYPE realvalue;\n");  LONGDOUBLE_TYPE realvalue; /* Value for real types */  printf("const et_info *infop;\n");  const et_info *infop;      /* Pointer to the appropriate info structure */  printf("char *zOut;\n");  char *zOut;                /* Rendering buffer */  printf("int nOut;\n");  int nOut;                  /* Size of the rendering buffer */  printf("char *zExtra;\n");  char *zExtra;              /* Malloced memory used by some conversion */#ifndef SQLITE_OMIT_FLOATING_POINT  printf("int  exp, e2;\n");  int  exp, e2;              /* exponent of real numbers */  printf("int nsd;\n");  int nsd;                   /* Number of significant digits returned */  printf("double rounder;\n");  double rounder;            /* Used for rounding floating point values */  printf("etByte flag_dp;\n");  etByte flag_dp;            /* True if decimal point should be shown */  printf("etByte flag_rtz;\n");  etByte flag_rtz;           /* True if trailing zeros should be removed */#endif  printf("char buf[etBUFSIZE];\n");  char buf[etBUFSIZE];       /* Conversion buffer */  printf("bufpt = 0;\n");bufpt = 0;  for(; (c=(*fmt))!=0; ++fmt){    if( c!='%' ){printf("if(c!='_')\n");          printf("int amt;\n");      int amt;      printf("bufpt = (char *)fmt;\n");bufpt = (char *)fmt;      printf("amt = 1;\n");amt = 1;      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");      sqlite3StrAccumAppend(pAccum, bufpt, amt);      if( c==0 ) {printf("if(c==0)\n");      break;}    }    if( (c=(*++fmt))==0 ){printf("if((c=(*++fmt))==0)\n");          printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");      sqlite3StrAccumAppend(pAccum, "%", 1);      break;    }    /* Find out what flags are present */    printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n");flag_leftjustify = flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0;    printf("done = 0;\n");done = 0;    do{      printf("switch(c)\n");      switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }    }while( !done && (c=(*++fmt))!=0 );    /* Get the field width */    printf("width = 0;\n");width = 0;    if( c=='*' ){printf("if(c=='*')\n");          printf("width = va_arg(ap,int);\n");width = va_arg(ap,int);      if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }      printf("c = *++fmt;\n");c = *++fmt;    }else{      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }    }    /* Get the precision */    if( c=='.' ){printf("if(c=='.')\n");          printf("precision = 0;\n");precision = 0;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }    }else{      printf("precision = -1;\n");precision = -1;    }    /* Get the conversion type modifier */    if( c=='l' ){printf("if(c=='l')\n");          printf("flag_long = 1;\n");flag_long = 1;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }    }else{      printf("flag_long = flag_longlong = 0;\n");flag_long = flag_longlong = 0;    }    /* Fetch the info entry for the field */    printf("infop = &fmtinfo[0];\n");infop = &fmtinfo[0];    printf("xtype = etINVALID;\n");xtype = etINVALID;    for(idx=0; idx<ArraySize(fmtinfo); idx++){printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");          if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }    }    printf("zExtra = 0;\n");zExtra = 0;    /*    ** At this point, variables are initialized as follows:    **    **   flag_alternateform          TRUE if a '#' is present.    **   flag_altform2               TRUE if a '!' is present.    **   flag_plussign               TRUE if a '+' is present.    **   flag_leftjustify            TRUE if a '-' is present or if the    **                               field width was negative.    **   flag_zeropad                TRUE if the width began with 0.    **   flag_long                   TRUE if the letter 'l' (ell) prefixed    **                               the conversion character.    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed    **                               the conversion character.    **   flag_blanksign              TRUE if a ' ' is present.    **   width                       The specified field width.  This is    **                               always non-negative.  Zero is the default.    **   precision                   The specified precision.  The default    **                               is -1.    **   xtype                       The class of the conversion.    **   infop                       Pointer to the appropriate info struct.    */    printf("switch(xtype)\n");    switch( xtype ){      case etPOINTER:        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");flag_longlong = sizeof(char*)==sizeof(i64);        printf("flag_long = sizeof(char*)==sizeof(long int);\n");flag_long = sizeof(char*)==sizeof(long int);        /* Fall through into the next case */      case etORDINAL:      case etRADIX:        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }        if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }        printf("bufpt = &zOut[nOut-1];\n");bufpt = &zOut[nOut-1];        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");        {          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }        if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}               /* Add sign */        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        break;      case etFLOAT:      case etEXP:      case etGENERIC:        printf("realvalue = va_arg(ap,double);\n");realvalue = va_arg(ap,double);#ifdef SQLITE_OMIT_FLOATING_POINT        printf("length = 0;\n");length = 0;#else        if( precision<0 ) precision = 6;         /* Set default precision */        if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }        if( xtype==etGENERIC && precision>0 ) precision--;        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}        if( xtype==etFLOAT ) realvalue += rounder;        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */        exp = 0;        if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }        if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }        bufpt = buf;        /*        ** If the field type is etGENERIC, then convert to either etEXP        ** or etFLOAT, as appropriate.        */        if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }        if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }        if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }        zOut = bufpt;        nsd = 16 + flag_altform2*10;        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;        /* The sign in front of the number */        if( prefix ){          *(bufpt++) = prefix;        }        /* Digits prior to the decimal point */        if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }        /* The decimal point */        if( flag_dp ){          *(bufpt++) = '.';        }        /* "0" digits after the decimal point but before the first        ** significant digit of the number */        for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }        /* Significant digits after the decimal point */        while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }        /* Remove trailing zeros and the "." if no digits follow the "." */        if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }        /* Add the "eNNN" suffix */        if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }        *bufpt = 0;        /* The converted number is in buf[] and zero terminated. Output it.        ** Note that the number is in the usual order, not reversed as with        ** integer conversions. */        length = (int)(bufpt-zOut);        bufpt = zOut;        /* Special case:  Add leading zeros if the flag_zeropad flag is        ** set and we are not left justified */        if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */        break;      case etSIZE:        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");*(va_arg(ap,int*)) = pAccum->nChar;        printf("length = width = 0;\n");length = width = 0;        break;      case etPERCENT:        printf("buf[0] = '_';\n");buf[0] = '%';        printf("bufpt = buf;\n");bufpt = buf;        printf("length = 1;\n");length = 1;        break;      case etCHARX:        printf("c = va_arg(ap,int);\n");c = va_arg(ap,int);        printf("buf[0] = (char)c;\n");buf[0] = (char)c;        if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }        printf("bufpt = buf;\n");bufpt = buf;        break;      case etSTRING:      case etDYNSTRING:        printf("bufpt = va_arg(ap,char*);\n");bufpt = va_arg(ap,char*);        if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }        if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }        break;      case etSQLESCAPE:      case etSQLESCAPE2:      case etSQLESCAPE3: {        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }      case etTOKEN: {        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }      case etSRCLIST: {        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }      default: {        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }    }/* End switch over the format type */    /*    ** The text of the conversion is pointed to by "bufpt" and is    ** "length" characters long.  The field width is "width".  Do    ** the output.    */    if( !flag_leftjustify ){printf("if(!flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    if( length>0 ){printf("if(length>0)\n");          printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");      sqlite3StrAccumAppend(pAccum, bufpt, length);    }    if( flag_leftjustify ){printf("if(flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    printf("sqlite3_free(zExtra);\n");    sqlite3_free(zExtra);  }/* End for loop over the format string */printf("------function end!------\n");}
printf("\nfile_name:%s\n",__FILE__);
printf("\nfile_name:%s\n",__FILE__)
printf
printf
"\nfile_name:%s\n"
__FILE__
printf("function_name:%s\n",__func__);
printf("function_name:%s\n",__func__)
printf
printf
"function_name:%s\n"
__func__
__func__
printf("------function start!------\n");
printf("------function start!------\n")
printf
printf
"------function start!------\n"
printf("void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){\n");
printf("void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){\n")
printf
printf
"void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){\n"
printf("int c;\n");
printf("int c;\n")
printf
printf
"int c;\n"
int c;
int c;
int
c
c
printf("char *bufpt;\n");
printf("char *bufpt;\n")
printf
printf
"char *bufpt;\n"
char *bufpt;
char *bufpt;
char
*bufpt
*
bufpt
printf("int precision;\n");
printf("int precision;\n")
printf
printf
"int precision;\n"
int precision;
int precision;
int
precision
precision
printf("int length;\n");
printf("int length;\n")
printf
printf
"int length;\n"
int length;
int length;
int
length
length
printf("int idx;\n");
printf("int idx;\n")
printf
printf
"int idx;\n"
int idx;
int idx;
int
idx
idx
printf("int width;\n");
printf("int width;\n")
printf
printf
"int width;\n"
int width;
int width;
int
width
width
printf("etByte flag_leftjustify;\n");
printf("etByte flag_leftjustify;\n")
printf
printf
"etByte flag_leftjustify;\n"
etByte flag_leftjustify;
etByte flag_leftjustify;
etByte
etByte
flag_leftjustify
flag_leftjustify
printf("etByte flag_plussign;\n");
printf("etByte flag_plussign;\n")
printf
printf
"etByte flag_plussign;\n"
etByte flag_plussign;
etByte flag_plussign;
etByte
etByte
flag_plussign
flag_plussign
printf("etByte flag_blanksign;\n");
printf("etByte flag_blanksign;\n")
printf
printf
"etByte flag_blanksign;\n"
etByte flag_blanksign;
etByte flag_blanksign;
etByte
etByte
flag_blanksign
flag_blanksign
printf("etByte flag_alternateform;\n");
printf("etByte flag_alternateform;\n")
printf
printf
"etByte flag_alternateform;\n"
etByte flag_alternateform;
etByte flag_alternateform;
etByte
etByte
flag_alternateform
flag_alternateform
printf("etByte flag_altform2;\n");
printf("etByte flag_altform2;\n")
printf
printf
"etByte flag_altform2;\n"
etByte flag_altform2;
etByte flag_altform2;
etByte
etByte
flag_altform2
flag_altform2
printf("etByte flag_zeropad;\n");
printf("etByte flag_zeropad;\n")
printf
printf
"etByte flag_zeropad;\n"
etByte flag_zeropad;
etByte flag_zeropad;
etByte
etByte
flag_zeropad
flag_zeropad
printf("etByte flag_long;\n");
printf("etByte flag_long;\n")
printf
printf
"etByte flag_long;\n"
etByte flag_long;
etByte flag_long;
etByte
etByte
flag_long
flag_long
printf("etByte flag_longlong;\n");
printf("etByte flag_longlong;\n")
printf
printf
"etByte flag_longlong;\n"
etByte flag_longlong;
etByte flag_longlong;
etByte
etByte
flag_longlong
flag_longlong
printf("etByte done;\n");
printf("etByte done;\n")
printf
printf
"etByte done;\n"
etByte done;
etByte done;
etByte
etByte
done
done
printf("etByte xtype = 0;\n");
printf("etByte xtype = 0;\n")
printf
printf
"etByte xtype = 0;\n"
etByte xtype = 0;
etByte xtype = 0;
etByte
etByte
xtype = 0
xtype
= 0
0
printf("char prefix;\n");
printf("char prefix;\n")
printf
printf
"char prefix;\n"
char prefix;
char prefix;
char
prefix
prefix
sqlite_uint64 longvalue;
sqlite_uint64 longvalue;
sqlite_uint64
sqlite_uint64
longvalue
longvalue
printf("LONGDOUBLE_TYPE realvalue;\n");
printf("LONGDOUBLE_TYPE realvalue;\n")
printf
printf
"LONGDOUBLE_TYPE realvalue;\n"
LONGDOUBLE_TYPE realvalue;
LONGDOUBLE_TYPE realvalue;
LONGDOUBLE_TYPE
LONGDOUBLE_TYPE
realvalue
realvalue
printf("const et_info *infop;\n");
printf("const et_info *infop;\n")
printf
printf
"const et_info *infop;\n"
const et_info *infop;
const et_info *infop;
const et_info
et_info
*infop
*
infop
printf("char *zOut;\n");
printf("char *zOut;\n")
printf
printf
"char *zOut;\n"
char *zOut;
char *zOut;
char
*zOut
*
zOut
printf("int nOut;\n");
printf("int nOut;\n")
printf
printf
"int nOut;\n"
int nOut;
int nOut;
int
nOut
nOut
printf("char *zExtra;\n");
printf("char *zExtra;\n")
printf
printf
"char *zExtra;\n"
char *zExtra;
char *zExtra;
char
*zExtra
*
zExtra
printf("int  exp, e2;\n");
printf("int  exp, e2;\n")
printf
printf
"int  exp, e2;\n"
int  exp, e2;
int  exp, e2;
int
exp
exp
e2
e2
printf("int nsd;\n");
printf("int nsd;\n")
printf
printf
"int nsd;\n"
int nsd;
int nsd;
int
nsd
nsd
printf("double rounder;\n");
printf("double rounder;\n")
printf
printf
"double rounder;\n"
double rounder;
double rounder;
double
rounder
rounder
printf("etByte flag_dp;\n");
printf("etByte flag_dp;\n")
printf
printf
"etByte flag_dp;\n"
etByte flag_dp;
etByte flag_dp;
etByte
etByte
flag_dp
flag_dp
printf("etByte flag_rtz;\n");
printf("etByte flag_rtz;\n")
printf
printf
"etByte flag_rtz;\n"
etByte flag_rtz;
etByte flag_rtz;
etByte
etByte
flag_rtz
flag_rtz
printf("char buf[etBUFSIZE];\n");
printf("char buf[etBUFSIZE];\n")
printf
printf
"char buf[etBUFSIZE];\n"
char buf[etBUFSIZE];
char buf[etBUFSIZE];
char
buf[etBUFSIZE]
buf
[etBUFSIZE]
etBUFSIZE
etBUFSIZE
printf("bufpt = 0;\n");
printf("bufpt = 0;\n")
printf
printf
"bufpt = 0;\n"
bufpt = 0;
bufpt = 0
bufpt
bufpt
0
for(; (c=(*fmt))!=0; ++fmt){    if( c!='%' ){printf("if(c!='_')\n");          printf("int amt;\n");      int amt;      printf("bufpt = (char *)fmt;\n");bufpt = (char *)fmt;      printf("amt = 1;\n");amt = 1;      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");      sqlite3StrAccumAppend(pAccum, bufpt, amt);      if( c==0 ) {printf("if(c==0)\n");      break;}    }    if( (c=(*++fmt))==0 ){printf("if((c=(*++fmt))==0)\n");          printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");      sqlite3StrAccumAppend(pAccum, "%", 1);      break;    }    /* Find out what flags are present */    printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n");flag_leftjustify = flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0;    printf("done = 0;\n");done = 0;    do{      printf("switch(c)\n");      switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }    }while( !done && (c=(*++fmt))!=0 );    /* Get the field width */    printf("width = 0;\n");width = 0;    if( c=='*' ){printf("if(c=='*')\n");          printf("width = va_arg(ap,int);\n");width = va_arg(ap,int);      if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }      printf("c = *++fmt;\n");c = *++fmt;    }else{      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }    }    /* Get the precision */    if( c=='.' ){printf("if(c=='.')\n");          printf("precision = 0;\n");precision = 0;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }    }else{      printf("precision = -1;\n");precision = -1;    }    /* Get the conversion type modifier */    if( c=='l' ){printf("if(c=='l')\n");          printf("flag_long = 1;\n");flag_long = 1;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }    }else{      printf("flag_long = flag_longlong = 0;\n");flag_long = flag_longlong = 0;    }    /* Fetch the info entry for the field */    printf("infop = &fmtinfo[0];\n");infop = &fmtinfo[0];    printf("xtype = etINVALID;\n");xtype = etINVALID;    for(idx=0; idx<ArraySize(fmtinfo); idx++){printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");          if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }    }    printf("zExtra = 0;\n");zExtra = 0;    /*    ** At this point, variables are initialized as follows:    **    **   flag_alternateform          TRUE if a '#' is present.    **   flag_altform2               TRUE if a '!' is present.    **   flag_plussign               TRUE if a '+' is present.    **   flag_leftjustify            TRUE if a '-' is present or if the    **                               field width was negative.    **   flag_zeropad                TRUE if the width began with 0.    **   flag_long                   TRUE if the letter 'l' (ell) prefixed    **                               the conversion character.    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed    **                               the conversion character.    **   flag_blanksign              TRUE if a ' ' is present.    **   width                       The specified field width.  This is    **                               always non-negative.  Zero is the default.    **   precision                   The specified precision.  The default    **                               is -1.    **   xtype                       The class of the conversion.    **   infop                       Pointer to the appropriate info struct.    */    printf("switch(xtype)\n");    switch( xtype ){      case etPOINTER:        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");flag_longlong = sizeof(char*)==sizeof(i64);        printf("flag_long = sizeof(char*)==sizeof(long int);\n");flag_long = sizeof(char*)==sizeof(long int);        /* Fall through into the next case */      case etORDINAL:      case etRADIX:        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }        if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }        printf("bufpt = &zOut[nOut-1];\n");bufpt = &zOut[nOut-1];        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");        {          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }        if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}               /* Add sign */        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        break;      case etFLOAT:      case etEXP:      case etGENERIC:        printf("realvalue = va_arg(ap,double);\n");realvalue = va_arg(ap,double);#ifdef SQLITE_OMIT_FLOATING_POINT        printf("length = 0;\n");length = 0;#else        if( precision<0 ) precision = 6;         /* Set default precision */        if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }        if( xtype==etGENERIC && precision>0 ) precision--;        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}        if( xtype==etFLOAT ) realvalue += rounder;        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */        exp = 0;        if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }        if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }        bufpt = buf;        /*        ** If the field type is etGENERIC, then convert to either etEXP        ** or etFLOAT, as appropriate.        */        if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }        if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }        if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }        zOut = bufpt;        nsd = 16 + flag_altform2*10;        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;        /* The sign in front of the number */        if( prefix ){          *(bufpt++) = prefix;        }        /* Digits prior to the decimal point */        if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }        /* The decimal point */        if( flag_dp ){          *(bufpt++) = '.';        }        /* "0" digits after the decimal point but before the first        ** significant digit of the number */        for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }        /* Significant digits after the decimal point */        while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }        /* Remove trailing zeros and the "." if no digits follow the "." */        if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }        /* Add the "eNNN" suffix */        if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }        *bufpt = 0;        /* The converted number is in buf[] and zero terminated. Output it.        ** Note that the number is in the usual order, not reversed as with        ** integer conversions. */        length = (int)(bufpt-zOut);        bufpt = zOut;        /* Special case:  Add leading zeros if the flag_zeropad flag is        ** set and we are not left justified */        if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */        break;      case etSIZE:        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");*(va_arg(ap,int*)) = pAccum->nChar;        printf("length = width = 0;\n");length = width = 0;        break;      case etPERCENT:        printf("buf[0] = '_';\n");buf[0] = '%';        printf("bufpt = buf;\n");bufpt = buf;        printf("length = 1;\n");length = 1;        break;      case etCHARX:        printf("c = va_arg(ap,int);\n");c = va_arg(ap,int);        printf("buf[0] = (char)c;\n");buf[0] = (char)c;        if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }        printf("bufpt = buf;\n");bufpt = buf;        break;      case etSTRING:      case etDYNSTRING:        printf("bufpt = va_arg(ap,char*);\n");bufpt = va_arg(ap,char*);        if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }        if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }        break;      case etSQLESCAPE:      case etSQLESCAPE2:      case etSQLESCAPE3: {        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }      case etTOKEN: {        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }      case etSRCLIST: {        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }      default: {        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }    }/* End switch over the format type */    /*    ** The text of the conversion is pointed to by "bufpt" and is    ** "length" characters long.  The field width is "width".  Do    ** the output.    */    if( !flag_leftjustify ){printf("if(!flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    if( length>0 ){printf("if(length>0)\n");          printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");      sqlite3StrAccumAppend(pAccum, bufpt, length);    }    if( flag_leftjustify ){printf("if(flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    printf("sqlite3_free(zExtra);\n");    sqlite3_free(zExtra);  }
;
(c=(*fmt))!=0
(c=(*fmt))
c=(*fmt)
c
c
(*fmt)
*fmt
fmt
fmt
0
++fmt
fmt
fmt
{    if( c!='%' ){printf("if(c!='_')\n");          printf("int amt;\n");      int amt;      printf("bufpt = (char *)fmt;\n");bufpt = (char *)fmt;      printf("amt = 1;\n");amt = 1;      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");      sqlite3StrAccumAppend(pAccum, bufpt, amt);      if( c==0 ) {printf("if(c==0)\n");      break;}    }    if( (c=(*++fmt))==0 ){printf("if((c=(*++fmt))==0)\n");          printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");      sqlite3StrAccumAppend(pAccum, "%", 1);      break;    }    /* Find out what flags are present */    printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n");flag_leftjustify = flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0;    printf("done = 0;\n");done = 0;    do{      printf("switch(c)\n");      switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }    }while( !done && (c=(*++fmt))!=0 );    /* Get the field width */    printf("width = 0;\n");width = 0;    if( c=='*' ){printf("if(c=='*')\n");          printf("width = va_arg(ap,int);\n");width = va_arg(ap,int);      if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }      printf("c = *++fmt;\n");c = *++fmt;    }else{      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }    }    /* Get the precision */    if( c=='.' ){printf("if(c=='.')\n");          printf("precision = 0;\n");precision = 0;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }    }else{      printf("precision = -1;\n");precision = -1;    }    /* Get the conversion type modifier */    if( c=='l' ){printf("if(c=='l')\n");          printf("flag_long = 1;\n");flag_long = 1;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }    }else{      printf("flag_long = flag_longlong = 0;\n");flag_long = flag_longlong = 0;    }    /* Fetch the info entry for the field */    printf("infop = &fmtinfo[0];\n");infop = &fmtinfo[0];    printf("xtype = etINVALID;\n");xtype = etINVALID;    for(idx=0; idx<ArraySize(fmtinfo); idx++){printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");          if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }    }    printf("zExtra = 0;\n");zExtra = 0;    /*    ** At this point, variables are initialized as follows:    **    **   flag_alternateform          TRUE if a '#' is present.    **   flag_altform2               TRUE if a '!' is present.    **   flag_plussign               TRUE if a '+' is present.    **   flag_leftjustify            TRUE if a '-' is present or if the    **                               field width was negative.    **   flag_zeropad                TRUE if the width began with 0.    **   flag_long                   TRUE if the letter 'l' (ell) prefixed    **                               the conversion character.    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed    **                               the conversion character.    **   flag_blanksign              TRUE if a ' ' is present.    **   width                       The specified field width.  This is    **                               always non-negative.  Zero is the default.    **   precision                   The specified precision.  The default    **                               is -1.    **   xtype                       The class of the conversion.    **   infop                       Pointer to the appropriate info struct.    */    printf("switch(xtype)\n");    switch( xtype ){      case etPOINTER:        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");flag_longlong = sizeof(char*)==sizeof(i64);        printf("flag_long = sizeof(char*)==sizeof(long int);\n");flag_long = sizeof(char*)==sizeof(long int);        /* Fall through into the next case */      case etORDINAL:      case etRADIX:        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }        if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }        printf("bufpt = &zOut[nOut-1];\n");bufpt = &zOut[nOut-1];        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");        {          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }        if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}               /* Add sign */        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        break;      case etFLOAT:      case etEXP:      case etGENERIC:        printf("realvalue = va_arg(ap,double);\n");realvalue = va_arg(ap,double);#ifdef SQLITE_OMIT_FLOATING_POINT        printf("length = 0;\n");length = 0;#else        if( precision<0 ) precision = 6;         /* Set default precision */        if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }        if( xtype==etGENERIC && precision>0 ) precision--;        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}        if( xtype==etFLOAT ) realvalue += rounder;        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */        exp = 0;        if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }        if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }        bufpt = buf;        /*        ** If the field type is etGENERIC, then convert to either etEXP        ** or etFLOAT, as appropriate.        */        if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }        if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }        if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }        zOut = bufpt;        nsd = 16 + flag_altform2*10;        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;        /* The sign in front of the number */        if( prefix ){          *(bufpt++) = prefix;        }        /* Digits prior to the decimal point */        if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }        /* The decimal point */        if( flag_dp ){          *(bufpt++) = '.';        }        /* "0" digits after the decimal point but before the first        ** significant digit of the number */        for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }        /* Significant digits after the decimal point */        while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }        /* Remove trailing zeros and the "." if no digits follow the "." */        if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }        /* Add the "eNNN" suffix */        if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }        *bufpt = 0;        /* The converted number is in buf[] and zero terminated. Output it.        ** Note that the number is in the usual order, not reversed as with        ** integer conversions. */        length = (int)(bufpt-zOut);        bufpt = zOut;        /* Special case:  Add leading zeros if the flag_zeropad flag is        ** set and we are not left justified */        if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */        break;      case etSIZE:        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");*(va_arg(ap,int*)) = pAccum->nChar;        printf("length = width = 0;\n");length = width = 0;        break;      case etPERCENT:        printf("buf[0] = '_';\n");buf[0] = '%';        printf("bufpt = buf;\n");bufpt = buf;        printf("length = 1;\n");length = 1;        break;      case etCHARX:        printf("c = va_arg(ap,int);\n");c = va_arg(ap,int);        printf("buf[0] = (char)c;\n");buf[0] = (char)c;        if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }        printf("bufpt = buf;\n");bufpt = buf;        break;      case etSTRING:      case etDYNSTRING:        printf("bufpt = va_arg(ap,char*);\n");bufpt = va_arg(ap,char*);        if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }        if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }        break;      case etSQLESCAPE:      case etSQLESCAPE2:      case etSQLESCAPE3: {        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }      case etTOKEN: {        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }      case etSRCLIST: {        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }      default: {        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }    }/* End switch over the format type */    /*    ** The text of the conversion is pointed to by "bufpt" and is    ** "length" characters long.  The field width is "width".  Do    ** the output.    */    if( !flag_leftjustify ){printf("if(!flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    if( length>0 ){printf("if(length>0)\n");          printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");      sqlite3StrAccumAppend(pAccum, bufpt, length);    }    if( flag_leftjustify ){printf("if(flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }    printf("sqlite3_free(zExtra);\n");    sqlite3_free(zExtra);  }
if( c!='%' ){printf("if(c!='_')\n");          printf("int amt;\n");      int amt;      printf("bufpt = (char *)fmt;\n");bufpt = (char *)fmt;      printf("amt = 1;\n");amt = 1;      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");      sqlite3StrAccumAppend(pAccum, bufpt, amt);      if( c==0 ) {printf("if(c==0)\n");      break;}    }
c!='%'
c
c
'%'
{printf("if(c!='_')\n");          printf("int amt;\n");      int amt;      printf("bufpt = (char *)fmt;\n");bufpt = (char *)fmt;      printf("amt = 1;\n");amt = 1;      while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}      printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");      sqlite3StrAccumAppend(pAccum, bufpt, amt);      if( c==0 ) {printf("if(c==0)\n");      break;}    }
printf("if(c!='_')\n");
printf("if(c!='_')\n")
printf
printf
"if(c!='_')\n"
printf("int amt;\n");
printf("int amt;\n")
printf
printf
"int amt;\n"
int amt;
int amt;
int
amt
amt
printf("bufpt = (char *)fmt;\n");
printf("bufpt = (char *)fmt;\n")
printf
printf
"bufpt = (char *)fmt;\n"
bufpt = (char *)fmt;
bufpt = (char *)fmt
bufpt
bufpt
(char *)fmt
char *
char
*
*
fmt
fmt
printf("amt = 1;\n");
printf("amt = 1;\n")
printf
printf
"amt = 1;\n"
amt = 1;
amt = 1
amt
amt
1
while( (c=(*++fmt))!='%' && c!=0 ) {printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}
(c=(*++fmt))!='%' && c!=0
(c=(*++fmt))!='%'
(c=(*++fmt))
c=(*++fmt)
c
c
(*++fmt)
*++fmt
++fmt
fmt
fmt
'%'
c!=0
c
c
0
{printf("while((c=(*++fmt))!='_' && c!=0)\n");      printf("amt++;\n");amt++;}
printf("while((c=(*++fmt))!='_' && c!=0)\n");
printf("while((c=(*++fmt))!='_' && c!=0)\n")
printf
printf
"while((c=(*++fmt))!='_' && c!=0)\n"
printf("amt++;\n");
printf("amt++;\n")
printf
printf
"amt++;\n"
amt++;
amt++
amt
amt
printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n");
printf("sqlite3StrAccumAppend(pAccum, bufpt, amt);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, bufpt, amt);\n"
sqlite3StrAccumAppend(pAccum, bufpt, amt);
sqlite3StrAccumAppend(pAccum, bufpt, amt)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
bufpt
bufpt
amt
amt
if( c==0 ) {printf("if(c==0)\n");      break;}
c==0
c
c
0
{printf("if(c==0)\n");      break;}
printf("if(c==0)\n");
printf("if(c==0)\n")
printf
printf
"if(c==0)\n"
break;
if( (c=(*++fmt))==0 ){printf("if((c=(*++fmt))==0)\n");          printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");      sqlite3StrAccumAppend(pAccum, "%", 1);      break;    }
(c=(*++fmt))==0
(c=(*++fmt))
c=(*++fmt)
c
c
(*++fmt)
*++fmt
++fmt
fmt
fmt
0
{printf("if((c=(*++fmt))==0)\n");          printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");      sqlite3StrAccumAppend(pAccum, "%", 1);      break;    }
printf("if((c=(*++fmt))==0)\n");
printf("if((c=(*++fmt))==0)\n")
printf
printf
"if((c=(*++fmt))==0)\n"
printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n");
printf("sqlite3StrAccumAppend(pAccum, '_', 1);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, '_', 1);\n"
sqlite3StrAccumAppend(pAccum, "%", 1);
sqlite3StrAccumAppend(pAccum, "%", 1)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
"%"
1
break;
printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n");
printf("flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n")
printf
printf
"flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;\n"
flag_leftjustify = flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0;
flag_leftjustify = flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0
flag_leftjustify
flag_leftjustify
flag_plussign = flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0
flag_plussign
flag_plussign
flag_blanksign =      flag_alternateform = flag_altform2 = flag_zeropad = 0
flag_blanksign
flag_blanksign
flag_alternateform = flag_altform2 = flag_zeropad = 0
flag_alternateform
flag_alternateform
flag_altform2 = flag_zeropad = 0
flag_altform2
flag_altform2
flag_zeropad = 0
flag_zeropad
flag_zeropad
0
printf("done = 0;\n");
printf("done = 0;\n")
printf
printf
"done = 0;\n"
done = 0;
done = 0
done
done
0
do{      printf("switch(c)\n");      switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }    }while( !done && (c=(*++fmt))!=0 );
{      printf("switch(c)\n");      switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }    }
printf("switch(c)\n");
printf("switch(c)\n")
printf
printf
"switch(c)\n"
switch( c ){        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }
c
c
{        case '-':   printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;     break;        case '+':   printf("flag_plussign = 1;\n");flag_plussign = 1;        break;        case ' ':   printf("flag_blanksign = 1;\n");flag_blanksign = 1;       break;        case '#':   printf("flag_alternateform = 1;\n");flag_alternateform = 1;   break;        case '!':   printf("flag_altform2 = 1;\n");flag_altform2 = 1;        break;        case '0':   printf("flag_zeropad = 1;\n");flag_zeropad = 1;         break;        default:    printf("done = 1;\n");done = 1;                 break;      }
case '-':
'-'
printf("flag_leftjustify = 1;\n");
printf("flag_leftjustify = 1;\n")
printf
printf
"flag_leftjustify = 1;\n"
flag_leftjustify = 1;
flag_leftjustify = 1
flag_leftjustify
flag_leftjustify
1
break;
case '+':
'+'
printf("flag_plussign = 1;\n");
printf("flag_plussign = 1;\n")
printf
printf
"flag_plussign = 1;\n"
flag_plussign = 1;
flag_plussign = 1
flag_plussign
flag_plussign
1
break;
case ' ':
' '
printf("flag_blanksign = 1;\n");
printf("flag_blanksign = 1;\n")
printf
printf
"flag_blanksign = 1;\n"
flag_blanksign = 1;
flag_blanksign = 1
flag_blanksign
flag_blanksign
1
break;
case '#':
'#'
printf("flag_alternateform = 1;\n");
printf("flag_alternateform = 1;\n")
printf
printf
"flag_alternateform = 1;\n"
flag_alternateform = 1;
flag_alternateform = 1
flag_alternateform
flag_alternateform
1
break;
case '!':
'!'
printf("flag_altform2 = 1;\n");
printf("flag_altform2 = 1;\n")
printf
printf
"flag_altform2 = 1;\n"
flag_altform2 = 1;
flag_altform2 = 1
flag_altform2
flag_altform2
1
break;
case '0':
'0'
printf("flag_zeropad = 1;\n");
printf("flag_zeropad = 1;\n")
printf
printf
"flag_zeropad = 1;\n"
flag_zeropad = 1;
flag_zeropad = 1
flag_zeropad
flag_zeropad
1
break;
default:
printf("done = 1;\n");
printf("done = 1;\n")
printf
printf
"done = 1;\n"
done = 1;
done = 1
done
done
1
break;
!done && (c=(*++fmt))!=0
!done
done
done
(c=(*++fmt))!=0
(c=(*++fmt))
c=(*++fmt)
c
c
(*++fmt)
*++fmt
++fmt
fmt
fmt
0
printf("width = 0;\n");
printf("width = 0;\n")
printf
printf
"width = 0;\n"
width = 0;
width = 0
width
width
0
if( c=='*' ){printf("if(c=='*')\n");          printf("width = va_arg(ap,int);\n");width = va_arg(ap,int);      if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }      printf("c = *++fmt;\n");c = *++fmt;    }else{      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }    }
c=='*'
c
c
'*'
{printf("if(c=='*')\n");          printf("width = va_arg(ap,int);\n");width = va_arg(ap,int);      if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }      printf("c = *++fmt;\n");c = *++fmt;    }
printf("if(c=='*')\n");
printf("if(c=='*')\n")
printf
printf
"if(c=='*')\n"
printf("width = va_arg(ap,int);\n");
printf("width = va_arg(ap,int);\n")
printf
printf
"width = va_arg(ap,int);\n"
width = va_arg(ap,int);
if( width<0 ){printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }
width<0
width
width
0
{printf("if(width<0)\n");              printf("flag_leftjustify = 1;\n");flag_leftjustify = 1;        printf("width = -width;\n");width = -width;      }
printf("if(width<0)\n");
printf("if(width<0)\n")
printf
printf
"if(width<0)\n"
printf("flag_leftjustify = 1;\n");
printf("flag_leftjustify = 1;\n")
printf
printf
"flag_leftjustify = 1;\n"
flag_leftjustify = 1;
flag_leftjustify = 1
flag_leftjustify
flag_leftjustify
1
printf("width = -width;\n");
printf("width = -width;\n")
printf
printf
"width = -width;\n"
width = -width;
width = -width
width
width
-width
width
width
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
{      while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }    }
while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }
c>='0' && c<='9'
c>='0'
c
c
'0'
c<='9'
c
c
'9'
{printf("while(c>='0' && c<='9')\n");              printf("width = width*10 + c - '0';\n");width = width*10 + c - '0';        printf("c = *++fmt;\n");c = *++fmt;      }
printf("while(c>='0' && c<='9')\n");
printf("while(c>='0' && c<='9')\n")
printf
printf
"while(c>='0' && c<='9')\n"
printf("width = width*10 + c - '0';\n");
printf("width = width*10 + c - '0';\n")
printf
printf
"width = width*10 + c - '0';\n"
width = width*10 + c - '0';
width = width*10 + c - '0'
width
width
width*10 + c - '0'
width*10 + c
width*10
width
width
10
c
c
'0'
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
if( c=='.' ){printf("if(c=='.')\n");          printf("precision = 0;\n");precision = 0;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }    }else{      printf("precision = -1;\n");precision = -1;    }
c=='.'
c
c
'.'
{printf("if(c=='.')\n");          printf("precision = 0;\n");precision = 0;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }    }
printf("if(c=='.')\n");
printf("if(c=='.')\n")
printf
printf
"if(c=='.')\n"
printf("precision = 0;\n");
printf("precision = 0;\n")
printf
printf
"precision = 0;\n"
precision = 0;
precision = 0
precision
precision
0
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
if( c=='*' ){printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }else{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }
c=='*'
c
c
'*'
{printf("if(c=='*')\n");              printf("precision = va_arg(ap,int);\n");precision = va_arg(ap,int);        if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}        printf("c = *++fmt;\n");c = *++fmt;      }
printf("if(c=='*')\n");
printf("if(c=='*')\n")
printf
printf
"if(c=='*')\n"
printf("precision = va_arg(ap,int);\n");
printf("precision = va_arg(ap,int);\n")
printf
printf
"precision = va_arg(ap,int);\n"
precision = va_arg(ap,int);
if( precision<0 ) {printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}
precision<0
precision
precision
0
{printf("if(precision<0)\n");        printf("precision = -precision;\n");precision = -precision;}
printf("if(precision<0)\n");
printf("if(precision<0)\n")
printf
printf
"if(precision<0)\n"
printf("precision = -precision;\n");
printf("precision = -precision;\n")
printf
printf
"precision = -precision;\n"
precision = -precision;
precision = -precision
precision
precision
-precision
precision
precision
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
{        while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }      }
while( c>='0' && c<='9' ){printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }
c>='0' && c<='9'
c>='0'
c
c
'0'
c<='9'
c
c
'9'
{printf("while(c>='0' && c<='9')\n");                  printf("precision = precision*10 + c - '0';\n");precision = precision*10 + c - '0';          printf("c = *++fmt;\n");c = *++fmt;        }
printf("while(c>='0' && c<='9')\n");
printf("while(c>='0' && c<='9')\n")
printf
printf
"while(c>='0' && c<='9')\n"
printf("precision = precision*10 + c - '0';\n");
printf("precision = precision*10 + c - '0';\n")
printf
printf
"precision = precision*10 + c - '0';\n"
precision = precision*10 + c - '0';
precision = precision*10 + c - '0'
precision
precision
precision*10 + c - '0'
precision*10 + c
precision*10
precision
precision
10
c
c
'0'
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
{      printf("precision = -1;\n");precision = -1;    }
printf("precision = -1;\n");
printf("precision = -1;\n")
printf
printf
"precision = -1;\n"
precision = -1;
precision = -1
precision
precision
-1
1
if( c=='l' ){printf("if(c=='l')\n");          printf("flag_long = 1;\n");flag_long = 1;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }    }else{      printf("flag_long = flag_longlong = 0;\n");flag_long = flag_longlong = 0;    }
c=='l'
c
c
'l'
{printf("if(c=='l')\n");          printf("flag_long = 1;\n");flag_long = 1;      printf("c = *++fmt;\n");c = *++fmt;      if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }    }
printf("if(c=='l')\n");
printf("if(c=='l')\n")
printf
printf
"if(c=='l')\n"
printf("flag_long = 1;\n");
printf("flag_long = 1;\n")
printf
printf
"flag_long = 1;\n"
flag_long = 1;
flag_long = 1
flag_long
flag_long
1
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
if( c=='l' ){printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }else{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }
c=='l'
c
c
'l'
{printf("if(c=='l')\n");              printf("flag_longlong = 1;\n");flag_longlong = 1;        printf("c = *++fmt;\n");c = *++fmt;      }
printf("if(c=='l')\n");
printf("if(c=='l')\n")
printf
printf
"if(c=='l')\n"
printf("flag_longlong = 1;\n");
printf("flag_longlong = 1;\n")
printf
printf
"flag_longlong = 1;\n"
flag_longlong = 1;
flag_longlong = 1
flag_longlong
flag_longlong
1
printf("c = *++fmt;\n");
printf("c = *++fmt;\n")
printf
printf
"c = *++fmt;\n"
c = *++fmt;
c = *++fmt
c
c
*++fmt
++fmt
fmt
fmt
{        printf("flag_longlong = 0;\n");flag_longlong = 0;      }
printf("flag_longlong = 0;\n");
printf("flag_longlong = 0;\n")
printf
printf
"flag_longlong = 0;\n"
flag_longlong = 0;
flag_longlong = 0
flag_longlong
flag_longlong
0
{      printf("flag_long = flag_longlong = 0;\n");flag_long = flag_longlong = 0;    }
printf("flag_long = flag_longlong = 0;\n");
printf("flag_long = flag_longlong = 0;\n")
printf
printf
"flag_long = flag_longlong = 0;\n"
flag_long = flag_longlong = 0;
flag_long = flag_longlong = 0
flag_long
flag_long
flag_longlong = 0
flag_longlong
flag_longlong
0
printf("infop = &fmtinfo[0];\n");
printf("infop = &fmtinfo[0];\n")
printf
printf
"infop = &fmtinfo[0];\n"
infop = &fmtinfo[0];
infop = &fmtinfo[0]
infop
infop
&fmtinfo[0]
fmtinfo[0]
fmtinfo
fmtinfo
0
printf("xtype = etINVALID;\n");
printf("xtype = etINVALID;\n")
printf
printf
"xtype = etINVALID;\n"
xtype = etINVALID;
xtype = etINVALID
xtype
xtype
etINVALID
etINVALID
for(idx=0; idx<ArraySize(fmtinfo); idx++){printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");          if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }    }
idx=0;
idx=0
idx
idx
0
idx<ArraySize(fmtinfo)
idx
idx
ArraySize(fmtinfo)
ArraySize
ArraySize
fmtinfo
fmtinfo
idx++
idx
idx
{printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");          if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }    }
printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n");
printf("for(idx=0;idx<ArraySize(fmtinfo);idx++)\n")
printf
printf
"for(idx=0;idx<ArraySize(fmtinfo);idx++)\n"
if( c==fmtinfo[idx].fmttype ){printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }
c==fmtinfo[idx].fmttype
c
c
fmtinfo[idx].fmttype
fmtinfo[idx]
fmtinfo
fmtinfo
idx
idx
fmttype
{printf("if(c==fmtinfo[idx].fmttype)\n");              printf("infop = &fmtinfo[idx];\n");infop = &fmtinfo[idx];        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }        break;      }
printf("if(c==fmtinfo[idx].fmttype)\n");
printf("if(c==fmtinfo[idx].fmttype)\n")
printf
printf
"if(c==fmtinfo[idx].fmttype)\n"
printf("infop = &fmtinfo[idx];\n");
printf("infop = &fmtinfo[idx];\n")
printf
printf
"infop = &fmtinfo[idx];\n"
infop = &fmtinfo[idx];
infop = &fmtinfo[idx]
infop
infop
&fmtinfo[idx]
fmtinfo[idx]
fmtinfo
fmtinfo
idx
idx
if( useExtended || (infop->flags & FLAG_INTERN)==0 ){printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }else{          printf("return;\n");          printf("------function end!------\n");          return;        }
useExtended || (infop->flags & FLAG_INTERN)==0
useExtended
useExtended
(infop->flags & FLAG_INTERN)==0
(infop->flags & FLAG_INTERN)
infop->flags & FLAG_INTERN
infop->flags
infop
infop
flags
FLAG_INTERN
FLAG_INTERN
0
{printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");                  printf("xtype = infop->type;\n");xtype = infop->type;        }
printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n");
printf("if(useExtended || (infop->flags & FLAG_INTERN)==0)\n")
printf
printf
"if(useExtended || (infop->flags & FLAG_INTERN)==0)\n"
printf("xtype = infop->type;\n");
printf("xtype = infop->type;\n")
printf
printf
"xtype = infop->type;\n"
xtype = infop->type;
xtype = infop->type
xtype
xtype
infop->type
infop
infop
type
{          printf("return;\n");          printf("------function end!------\n");          return;        }
printf("return;\n");
printf("return;\n")
printf
printf
"return;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return;
break;
printf("zExtra = 0;\n");
printf("zExtra = 0;\n")
printf
printf
"zExtra = 0;\n"
zExtra = 0;
zExtra = 0
zExtra
zExtra
0
printf("switch(xtype)\n");
printf("switch(xtype)\n")
printf
printf
"switch(xtype)\n"
switch( xtype ){      case etPOINTER:        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");flag_longlong = sizeof(char*)==sizeof(i64);        printf("flag_long = sizeof(char*)==sizeof(long int);\n");flag_long = sizeof(char*)==sizeof(long int);        /* Fall through into the next case */      case etORDINAL:      case etRADIX:        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }        if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }        printf("bufpt = &zOut[nOut-1];\n");bufpt = &zOut[nOut-1];        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");        {          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }        if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}               /* Add sign */        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        break;      case etFLOAT:      case etEXP:      case etGENERIC:        printf("realvalue = va_arg(ap,double);\n");realvalue = va_arg(ap,double);#ifdef SQLITE_OMIT_FLOATING_POINT        printf("length = 0;\n");length = 0;#else        if( precision<0 ) precision = 6;         /* Set default precision */        if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }        if( xtype==etGENERIC && precision>0 ) precision--;        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}        if( xtype==etFLOAT ) realvalue += rounder;        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */        exp = 0;        if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }        if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }        bufpt = buf;        /*        ** If the field type is etGENERIC, then convert to either etEXP        ** or etFLOAT, as appropriate.        */        if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }        if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }        if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }        zOut = bufpt;        nsd = 16 + flag_altform2*10;        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;        /* The sign in front of the number */        if( prefix ){          *(bufpt++) = prefix;        }        /* Digits prior to the decimal point */        if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }        /* The decimal point */        if( flag_dp ){          *(bufpt++) = '.';        }        /* "0" digits after the decimal point but before the first        ** significant digit of the number */        for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }        /* Significant digits after the decimal point */        while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }        /* Remove trailing zeros and the "." if no digits follow the "." */        if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }        /* Add the "eNNN" suffix */        if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }        *bufpt = 0;        /* The converted number is in buf[] and zero terminated. Output it.        ** Note that the number is in the usual order, not reversed as with        ** integer conversions. */        length = (int)(bufpt-zOut);        bufpt = zOut;        /* Special case:  Add leading zeros if the flag_zeropad flag is        ** set and we are not left justified */        if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */        break;      case etSIZE:        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");*(va_arg(ap,int*)) = pAccum->nChar;        printf("length = width = 0;\n");length = width = 0;        break;      case etPERCENT:        printf("buf[0] = '_';\n");buf[0] = '%';        printf("bufpt = buf;\n");bufpt = buf;        printf("length = 1;\n");length = 1;        break;      case etCHARX:        printf("c = va_arg(ap,int);\n");c = va_arg(ap,int);        printf("buf[0] = (char)c;\n");buf[0] = (char)c;        if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }        printf("bufpt = buf;\n");bufpt = buf;        break;      case etSTRING:      case etDYNSTRING:        printf("bufpt = va_arg(ap,char*);\n");bufpt = va_arg(ap,char*);        if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }        if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }        break;      case etSQLESCAPE:      case etSQLESCAPE2:      case etSQLESCAPE3: {        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }      case etTOKEN: {        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }      case etSRCLIST: {        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }      default: {        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }    }
xtype
xtype
{      case etPOINTER:        printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");flag_longlong = sizeof(char*)==sizeof(i64);        printf("flag_long = sizeof(char*)==sizeof(long int);\n");flag_long = sizeof(char*)==sizeof(long int);        /* Fall through into the next case */      case etORDINAL:      case etRADIX:        if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }        if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}        if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }        if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }        printf("bufpt = &zOut[nOut-1];\n");bufpt = &zOut[nOut-1];        if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }        printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");        {          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }        if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}               /* Add sign */        if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }        printf("length = (int)(&zOut[nOut-1]-bufpt);\n");length = (int)(&zOut[nOut-1]-bufpt);        break;      case etFLOAT:      case etEXP:      case etGENERIC:        printf("realvalue = va_arg(ap,double);\n");realvalue = va_arg(ap,double);#ifdef SQLITE_OMIT_FLOATING_POINT        printf("length = 0;\n");length = 0;#else        if( precision<0 ) precision = 6;         /* Set default precision */        if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }        if( xtype==etGENERIC && precision>0 ) precision--;        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}        if( xtype==etFLOAT ) realvalue += rounder;        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */        exp = 0;        if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }        if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }        bufpt = buf;        /*        ** If the field type is etGENERIC, then convert to either etEXP        ** or etFLOAT, as appropriate.        */        if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }        if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }        if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }        if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }        zOut = bufpt;        nsd = 16 + flag_altform2*10;        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;        /* The sign in front of the number */        if( prefix ){          *(bufpt++) = prefix;        }        /* Digits prior to the decimal point */        if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }        /* The decimal point */        if( flag_dp ){          *(bufpt++) = '.';        }        /* "0" digits after the decimal point but before the first        ** significant digit of the number */        for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }        /* Significant digits after the decimal point */        while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }        /* Remove trailing zeros and the "." if no digits follow the "." */        if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }        /* Add the "eNNN" suffix */        if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }        *bufpt = 0;        /* The converted number is in buf[] and zero terminated. Output it.        ** Note that the number is in the usual order, not reversed as with        ** integer conversions. */        length = (int)(bufpt-zOut);        bufpt = zOut;        /* Special case:  Add leading zeros if the flag_zeropad flag is        ** set and we are not left justified */        if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */        break;      case etSIZE:        printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");*(va_arg(ap,int*)) = pAccum->nChar;        printf("length = width = 0;\n");length = width = 0;        break;      case etPERCENT:        printf("buf[0] = '_';\n");buf[0] = '%';        printf("bufpt = buf;\n");bufpt = buf;        printf("length = 1;\n");length = 1;        break;      case etCHARX:        printf("c = va_arg(ap,int);\n");c = va_arg(ap,int);        printf("buf[0] = (char)c;\n");buf[0] = (char)c;        if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }        printf("bufpt = buf;\n");bufpt = buf;        break;      case etSTRING:      case etDYNSTRING:        printf("bufpt = va_arg(ap,char*);\n");bufpt = va_arg(ap,char*);        if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }        if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }        break;      case etSQLESCAPE:      case etSQLESCAPE2:      case etSQLESCAPE3: {        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }      case etTOKEN: {        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }      case etSRCLIST: {        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }      default: {        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }    }
case etPOINTER:
etPOINTER
etPOINTER
printf("flag_longlong = sizeof(char*)==sizeof(i64);\n");
printf("flag_longlong = sizeof(char*)==sizeof(i64);\n")
printf
printf
"flag_longlong = sizeof(char*)==sizeof(i64);\n"
flag_longlong = sizeof(char*)==sizeof(i64);
flag_longlong = sizeof(char*)==sizeof(i64)
flag_longlong
flag_longlong
sizeof(char*)==sizeof(i64)
sizeof(char*)
char*
char
*
*
sizeof(i64)
i64
i64
i64

printf("flag_long = sizeof(char*)==sizeof(long int);\n");
printf("flag_long = sizeof(char*)==sizeof(long int);\n")
printf
printf
"flag_long = sizeof(char*)==sizeof(long int);\n"
flag_long = sizeof(char*)==sizeof(long int);
flag_long = sizeof(char*)==sizeof(long int)
flag_long
flag_long
sizeof(char*)==sizeof(long int)
sizeof(char*)
char*
char
*
*
sizeof(long int)
long int
long int

case etORDINAL:
etORDINAL
etORDINAL
case etRADIX:
etRADIX
etRADIX
if( infop->flags & FLAG_SIGNED ){printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }else{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }
infop->flags & FLAG_SIGNED
infop->flags
infop
infop
flags
FLAG_SIGNED
FLAG_SIGNED
{printf("if(infop->flags & FLAG_SIGNED)\n");                  printf("i64 v;\n");          i64 v;          if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }          if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }        }
printf("if(infop->flags & FLAG_SIGNED)\n");
printf("if(infop->flags & FLAG_SIGNED)\n")
printf
printf
"if(infop->flags & FLAG_SIGNED)\n"
printf("i64 v;\n");
printf("i64 v;\n")
printf
printf
"i64 v;\n"
i64 v;
i64 v;
i64
i64
v
v
if( flag_longlong ){printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }else if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }
flag_longlong
flag_longlong
{printf("if(flag_longlong)\n");                      printf("v = va_arg(ap,i64);\n");v = va_arg(ap,i64);          }
printf("if(flag_longlong)\n");
printf("if(flag_longlong)\n")
printf
printf
"if(flag_longlong)\n"
printf("v = va_arg(ap,i64);\n");
printf("v = va_arg(ap,i64);\n")
printf
printf
"v = va_arg(ap,i64);\n"
v = va_arg(ap,i64);
v = va_arg(ap,i64)
v
v
va_arg(ap,i64)
va_arg
va_arg
ap
ap
i64
i64
if( flag_long ){printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }else{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }
flag_long
flag_long
{printf("if(flag_long)\n");                      printf("v = va_arg(ap,long int);\n");v = va_arg(ap,long int);          }
printf("if(flag_long)\n");
printf("if(flag_long)\n")
printf
printf
"if(flag_long)\n"
printf("v = va_arg(ap,long int);\n");
printf("v = va_arg(ap,long int);\n")
printf
printf
"v = va_arg(ap,long int);\n"
v = va_arg(ap,long int);
{            printf("v = va_arg(ap,int);\n");v = va_arg(ap,int);          }
printf("v = va_arg(ap,int);\n");
printf("v = va_arg(ap,int);\n")
printf
printf
"v = va_arg(ap,int);\n"
v = va_arg(ap,int);
if( v<0 ){printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }else{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }
v<0
v
v
0
{printf("if(v<0)\n");                      if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }            printf("prefix = '-';\n");prefix = '-';          }
printf("if(v<0)\n");
printf("if(v<0)\n")
printf
printf
"if(v<0)\n"
if( v==SMALLEST_INT64 ){printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }else{              longvalue = -v;            }
v==SMALLEST_INT64
v
v
SMALLEST_INT64
SMALLEST_INT64
{printf("if(v==SMALLEST_INT64)\n");                          longvalue = ((u64)1)<<63;            }
printf("if(v==SMALLEST_INT64)\n");
printf("if(v==SMALLEST_INT64)\n")
printf
printf
"if(v==SMALLEST_INT64)\n"
longvalue = ((u64)1)<<63;
longvalue = ((u64)1)<<63
longvalue
longvalue
((u64)1)<<63
((u64)1)
(u64)1
u64
u64
u64

1
63
{              longvalue = -v;            }
longvalue = -v;
longvalue = -v
longvalue
longvalue
-v
v
v
printf("prefix = '-';\n");
printf("prefix = '-';\n")
printf
printf
"prefix = '-';\n"
prefix = '-';
prefix = '-'
prefix
prefix
'-'
{            longvalue = v;            if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}          }
longvalue = v;
longvalue = v
longvalue
longvalue
v
v
if( flag_plussign )        {printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}            else if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}
flag_plussign
flag_plussign
{printf("if(flag_plussign)\n");            printf("prefix = '+';\n");prefix = '+';}
printf("if(flag_plussign)\n");
printf("if(flag_plussign)\n")
printf
printf
"if(flag_plussign)\n"
printf("prefix = '+';\n");
printf("prefix = '+';\n")
printf
printf
"prefix = '+';\n"
prefix = '+';
prefix = '+'
prefix
prefix
'+'
if( flag_blanksign )  {printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}            else                       {printf("prefix = 0;\n");prefix = 0;}
flag_blanksign
flag_blanksign
{printf("if(flag_blanksign)\n");            printf("prefix = ' ';\n");prefix = ' ';}
printf("if(flag_blanksign)\n");
printf("if(flag_blanksign)\n")
printf
printf
"if(flag_blanksign)\n"
printf("prefix = ' ';\n");
printf("prefix = ' ';\n")
printf
printf
"prefix = ' ';\n"
prefix = ' ';
prefix = ' '
prefix
prefix
' '
{printf("prefix = 0;\n");prefix = 0;}
printf("prefix = 0;\n");
printf("prefix = 0;\n")
printf
printf
"prefix = 0;\n"
prefix = 0;
prefix = 0
prefix
prefix
0
{          if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }          printf("prefix = 0;\n");prefix = 0;        }
if( flag_longlong ){printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }else if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }
flag_longlong
flag_longlong
{printf("if(flag_longlong)\n");                      longvalue = va_arg(ap,u64);          }
printf("if(flag_longlong)\n");
printf("if(flag_longlong)\n")
printf
printf
"if(flag_longlong)\n"
longvalue = va_arg(ap,u64);
longvalue = va_arg(ap,u64)
longvalue
longvalue
va_arg(ap,u64)
va_arg
va_arg
ap
ap
u64
u64
if( flag_long ){printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }else{            longvalue = va_arg(ap,unsigned int);          }
flag_long
flag_long
{printf("if(flag_long)\n");                      longvalue = va_arg(ap,unsigned long int);          }
printf("if(flag_long)\n");
printf("if(flag_long)\n")
printf
printf
"if(flag_long)\n"
longvalue = va_arg(ap,unsigned long int);
{            longvalue = va_arg(ap,unsigned int);          }
longvalue = va_arg(ap,unsigned int);
printf("prefix = 0;\n");
printf("prefix = 0;\n")
printf
printf
"prefix = 0;\n"
prefix = 0;
prefix = 0
prefix
prefix
0
if( longvalue==0 ) {printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}
longvalue==0
longvalue
longvalue
0
{printf("if()\n");        printf("flag_alternateform = 0;\n");flag_alternateform = 0;}
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("flag_alternateform = 0;\n");
printf("flag_alternateform = 0;\n")
printf
printf
"flag_alternateform = 0;\n"
flag_alternateform = 0;
flag_alternateform = 0
flag_alternateform
flag_alternateform
0
if( flag_zeropad && precision<width-(prefix!=0) ){printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }
flag_zeropad && precision<width-(prefix!=0)
flag_zeropad
flag_zeropad
precision<width-(prefix!=0)
precision
precision
width-(prefix!=0)
width
width
(prefix!=0)
prefix!=0
prefix
prefix
0
{printf("if(flag_zeropad && precision<width-(prefix!=0))\n");                  printf("precision = width-(prefix!=0);\n");precision = width-(prefix!=0);        }
printf("if(flag_zeropad && precision<width-(prefix!=0))\n");
printf("if(flag_zeropad && precision<width-(prefix!=0))\n")
printf
printf
"if(flag_zeropad && precision<width-(prefix!=0))\n"
printf("precision = width-(prefix!=0);\n");
printf("precision = width-(prefix!=0);\n")
printf
printf
"precision = width-(prefix!=0);\n"
precision = width-(prefix!=0);
precision = width-(prefix!=0)
precision
precision
width-(prefix!=0)
width
width
(prefix!=0)
prefix!=0
prefix
prefix
0
if( precision<etBUFSIZE-10 ){printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }else{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }
precision<etBUFSIZE-10
precision
precision
etBUFSIZE-10
etBUFSIZE
etBUFSIZE
10
{printf("if(precision<etBUFSIZE-10)\n");                  printf("nOut = etBUFSIZE;\n");nOut = etBUFSIZE;          printf("zOut = buf;\n");zOut = buf;        }
printf("if(precision<etBUFSIZE-10)\n");
printf("if(precision<etBUFSIZE-10)\n")
printf
printf
"if(precision<etBUFSIZE-10)\n"
printf("nOut = etBUFSIZE;\n");
printf("nOut = etBUFSIZE;\n")
printf
printf
"nOut = etBUFSIZE;\n"
nOut = etBUFSIZE;
nOut = etBUFSIZE
nOut
nOut
etBUFSIZE
etBUFSIZE
printf("zOut = buf;\n");
printf("zOut = buf;\n")
printf
printf
"zOut = buf;\n"
zOut = buf;
zOut = buf
zOut
zOut
buf
buf
{          printf("nOut = precision + 10;\n");nOut = precision + 10;          printf("zOut = zExtra = sqlite3Malloc( nOut );\n");zOut = zExtra = sqlite3Malloc( nOut );          if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }
printf("nOut = precision + 10;\n");
printf("nOut = precision + 10;\n")
printf
printf
"nOut = precision + 10;\n"
nOut = precision + 10;
nOut = precision + 10
nOut
nOut
precision + 10
precision
precision
10
printf("zOut = zExtra = sqlite3Malloc( nOut );\n");
printf("zOut = zExtra = sqlite3Malloc( nOut );\n")
printf
printf
"zOut = zExtra = sqlite3Malloc( nOut );\n"
zOut = zExtra = sqlite3Malloc( nOut );
zOut = zExtra = sqlite3Malloc( nOut )
zOut
zOut
zExtra = sqlite3Malloc( nOut )
zExtra
zExtra
sqlite3Malloc( nOut )
sqlite3Malloc
sqlite3Malloc
nOut
nOut
if( zOut==0 ){printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }
zOut==0
zOut
zOut
0
{printf("if(zOut==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }
printf("if(zOut==0)\n");
printf("if(zOut==0)\n")
printf
printf
"if(zOut==0)\n"
printf("pAccum->accError = STRACCUM_NOMEM;\n");
printf("pAccum->accError = STRACCUM_NOMEM;\n")
printf
printf
"pAccum->accError = STRACCUM_NOMEM;\n"
pAccum->accError = STRACCUM_NOMEM;
pAccum->accError = STRACCUM_NOMEM
pAccum->accError
pAccum
pAccum
accError
STRACCUM_NOMEM
STRACCUM_NOMEM
printf("return;\n");
printf("return;\n")
printf
printf
"return;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return;
printf("bufpt = &zOut[nOut-1];\n");
printf("bufpt = &zOut[nOut-1];\n")
printf
printf
"bufpt = &zOut[nOut-1];\n"
bufpt = &zOut[nOut-1];
bufpt = &zOut[nOut-1]
bufpt
bufpt
&zOut[nOut-1]
zOut[nOut-1]
zOut
zOut
nOut-1
nOut
nOut
1
if( xtype==etORDINAL ){printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }
xtype==etORDINAL
xtype
xtype
etORDINAL
etORDINAL
{printf("if(xtype==etORDINAL)\n");                  printf("static const char zOrd[] = 'thstndrd';\n");          static const char zOrd[] = "thstndrd";          printf("int x = (int)(longvalue _ 10);\n");          int x = (int)(longvalue % 10);          if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }          printf("*(--bufpt) = zOrd[x*2+1];\n");*(--bufpt) = zOrd[x*2+1];          printf("*(--bufpt) = zOrd[x*2];\n");*(--bufpt) = zOrd[x*2];        }
printf("if(xtype==etORDINAL)\n");
printf("if(xtype==etORDINAL)\n")
printf
printf
"if(xtype==etORDINAL)\n"
printf("static const char zOrd[] = 'thstndrd';\n");
printf("static const char zOrd[] = 'thstndrd';\n")
printf
printf
"static const char zOrd[] = 'thstndrd';\n"
static const char zOrd[] = "thstndrd";
static const char zOrd[] = "thstndrd";
static const char
zOrd[] = "thstndrd"
zOrd
[]
= "thstndrd"
"thstndrd"
printf("int x = (int)(longvalue _ 10);\n");
printf("int x = (int)(longvalue _ 10);\n")
printf
printf
"int x = (int)(longvalue _ 10);\n"
int x = (int)(longvalue % 10);
int x = (int)(longvalue % 10);
int
x = (int)(longvalue % 10)
x
= (int)(longvalue % 10)
(int)(longvalue % 10)
int
int

(longvalue % 10)
longvalue % 10
longvalue
longvalue
10
if( x>=4 || (longvalue/10)%10==1 ){printf("if()\n");                      printf("x = 0;\n");x = 0;          }
x>=4 || (longvalue/10)%10==1
x>=4
x
x
4
(longvalue/10)%10==1
(longvalue/10)%10
(longvalue/10)
longvalue/10
longvalue
longvalue
10
10
1
{printf("if()\n");                      printf("x = 0;\n");x = 0;          }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("x = 0;\n");
printf("x = 0;\n")
printf
printf
"x = 0;\n"
x = 0;
x = 0
x
x
0
printf("*(--bufpt) = zOrd[x*2+1];\n");
printf("*(--bufpt) = zOrd[x*2+1];\n")
printf
printf
"*(--bufpt) = zOrd[x*2+1];\n"
*(--bufpt) = zOrd[x*2+1];
*(--bufpt) = zOrd[x*2+1]
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
zOrd[x*2+1]
zOrd
zOrd
x*2+1
x*2
x
x
2
1
printf("*(--bufpt) = zOrd[x*2];\n");
printf("*(--bufpt) = zOrd[x*2];\n")
printf
printf
"*(--bufpt) = zOrd[x*2];\n"
*(--bufpt) = zOrd[x*2];
*(--bufpt) = zOrd[x*2]
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
zOrd[x*2]
zOrd
zOrd
x*2
x
x
2
printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n");
printf("{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n")
printf
printf
"{           register const char *cset;      /* Use registers for speed */           register int base;           cset = &aDigits[infop->charset];           base = infop->base;           do{                                           /* Convert to ascii */             *(--bufpt) = cset[longvalue_base];             longvalue = longvalue/base;           }while( longvalue>0 );         };\n"
{          printf("register const char *cset;\n");          register const char *cset;      /* Use registers for speed */          printf("register int base;\n");          register int base;          printf("cset = &aDigits[infop->charset];\n");cset = &aDigits[infop->charset];          printf("base = infop->base;\n");base = infop->base;          do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );        }
printf("register const char *cset;\n");
printf("register const char *cset;\n")
printf
printf
"register const char *cset;\n"
register const char *cset;
register const char *cset;
register const char
*cset
*
cset
printf("register int base;\n");
printf("register int base;\n")
printf
printf
"register int base;\n"
register int base;
register int base;
register int
base
base
printf("cset = &aDigits[infop->charset];\n");
printf("cset = &aDigits[infop->charset];\n")
printf
printf
"cset = &aDigits[infop->charset];\n"
cset = &aDigits[infop->charset];
cset = &aDigits[infop->charset]
cset
cset
&aDigits[infop->charset]
aDigits[infop->charset]
aDigits
aDigits
infop->charset
infop
infop
charset
printf("base = infop->base;\n");
printf("base = infop->base;\n")
printf
printf
"base = infop->base;\n"
base = infop->base;
base = infop->base
base
base
infop->base
infop
infop
base
do{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }while( longvalue>0 );
{                                           /* Convert to ascii */            *(--bufpt) = cset[longvalue%base];            longvalue = longvalue/base;          }
*(--bufpt) = cset[longvalue%base];
*(--bufpt) = cset[longvalue%base]
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
cset[longvalue%base]
cset
cset
longvalue%base
longvalue
longvalue
base
base
longvalue = longvalue/base;
longvalue = longvalue/base
longvalue
longvalue
longvalue/base
longvalue
longvalue
base
base
longvalue>0
longvalue
longvalue
0
printf("length = (int)(&zOut[nOut-1]-bufpt);\n");
printf("length = (int)(&zOut[nOut-1]-bufpt);\n")
printf
printf
"length = (int)(&zOut[nOut-1]-bufpt);\n"
length = (int)(&zOut[nOut-1]-bufpt);
length = (int)(&zOut[nOut-1]-bufpt)
length
length
(int)(&zOut[nOut-1]-bufpt)
int
int

(&zOut[nOut-1]-bufpt)
&zOut[nOut-1]-bufpt
&zOut[nOut-1]
zOut[nOut-1]
zOut
zOut
nOut-1
nOut
nOut
1
bufpt
bufpt
for(idx=precision-length; idx>0; idx--){printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }
idx=precision-length;
idx=precision-length
idx
idx
precision-length
precision
precision
length
length
idx>0
idx
idx
0
idx--
idx
idx
{printf("for(idx=precision-length;idx>0;idx--)\n");                  printf("*(--bufpt) = '0';\n");*(--bufpt) = '0';                             /* Zero pad */        }
printf("for(idx=precision-length;idx>0;idx--)\n");
printf("for(idx=precision-length;idx>0;idx--)\n")
printf
printf
"for(idx=precision-length;idx>0;idx--)\n"
printf("*(--bufpt) = '0';\n");
printf("*(--bufpt) = '0';\n")
printf
printf
"*(--bufpt) = '0';\n"
*(--bufpt) = '0';
*(--bufpt) = '0'
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
'0'
if( prefix ) {printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}
prefix
prefix
{printf("if(prefix)\n");        printf("*(--bufpt) = prefix;\n");*(--bufpt) = prefix;}
printf("if(prefix)\n");
printf("if(prefix)\n")
printf
printf
"if(prefix)\n"
printf("*(--bufpt) = prefix;\n");
printf("*(--bufpt) = prefix;\n")
printf
printf
"*(--bufpt) = prefix;\n"
*(--bufpt) = prefix;
*(--bufpt) = prefix
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
prefix
prefix
if( flag_alternateform && infop->prefix ){printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }
flag_alternateform && infop->prefix
flag_alternateform
flag_alternateform
infop->prefix
infop
infop
prefix
{printf("if(flag_alternateform && infop->prefix)\n");              /* Add "0" or "0x" */          printf("const char *pre;\n");          const char *pre;          printf("char x;\n");          char x;          printf("pre = &aPrefix[infop->prefix];\n");pre = &aPrefix[infop->prefix];          for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}        }
printf("if(flag_alternateform && infop->prefix)\n");
printf("if(flag_alternateform && infop->prefix)\n")
printf
printf
"if(flag_alternateform && infop->prefix)\n"
printf("const char *pre;\n");
printf("const char *pre;\n")
printf
printf
"const char *pre;\n"
const char *pre;
const char *pre;
const char
*pre
*
pre
printf("char x;\n");
printf("char x;\n")
printf
printf
"char x;\n"
char x;
char x;
char
x
x
printf("pre = &aPrefix[infop->prefix];\n");
printf("pre = &aPrefix[infop->prefix];\n")
printf
printf
"pre = &aPrefix[infop->prefix];\n"
pre = &aPrefix[infop->prefix];
pre = &aPrefix[infop->prefix]
pre
pre
&aPrefix[infop->prefix]
aPrefix[infop->prefix]
aPrefix
aPrefix
infop->prefix
infop
infop
prefix
for(; (x=(*pre))!=0; pre++) {printf("*(--bufpt) = x;\n");*(--bufpt) = x;}
;
(x=(*pre))!=0
(x=(*pre))
x=(*pre)
x
x
(*pre)
*pre
pre
pre
0
pre++
pre
pre
{printf("*(--bufpt) = x;\n");*(--bufpt) = x;}
printf("*(--bufpt) = x;\n");
printf("*(--bufpt) = x;\n")
printf
printf
"*(--bufpt) = x;\n"
*(--bufpt) = x;
*(--bufpt) = x
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
x
x
printf("length = (int)(&zOut[nOut-1]-bufpt);\n");
printf("length = (int)(&zOut[nOut-1]-bufpt);\n")
printf
printf
"length = (int)(&zOut[nOut-1]-bufpt);\n"
length = (int)(&zOut[nOut-1]-bufpt);
length = (int)(&zOut[nOut-1]-bufpt)
length
length
(int)(&zOut[nOut-1]-bufpt)
int
int

(&zOut[nOut-1]-bufpt)
&zOut[nOut-1]-bufpt
&zOut[nOut-1]
zOut[nOut-1]
zOut
zOut
nOut-1
nOut
nOut
1
bufpt
bufpt
break;
case etFLOAT:
etFLOAT
etFLOAT
case etEXP:
etEXP
etEXP
case etGENERIC:
etGENERIC
etGENERIC
printf("realvalue = va_arg(ap,double);\n");
printf("realvalue = va_arg(ap,double);\n")
printf
printf
"realvalue = va_arg(ap,double);\n"
realvalue = va_arg(ap,double);
if( precision<0 ) precision = 6;
precision<0
precision
precision
0
precision = 6;
precision = 6
precision
precision
6
if( realvalue<0.0 ){          realvalue = -realvalue;          prefix = '-';        }else{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }
realvalue<0.0
realvalue
realvalue
0.0
{          realvalue = -realvalue;          prefix = '-';        }
realvalue = -realvalue;
realvalue = -realvalue
realvalue
realvalue
-realvalue
realvalue
realvalue
prefix = '-';
prefix = '-'
prefix
prefix
'-'
{          if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;        }
if( flag_plussign )          prefix = '+';          else if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;
flag_plussign
flag_plussign
prefix = '+';
prefix = '+'
prefix
prefix
'+'
if( flag_blanksign )    prefix = ' ';          else                         prefix = 0;
flag_blanksign
flag_blanksign
prefix = ' ';
prefix = ' '
prefix
prefix
' '
prefix = 0;
prefix = 0
prefix
prefix
0
if( xtype==etGENERIC && precision>0 ) precision--;
xtype==etGENERIC && precision>0
xtype==etGENERIC
xtype
xtype
etGENERIC
etGENERIC
precision>0
precision
precision
0
precision--;
precision--
precision
precision
for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}
idx=precision, rounder=0.5;
idx=precision, rounder=0.5
idx=precision
idx
idx
precision
precision
rounder=0.5
rounder
rounder
0.5
idx>0
idx
idx
0
idx--, rounder*=0.1
idx--
idx
idx
rounder*=0.1
rounder
rounder
0.1
{}
if( xtype==etFLOAT ) realvalue += rounder;
xtype==etFLOAT
xtype
xtype
etFLOAT
etFLOAT
realvalue += rounder;
realvalue += rounder
realvalue
realvalue
rounder
rounder
exp = 0;
exp = 0
exp
exp
0
if( sqlite3IsNaN((double)realvalue) ){          bufpt = "NaN";          length = 3;          break;        }
sqlite3IsNaN((double)realvalue)
sqlite3IsNaN
sqlite3IsNaN
(double)realvalue
double
double

realvalue
realvalue
{          bufpt = "NaN";          length = 3;          break;        }
bufpt = "NaN";
bufpt = "NaN"
bufpt
bufpt
"NaN"
length = 3;
length = 3
length
length
3
break;
if( realvalue>0.0 ){          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }
realvalue>0.0
realvalue
realvalue
0.0
{          LONGDOUBLE_TYPE scale = 1.0;          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }          realvalue /= scale;          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }          if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }        }
LONGDOUBLE_TYPE scale = 1.0;
LONGDOUBLE_TYPE scale = 1.0;
LONGDOUBLE_TYPE
LONGDOUBLE_TYPE
scale = 1.0
scale
= 1.0
1.0
while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}
realvalue>=1e100*scale && exp<=350
realvalue>=1e100*scale
realvalue
realvalue
1e100*scale
1e100
scale
scale
exp<=350
exp
exp
350
{ scale *= 1e100;exp+=100;}
scale *= 1e100;
scale *= 1e100
scale
scale
1e100
exp+=100;
exp+=100
exp
exp
100
while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }
realvalue>=1e64*scale && exp<=350
realvalue>=1e64*scale
realvalue
realvalue
1e64*scale
1e64
scale
scale
exp<=350
exp
exp
350
{ scale *= 1e64; exp+=64; }
scale *= 1e64;
scale *= 1e64
scale
scale
1e64
exp+=64;
exp+=64
exp
exp
64
while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }
realvalue>=1e8*scale && exp<=350
realvalue>=1e8*scale
realvalue
realvalue
1e8*scale
1e8
scale
scale
exp<=350
exp
exp
350
{ scale *= 1e8; exp+=8; }
scale *= 1e8;
scale *= 1e8
scale
scale
1e8
exp+=8;
exp+=8
exp
exp
8
while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }
realvalue>=10.0*scale && exp<=350
realvalue>=10.0*scale
realvalue
realvalue
10.0*scale
10.0
scale
scale
exp<=350
exp
exp
350
{ scale *= 10.0; exp++; }
scale *= 10.0;
scale *= 10.0
scale
scale
10.0
exp++;
exp++
exp
exp
realvalue /= scale;
realvalue /= scale
realvalue
realvalue
scale
scale
while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }
realvalue<1e-8
realvalue
realvalue
1e-8
{ realvalue *= 1e8; exp-=8; }
realvalue *= 1e8;
realvalue *= 1e8
realvalue
realvalue
1e8
exp-=8;
exp-=8
exp
exp
8
while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }
realvalue<1.0
realvalue
realvalue
1.0
{ realvalue *= 10.0; exp--; }
realvalue *= 10.0;
realvalue *= 10.0
realvalue
realvalue
10.0
exp--;
exp--
exp
exp
if( exp>350 ){            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }
exp>350
exp
exp
350
{            if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }            length = sqlite3Strlen30(bufpt);            break;          }
if( prefix=='-' ){              bufpt = "-Inf";            }else if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }
prefix=='-'
prefix
prefix
'-'
{              bufpt = "-Inf";            }
bufpt = "-Inf";
bufpt = "-Inf"
bufpt
bufpt
"-Inf"
if( prefix=='+' ){              bufpt = "+Inf";            }else{              bufpt = "Inf";            }
prefix=='+'
prefix
prefix
'+'
{              bufpt = "+Inf";            }
bufpt = "+Inf";
bufpt = "+Inf"
bufpt
bufpt
"+Inf"
{              bufpt = "Inf";            }
bufpt = "Inf";
bufpt = "Inf"
bufpt
bufpt
"Inf"
length = sqlite3Strlen30(bufpt);
length = sqlite3Strlen30(bufpt)
length
length
sqlite3Strlen30(bufpt)
sqlite3Strlen30
sqlite3Strlen30
bufpt
bufpt
break;
bufpt = buf;
bufpt = buf
bufpt
bufpt
buf
buf
if( xtype!=etFLOAT ){          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }
xtype!=etFLOAT
xtype
xtype
etFLOAT
etFLOAT
{          realvalue += rounder;          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }        }
realvalue += rounder;
realvalue += rounder
realvalue
realvalue
rounder
rounder
if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }
realvalue>=10.0
realvalue
realvalue
10.0
{ realvalue *= 0.1; exp++; }
realvalue *= 0.1;
realvalue *= 0.1
realvalue
realvalue
0.1
exp++;
exp++
exp
exp
if( xtype==etGENERIC ){          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }else{          flag_rtz = flag_altform2;        }
xtype==etGENERIC
xtype
xtype
etGENERIC
etGENERIC
{          flag_rtz = !flag_alternateform;          if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }        }
flag_rtz = !flag_alternateform;
flag_rtz = !flag_alternateform
flag_rtz
flag_rtz
!flag_alternateform
flag_alternateform
flag_alternateform
if( exp<-4 || exp>precision ){            xtype = etEXP;          }else{            precision = precision - exp;            xtype = etFLOAT;          }
exp<-4 || exp>precision
exp<-4
exp
exp
-4
4
exp>precision
exp
exp
precision
precision
{            xtype = etEXP;          }
xtype = etEXP;
xtype = etEXP
xtype
xtype
etEXP
etEXP
{            precision = precision - exp;            xtype = etFLOAT;          }
precision = precision - exp;
precision = precision - exp
precision
precision
precision - exp
precision
precision
exp
exp
xtype = etFLOAT;
xtype = etFLOAT
xtype
xtype
etFLOAT
etFLOAT
{          flag_rtz = flag_altform2;        }
flag_rtz = flag_altform2;
flag_rtz = flag_altform2
flag_rtz
flag_rtz
flag_altform2
flag_altform2
if( xtype==etEXP ){          e2 = 0;        }else{          e2 = exp;        }
xtype==etEXP
xtype
xtype
etEXP
etEXP
{          e2 = 0;        }
e2 = 0;
e2 = 0
e2
e2
0
{          e2 = exp;        }
e2 = exp;
e2 = exp
e2
e2
exp
exp
if( MAX(e2,0)+precision+width > etBUFSIZE - 15 ){          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }
MAX(e2,0)+precision+width > etBUFSIZE - 15
MAX(e2,0)+precision+width
MAX(e2,0)+precision
MAX(e2,0)
MAX
MAX
e2
e2
0
precision
precision
width
width
etBUFSIZE - 15
etBUFSIZE
etBUFSIZE
15
{          bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );          if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }        }
bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 );
bufpt = zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 )
bufpt
bufpt
zExtra = sqlite3Malloc( MAX(e2,0)+precision+width+15 )
zExtra
zExtra
sqlite3Malloc( MAX(e2,0)+precision+width+15 )
sqlite3Malloc
sqlite3Malloc
MAX(e2,0)+precision+width+15
MAX(e2,0)+precision+width
MAX(e2,0)+precision
MAX(e2,0)
MAX
MAX
e2
e2
0
precision
precision
width
width
15
if( bufpt==0 ){            pAccum->accError = STRACCUM_NOMEM;            return;          }
bufpt==0
bufpt
bufpt
0
{            pAccum->accError = STRACCUM_NOMEM;            return;          }
pAccum->accError = STRACCUM_NOMEM;
pAccum->accError = STRACCUM_NOMEM
pAccum->accError
pAccum
pAccum
accError
STRACCUM_NOMEM
STRACCUM_NOMEM
return;
zOut = bufpt;
zOut = bufpt
zOut
zOut
bufpt
bufpt
nsd = 16 + flag_altform2*10;
nsd = 16 + flag_altform2*10
nsd
nsd
16 + flag_altform2*10
16
flag_altform2*10
flag_altform2
flag_altform2
10
flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;
flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2
flag_dp
flag_dp
(precision>0 ?1:0) | flag_alternateform | flag_altform2
(precision>0 ?1:0) | flag_alternateform
(precision>0 ?1:0)
precision>0 ?1:0
precision>0
precision
precision
0
1
0
flag_alternateform
flag_alternateform
flag_altform2
flag_altform2
if( prefix ){          *(bufpt++) = prefix;        }
prefix
prefix
{          *(bufpt++) = prefix;        }
*(bufpt++) = prefix;
*(bufpt++) = prefix
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
prefix
prefix
if( e2<0 ){          *(bufpt++) = '0';        }else{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }
e2<0
e2
e2
0
{          *(bufpt++) = '0';        }
*(bufpt++) = '0';
*(bufpt++) = '0'
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
'0'
{          for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }        }
for(; e2>=0; e2--){            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }
;
e2>=0
e2
e2
0
e2--
e2
e2
{            *(bufpt++) = et_getdigit(&realvalue,&nsd);          }
*(bufpt++) = et_getdigit(&realvalue,&nsd);
*(bufpt++) = et_getdigit(&realvalue,&nsd)
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
et_getdigit(&realvalue,&nsd)
et_getdigit
et_getdigit
&realvalue
realvalue
realvalue
&nsd
nsd
nsd
if( flag_dp ){          *(bufpt++) = '.';        }
flag_dp
flag_dp
{          *(bufpt++) = '.';        }
*(bufpt++) = '.';
*(bufpt++) = '.'
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
'.'
for(e2++; e2<0; precision--, e2++){          assert( precision>0 );          *(bufpt++) = '0';        }
e2++;
e2++
e2
e2
e2<0
e2
e2
0
precision--, e2++
precision--
precision
precision
e2++
e2
e2
{          assert( precision>0 );          *(bufpt++) = '0';        }
assert( precision>0 );
assert( precision>0 )
assert
assert
precision>0
precision
precision
0
*(bufpt++) = '0';
*(bufpt++) = '0'
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
'0'
while( (precision--)>0 ){          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }
(precision--)>0
(precision--)
precision--
precision
precision
0
{          *(bufpt++) = et_getdigit(&realvalue,&nsd);        }
*(bufpt++) = et_getdigit(&realvalue,&nsd);
*(bufpt++) = et_getdigit(&realvalue,&nsd)
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
et_getdigit(&realvalue,&nsd)
et_getdigit
et_getdigit
&realvalue
realvalue
realvalue
&nsd
nsd
nsd
if( flag_rtz && flag_dp ){          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }
flag_rtz && flag_dp
flag_rtz
flag_rtz
flag_dp
flag_dp
{          while( bufpt[-1]=='0' ) *(--bufpt) = 0;          assert( bufpt>zOut );          if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }        }
while( bufpt[-1]=='0' ) *(--bufpt) = 0;
bufpt[-1]=='0'
bufpt[-1]
bufpt
bufpt
-1
1
'0'
*(--bufpt) = 0;
*(--bufpt) = 0
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
0
assert( bufpt>zOut );
assert( bufpt>zOut )
assert
assert
bufpt>zOut
bufpt
bufpt
zOut
zOut
if( bufpt[-1]=='.' ){            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }
bufpt[-1]=='.'
bufpt[-1]
bufpt
bufpt
-1
1
'.'
{            if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }          }
if( flag_altform2 ){              *(bufpt++) = '0';            }else{              *(--bufpt) = 0;            }
flag_altform2
flag_altform2
{              *(bufpt++) = '0';            }
*(bufpt++) = '0';
*(bufpt++) = '0'
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
'0'
{              *(--bufpt) = 0;            }
*(--bufpt) = 0;
*(--bufpt) = 0
*(--bufpt)
(--bufpt)
--bufpt
bufpt
bufpt
0
if( xtype==etEXP ){          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }
xtype==etEXP
xtype
xtype
etEXP
etEXP
{          *(bufpt++) = aDigits[infop->charset];          if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }          if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */        }
*(bufpt++) = aDigits[infop->charset];
*(bufpt++) = aDigits[infop->charset]
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
aDigits[infop->charset]
aDigits
aDigits
infop->charset
infop
infop
charset
if( exp<0 ){            *(bufpt++) = '-'; exp = -exp;          }else{            *(bufpt++) = '+';          }
exp<0
exp
exp
0
{            *(bufpt++) = '-'; exp = -exp;          }
*(bufpt++) = '-';
*(bufpt++) = '-'
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
'-'
exp = -exp;
exp = -exp
exp
exp
-exp
exp
exp
{            *(bufpt++) = '+';          }
*(bufpt++) = '+';
*(bufpt++) = '+'
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
'+'
if( exp>=100 ){            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }
exp>=100
exp
exp
100
{            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */            exp %= 100;          }
*(bufpt++) = (char)((exp/100)+'0');
*(bufpt++) = (char)((exp/100)+'0')
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
(char)((exp/100)+'0')
char
char

((exp/100)+'0')
(exp/100)+'0'
(exp/100)
exp/100
exp
exp
100
'0'
exp %= 100;
exp %= 100
exp
exp
100
*(bufpt++) = (char)(exp/10+'0');
*(bufpt++) = (char)(exp/10+'0')
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
(char)(exp/10+'0')
char
char

(exp/10+'0')
exp/10+'0'
exp/10
exp
exp
10
'0'
*(bufpt++) = (char)(exp%10+'0');
*(bufpt++) = (char)(exp%10+'0')
*(bufpt++)
(bufpt++)
bufpt++
bufpt
bufpt
(char)(exp%10+'0')
char
char

(exp%10+'0')
exp%10+'0'
exp%10
exp
exp
10
'0'
*bufpt = 0;
*bufpt = 0
*bufpt
bufpt
bufpt
0
length = (int)(bufpt-zOut);
length = (int)(bufpt-zOut)
length
length
(int)(bufpt-zOut)
int
int

(bufpt-zOut)
bufpt-zOut
bufpt
bufpt
zOut
zOut
bufpt = zOut;
bufpt = zOut
bufpt
bufpt
zOut
zOut
if( flag_zeropad && !flag_leftjustify && length < width){          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }
flag_zeropad && !flag_leftjustify && length < width
flag_zeropad && !flag_leftjustify
flag_zeropad
flag_zeropad
!flag_leftjustify
flag_leftjustify
flag_leftjustify
length < width
length
length
width
width
{          int i;          int nPad = width - length;          for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }          i = prefix!=0;          while( nPad-- ) bufpt[i++] = '0';          length = width;        }
int i;
int i;
int
i
i
int nPad = width - length;
int nPad = width - length;
int
nPad = width - length
nPad
= width - length
width - length
width
width
length
length
for(i=width; i>=nPad; i--){            bufpt[i] = bufpt[i-nPad];          }
i=width;
i=width
i
i
width
width
i>=nPad
i
i
nPad
nPad
i--
i
i
{            bufpt[i] = bufpt[i-nPad];          }
bufpt[i] = bufpt[i-nPad];
bufpt[i] = bufpt[i-nPad]
bufpt[i]
bufpt
bufpt
i
i
bufpt[i-nPad]
bufpt
bufpt
i-nPad
i
i
nPad
nPad
i = prefix!=0;
i = prefix!=0
i
i
prefix!=0
prefix
prefix
0
while( nPad-- ) bufpt[i++] = '0';
nPad--
nPad
nPad
bufpt[i++] = '0';
bufpt[i++] = '0'
bufpt[i++]
bufpt
bufpt
i++
i
i
'0'
length = width;
length = width
length
length
width
width
break;
case etSIZE:
etSIZE
etSIZE
printf("*(va_arg(ap,int*)) = pAccum->nChar;\n");
printf("*(va_arg(ap,int*)) = pAccum->nChar;\n")
printf
printf
"*(va_arg(ap,int*)) = pAccum->nChar;\n"
*(va_arg(ap,int*)) = pAccum->nChar;
printf("length = width = 0;\n");
printf("length = width = 0;\n")
printf
printf
"length = width = 0;\n"
length = width = 0;
length = width = 0
length
length
width = 0
width
width
0
break;
case etPERCENT:
etPERCENT
etPERCENT
printf("buf[0] = '_';\n");
printf("buf[0] = '_';\n")
printf
printf
"buf[0] = '_';\n"
buf[0] = '%';
buf[0] = '%'
buf[0]
buf
buf
0
'%'
printf("bufpt = buf;\n");
printf("bufpt = buf;\n")
printf
printf
"bufpt = buf;\n"
bufpt = buf;
bufpt = buf
bufpt
bufpt
buf
buf
printf("length = 1;\n");
printf("length = 1;\n")
printf
printf
"length = 1;\n"
length = 1;
length = 1
length
length
1
break;
case etCHARX:
etCHARX
etCHARX
printf("c = va_arg(ap,int);\n");
printf("c = va_arg(ap,int);\n")
printf
printf
"c = va_arg(ap,int);\n"
c = va_arg(ap,int);
printf("buf[0] = (char)c;\n");
printf("buf[0] = (char)c;\n")
printf
printf
"buf[0] = (char)c;\n"
buf[0] = (char)c;
buf[0] = (char)c
buf[0]
buf
buf
0
(char)c
char
char

c
c
if( precision>=0 ){printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }else{          printf("length =1;\n");length =1;        }
precision>=0
precision
precision
0
{printf("if(precision>=0)\n");                  for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}          printf("length = precision;\n");length = precision;        }
printf("if(precision>=0)\n");
printf("if(precision>=0)\n")
printf
printf
"if(precision>=0)\n"
for(idx=1; idx<precision; idx++) {printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}
idx=1;
idx=1
idx
idx
1
idx<precision
idx
idx
precision
precision
idx++
idx
idx
{printf("for(idx=1;idx<precision;idx++)\n");          printf("buf[idx] = (char)c;\n");buf[idx] = (char)c;}
printf("for(idx=1;idx<precision;idx++)\n");
printf("for(idx=1;idx<precision;idx++)\n")
printf
printf
"for(idx=1;idx<precision;idx++)\n"
printf("buf[idx] = (char)c;\n");
printf("buf[idx] = (char)c;\n")
printf
printf
"buf[idx] = (char)c;\n"
buf[idx] = (char)c;
buf[idx] = (char)c
buf[idx]
buf
buf
idx
idx
(char)c
char
char

c
c
printf("length = precision;\n");
printf("length = precision;\n")
printf
printf
"length = precision;\n"
length = precision;
length = precision
length
length
precision
precision
{          printf("length =1;\n");length =1;        }
printf("length =1;\n");
printf("length =1;\n")
printf
printf
"length =1;\n"
length =1;
length =1
length
length
1
printf("bufpt = buf;\n");
printf("bufpt = buf;\n")
printf
printf
"bufpt = buf;\n"
bufpt = buf;
bufpt = buf
bufpt
bufpt
buf
buf
break;
case etSTRING:
etSTRING
etSTRING
case etDYNSTRING:
etDYNSTRING
etDYNSTRING
printf("bufpt = va_arg(ap,char*);\n");
printf("bufpt = va_arg(ap,char*);\n")
printf
printf
"bufpt = va_arg(ap,char*);\n"
bufpt = va_arg(ap,char*);
if( bufpt==0 ){printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }else if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }
bufpt==0
bufpt
bufpt
0
{printf("if(bufpt==0)\n");                  printf("bufpt = '';\n");bufpt = "";        }
printf("if(bufpt==0)\n");
printf("if(bufpt==0)\n")
printf
printf
"if(bufpt==0)\n"
printf("bufpt = '';\n");
printf("bufpt = '';\n")
printf
printf
"bufpt = '';\n"
bufpt = "";
bufpt = ""
bufpt
bufpt
""
if( xtype==etDYNSTRING ){printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }
xtype==etDYNSTRING
xtype
xtype
etDYNSTRING
etDYNSTRING
{printf("if(xtype==etDYNSTRING)\n");                  printf("zExtra = bufpt;\n");zExtra = bufpt;        }
printf("if(xtype==etDYNSTRING)\n");
printf("if(xtype==etDYNSTRING)\n")
printf
printf
"if(xtype==etDYNSTRING)\n"
printf("zExtra = bufpt;\n");
printf("zExtra = bufpt;\n")
printf
printf
"zExtra = bufpt;\n"
zExtra = bufpt;
zExtra = bufpt
zExtra
zExtra
bufpt
bufpt
if( precision>=0 ){printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }else{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }
precision>=0
precision
precision
0
{printf("if(precision>=0)\n");                  for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }        }
printf("if(precision>=0)\n");
printf("if(precision>=0)\n")
printf
printf
"if(precision>=0)\n"
for(length=0; length<precision && bufpt[length]; length++){printf("for(length=0;length<precision && bufpt[length];length++)\n");          }
length=0;
length=0
length
length
0
length<precision && bufpt[length]
length<precision
length
length
precision
precision
bufpt[length]
bufpt
bufpt
length
length
length++
length
length
{printf("for(length=0;length<precision && bufpt[length];length++)\n");          }
printf("for(length=0;length<precision && bufpt[length];length++)\n");
printf("for(length=0;length<precision && bufpt[length];length++)\n")
printf
printf
"for(length=0;length<precision && bufpt[length];length++)\n"
{          printf("length = sqlite3Strlen30(bufpt);\n");length = sqlite3Strlen30(bufpt);        }
printf("length = sqlite3Strlen30(bufpt);\n");
printf("length = sqlite3Strlen30(bufpt);\n")
printf
printf
"length = sqlite3Strlen30(bufpt);\n"
length = sqlite3Strlen30(bufpt);
length = sqlite3Strlen30(bufpt)
length
length
sqlite3Strlen30(bufpt)
sqlite3Strlen30
sqlite3Strlen30
bufpt
bufpt
break;
case etSQLESCAPE:
etSQLESCAPE
etSQLESCAPE
case etSQLESCAPE2:
etSQLESCAPE2
etSQLESCAPE2
case etSQLESCAPE3:
etSQLESCAPE3
etSQLESCAPE3
{        printf("int i, j, k, n, isnull;\n");        int i, j, k, n, isnull;        printf("int needQuote;\n");        int needQuote;        printf("char ch;\n");        char ch;        printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */        printf("char *escarg = va_arg(ap,char*);\n");        char *escarg = va_arg(ap,char*);        printf("isnull = escarg==0;\n");isnull = escarg==0;        if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}        printf("k = precision;\n");k = precision;        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }        printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");needQuote = !isnull && xtype==etSQLESCAPE2;        printf("n += i + 1 + needQuote*2;\n");n += i + 1 + needQuote*2;        if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }        printf("j = 0;\n");j = 0;        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("k = i;\n");k = i;        for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }        if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}        printf("bufpt[j] = 0;\n");bufpt[j] = 0;        printf("length = j;\n");length = j;        /* The precision in %q and %Q means how many input characters to        ** consume, not the length of the output...        ** if( precision>=0 && precision<length ) length = precision; */        break;      }
printf("int i, j, k, n, isnull;\n");
printf("int i, j, k, n, isnull;\n")
printf
printf
"int i, j, k, n, isnull;\n"
int i, j, k, n, isnull;
int i, j, k, n, isnull;
int
i
i
j
j
k
k
n
n
isnull
isnull
printf("int needQuote;\n");
printf("int needQuote;\n")
printf
printf
"int needQuote;\n"
int needQuote;
int needQuote;
int
needQuote
needQuote
printf("char ch;\n");
printf("char ch;\n")
printf
printf
"char ch;\n"
char ch;
char ch;
char
ch
ch
printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n");
printf("char q = ((xtype==etSQLESCAPE3)?''':'\'');\n")
printf
printf
"char q = ((xtype==etSQLESCAPE3)?''':'\'');\n"
char q = ((xtype==etSQLESCAPE3)?'"':'\'');
char q = ((xtype==etSQLESCAPE3)?'"':'\'');
char
q = ((xtype==etSQLESCAPE3)?'"':'\'')
q
= ((xtype==etSQLESCAPE3)?'"':'\'')
((xtype==etSQLESCAPE3)?'"':'\'')
(xtype==etSQLESCAPE3)?'"':'\''
(xtype==etSQLESCAPE3)
xtype==etSQLESCAPE3
xtype
xtype
etSQLESCAPE3
etSQLESCAPE3
'"'
'\''
printf("char *escarg = va_arg(ap,char*);\n");
printf("char *escarg = va_arg(ap,char*);\n")
printf
printf
"char *escarg = va_arg(ap,char*);\n"
char *escarg = va_arg(ap,char*);
printf("isnull = escarg==0;\n");
printf("isnull = escarg==0;\n")
printf
printf
"isnull = escarg==0;\n"
isnull = escarg==0;
isnull = escarg==0
isnull
isnull
escarg==0
escarg
escarg
0
if( isnull ) {printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}
isnull
isnull
{printf("if(isnull)\n");        printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");}
printf("if(isnull)\n");
printf("if(isnull)\n")
printf
printf
"if(isnull)\n"
printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n");
printf("escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n")
printf
printf
"escarg = (xtype==etSQLESCAPE2 ? 'NULL' : '(NULL)');\n"
escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");
escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)")
escarg
escarg
(xtype==etSQLESCAPE2 ? "NULL" : "(NULL)")
xtype==etSQLESCAPE2 ? "NULL" : "(NULL)"
xtype==etSQLESCAPE2
xtype
xtype
etSQLESCAPE2
etSQLESCAPE2
"NULL"
"(NULL)"
printf("k = precision;\n");
printf("k = precision;\n")
printf
printf
"k = precision;\n"
k = precision;
k = precision
k
k
precision
precision
for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }
i=n=0;
i=n=0
i
i
n=0
n
n
0
k!=0 && (ch=escarg[i])!=0
k!=0
k
k
0
(ch=escarg[i])!=0
(ch=escarg[i])
ch=escarg[i]
ch
ch
escarg[i]
escarg
escarg
i
i
0
i++, k--
i++
i
i
k--
k
k
{printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");                  if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}        }
printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n");
printf("for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n")
printf
printf
"for(i=n=0;k!=0 && (ch=escarg[i])!=0;i++, k--)\n"
if( ch==q )  {printf("if(ch==q)\n");          printf("n++;\n");n++;}
ch==q
ch
ch
q
q
{printf("if(ch==q)\n");          printf("n++;\n");n++;}
printf("if(ch==q)\n");
printf("if(ch==q)\n")
printf
printf
"if(ch==q)\n"
printf("n++;\n");
printf("n++;\n")
printf
printf
"n++;\n"
n++;
n++
n
n
printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n");
printf("needQuote = !isnull && xtype==etSQLESCAPE2;\n")
printf
printf
"needQuote = !isnull && xtype==etSQLESCAPE2;\n"
needQuote = !isnull && xtype==etSQLESCAPE2;
needQuote = !isnull && xtype==etSQLESCAPE2
needQuote
needQuote
!isnull && xtype==etSQLESCAPE2
!isnull
isnull
isnull
xtype==etSQLESCAPE2
xtype
xtype
etSQLESCAPE2
etSQLESCAPE2
printf("n += i + 1 + needQuote*2;\n");
printf("n += i + 1 + needQuote*2;\n")
printf
printf
"n += i + 1 + needQuote*2;\n"
n += i + 1 + needQuote*2;
n += i + 1 + needQuote*2
n
n
i + 1 + needQuote*2
i + 1
i
i
1
needQuote*2
needQuote
needQuote
2
if( n>etBUFSIZE ){printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }else{          printf("bufpt = buf;\n");bufpt = buf;        }
n>etBUFSIZE
n
n
etBUFSIZE
etBUFSIZE
{printf("if(n>etBUFSIZE)\n");                  printf("bufpt = zExtra = sqlite3Malloc( n );\n");bufpt = zExtra = sqlite3Malloc( n );          if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }        }
printf("if(n>etBUFSIZE)\n");
printf("if(n>etBUFSIZE)\n")
printf
printf
"if(n>etBUFSIZE)\n"
printf("bufpt = zExtra = sqlite3Malloc( n );\n");
printf("bufpt = zExtra = sqlite3Malloc( n );\n")
printf
printf
"bufpt = zExtra = sqlite3Malloc( n );\n"
bufpt = zExtra = sqlite3Malloc( n );
bufpt = zExtra = sqlite3Malloc( n )
bufpt
bufpt
zExtra = sqlite3Malloc( n )
zExtra
zExtra
sqlite3Malloc( n )
sqlite3Malloc
sqlite3Malloc
n
n
if( bufpt==0 ){printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }
bufpt==0
bufpt
bufpt
0
{printf("if(bufpt==0)\n");                      printf("pAccum->accError = STRACCUM_NOMEM;\n");pAccum->accError = STRACCUM_NOMEM;            printf("return;\n");            printf("------function end!------\n");            return;          }
printf("if(bufpt==0)\n");
printf("if(bufpt==0)\n")
printf
printf
"if(bufpt==0)\n"
printf("pAccum->accError = STRACCUM_NOMEM;\n");
printf("pAccum->accError = STRACCUM_NOMEM;\n")
printf
printf
"pAccum->accError = STRACCUM_NOMEM;\n"
pAccum->accError = STRACCUM_NOMEM;
pAccum->accError = STRACCUM_NOMEM
pAccum->accError
pAccum
pAccum
accError
STRACCUM_NOMEM
STRACCUM_NOMEM
printf("return;\n");
printf("return;\n")
printf
printf
"return;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return;
{          printf("bufpt = buf;\n");bufpt = buf;        }
printf("bufpt = buf;\n");
printf("bufpt = buf;\n")
printf
printf
"bufpt = buf;\n"
bufpt = buf;
bufpt = buf
bufpt
bufpt
buf
buf
printf("j = 0;\n");
printf("j = 0;\n")
printf
printf
"j = 0;\n"
j = 0;
j = 0
j
j
0
if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}
needQuote
needQuote
{printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}
printf("if(needQuote)\n");
printf("if(needQuote)\n")
printf
printf
"if(needQuote)\n"
printf("bufpt[j++] = q;\n");
printf("bufpt[j++] = q;\n")
printf
printf
"bufpt[j++] = q;\n"
bufpt[j++] = q;
bufpt[j++] = q
bufpt[j++]
bufpt
bufpt
j++
j
j
q
q
printf("k = i;\n");
printf("k = i;\n")
printf
printf
"k = i;\n"
k = i;
k = i
k
k
i
i
for(i=0; i<k; i++){printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }
i=0;
i=0
i
i
0
i<k
i
i
k
k
i++
i
i
{printf("for(i=0;i<k;i++)\n");                  printf("bufpt[j++] = ch = escarg[i];\n");bufpt[j++] = ch = escarg[i];          if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}        }
printf("for(i=0;i<k;i++)\n");
printf("for(i=0;i<k;i++)\n")
printf
printf
"for(i=0;i<k;i++)\n"
printf("bufpt[j++] = ch = escarg[i];\n");
printf("bufpt[j++] = ch = escarg[i];\n")
printf
printf
"bufpt[j++] = ch = escarg[i];\n"
bufpt[j++] = ch = escarg[i];
bufpt[j++] = ch = escarg[i]
bufpt[j++]
bufpt
bufpt
j++
j
j
ch = escarg[i]
ch
ch
escarg[i]
escarg
escarg
i
i
if( ch==q ) {printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}
ch==q
ch
ch
q
q
{printf("if(ch==q)\n");          printf("bufpt[j++] = ch;\n");bufpt[j++] = ch;}
printf("if(ch==q)\n");
printf("if(ch==q)\n")
printf
printf
"if(ch==q)\n"
printf("bufpt[j++] = ch;\n");
printf("bufpt[j++] = ch;\n")
printf
printf
"bufpt[j++] = ch;\n"
bufpt[j++] = ch;
bufpt[j++] = ch
bufpt[j++]
bufpt
bufpt
j++
j
j
ch
ch
if( needQuote ) {printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}
needQuote
needQuote
{printf("if(needQuote)\n");        printf("bufpt[j++] = q;\n");bufpt[j++] = q;}
printf("if(needQuote)\n");
printf("if(needQuote)\n")
printf
printf
"if(needQuote)\n"
printf("bufpt[j++] = q;\n");
printf("bufpt[j++] = q;\n")
printf
printf
"bufpt[j++] = q;\n"
bufpt[j++] = q;
bufpt[j++] = q
bufpt[j++]
bufpt
bufpt
j++
j
j
q
q
printf("bufpt[j] = 0;\n");
printf("bufpt[j] = 0;\n")
printf
printf
"bufpt[j] = 0;\n"
bufpt[j] = 0;
bufpt[j] = 0
bufpt[j]
bufpt
bufpt
j
j
0
printf("length = j;\n");
printf("length = j;\n")
printf
printf
"length = j;\n"
length = j;
length = j
length
length
j
j
break;
case etTOKEN:
etTOKEN
etTOKEN
{        printf("Token *pToken = va_arg(ap, Token*);\n");        Token *pToken = va_arg(ap, Token*);        if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }        printf("length = width = 0;\n");length = width = 0;        break;      }
printf("Token *pToken = va_arg(ap, Token*);\n");
printf("Token *pToken = va_arg(ap, Token*);\n")
printf
printf
"Token *pToken = va_arg(ap, Token*);\n"
Token *pToken = va_arg(ap, Token*);
if( pToken ){printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }
pToken
pToken
{printf("if(pToken)\n");                  printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);        }
printf("if(pToken)\n");
printf("if(pToken)\n")
printf
printf
"if(pToken)\n"
printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n");
printf("sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n"
sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);
sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
(const char*)pToken->z
const char*
const char
*
*
pToken->z
pToken
pToken
z
pToken->n
pToken
pToken
n
printf("length = width = 0;\n");
printf("length = width = 0;\n")
printf
printf
"length = width = 0;\n"
length = width = 0;
length = width = 0
length
length
width = 0
width
width
0
break;
case etSRCLIST:
etSRCLIST
etSRCLIST
{        printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");        SrcList *pSrc = va_arg(ap, SrcList*);        printf("int k = va_arg(ap, int);\n");        int k = va_arg(ap, int);        printf("struct SrcList_item *pItem = &pSrc->a[k];\n");        struct SrcList_item *pItem = &pSrc->a[k];        printf("assert( k>=0 && k<pSrc->nSrc );\n");        assert( k>=0 && k<pSrc->nSrc );        if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }        printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);        printf("length = width = 0;\n");length = width = 0;        break;      }
printf("SrcList *pSrc = va_arg(ap, SrcList*);\n");
printf("SrcList *pSrc = va_arg(ap, SrcList*);\n")
printf
printf
"SrcList *pSrc = va_arg(ap, SrcList*);\n"
SrcList *pSrc = va_arg(ap, SrcList*);
printf("int k = va_arg(ap, int);\n");
printf("int k = va_arg(ap, int);\n")
printf
printf
"int k = va_arg(ap, int);\n"
int k = va_arg(ap, int);
printf("struct SrcList_item *pItem = &pSrc->a[k];\n");
printf("struct SrcList_item *pItem = &pSrc->a[k];\n")
printf
printf
"struct SrcList_item *pItem = &pSrc->a[k];\n"
struct SrcList_item *pItem = &pSrc->a[k];
struct SrcList_item *pItem = &pSrc->a[k];
struct SrcList_item
SrcList_item
*pItem = &pSrc->a[k]
*
pItem
= &pSrc->a[k]
&pSrc->a[k]
pSrc->a[k]
pSrc->a
pSrc
pSrc
a
k
k
printf("assert( k>=0 && k<pSrc->nSrc );\n");
printf("assert( k>=0 && k<pSrc->nSrc );\n")
printf
printf
"assert( k>=0 && k<pSrc->nSrc );\n"
assert( k>=0 && k<pSrc->nSrc );
assert( k>=0 && k<pSrc->nSrc )
assert
assert
k>=0 && k<pSrc->nSrc
k>=0
k
k
0
k<pSrc->nSrc
k
k
pSrc->nSrc
pSrc
pSrc
nSrc
if( pItem->zDatabase ){printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }
pItem->zDatabase
pItem
pItem
zDatabase
{printf("if(pItem->zDatabase)\n");                  printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);          printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");          sqlite3StrAccumAppend(pAccum, ".", 1);        }
printf("if(pItem->zDatabase)\n");
printf("if(pItem->zDatabase)\n")
printf
printf
"if(pItem->zDatabase)\n"
printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n");
printf("sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n"
sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);
sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
pItem->zDatabase
pItem
pItem
zDatabase
-1
1
printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n");
printf("sqlite3StrAccumAppend(pAccum, '.', 1);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, '.', 1);\n"
sqlite3StrAccumAppend(pAccum, ".", 1);
sqlite3StrAccumAppend(pAccum, ".", 1)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
"."
1
printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n");
printf("sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n"
sqlite3StrAccumAppend(pAccum, pItem->zName, -1);
sqlite3StrAccumAppend(pAccum, pItem->zName, -1)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
pItem->zName
pItem
pItem
zName
-1
1
printf("length = width = 0;\n");
printf("length = width = 0;\n")
printf
printf
"length = width = 0;\n"
length = width = 0;
length = width = 0
length
length
width = 0
width
width
0
break;
default:
{        printf("assert( xtype==etINVALID );\n");        assert( xtype==etINVALID );        printf("return;\n");        printf("------function end!------\n");        return;      }
printf("assert( xtype==etINVALID );\n");
printf("assert( xtype==etINVALID );\n")
printf
printf
"assert( xtype==etINVALID );\n"
assert( xtype==etINVALID );
assert( xtype==etINVALID )
assert
assert
xtype==etINVALID
xtype
xtype
etINVALID
etINVALID
printf("return;\n");
printf("return;\n")
printf
printf
"return;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return;
if( !flag_leftjustify ){printf("if(!flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }
!flag_leftjustify
flag_leftjustify
flag_leftjustify
{printf("if(!flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }
printf("if(!flag_leftjustify)\n");
printf("if(!flag_leftjustify)\n")
printf
printf
"if(!flag_leftjustify)\n"
printf("register int nspace;\n");
printf("register int nspace;\n")
printf
printf
"register int nspace;\n"
register int nspace;
register int nspace;
register int
nspace
nspace
printf("nspace = width-length;\n");
printf("nspace = width-length;\n")
printf
printf
"nspace = width-length;\n"
nspace = width-length;
nspace = width-length
nspace
nspace
width-length
width
width
length
length
if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }
nspace>0
nspace
nspace
0
{printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }
printf("if(nspace>0)\n");
printf("if(nspace>0)\n")
printf
printf
"if(nspace>0)\n"
printf("sqlite3AppendSpace(pAccum, nspace);\n");
printf("sqlite3AppendSpace(pAccum, nspace);\n")
printf
printf
"sqlite3AppendSpace(pAccum, nspace);\n"
sqlite3AppendSpace(pAccum, nspace);
sqlite3AppendSpace(pAccum, nspace)
sqlite3AppendSpace
sqlite3AppendSpace
pAccum
pAccum
nspace
nspace
if( length>0 ){printf("if(length>0)\n");          printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");      sqlite3StrAccumAppend(pAccum, bufpt, length);    }
length>0
length
length
0
{printf("if(length>0)\n");          printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");      sqlite3StrAccumAppend(pAccum, bufpt, length);    }
printf("if(length>0)\n");
printf("if(length>0)\n")
printf
printf
"if(length>0)\n"
printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n");
printf("sqlite3StrAccumAppend(pAccum, bufpt, length);\n")
printf
printf
"sqlite3StrAccumAppend(pAccum, bufpt, length);\n"
sqlite3StrAccumAppend(pAccum, bufpt, length);
sqlite3StrAccumAppend(pAccum, bufpt, length)
sqlite3StrAccumAppend
sqlite3StrAccumAppend
pAccum
pAccum
bufpt
bufpt
length
length
if( flag_leftjustify ){printf("if(flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }
flag_leftjustify
flag_leftjustify
{printf("if(flag_leftjustify)\n");          printf("register int nspace;\n");      register int nspace;      printf("nspace = width-length;\n");nspace = width-length;      if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }    }
printf("if(flag_leftjustify)\n");
printf("if(flag_leftjustify)\n")
printf
printf
"if(flag_leftjustify)\n"
printf("register int nspace;\n");
printf("register int nspace;\n")
printf
printf
"register int nspace;\n"
register int nspace;
register int nspace;
register int
nspace
nspace
printf("nspace = width-length;\n");
printf("nspace = width-length;\n")
printf
printf
"nspace = width-length;\n"
nspace = width-length;
nspace = width-length
nspace
nspace
width-length
width
width
length
length
if( nspace>0 ){printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }
nspace>0
nspace
nspace
0
{printf("if(nspace>0)\n");              printf("sqlite3AppendSpace(pAccum, nspace);\n");        sqlite3AppendSpace(pAccum, nspace);      }
printf("if(nspace>0)\n");
printf("if(nspace>0)\n")
printf
printf
"if(nspace>0)\n"
printf("sqlite3AppendSpace(pAccum, nspace);\n");
printf("sqlite3AppendSpace(pAccum, nspace);\n")
printf
printf
"sqlite3AppendSpace(pAccum, nspace);\n"
sqlite3AppendSpace(pAccum, nspace);
sqlite3AppendSpace(pAccum, nspace)
sqlite3AppendSpace
sqlite3AppendSpace
pAccum
pAccum
nspace
nspace
printf("sqlite3_free(zExtra);\n");
printf("sqlite3_free(zExtra);\n")
printf
printf
"sqlite3_free(zExtra);\n"
sqlite3_free(zExtra);
sqlite3_free(zExtra)
sqlite3_free
sqlite3_free
zExtra
zExtra
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
-----joern-----
(41,151,0)
(173,190,0)
(163,146,0)
(194,102,0)
(6,64,0)
(93,65,0)
(83,125,0)
(34,15,0)
(193,68,0)
(86,132,0)
(122,1,0)
(74,65,0)
(107,145,0)
(123,107,0)
(38,143,0)
(34,125,0)
(92,10,0)
(180,199,0)
(23,192,0)
(157,140,0)
(153,34,0)
(2,131,0)
(42,6,0)
(15,34,0)
(209,85,0)
(7,74,0)
(156,199,0)
(65,203,0)
(49,184,0)
(164,167,0)
(128,132,0)
(151,138,0)
(30,157,0)
(184,69,0)
(20,69,0)
(188,125,0)
(130,44,0)
(127,88,0)
(64,69,0)
(129,140,0)
(65,161,0)
(89,142,0)
(39,69,0)
(85,125,0)
(91,199,0)
(6,42,0)
(154,69,0)
(174,108,0)
(150,176,0)
(12,209,0)
(27,187,0)
(11,198,0)
(146,195,0)
(148,156,0)
(55,73,0)
(42,61,0)
(65,74,0)
(29,127,0)
(74,7,0)
(179,160,0)
(209,12,0)
(195,146,0)
(186,133,0)
(77,22,0)
(9,199,0)
(139,111,0)
(88,127,0)
(210,199,0)
(146,44,0)
(190,195,0)
(138,135,0)
(124,69,0)
(137,61,0)
(158,116,0)
(135,203,0)
(58,20,0)
(203,67,0)
(162,55,0)
(78,15,0)
(81,203,0)
(155,108,0)
(140,65,0)
(16,72,0)
(15,26,0)
(132,211,0)
(160,179,0)
(206,90,0)
(84,51,0)
(147,136,0)
(103,199,0)
(135,138,0)
(203,199,0)
(19,114,0)
(141,108,0)
(65,140,0)
(209,49,0)
(43,49,0)
(133,118,0)
(123,69,0)
(81,190,0)
(12,69,0)
(56,179,0)
(208,67,0)
(94,68,0)
(104,108,0)
(61,42,0)
(127,140,0)
(115,180,0)
(146,163,0)
(140,199,0)
(122,132,0)
(212,9,0)
(182,107,0)
(85,184,0)
(134,144,0)
(114,141,0)
(117,206,0)
(132,125,0)
(131,195,0)
(169,130,0)
(68,70,0)
(167,108,0)
(192,199,0)
(191,69,0)
(1,70,0)
(105,143,0)
(90,125,0)
(47,72,0)
(119,103,0)
(100,125,0)
(107,182,0)
(211,132,0)
(13,118,0)
(45,127,0)
(22,199,0)
(118,20,0)
(118,133,0)
(4,129,0)
(184,132,0)
(173,125,0)
(116,69,0)
(196,102,0)
(18,131,0)
(97,173,0)
(67,203,0)
(195,69,0)
(175,190,0)
(44,146,0)
(179,187,0)
(206,123,0)
(136,199,0)
(48,1,0)
(79,160,0)
(44,130,0)
(20,118,0)
(152,100,0)
(101,73,0)
(197,88,0)
(51,73,0)
(133,125,0)
(68,108,0)
(126,191,0)
(143,184,0)
(72,144,0)
(113,130,0)
(88,201,0)
(160,125,0)
(132,122,0)
(132,184,0)
(125,73,0)
(6,66,0)
(5,47,0)
(129,4,0)
(87,65,0)
(35,64,0)
(49,209,0)
(183,36,0)
(110,191,0)
(68,184,0)
(72,47,0)
(63,140,0)
(102,125,0)
(99,210,0)
(7,70,0)
(130,125,0)
(151,4,0)
(26,69,0)
(96,85,0)
(75,141,0)
(66,6,0)
(81,25,0)
(111,69,0)
(190,81,0)
(21,7,0)
(53,69,0)
(90,206,0)
(64,6,0)
(166,2,0)
(102,211,0)
(59,160,0)
(112,199,0)
(138,100,0)
(25,69,0)
(71,69,0)
(176,125,0)
(40,20,0)
(118,195,0)
(181,83,0)
(200,2,0)
(95,199,0)
(35,83,0)
(185,104,0)
(178,184,0)
(82,25,0)
(47,125,0)
(157,199,0)
(33,90,0)
(107,123,0)
(17,35,0)
(100,70,0)
(83,35,0)
(52,173,0)
(131,2,0)
(80,61,0)
(182,176,0)
(121,124,0)
(10,199,0)
(1,122,0)
(57,157,0)
(28,202,0)
(62,203,0)
(20,203,0)
(170,154,0)
(36,199,0)
(176,182,0)
(67,161,0)
(2,125,0)
(165,135,0)
(46,90,0)
(168,47,0)
(85,209,0)
(54,207,0)
(202,69,0)
(159,26,0)
(50,39,0)
(205,71,0)
(149,174,0)
(20,161,0)
(157,207,0)
(138,151,0)
(145,107,0)
(106,34,0)
(98,210,0)
(171,69,0)
(37,1,0)
(211,195,0)
(120,85,0)
(0,135,0)
(204,36,0)
(177,211,0)
(3,7,0)
(24,114,0)
(60,207,0)
(125,100,0)
(187,69,0)
(132,203,0)
(114,70,0)
(61,125,0)
(142,69,0)
(172,83,0)
(8,49,0)
(31,133,0)
(144,69,0)
(76,81,0)
(100,138,0)
(4,151,0)
(198,69,0)
(189,129,0)
(109,155,0)
(157,125,0)
(211,102,0)
(207,108,0)
(190,173,0)
(32,176,0)
(35,83,1)
(194,122,1)
(1,48,1)
(173,52,1)
(182,176,1)
(129,140,1)
(39,50,1)
(67,208,1)
(210,98,1)
(49,184,1)
(37,178,1)
(107,145,1)
(208,62,1)
(29,45,1)
(186,31,1)
(88,197,1)
(148,203,1)
(142,89,1)
(166,71,1)
(168,123,1)
(150,32,1)
(76,190,1)
(22,77,1)
(65,93,1)
(206,117,1)
(33,39,1)
(178,202,1)
(6,42,1)
(14,125,1)
(132,128,1)
(157,140,1)
(122,1,1)
(176,125,1)
(81,190,1)
(65,203,1)
(100,70,1)
(106,153,1)
(190,173,1)
(100,138,1)
(132,203,1)
(149,143,1)
(187,27,1)
(51,84,1)
(179,160,1)
(204,183,1)
(139,184,1)
(120,96,1)
(44,130,1)
(31,116,1)
(6,66,1)
(131,2,1)
(184,132,1)
(159,15,1)
(16,47,1)
(2,125,1)
(110,126,1)
(147,10,1)
(107,182,1)
(176,150,1)
(75,114,1)
(21,3,1)
(23,207,1)
(132,125,1)
(42,61,1)
(143,184,1)
(35,17,1)
(55,162,1)
(85,120,1)
(160,59,1)
(26,159,1)
(43,111,1)
(92,180,1)
(151,4,1)
(157,207,1)
(40,118,1)
(138,151,1)
(2,200,1)
(117,90,1)
(133,186,1)
(71,205,1)
(60,167,1)
(88,127,1)
(203,67,1)
(85,184,1)
(154,170,1)
(126,124,1)
(131,18,1)
(20,203,1)
(114,19,1)
(10,92,1)
(136,147,1)
(68,70,1)
(127,140,1)
(129,189,1)
(105,12,1)
(80,35,1)
(89,187,1)
(132,211,1)
(207,54,1)
(9,212,1)
(4,129,1)
(3,63,1)
(84,88,1)
(1,70,1)
(146,44,1)
(88,201,1)
(153,64,1)
(86,211,1)
(79,195,1)
(164,68,1)
(123,107,1)
(206,90,1)
(202,28,1)
(125,100,1)
(54,60,1)
(200,166,1)
(190,195,1)
(41,152,1)
(49,8,1)
(124,121,1)
(170,20,1)
(19,24,1)
(132,122,1)
(11,14,1)
(102,196,1)
(27,179,1)
(209,49,1)
(47,5,1)
(7,21,1)
(61,137,1)
(188,55,1)
(87,74,1)
(189,41,1)
(23,88,1)
(109,174,1)
(81,76,1)
(64,6,1)
(134,72,1)
(81,203,1)
(180,115,1)
(45,140,1)
(162,51,1)
(90,125,1)
(83,181,1)
(38,105,1)
(197,127,1)
(48,37,1)
(65,161,1)
(8,43,1)
(57,103,1)
(137,80,1)
(211,177,1)
(12,209,1)
(83,125,1)
(181,172,1)
(177,102,1)
(119,192,1)
(128,86,1)
(7,70,1)
(85,125,1)
(30,9,1)
(65,74,1)
(211,102,1)
(68,94,1)
(118,133,1)
(25,82,1)
(36,204,1)
(133,125,1)
(173,125,1)
(5,168,1)
(34,125,1)
(67,161,1)
(23,143,1)
(121,198,1)
(61,125,1)
(118,13,1)
(140,65,1)
(155,109,1)
(99,36,1)
(20,118,1)
(68,184,1)
(96,49,1)
(63,156,1)
(143,38,1)
(52,97,1)
(152,188,1)
(17,83,1)
(78,34,1)
(130,113,1)
(20,161,1)
(191,110,1)
(205,191,1)
(135,0,1)
(97,154,1)
(93,87,1)
(138,135,1)
(58,40,1)
(185,141,1)
(34,106,1)
(23,14,1)
(160,125,1)
(103,119,1)
(195,146,1)
(72,47,1)
(32,206,1)
(144,134,1)
(192,23,1)
(165,151,1)
(15,34,1)
(115,210,1)
(15,78,1)
(196,194,1)
(118,195,1)
(174,149,1)
(59,79,1)
(179,56,1)
(18,2,1)
(104,185,1)
(209,85,1)
(157,57,1)
(211,195,1)
(50,26,1)
(146,163,1)
(198,11,1)
(190,175,1)
(56,160,1)
(28,25,1)
(114,70,1)
(13,133,1)
(24,155,1)
(30,157,1)
(111,139,1)
(47,125,1)
(0,165,1)
(102,125,1)
(74,7,1)
(20,58,1)
(127,29,1)
(135,203,1)
(167,164,1)
(77,136,1)
(157,125,1)
(72,16,1)
(158,144,1)
(82,81,1)
(193,104,1)
(113,169,1)
(62,22,1)
(172,142,1)
(130,125,1)
(175,173,1)
(169,131,1)
(141,75,1)
(46,33,1)
(94,193,1)
(156,148,1)
(98,99,1)
(116,158,1)
(90,46,1)
(138,151,2)
(117,14,2)
(179,14,2)
(24,143,2)
(64,6,2)
(41,88,2)
(211,195,2)
(126,14,2)
(65,203,2)
(129,88,2)
(195,14,2)
(129,140,2)
(90,125,2)
(104,143,2)
(32,14,2)
(17,14,2)
(138,135,2)
(85,49,2)
(15,34,2)
(80,14,2)
(130,14,2)
(100,138,2)
(118,14,2)
(146,163,2)
(59,14,2)
(194,14,2)
(75,143,2)
(20,203,2)
(81,203,2)
(186,14,2)
(182,176,2)
(206,90,2)
(181,14,2)
(35,14,2)
(167,143,2)
(4,129,2)
(131,14,2)
(179,160,2)
(130,125,2)
(122,14,2)
(11,14,2)
(114,70,2)
(113,14,2)
(157,125,2)
(67,161,2)
(68,184,2)
(1,70,2)
(71,14,2)
(49,14,2)
(131,2,2)
(172,14,2)
(132,125,2)
(44,130,2)
(169,14,2)
(196,14,2)
(37,14,2)
(58,14,2)
(176,14,2)
(106,14,2)
(206,14,2)
(176,125,2)
(124,14,2)
(12,14,2)
(142,14,2)
(13,14,2)
(1,14,2)
(160,14,2)
(133,125,2)
(46,14,2)
(188,88,2)
(175,14,2)
(153,14,2)
(28,14,2)
(50,14,2)
(34,125,2)
(65,161,2)
(197,127,2)
(34,14,2)
(6,14,2)
(151,88,2)
(94,143,2)
(207,143,2)
(125,88,2)
(82,14,2)
(178,14,2)
(195,146,2)
(152,88,2)
(111,14,2)
(15,14,2)
(86,14,2)
(141,143,2)
(78,14,2)
(88,201,2)
(0,88,2)
(139,14,2)
(205,14,2)
(123,14,2)
(90,14,2)
(52,14,2)
(26,14,2)
(6,42,2)
(105,14,2)
(27,14,2)
(133,14,2)
(146,14,2)
(190,14,2)
(48,14,2)
(177,14,2)
(97,14,2)
(170,14,2)
(209,49,2)
(155,143,2)
(51,88,2)
(134,14,2)
(85,184,2)
(132,122,2)
(203,67,2)
(173,14,2)
(14,88,2)
(38,14,2)
(68,143,2)
(211,102,2)
(166,14,2)
(31,14,2)
(144,14,2)
(120,49,2)
(138,88,2)
(33,14,2)
(122,1,2)
(132,203,2)
(85,125,2)
(81,14,2)
(68,70,2)
(118,195,2)
(135,203,2)
(107,182,2)
(89,14,2)
(96,49,2)
(187,14,2)
(64,14,2)
(140,65,2)
(102,125,2)
(72,47,2)
(47,125,2)
(116,14,2)
(54,143,2)
(184,14,2)
(42,14,2)
(44,14,2)
(168,14,2)
(159,14,2)
(19,143,2)
(137,14,2)
(74,7,2)
(42,61,2)
(193,143,2)
(8,14,2)
(83,14,2)
(35,83,2)
(123,107,2)
(109,143,2)
(65,74,2)
(209,85,2)
(81,190,2)
(190,195,2)
(160,125,2)
(60,143,2)
(132,14,2)
(150,14,2)
(20,161,2)
(61,14,2)
(121,14,2)
(5,14,2)
(173,125,2)
(55,88,2)
(146,44,2)
(191,14,2)
(107,14,2)
(2,14,2)
(118,133,2)
(100,70,2)
(190,173,2)
(114,143,2)
(174,143,2)
(185,143,2)
(25,14,2)
(151,4,2)
(18,14,2)
(76,14,2)
(39,14,2)
(20,14,2)
(43,14,2)
(162,88,2)
(132,211,2)
(56,14,2)
(127,140,2)
(40,14,2)
(72,14,2)
(149,143,2)
(198,14,2)
(184,132,2)
(49,184,2)
(84,88,2)
(100,88,2)
(209,14,2)
(135,88,2)
(4,88,2)
(107,145,2)
(61,125,2)
(128,14,2)
(6,66,2)
(7,70,2)
(157,207,2)
(12,209,2)
(182,14,2)
(79,14,2)
(125,100,2)
(88,127,2)
(16,14,2)
(83,125,2)
(143,14,2)
(211,14,2)
(189,88,2)
(164,143,2)
(20,118,2)
(165,88,2)
(158,14,2)
(2,125,2)
(47,14,2)
(30,157,2)
(102,14,2)
(154,14,2)
(202,14,2)
(110,14,2)
(143,184,2)
(200,14,2)
(157,140,2)
-----------------------------------
(0,1)
(1,db->aCollSeq)
(2,pColl[0])
(3,db)
(4,sizeof(*pColl)
(5,2)
(6,(char*)
(7,db->aCollSeq)
(8,0)
(9,printf("------function end!------\\n")
(10,printf("static CollSeq *findCollSeqEntry(   sqlite3 *db,          /* Database connection */   const char *zName,    /* Name of the collating sequence */   int create            /* Create a new entry if true */ )
(11,"if(pColl)
(12,assert( pDel==0 || pDel==pColl )
(13,zName)
(14,pColl)
(15,pColl[1].enc)
(16,enc)
(17,zName)
(18,zName)
(19,mallocFailed)
(20,memcpy(pColl[0].zName, zName, nName)
(21,aCollSeq)
(22,printf("int nName = sqlite3Strlen30(zName)
(23,"return pColl;\\n")
(24,db)
(25,pColl[0].zName[nName] = 0)
(26,pColl[1].enc = SQLITE_UTF16LE)
(27,SQLITE_UTF8)
(28,"pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl)
(29,pColl)
(30,RET)
(31,pColl)
(32,pColl)
(33,pColl)
(34,pColl[1])
(35,pColl[1].zName)
(36,printf("\\nfile_name:%s\\n",__FILE__)
(37,db)
(38,0)
(39,printf("pColl[2].zName = (char*)
(40,zName)
(41,3)
(42,&pColl[3])
(43,pDel)
(44,&pColl[3])
(45,0)
(46,2)
(47,pColl[2])
(48,aCollSeq)
(49,pDel==0)
(50,"pColl[2].zName = (char*)
(51,printf("if(0==pColl && create)
(52,0)
(53,if( pDel!=0 )
(54,0)
(55,printf("pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl)
(56,enc)
(57,pColl)
(58,nName)
(59,0)
(60,pColl)
(61,pColl[3])
(62,nName)
(63,pColl)
(64,pColl[1].zName = (char*)
(65,sqlite3HashFind(&db->aCollSeq, zName, nName)
(66,char*)
(67,sqlite3Strlen30(zName)
(68,sqlite3DbFree(db, pDel)
(69,)
(70,sqlite3 *db)
(71,printf("pColl[0].zName = (char*)
(72,pColl[2].enc)
(73,)
(74,&db->aCollSeq)
(75,1)
(76,nName)
(77,"int nName = sqlite3Strlen30(zName)
(78,enc)
(79,pColl)
(80,pColl)
(81,pColl[0].zName[nName])
(82,0)
(83,pColl[1])
(84,"if(0==pColl && create)
(85,pDel==pColl)
(86,nName)
(87,zName)
(88,0==pColl && create)
(89,"pColl[1].zName = (char*)
(90,pColl[2])
(91,nName)
(92,"static CollSeq *findCollSeqEntry(   sqlite3 *db,          /* Database connection */   const char *zName,    /* Name of the collating sequence */   int create            /* Create a new entry if true */ )
(93,nName)
(94,pDel)
(95,pColl)
(96,pDel)
(97,pColl)
(98,__func__)
(99,"function_name:%s\\n")
(100,sqlite3DbMallocZero(db, 3*sizeof(*pColl)
(101,if( pColl )
(102,pColl[0])
(103,printf("------function end!------\\n")
(104,printf("sqlite3DbFree(db, pDel)
(105,pDel)
(106,1)
(107,(char*)
(108,)
(109,"db->mallocFailed = 1;\\n")
(110,0)
(111,printf("assert( pDel==0 || pDel==pColl )
(112,if( 0==pColl && create )
(113,3)
(114,db->mallocFailed)
(115,"------function start!------\\n")
(116,printf("memcpy(pColl[0].zName, zName, nName)
(117,zName)
(118,pColl[0].zName)
(119,"------function end!------\\n")
(120,pColl)
(121,"CollSeq *pDel = 0;\\n")
(122,&db->aCollSeq)
(123,pColl[2].zName = (char*)
(124,printf("CollSeq *pDel = 0;\\n")
(125,pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl)
(126,pDel)
(127,0==pColl)
(128,pColl)
(129,*pColl)
(130,pColl[3])
(131,pColl[0].zName)
(132,sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl)
(133,pColl[0])
(134,SQLITE_UTF16BE)
(135,nName + 1)
(136,printf("CollSeq *pColl;\\n")
(137,3)
(138,3*sizeof(*pColl)
(139,"assert( pDel==0 || pDel==pColl )
(140,pColl = sqlite3HashFind(&db->aCollSeq, zName, nName)
(141,db->mallocFailed = 1)
(142,printf("pColl[1].zName = (char*)
(143,pDel!=0)
(144,pColl[2].enc = SQLITE_UTF16BE)
(145,char*)
(146,(char*)
(147,"CollSeq *pColl;\\n")
(148,"pColl = sqlite3HashFind(&db->aCollSeq, zName, nName)
(149,"if(pDel!=0)
(150,3)
(151,3*sizeof(*pColl)
(152,db)
(153,pColl)
(154,printf("pColl[0].zName[nName] = 0;\\n")
(155,printf("db->mallocFailed = 1;\\n")
(156,printf("pColl = sqlite3HashFind(&db->aCollSeq, zName, nName)
(157,return pColl;)
(158,"memcpy(pColl[0].zName, zName, nName)
(159,SQLITE_UTF16LE)
(160,pColl[0])
(161,const char *zName)
(162,"pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl)
(163,char*)
(164,"pColl = 0;\\n")
(165,nName)
(166,pColl)
(167,printf("pColl = 0;\\n")
(168,pColl)
(169,pColl)
(170,"pColl[0].zName[nName] = 0;\\n")
(171,pDel)
(172,pColl)
(173,pColl[0])
(174,printf("if(pDel!=0)
(175,zName)
(176,pColl[3])
(177,zName)
(178,pDel)
(179,pColl[0].enc)
(180,printf("------function start!------\\n")
(181,1)
(182,&pColl[3])
(183,"\\nfile_name:%s\\n")
(184,pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl)
(185,"sqlite3DbFree(db, pDel)
(186,0)
(187,pColl[0].enc = SQLITE_UTF8)
(188,pColl)
(189,pColl)
(190,pColl[0].zName)
(191,*pDel = 0)
(192,printf("return pColl;\\n")
(193,db)
(194,pColl)
(195,pColl[0].zName = (char*)
(196,0)
(197,create)
(198,printf("if(pColl)
(199,)
(200,0)
(201,int create)
(202,printf("pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl)
(203,nName = sqlite3Strlen30(zName)
(204,__FILE__)
(205,"pColl[0].zName = (char*)
(206,pColl[2].zName)
(207,pColl = 0)
(208,zName)
(209,pDel==0 || pDel==pColl)
(210,printf("function_name:%s\\n",__func__)
(211,pColl[0].zName)
(212,"------function end!------\\n")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
----------------dynamic----------------
=======testcase========
model_version:0x01000000
stdin-stat:0x000800000000000001000000ffffffff0100000000000000a4810000e8030000e8030000ffffffff0000000000000000ffffffffffffffff0010000000000000ffffffffffffffff2ff9366400000000ffffffffffffffff9ff8366400000000ffffffffffffffff9ff8366400000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
stdin:0x2e68000000000000000000000000000000000000
=========trace=========
void sqlite3VXPrintf(   StrAccum *pAccum,                  /* Accumulate results here */   int useExtended,                   /* Allow extended _-conversions */   const char *fmt,                   /* Format string */   va_list ap                         /* arguments */ ){
int c;
char *bufpt;
int precision;
int length;
int idx;
int width;
etByte flag_leftjustify;
etByte flag_plussign;
etByte flag_blanksign;
etByte flag_alternateform;
etByte flag_altform2;
etByte flag_zeropad;
etByte flag_long;
etByte flag_longlong;
etByte done;
etByte xtype = 0;
char prefix;
LONGDOUBLE_TYPE realvalue;
const et_info *infop;
char *zOut;
int nOut;
char *zExtra;
int  exp, e2;
int nsd;
double rounder;
etByte flag_dp;
etByte flag_rtz;
char buf[etBUFSIZE];
bufpt = 0;
flag_leftjustify = flag_plussign = flag_blanksign =       flag_alternateform = flag_altform2 = flag_zeropad = 0;
done = 0;
switch(c)
done = 1;
width = 0;
precision = -1;
flag_long = flag_longlong = 0;
infop = &fmtinfo[0];
xtype = etINVALID;
for(idx=0;idx<ArraySize(fmtinfo);idx++)
for(idx=0;idx<ArraySize(fmtinfo);idx++)
if(c==fmtinfo[idx].fmttype)
infop = &fmtinfo[idx];
if(useExtended || (infop->flags & FLAG_INTERN)==0)
xtype = infop->type;
zExtra = 0;
switch(xtype)
bufpt = va_arg(ap,char*);
length = sqlite3Strlen30(bufpt);
if(!flag_leftjustify)
register int nspace;
nspace = width-length;
if(length>0)
sqlite3StrAccumAppend(pAccum, bufpt, length);
sqlite3_free(zExtra);
if(c!='_')
int amt;
bufpt = (char *)fmt;
amt = 1;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
while((c=(*++fmt))!='_' && c!=0)
amt++;
sqlite3StrAccumAppend(pAccum, bufpt, amt);
if(c==0)
=======================
