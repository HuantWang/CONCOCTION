-----label-----
1
-----code-----
zip_int64_t
zip_get_num_entries(zip_t *za, zip_flags_t flags)
{
    zip_uint64_t n;

    if (za == NULL)
	return -1;

    if (flags & ZIP_FL_UNCHANGED) {
	n = za->nentry;
	while (n>0 && za->entry[n-1].orig == NULL)
	    --n;
	return (zip_int64_t)n;
    }
    return (zip_int64_t)za->nentry;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
6,7
6,8
7,8
9,10
9,11
12,13
12,14
13,14
15,16
17,18
17,19
17,20
17,21
18,19
19,20
19,21
20,21
22,23
24,25
24,26
25,26
25,27
26,27
28,29
30,31
31,32
33,34
33,35
34,35
34,36
35,36
37,38
39,40
39,41
39,42
40,41
41,42
41,43
42,43
44,45
44,46
45,46
48,49
48,50
49,50
49,51
50,51
50,52
51,52
54,55
54,56
55,56
55,57
56,57
56,58
57,58
57,59
58,59
61,62
61,63
62,63
66,67
68,69
69,70
70,71
72,73
73,74
73,75
74,75
74,76
75,76
78,79
80,81
81,82
81,83
82,83
82,84
83,84
86,87
86,88
87,88
-----nextToken-----
3,5,8,10,11,14,16,21,23,27,29,32,36,38,43,46,47,52,53,59,60,63,64,65,67,71,76,77,79,84,85,88,89
-----computeFrom-----
25,26
25,27
34,35
34,36
41,42
41,43
49,50
49,51
50,51
50,52
54,55
54,56
61,62
61,63
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ReturnStatement;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;ReturnStatement;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;
-----ast_node-----
zip_int64_tzip_get_num_entries(zip_t *za, zip_flags_t flags){    zip_uint64_t n;    if (za == NULL)	return -1;    if (flags & ZIP_FL_UNCHANGED) {	n = za->nentry;	while (n>0 && za->entry[n-1].orig == NULL)	    --n;	return (zip_int64_t)n;    }    return (zip_int64_t)za->nentry;}
zip_int64_t
zip_int64_t
zip_get_num_entries(zip_t *za, zip_flags_t flags)
zip_get_num_entries
zip_t *za
zip_t
zip_t
*za
*
za
zip_flags_t flags
zip_flags_t
zip_flags_t
flags
flags
{    zip_uint64_t n;    if (za == NULL)	return -1;    if (flags & ZIP_FL_UNCHANGED) {	n = za->nentry;	while (n>0 && za->entry[n-1].orig == NULL)	    --n;	return (zip_int64_t)n;    }    return (zip_int64_t)za->nentry;}
zip_uint64_t n;
zip_uint64_t n;
zip_uint64_t
zip_uint64_t
n
n
if (za == NULL)	return -1;
za == NULL
za
za
NULL
NULL
return -1;
-1
1
if (flags & ZIP_FL_UNCHANGED) {	n = za->nentry;	while (n>0 && za->entry[n-1].orig == NULL)	    --n;	return (zip_int64_t)n;    }
flags & ZIP_FL_UNCHANGED
flags
flags
ZIP_FL_UNCHANGED
ZIP_FL_UNCHANGED
{	n = za->nentry;	while (n>0 && za->entry[n-1].orig == NULL)	    --n;	return (zip_int64_t)n;    }
n = za->nentry;
n = za->nentry
n
n
za->nentry
za
za
nentry
while (n>0 && za->entry[n-1].orig == NULL)	    --n;
n>0 && za->entry[n-1].orig == NULL
n>0
n
n
0
za->entry[n-1].orig == NULL
za->entry[n-1].orig
za->entry[n-1]
za->entry
za
za
entry
n-1
n
n
1
orig
NULL
NULL
--n;
--n
n
n
return (zip_int64_t)n;
(zip_int64_t)n
zip_int64_t
zip_int64_t
zip_int64_t

n
n
return (zip_int64_t)za->nentry;
(zip_int64_t)za->nentry
zip_int64_t
zip_int64_t
zip_int64_t

za->nentry
za
za
nentry
-----joern-----
(47,19,0)
(14,7,0)
(36,32,0)
(31,3,0)
(42,32,0)
(33,24,0)
(33,26,0)
(16,40,0)
(26,30,0)
(3,1,0)
(0,31,0)
(48,1,0)
(32,30,0)
(23,29,0)
(40,48,0)
(27,40,0)
(13,31,0)
(3,44,0)
(15,20,0)
(39,20,0)
(26,33,0)
(37,19,0)
(34,3,0)
(40,3,0)
(9,30,0)
(17,9,0)
(32,13,0)
(6,31,0)
(5,13,0)
(40,16,0)
(8,35,0)
(23,48,0)
(11,28,0)
(31,13,0)
(13,32,0)
(21,7,0)
(44,30,0)
(38,12,0)
(20,15,0)
(20,5,0)
(12,3,0)
(33,47,0)
(49,44,0)
(45,26,0)
(4,35,0)
(7,3,0)
(25,26,0)
(10,19,0)
(35,46,0)
(44,3,0)
(24,33,0)
(2,1,0)
(28,29,0)
(7,15,0)
(43,19,0)
(23,47,0)
(13,5,0)
(5,20,0)
(41,5,0)
(15,7,0)
(22,9,0)
(18,44,0)
(44,18,1)
(40,27,1)
(26,30,1)
(33,26,1)
(26,45,1)
(8,9,1)
(42,7,1)
(5,13,1)
(21,12,1)
(15,7,1)
(15,20,1)
(31,0,1)
(0,6,1)
(36,42,1)
(6,32,1)
(7,3,1)
(4,8,1)
(38,15,1)
(41,13,1)
(35,46,1)
(12,38,1)
(39,5,1)
(13,31,1)
(27,15,1)
(9,30,1)
(7,14,1)
(14,21,1)
(32,36,1)
(34,35,1)
(40,16,1)
(31,3,1)
(20,39,1)
(21,3,1)
(47,33,1)
(9,17,1)
(40,3,1)
(3,44,1)
(44,30,1)
(28,11,1)
(35,4,1)
(33,24,1)
(13,32,1)
(32,30,1)
(18,49,1)
(23,47,1)
(11,9,1)
(12,3,1)
(17,22,1)
(25,35,1)
(29,28,1)
(5,41,1)
(45,25,1)
(20,5,1)
(23,48,1)
(23,29,1)
(48,40,1)
(49,34,1)
(5,7,2)
(27,35,2)
(13,32,2)
(32,7,2)
(26,30,2)
(15,7,2)
(12,15,2)
(13,31,2)
(29,9,2)
(25,35,2)
(7,15,2)
(33,26,2)
(33,35,2)
(3,35,2)
(20,5,2)
(15,20,2)
(34,35,2)
(48,35,2)
(35,46,2)
(31,3,2)
(14,35,2)
(36,7,2)
(23,47,2)
(7,35,2)
(49,35,2)
(3,44,2)
(6,7,2)
(21,35,2)
(23,48,2)
(32,30,2)
(42,7,2)
(5,13,2)
(12,3,2)
(8,9,2)
(31,7,2)
(21,15,2)
(4,9,2)
(41,7,2)
(44,30,2)
(28,9,2)
(26,35,2)
(40,3,2)
(38,15,2)
(0,7,2)
(13,7,2)
(40,16,2)
(18,35,2)
(39,7,2)
(23,29,2)
(44,35,2)
(7,3,2)
(35,9,2)
(45,35,2)
(33,24,2)
(47,35,2)
(40,35,2)
(20,7,2)
(15,15,2)
(11,9,2)
(9,30,2)
(14,15,2)
(15,35,2)
-----------------------------------
(0,1)
(1,)
(2,while (n>0 && za->entry[n-1].orig == NULL)
(3,n = za->nentry)
(4,ZIP_FL_UNCHANGED)
(5,za->entry[n-1].orig)
(6,n)
(7,n>0)
(8,flags)
(9,za == NULL)
(10,if (za == NULL)
(11,1)
(12,--n)
(13,za->entry[n-1])
(14,0)
(15,n>0 && za->entry[n-1].orig == NULL)
(16,zip_int64_t)
(17,NULL)
(18,nentry)
(19,)
(20,za->entry[n-1].orig == NULL)
(21,n)
(22,za)
(23,RET)
(24,zip_int64_t)
(25,za)
(26,za->nentry)
(27,n)
(28,-1)
(29,return -1;)
(30,zip_t *za)
(31,n-1)
(32,za->entry)
(33,(zip_int64_t)
(34,n)
(35,flags & ZIP_FL_UNCHANGED)
(36,entry)
(37,if (flags & ZIP_FL_UNCHANGED)
(38,n)
(39,NULL)
(40,(zip_int64_t)
(41,orig)
(42,za)
(43,n)
(44,za->nentry)
(45,nentry)
(46,zip_flags_t flags)
(47,return (zip_int64_t)
(48,return (zip_int64_t)
(49,za)
-----cfg-----
(7,13)
(13,18)
(13,21)
(17,58)
(18,17)
(21,54)
(21,29)
(25,32)
(27,25)
(29,27)
(31,50)
(31,46)
(32,31)
(32,40)
(35,31)
(36,35)
(37,44)
(38,41)
(40,38)
(41,37)
(44,36)
(46,32)
(48,58)
(49,48)
(50,49)
(52,58)
(53,52)
(54,57)
(55,53)
(57,55)
-----path-----
7,13,18,17,58
7,13,21,54,57,55,53,52,58
7,13,21,29,27,25,32,31,50,49,48,58
7,13,21,29,27,25,32,31,46,32,31,50,49,48,58
7,13,21,29,27,25,32,31,46,32,40,38,41,37,44,36,35,31,50,49,48,58
7,13,21,29,27,25,32,40,38,41,37,44,36,35,31,50,49,48,58
-----cfgNode-----
5,<global>
6,<empty>
7,zip_int64_t zip_get_num_entries (zip_t *za,zip_flags_t flags)
8,zip_t *za
9,zip_flags_t flags
10,<empty>
11,zip_uint64_t n
12,if (za == NULL)
13,za == NULL
14,za
15,NULL
16,<empty>
17,return -1;
18,-1
19,1
20,if (flags & ZIP_FL_UNCHANGED)
21,flags & ZIP_FL_UNCHANGED
22,flags
23,ZIP_FL_UNCHANGED
24,<empty>
25,n = za->nentry
26,n
27,za->nentry
28,za
29,nentry
30,while (n>0 && za->entry[n-1].orig == NULL)
31,n>0 && za->entry[n-1].orig == NULL
32,n>0
33,n
34,0
35,za->entry[n-1].orig == NULL
36,za->entry[n-1].orig
37,za->entry[n-1]
38,za->entry
39,za
40,entry
41,n-1
42,n
43,1
44,orig
45,NULL
46,--n
47,n
48,return (zip_int64_t)n;
49,(zip_int64_t)n
50,zip_int64_t
51,n
52,return (zip_int64_t)za->nentry;
53,(zip_int64_t)za->nentry
54,zip_int64_t
55,za->nentry
56,za
57,nentry
58,RET
59,zip_t *za
60,zip_flags_t flags
61,RET
62,zip_int64_t zip_get_num_entries (zip_t *za,zip_flags_t flags)
63,zip_t *za
64,zip_flags_t flags
65,<empty>
66,zip_uint64_t n
67,if (za == NULL)
68,za == NULL
69,za
70,NULL
71,<empty>
72,return -1;
73,-1
74,1
75,if (flags & ZIP_FL_UNCHANGED)
76,flags & ZIP_FL_UNCHANGED
77,flags
78,ZIP_FL_UNCHANGED
79,<empty>
80,n = za->nentry
81,n
82,za->nentry
83,za
84,nentry
85,while (n>0 && za->entry[n-1].orig == NULL)
86,n>0 && za->entry[n-1].orig == NULL
87,n>0
88,n
89,0
90,za->entry[n-1].orig == NULL
91,za->entry[n-1].orig
92,za->entry[n-1]
93,za->entry
94,za
95,entry
96,n-1
97,n
98,1
99,orig
100,NULL
101,--n
102,n
103,return (zip_int64_t)n;
104,(zip_int64_t)n
105,zip_int64_t
106,n
107,return (zip_int64_t)za->nentry;
108,(zip_int64_t)za->nentry
109,zip_int64_t
110,za->nentry
111,za
112,nentry
113,RET
114,zip_t *za
115,zip_flags_t flags
=====================================----------------dynamic----------------
=======testcase========
model_version:0x01000000
A-data-stat:0x000800000000000000000020000000000100000000000000a4810000e8030000e8030000ffffffff0000000000000000b7000000000000000010000000000000ffffffffffffffffa07c456400000000ffffffffffffffff777c456400000000ffffffffffffffff777c456400000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
A-data:0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000504b0506000000000000000000000000000000000000
arg00:0x2d53ff
=========trace=========
ZIP_EXTERN zip_int64_t zip_get_num_entries(zip_t *za, zip_flags_t flags) {
zip_uint64_t n;
return (zip_int64_t)za->nentry;
=======================
