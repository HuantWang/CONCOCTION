-----label-----
0
-----code-----
static int do_meta_command(char *zLine, struct callback_data *p){
printf("\nfile_name:%s\n",__FILE__);
printf("function_name:%s\n",__func__);
printf("------function start!------\n");
printf("static int do_meta_command(char *zLine, struct callback_data *p){\n");
  printf("int i = 1;\n");
  int i = 1;
  printf("int nArg = 0;\n");
  int nArg = 0;
  printf("int n, c;\n");
  int n, c;
  printf("int rc = 0;\n");
  int rc = 0;
  printf("char *azArg[50];\n");
  char *azArg[50];

  /* Parse the input line into tokens.
  */
  while( zLine[i] && nArg<ArraySize(azArg) ){printf("while(zLine[i] && nArg<ArraySize(azArg))\n");
  
    while( IsSpace(zLine[i]) ){printf("while(IsSpace(zLine[i]))\n");
     printf("i++;\n");
i++; }
    if( zLine[i]==0 ) {printf("if(zLine[i]==0)\n");
    break;}
    if( zLine[i]=='\'' || zLine[i]=='"' ){printf("if(zLine[i]=='\'' || zLine[i]==''')\n");
    
      printf("int delim = zLine[i++];\n");
      int delim = zLine[i++];
      printf("azArg[nArg++] = &zLine[i];\n");
azArg[nArg++] = &zLine[i];
      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");
       
        if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");
        printf("i++;\n");
i++;}
        printf("i++;\n");
i++; 
      }
      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");
      
        printf("zLine[i++] = 0;\n");
zLine[i++] = 0;
      }
      if( delim=='"' ) {printf("if(delim==''')\n");
      printf("resolve_backslashes(azArg[nArg-1]);\n");
      resolve_backslashes(azArg[nArg-1]);}
    }else{
      printf("azArg[nArg++] = &zLine[i];\n");
azArg[nArg++] = &zLine[i];
      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");
       printf("i++;\n");
i++; }
      if( zLine[i] ) {printf("if(zLine[i])\n");
      printf("zLine[i++] = 0;\n");
zLine[i++] = 0;}
      printf("resolve_backslashes(azArg[nArg-1]);\n");
      resolve_backslashes(azArg[nArg-1]);
    }
  }

  /* Process the input line.
  */
  if( nArg==0 ) {printf("if(nArg==0)\n");
  printf("return 0;\n");
  printf("------function end!------\n");
  return 0;} /* no tokens, no error */
  printf("n = strlen30(azArg[0]);\n");
n = strlen30(azArg[0]);
  printf("c = azArg[0][0];\n");
c = azArg[0][0];
  if( c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n");
  
    printf("const char *zDestFile = 0;\n");
    const char *zDestFile = 0;
    printf("const char *zDb = 0;\n");
    const char *zDb = 0;
    sqlite3 *pDest;
    sqlite3_backup *pBackup;
    printf("int j;\n");
    int j;
    for(j=1; j<nArg; j++){printf("for(j=1;j<nArg;j++)\n");
    
      printf("const char *z = azArg[j];\n");
      const char *z = azArg[j];
      if( z[0]=='-' ){printf("if(z[0]=='-')\n");
      
        while( z[0]=='-' ) {printf("while(z[0]=='-')\n");
        printf("z++;\n");
z++;}
        /* No options to process at this time */
        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");
        {
          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");
          fprintf(stderr, "unknown option: %s\n", azArg[j]);
          printf("return 1;\n");
          printf("------function end!------\n");
          return 1;
        }
      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");
      
        printf("zDestFile = azArg[j];\n");
zDestFile = azArg[j];
      }else if( zDb==0 ){printf("if(zDb==0)\n");
      
        printf("zDb = zDestFile;\n");
zDb = zDestFile;
        printf("zDestFile = azArg[j];\n");
zDestFile = azArg[j];
      }else{
        printf("fprintf(stderr, 'too many arguments to .backup ');\n");
        fprintf(stderr, "too many arguments to .backup\n");
        printf("return 1;\n");
        printf("------function end!------\n");
        return 1;
      }
    }
    if( zDestFile==0 ){printf("if(zDestFile==0)\n");
    
      printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");
      fprintf(stderr, "missing FILENAME argument on .backup\n");
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    if( zDb==0 ) {printf("if(zDb==0)\n");
    printf("zDb = 'main';\n");
zDb = "main";}
    rc = sqlite3_open(zDestFile, &pDest);
    if( rc!=SQLITE_OK ){printf("if()\n");
    
      printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");
      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);
      sqlite3_close(pDest);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);
    if( pBackup==0 ){printf("if()\n");
    
      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
      sqlite3_close(pDest);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}
    sqlite3_backup_finish(pBackup);
    if( rc==SQLITE_DONE ){printf("if()\n");
    
      printf("rc = 0;\n");
rc = 0;
    }else{
      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
      printf("rc = 1;\n");
rc = 1;
    }
    sqlite3_close(pDest);
  }else

  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");
  
    printf("bail_on_error = booleanValue(azArg[1]);\n");
bail_on_error = booleanValue(azArg[1]);
  }else

  /* The undocumented ".breakpoint" command causes a call to the no-op
  ** routine named test_breakpoint().
  */
  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");
  
    printf("test_breakpoint();\n");
    test_breakpoint();
  }else

  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");
  
    printf("struct callback_data data;\n");
    struct callback_data data;
    printf("char *zErrMsg = 0;\n");
    char *zErrMsg = 0;
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    printf("memcpy(&data, p, sizeof(data));\n");
    memcpy(&data, p, sizeof(data));
    printf("data.showHeader = 1;\n");
data.showHeader = 1;
    printf("data.mode = MODE_Column;\n");
data.mode = MODE_Column;
    printf("data.colWidth[0] = 3;\n");
data.colWidth[0] = 3;
    printf("data.colWidth[1] = 15;\n");
data.colWidth[1] = 15;
    printf("data.colWidth[2] = 58;\n");
data.colWidth[2] = 58;
    printf("data.cnt = 0;\n");
data.cnt = 0;
    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);
    if( zErrMsg ){printf("if(zErrMsg)\n");
    
      printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");
      fprintf(stderr,"Error: %s\n", zErrMsg);
      printf("sqlite3_free(zErrMsg);\n");
      sqlite3_free(zErrMsg);
      printf("rc = 1;\n");
rc = 1;
    }
  }else

  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");
  
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    /* When playing back a "dump", the content might appear in an order
    ** which causes immediate foreign key constraints to be violated.
    ** So disable foreign-key constraint enforcement to prevent problems. */
    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");
    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");
    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");
    fprintf(p->out, "BEGIN TRANSACTION;\n");
    printf("p->writableSchema = 0;\n");
p->writableSchema = 0;
    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);
    printf("p->nErr = 0;\n");
p->nErr = 0;
    if( nArg==1 ){printf("if(nArg==1)\n");
    
      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");
      run_schema_dump_query(p, 
        "SELECT name, type, sql FROM sqlite_master "
        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"
      );
      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");
      run_schema_dump_query(p, 
        "SELECT name, type, sql FROM sqlite_master "
        "WHERE name=='sqlite_sequence'"
      );
      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");
      run_table_dump_query(p,
        "SELECT sql FROM sqlite_master "
        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0
      );
    }else{
      printf("int i;\n");
      int i;
      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");
      
        printf("zShellStatic = azArg[i];\n");
zShellStatic = azArg[i];
        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");
        run_schema_dump_query(p,
          "SELECT name, type, sql FROM sqlite_master "
          "WHERE tbl_name LIKE shellstatic() AND type=='table'"
          "  AND sql NOT NULL");
        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");
        run_table_dump_query(p,
          "SELECT sql FROM sqlite_master "
          "WHERE sql NOT NULL"
          "  AND type IN ('index','trigger','view')"
          "  AND tbl_name LIKE shellstatic()", 0
        );
        printf("zShellStatic = 0;\n");
zShellStatic = 0;
      }
    }
    if( p->writableSchema ){printf("if(p->writableSchema)\n");
    
      printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");
      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");
      printf("p->writableSchema = 0;\n");
p->writableSchema = 0;
    }
    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);
    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);
    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");
    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");
  }else

  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");
  
    printf("p->echoOn = booleanValue(azArg[1]);\n");
p->echoOn = booleanValue(azArg[1]);
  }else

  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");
  
    if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");
    printf("exit(rc);\n");
    exit(rc);}
    printf("rc = 2;\n");
rc = 2;
  }else

  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");
  
    printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");
    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;
    if(val == 1) {printf("if(val == 1)\n");
    
      if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");
      
        printf("p->explainPrev.valid = 1;\n");
p->explainPrev.valid = 1;
        printf("p->explainPrev.mode = p->mode;\n");
p->explainPrev.mode = p->mode;
        printf("p->explainPrev.showHeader = p->showHeader;\n");
p->explainPrev.showHeader = p->showHeader;
        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");
        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));
      }
      /* We could put this code under the !p->explainValid
      ** condition so that it does not execute if we are already in
      ** explain mode. However, always executing it allows us an easy
      ** was to reset to explain mode in case the user previously
      ** did an .explain followed by a .width, .mode or .header
      ** command.
      */
      printf("p->mode = MODE_Explain;\n");
p->mode = MODE_Explain;
      printf("p->showHeader = 1;\n");
p->showHeader = 1;
      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");
      memset(p->colWidth,0,sizeof(p->colWidth));
      printf("p->colWidth[0] = 4;\n");
p->colWidth[0] = 4;                  /* addr */
      printf("p->colWidth[1] = 13;\n");
p->colWidth[1] = 13;                 /* opcode */
      printf("p->colWidth[2] = 4;\n");
p->colWidth[2] = 4;                  /* P1 */
      printf("p->colWidth[3] = 4;\n");
p->colWidth[3] = 4;                  /* P2 */
      printf("p->colWidth[4] = 4;\n");
p->colWidth[4] = 4;                  /* P3 */
      printf("p->colWidth[5] = 13;\n");
p->colWidth[5] = 13;                 /* P4 */
      printf("p->colWidth[6] = 2;\n");
p->colWidth[6] = 2;                  /* P5 */
      printf("p->colWidth[7] = 13;\n");
p->colWidth[7] = 13;                  /* Comment */
    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");
    
      printf("p->explainPrev.valid = 0;\n");
p->explainPrev.valid = 0;
      printf("p->mode = p->explainPrev.mode;\n");
p->mode = p->explainPrev.mode;
      printf("p->showHeader = p->explainPrev.showHeader;\n");
p->showHeader = p->explainPrev.showHeader;
      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");
      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));
    }
  }else

  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||
                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");
                 
    printf("p->showHeader = booleanValue(azArg[1]);\n");
p->showHeader = booleanValue(azArg[1]);
  }else

  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");
  
    printf("fprintf(stderr,'_s',zHelp);\n");
    fprintf(stderr,"%s",zHelp);
    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");
    
      printf("fprintf(stderr,'_s',zTimerHelp);\n");
      fprintf(stderr,"%s",zTimerHelp);
    }
  }else

  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");
  
    printf("char *zTable = azArg[2];\n");
    char *zTable = azArg[2];    /* Insert data into this table */
    printf("char *zFile = azArg[1];\n");
    char *zFile = azArg[1];     /* Name of file to extra content from */
    sqlite3_stmt *pStmt = NULL; /* A statement */
    printf("int nCol;\n");
    int nCol;                   /* Number of columns in the table */
    printf("int nByte;\n");
    int nByte;                  /* Number of bytes in an SQL string */
    printf("int i, j;\n");
    int i, j;                   /* Loop counters */
    printf("int needCommit;\n");
    int needCommit;             /* True to COMMIT or ROLLBACK at end */
    printf("int nSep;\n");
    int nSep;                   /* Number of bytes in p->separator[] */
    printf("char *zSql;\n");
    char *zSql;                 /* An SQL statement */
    printf("CSVReader sCsv;\n");
    CSVReader sCsv;             /* Reader context */
    printf("int (*xCloser)(FILE*);\n");
    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */

    printf("seenInterrupt = 0;\n");
seenInterrupt = 0;
    printf("memset(&sCsv, 0, sizeof(sCsv));\n");
    memset(&sCsv, 0, sizeof(sCsv));
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    printf("nSep = strlen30(p->separator);\n");
nSep = strlen30(p->separator);
    if( nSep==0 ){printf("if(nSep==0)\n");
    
      printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");
      fprintf(stderr, "Error: non-null separator required for import\n");
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    if( nSep>1 ){printf("if(nSep>1)\n");
    
      printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");
      fprintf(stderr, "Error: multi-character separators not allowed"
                      " for import\n");
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    printf("sCsv.zFile = zFile;\n");
sCsv.zFile = zFile;
    printf("sCsv.nLine = 1;\n");
sCsv.nLine = 1;
    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");
    
      printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");
sCsv.in = popen(sCsv.zFile+1, "r");
      printf("sCsv.zFile = '<pipe>';\n");
sCsv.zFile = "<pipe>";
      printf("xCloser = pclose;\n");
xCloser = pclose;
    }else{
      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");
sCsv.in = fopen(sCsv.zFile, "rb");
      printf("xCloser = fclose;\n");
xCloser = fclose;
    }
    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");
    
      printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");
      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    printf("sCsv.cSeparator = p->separator[0];\n");
sCsv.cSeparator = p->separator[0];
    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");
zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);
    if( zSql==0 ){printf("if(zSql==0)\n");
    
      printf("fprintf(stderr, 'Error: out of memory ');\n");
      fprintf(stderr, "Error: out of memory\n");
      printf("xCloser(sCsv.in);\n");
      xCloser(sCsv.in);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    printf("nByte = strlen30(zSql);\n");
nByte = strlen30(zSql);
    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");
    
      printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");
      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);
      printf("char cSep = '(';\n");
      char cSep = '(';
      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");
      
        printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");
zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);
        printf("cSep = ',';\n");
cSep = ',';
        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");
        break;}
      }
      if( cSep=='(' ){printf("if(cSep=='(')\n");
      
        printf("sqlite3_free(zCreate);\n");
        sqlite3_free(zCreate);
        printf("sqlite3_free(sCsv.z);\n");
        sqlite3_free(sCsv.z);
        printf("xCloser(sCsv.in);\n");
        xCloser(sCsv.in);
        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");
        fprintf(stderr,"%s: empty file\n", sCsv.zFile);
        printf("return 1;\n");
        printf("------function end!------\n");
        return 1;
      }
      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");
zCreate = sqlite3_mprintf("%z\n)", zCreate);
      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);
      printf("sqlite3_free(zCreate);\n");
      sqlite3_free(zCreate);
      if( rc ){printf("if(rc)\n");
      
        fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,
                sqlite3_errmsg(db));
        printf("sqlite3_free(sCsv.z);\n");
        sqlite3_free(sCsv.z);
        printf("xCloser(sCsv.in);\n");
        xCloser(sCsv.in);
        printf("return 1;\n");
        printf("------function end!------\n");
        return 1;
      }
      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
    }
    printf("sqlite3_free(zSql);\n");
    sqlite3_free(zSql);
    if( rc ){printf("if(rc)\n");
    
      if (pStmt) sqlite3_finalize(pStmt);
      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));
      printf("xCloser(sCsv.in);\n");
      xCloser(sCsv.in);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    nCol = sqlite3_column_count(pStmt);
    sqlite3_finalize(pStmt);
    pStmt = 0;
    if( nCol==0 ) {printf("if(nCol==0)\n");
    printf("return 0;\n");
    printf("------function end!------\n");
    return 0;} /* no columns, no error */
    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");
zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );
    if( zSql==0 ){printf("if(zSql==0)\n");
    
      printf("fprintf(stderr, 'Error: out of memory ');\n");
      fprintf(stderr, "Error: out of memory\n");
      printf("xCloser(sCsv.in);\n");
      xCloser(sCsv.in);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");
    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);
    printf("j = strlen30(zSql);\n");
j = strlen30(zSql);
    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");
    
      printf("zSql[j++] = ',';\n");
zSql[j++] = ',';
      printf("zSql[j++] = '?';\n");
zSql[j++] = '?';
    }
    printf("zSql[j++] = ')';\n");
zSql[j++] = ')';
    printf("zSql[j] = 0;\n");
zSql[j] = 0;
    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
    printf("sqlite3_free(zSql);\n");
    sqlite3_free(zSql);
    if( rc ){printf("if(rc)\n");
    
      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
      if (pStmt) sqlite3_finalize(pStmt);
      printf("xCloser(sCsv.in);\n");
      xCloser(sCsv.in);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    needCommit = sqlite3_get_autocommit(db);
    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);
    do{
      printf("int startLine = sCsv.nLine;\n");
      int startLine = sCsv.nLine;
      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");
      
        printf("char *z = csv_read_one_field(&sCsv);\n");
        char *z = csv_read_one_field(&sCsv);
        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");
        break;}
        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);
        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");
        
          printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");
          fprintf(stderr, "%s:%d: expected %d columns but found %d - "
                          "filling the rest with NULL\n",
                          sCsv.zFile, startLine, nCol, i+1);
          printf("i++;\n");
i++;
          while( i<nCol ){printf("while(i<nCol)\n");
           sqlite3_bind_null(pStmt, i); printf("i++;\n");
i++; }
        }
      }
      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");
      
        do{
          printf("csv_read_one_field(&sCsv);\n");
          csv_read_one_field(&sCsv);
          printf("i++;\n");
i++;
        }while( sCsv.cTerm==sCsv.cSeparator );
        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");
        fprintf(stderr, "%s:%d: expected %d columns but found %d - "
                        "extras ignored\n",
                        sCsv.zFile, startLine, nCol, i);
      }
      if( i>=nCol ){printf("if(i>=nCol)\n");
      
        sqlite3_step(pStmt);
        rc = sqlite3_reset(pStmt);
        if( rc!=SQLITE_OK ){printf("if()\n");
        
          fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,
                  sqlite3_errmsg(db));
        }
      }
    }while( sCsv.cTerm!=EOF );

    printf("xCloser(sCsv.in);\n");
    xCloser(sCsv.in);
    printf("sqlite3_free(sCsv.z);\n");
    sqlite3_free(sCsv.z);
    sqlite3_finalize(pStmt);
    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);
  }else

  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");
  
    printf("struct callback_data data;\n");
    struct callback_data data;
    printf("char *zErrMsg = 0;\n");
    char *zErrMsg = 0;
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    printf("memcpy(&data, p, sizeof(data));\n");
    memcpy(&data, p, sizeof(data));
    printf("data.showHeader = 0;\n");
data.showHeader = 0;
    printf("data.mode = MODE_List;\n");
data.mode = MODE_List;
    if( nArg==1 ){printf("if(nArg==1)\n");
    
      rc = sqlite3_exec(p->db,
        "SELECT name FROM sqlite_master "
        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "
        "UNION ALL "
        "SELECT name FROM sqlite_temp_master "
        "WHERE type='index' "
        "ORDER BY 1",
        callback, &data, &zErrMsg
      );
    }else{
      printf("zShellStatic = azArg[1];\n");
zShellStatic = azArg[1];
      rc = sqlite3_exec(p->db,
        "SELECT name FROM sqlite_master "
        "WHERE type='index' AND tbl_name LIKE shellstatic() "
        "UNION ALL "
        "SELECT name FROM sqlite_temp_master "
        "WHERE type='index' AND tbl_name LIKE shellstatic() "
        "ORDER BY 1",
        callback, &data, &zErrMsg
      );
      printf("zShellStatic = 0;\n");
zShellStatic = 0;
    }
    if( zErrMsg ){printf("if(zErrMsg)\n");
    
      printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");
      fprintf(stderr,"Error: %s\n", zErrMsg);
      printf("sqlite3_free(zErrMsg);\n");
      sqlite3_free(zErrMsg);
      printf("rc = 1;\n");
rc = 1;
    }else if( rc != SQLITE_OK ){printf("if()\n");
    
      printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");
      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");
      printf("rc = 1;\n");
rc = 1;
    }
  }else

#ifdef SQLITE_ENABLE_IOTRACE
  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");
  
    printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");
    extern void (*sqlite3IoTrace)(const char*, ...);
    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");
    printf("fclose(iotrace);\n");
    fclose(iotrace);}
    printf("iotrace = 0;\n");
iotrace = 0;
    if( nArg<2 ){printf("if(nArg<2)\n");
    
      printf("sqlite3IoTrace = 0;\n");
sqlite3IoTrace = 0;
    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");
    
      printf("sqlite3IoTrace = iotracePrintf;\n");
sqlite3IoTrace = iotracePrintf;
      printf("iotrace = stdout;\n");
iotrace = stdout;
    }else{
      printf("iotrace = fopen(azArg[1], 'w');\n");
iotrace = fopen(azArg[1], "w");
      if( iotrace==0 ){printf("if(iotrace==0)\n");
      
        printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");
        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);
        printf("sqlite3IoTrace = 0;\n");
sqlite3IoTrace = 0;
        printf("rc = 1;\n");
rc = 1;
      }else{
        printf("sqlite3IoTrace = iotracePrintf;\n");
sqlite3IoTrace = iotracePrintf;
      }
    }
  }else
#endif

#ifndef SQLITE_OMIT_LOAD_EXTENSION
  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");
  
    printf("const char *zFile, *zProc;\n");
    const char *zFile, *zProc;
    printf("char *zErrMsg = 0;\n");
    char *zErrMsg = 0;
    printf("zFile = azArg[1];\n");
zFile = azArg[1];
    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");
zProc = nArg>=3 ? azArg[2] : 0;
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);
    if( rc!=SQLITE_OK ){printf("if()\n");
    
      printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");
      fprintf(stderr, "Error: %s\n", zErrMsg);
      printf("sqlite3_free(zErrMsg);\n");
      sqlite3_free(zErrMsg);
      printf("rc = 1;\n");
rc = 1;
    }
  }else
#endif

  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");
  
    printf("const char *zFile = azArg[1];\n");
    const char *zFile = azArg[1];
    printf("output_file_close(p->pLog);\n");
    output_file_close(p->pLog);
    printf("p->pLog = output_file_open(zFile);\n");
p->pLog = output_file_open(zFile);
  }else

  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");
  
    printf("int n2 = strlen30(azArg[1]);\n");
    int n2 = strlen30(azArg[1]);
    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)
        ||
        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");
        
      printf("p->mode = MODE_Line;\n");
p->mode = MODE_Line;
    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)
              ||
              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");
              
      printf("p->mode = MODE_Column;\n");
p->mode = MODE_Column;
    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");
    
      printf("p->mode = MODE_List;\n");
p->mode = MODE_List;
    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");
    
      printf("p->mode = MODE_Html;\n");
p->mode = MODE_Html;
    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");
    
      printf("p->mode = MODE_Tcl;\n");
p->mode = MODE_Tcl;
      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");
      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");
    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");
    
      printf("p->mode = MODE_Csv;\n");
p->mode = MODE_Csv;
      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");
      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");
    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");
    
      printf("p->mode = MODE_List;\n");
p->mode = MODE_List;
      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");
      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");
    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");
    
      printf("p->mode = MODE_Insert;\n");
p->mode = MODE_Insert;
      printf("set_table_name(p, 'table');\n");
      set_table_name(p, "table");
    }else {
      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");
      fprintf(stderr,"Error: mode should be one of: "
         "column csv html insert line list tabs tcl\n");
      printf("rc = 1;\n");
rc = 1;
    }
  }else

  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");
  
    printf("int n2 = strlen30(azArg[1]);\n");
    int n2 = strlen30(azArg[1]);
    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");
    
      printf("p->mode = MODE_Insert;\n");
p->mode = MODE_Insert;
      printf("set_table_name(p, azArg[2]);\n");
      set_table_name(p, azArg[2]);
    }else {
      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");
      fprintf(stderr, "Error: invalid arguments: "
        " \"%s\". Enter \".help\" for help\n", azArg[2]);
      printf("rc = 1;\n");
rc = 1;
    }
  }else

  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");
  
    printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");
    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,
                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);
  }else

  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");
  
    sqlite3 *savedDb = p->db;
    printf("const char *zSavedFilename = p->zDbFilename;\n");
    const char *zSavedFilename = p->zDbFilename;
    printf("char *zNewFilename = 0;\n");
    char *zNewFilename = 0;
    p->db = 0;
    if( nArg>=2 ){printf("if(nArg>=2)\n");
    
      printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");
p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);
    }
    printf("open_db(p, 1);\n");
    open_db(p, 1);
    if( p->db!=0 ){printf("if()\n");
    
      sqlite3_close(savedDb);
      printf("sqlite3_free(p->zFreeOnClose);\n");
      sqlite3_free(p->zFreeOnClose);
      printf("p->zFreeOnClose = zNewFilename;\n");
p->zFreeOnClose = zNewFilename;
    }else{
      printf("sqlite3_free(zNewFilename);\n");
      sqlite3_free(zNewFilename);
      p->db = savedDb;
      printf("p->zDbFilename = zSavedFilename;\n");
p->zDbFilename = zSavedFilename;
    }
  }else

  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");
  
    if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");
    
      printf("pclose(p->out);\n");
      pclose(p->out);
    }else{
      printf("output_file_close(p->out);\n");
      output_file_close(p->out);
    }
    printf("p->outfile[0] = 0;\n");
p->outfile[0] = 0;
    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");
    
      printf("p->out = popen(&azArg[1][1], 'w');\n");
p->out = popen(&azArg[1][1], "w");
      if( p->out==0 ){printf("if(p->out==0)\n");
      
        printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");
        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);
        printf("p->out = stdout;\n");
p->out = stdout;
        printf("rc = 1;\n");
rc = 1;
      }else{
        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");
        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);
      }
    }else{
      printf("p->out = output_file_open(azArg[1]);\n");
p->out = output_file_open(azArg[1]);
      if( p->out==0 ){printf("if(p->out==0)\n");
      
        if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");
        
          printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");
          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);
        }
        printf("p->out = stdout;\n");
p->out = stdout;
        printf("rc = 1;\n");
rc = 1;
      } else {
        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");
        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);
      }
    }
  }else

  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");
  
    printf("int i;\n");
    int i;
    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");
    
      if( i>1 ) {printf("if(i>1)\n");
      printf("fprintf(p->out, ' ');\n");
      fprintf(p->out, " ");}
      printf("fprintf(p->out, '_s', azArg[i]);\n");
      fprintf(p->out, "%s", azArg[i]);
    }
    printf("fprintf(p->out, ' ');\n");
    fprintf(p->out, "\n");
  }else

  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");
  
    if( nArg >= 2) {printf("if(nArg >= 2)\n");
    
      printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");
      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);
    }
    if( nArg >= 3) {printf("if(nArg >= 3)\n");
    
      printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");
      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);
    }
  }else

  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");
  
    printf("rc = 2;\n");
rc = 2;
  }else

  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");
  
    printf("FILE *alt = fopen(azArg[1], 'rb');\n");
    FILE *alt = fopen(azArg[1], "rb");
    if( alt==0 ){printf("if(alt==0)\n");
    
      printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");
      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);
      printf("rc = 1;\n");
rc = 1;
    }else{
      printf("rc = process_input(p, alt);\n");
rc = process_input(p, alt);
      printf("fclose(alt);\n");
      fclose(alt);
    }
  }else

  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");
  
    printf("const char *zSrcFile;\n");
    const char *zSrcFile;
    printf("const char *zDb;\n");
    const char *zDb;
    sqlite3 *pSrc;
    sqlite3_backup *pBackup;
    printf("int nTimeout = 0;\n");
    int nTimeout = 0;

    if( nArg==2 ){printf("if(nArg==2)\n");
    
      printf("zSrcFile = azArg[1];\n");
zSrcFile = azArg[1];
      printf("zDb = 'main';\n");
zDb = "main";
    }else{
      printf("zSrcFile = azArg[2];\n");
zSrcFile = azArg[2];
      printf("zDb = azArg[1];\n");
zDb = azArg[1];
    }
    rc = sqlite3_open(zSrcFile, &pSrc);
    if( rc!=SQLITE_OK ){printf("if()\n");
    
      printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");
      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);
      sqlite3_close(pSrc);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");
    if( pBackup==0 ){printf("if()\n");
    
      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
      sqlite3_close(pSrc);
      printf("return 1;\n");
      printf("------function end!------\n");
      return 1;
    }
    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
          || rc==SQLITE_BUSY  ){
      if( rc==SQLITE_BUSY ){
        if( nTimeout++ >= 3 ) break;
        sqlite3_sleep(100);
      }
    }
    sqlite3_backup_finish(pBackup);
    if( rc==SQLITE_DONE ){printf("if()\n");
    
      printf("rc = 0;\n");
rc = 0;
    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");
    
      printf("fprintf(stderr, 'Error: source database is busy ');\n");
      fprintf(stderr, "Error: source database is busy\n");
      printf("rc = 1;\n");
rc = 1;
    }else{
      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
      printf("rc = 1;\n");
rc = 1;
    }
    sqlite3_close(pSrc);
  }else

  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");
  
    printf("struct callback_data data;\n");
    struct callback_data data;
    printf("char *zErrMsg = 0;\n");
    char *zErrMsg = 0;
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    printf("memcpy(&data, p, sizeof(data));\n");
    memcpy(&data, p, sizeof(data));
    printf("data.showHeader = 0;\n");
data.showHeader = 0;
    printf("data.mode = MODE_Semi;\n");
data.mode = MODE_Semi;
    if( nArg>1 ){printf("if(nArg>1)\n");
    
      printf("int i;\n");
      int i;
      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");
      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");
azArg[1][i] = ToLower(azArg[1][i]);}
      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");
      
        printf("char *new_argv[2], *new_colv[2];\n");
        char *new_argv[2], *new_colv[2];
        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");
new_argv[0] = "CREATE TABLE sqlite_master (\n"
                      "  type text,\n"
                      "  name text,\n"
                      "  tbl_name text,\n"
                      "  rootpage integer,\n"
                      "  sql text\n"
                      ")";
        printf("new_argv[1] = 0;\n");
new_argv[1] = 0;
        printf("new_colv[0] = 'sql';\n");
new_colv[0] = "sql";
        printf("new_colv[1] = 0;\n");
new_colv[1] = 0;
        printf("callback(&data, 1, new_argv, new_colv);\n");
        callback(&data, 1, new_argv, new_colv);
        rc = SQLITE_OK;
      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");
      
        printf("char *new_argv[2], *new_colv[2];\n");
        char *new_argv[2], *new_colv[2];
        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");
new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"
                      "  type text,\n"
                      "  name text,\n"
                      "  tbl_name text,\n"
                      "  rootpage integer,\n"
                      "  sql text\n"
                      ")";
        printf("new_argv[1] = 0;\n");
new_argv[1] = 0;
        printf("new_colv[0] = 'sql';\n");
new_colv[0] = "sql";
        printf("new_colv[1] = 0;\n");
new_colv[1] = 0;
        printf("callback(&data, 1, new_argv, new_colv);\n");
        callback(&data, 1, new_argv, new_colv);
        rc = SQLITE_OK;
      }else{
        printf("zShellStatic = azArg[1];\n");
zShellStatic = azArg[1];
        rc = sqlite3_exec(p->db,
          "SELECT sql FROM "
          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
          "     FROM sqlite_master UNION ALL"
          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "
          "WHERE lower(tbl_name) LIKE shellstatic()"
          "  AND type!='meta' AND sql NOTNULL "
          "ORDER BY rowid",
          callback, &data, &zErrMsg);
        printf("zShellStatic = 0;\n");
zShellStatic = 0;
      }
    }else{
      rc = sqlite3_exec(p->db,
         "SELECT sql FROM "
         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
         "     FROM sqlite_master UNION ALL"
         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "
         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"
         "ORDER BY rowid",
         callback, &data, &zErrMsg
      );
    }
    if( zErrMsg ){printf("if(zErrMsg)\n");
    
      printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");
      fprintf(stderr,"Error: %s\n", zErrMsg);
      printf("sqlite3_free(zErrMsg);\n");
      sqlite3_free(zErrMsg);
      printf("rc = 1;\n");
rc = 1;
    }else if( rc != SQLITE_OK ){printf("if()\n");
    
      printf("fprintf(stderr,'Error: querying schema information ');\n");
      fprintf(stderr,"Error: querying schema information\n");
      printf("rc = 1;\n");
rc = 1;
    }else{
      printf("rc = 0;\n");
rc = 0;
    }
  }else

#ifdef SQLITE_DEBUG
  /* Undocumented commands for internal testing.  Subject to change
  ** without notice. */
  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");
  
    if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");
    
      printf("int i, v;\n");
      int i, v;
      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");
      
        printf("v = booleanValue(azArg[i]);\n");
v = booleanValue(azArg[i]);
        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");
        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);
      }
    }
    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");
    
      printf("int i;\n");
      int i; sqlite3_int64 v;
      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");
      
        printf("char zBuf[200];\n");
        char zBuf[200];
        v = integerValue(azArg[i]);
        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);
        printf("fprintf(p->out, '_s', zBuf);\n");
        fprintf(p->out, "%s", zBuf);
      }
    }
  }else
#endif

  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");
  
    printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");
    sqlite3_snprintf(sizeof(p->separator), p->separator,
                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);
  }else

  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");
  
    printf("int i;\n");
    int i;
    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");
    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");
    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");
    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");
    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");
    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");
    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");
    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);
    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");
    fprintf(p->out,"%9.9s: ", "nullvalue");
      printf("output_c_string(p->out, p->nullvalue);\n");
      output_c_string(p->out, p->nullvalue);
      printf("fprintf(p->out, ' ');\n");
      fprintf(p->out, "\n");
    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");
    fprintf(p->out,"%9.9s: %s\n","output",
            strlen30(p->outfile) ? p->outfile : "stdout");
    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");
    fprintf(p->out,"%9.9s: ", "separator");
      printf("output_c_string(p->out, p->separator);\n");
      output_c_string(p->out, p->separator);
      printf("fprintf(p->out, ' ');\n");
      fprintf(p->out, "\n");
    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");
    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");
    printf("fprintf(p->out,'_9.9s: ','width');\n");
    fprintf(p->out,"%9.9s: ","width");
    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");
    
      printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");
      fprintf(p->out,"%d ",p->colWidth[i]);
    }
    printf("fprintf(p->out,' ');\n");
    fprintf(p->out,"\n");
  }else

  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");
  
    printf("p->statsOn = booleanValue(azArg[1]);\n");
p->statsOn = booleanValue(azArg[1]);
  }else

  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");
  
    sqlite3_stmt *pStmt;
    printf("char **azResult;\n");
    char **azResult;
    printf("int nRow, nAlloc;\n");
    int nRow, nAlloc;
    printf("char *zSql = 0;\n");
    char *zSql = 0;
    printf("int ii;\n");
    int ii;
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);
    if( rc ) {printf("if(rc)\n");
    printf("return rc;\n");
    printf("------function end!------\n");
    return rc;}
    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");
zSql = sqlite3_mprintf(
        "SELECT name FROM sqlite_master"
        " WHERE type IN ('table','view')"
        "   AND name NOT LIKE 'sqlite_%%'"
        "   AND name LIKE ?1");
    while( sqlite3_step(pStmt)==SQLITE_ROW ){
      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);
      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;
      if( strcmp(zDbName,"temp")==0 ){
        zSql = sqlite3_mprintf(
                 "%z UNION ALL "
                 "SELECT 'temp.' || name FROM sqlite_temp_master"
                 " WHERE type IN ('table','view')"
                 "   AND name NOT LIKE 'sqlite_%%'"
                 "   AND name LIKE ?1", zSql);
      }else{
        zSql = sqlite3_mprintf(
                 "%z UNION ALL "
                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"
                 " WHERE type IN ('table','view')"
                 "   AND name NOT LIKE 'sqlite_%%'"
                 "   AND name LIKE ?1", zSql, zDbName, zDbName);
      }
    }
    sqlite3_finalize(pStmt);
    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");
zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);
    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    printf("sqlite3_free(zSql);\n");
    sqlite3_free(zSql);
    if( rc ) {printf("if(rc)\n");
    printf("return rc;\n");
    printf("------function end!------\n");
    return rc;}
    printf("nRow = nAlloc = 0;\n");
nRow = nAlloc = 0;
    printf("azResult = 0;\n");
azResult = 0;
    if( nArg>1 ){printf("if(nArg>1)\n");
    
      sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);
    }else{
      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);
    }
    while( sqlite3_step(pStmt)==SQLITE_ROW ){
      if( nRow>=nAlloc ){
        char **azNew;
        int n = nAlloc*2 + 10;
        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);
        if( azNew==0 ){
          fprintf(stderr, "Error: out of memory\n");
          break;
        }
        nAlloc = n;
        azResult = azNew;
      }
      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));
      if( azResult[nRow] ) nRow++;
    }
    sqlite3_finalize(pStmt);        
    if( nRow>0 ){printf("if(nRow>0)\n");
    
      printf("int len, maxlen = 0;\n");
      int len, maxlen = 0;
      printf("int i, j;\n");
      int i, j;
      printf("int nPrintCol, nPrintRow;\n");
      int nPrintCol, nPrintRow;
      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");
      
        printf("len = strlen30(azResult[i]);\n");
len = strlen30(azResult[i]);
        if( len>maxlen ) {printf("if(len>maxlen)\n");
        printf("maxlen = len;\n");
maxlen = len;}
      }
      printf("nPrintCol = 80/(maxlen+2);\n");
nPrintCol = 80/(maxlen+2);
      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");
      printf("nPrintCol = 1;\n");
nPrintCol = 1;}
      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");
nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;
      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");
      
        for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");
        
          printf("char *zSp = j<nPrintRow ? '' : '  ';\n");
          char *zSp = j<nPrintRow ? "" : "  ";
          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");
          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");
        }
        printf("fprintf(p->out, ' ');\n");
        fprintf(p->out, "\n");
      }
    }
    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");
    printf("sqlite3_free(azResult[ii]);\n");
    sqlite3_free(azResult[ii]);}
    printf("sqlite3_free(azResult);\n");
    sqlite3_free(azResult);
  }else

  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");
  
    printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");
    static const struct {
       const char *zCtrlName;   /* Name of a test-control option */
       int ctrlCode;            /* Integer code for that option */
    } aCtrl[] = {
      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },
      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },
      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },
      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },
      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },
      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },
      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },
      { "assert",                SQLITE_TESTCTRL_ASSERT                 },
      { "always",                SQLITE_TESTCTRL_ALWAYS                 },
      { "reserve",               SQLITE_TESTCTRL_RESERVE                },
      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },
      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },
      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },
    };
    printf("int testctrl = -1;\n");
    int testctrl = -1;
    printf("int rc = 0;\n");
    int rc = 0;
    printf("int i, n;\n");
    int i, n;
    printf("open_db(p, 0);\n");
    open_db(p, 0);

    /* convert testctrl text option to value. allow any unique prefix
    ** of the option name, or a numerical value. */
    printf("n = strlen30(azArg[1]);\n");
n = strlen30(azArg[1]);
    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){
      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){
        if( testctrl<0 ){
          testctrl = aCtrl[i].ctrlCode;
        }else{
          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);
          testctrl = -1;
          break;
        }
      }
    }
    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);
    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");
    
      printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");
      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);
    }else{
      printf("switch(testctrl)\n");
      switch(testctrl){

        /* sqlite3_test_control(int, db, int) */
        case SQLITE_TESTCTRL_OPTIMIZATIONS:
        case SQLITE_TESTCTRL_RESERVE:             
          if( nArg==3 ){
            int opt = (int)strtol(azArg[2], 0, 0);        
            rc = sqlite3_test_control(testctrl, p->db, opt);
            fprintf(p->out, "%d (0x%08x)\n", rc, rc);
          } else {
            fprintf(stderr,"Error: testctrl %s takes a single int option\n",
                    azArg[1]);
          }
          break;

        /* sqlite3_test_control(int) */
        case SQLITE_TESTCTRL_PRNG_SAVE:           
        case SQLITE_TESTCTRL_PRNG_RESTORE:        
        case SQLITE_TESTCTRL_PRNG_RESET:
          if( nArg==2 ){
            rc = sqlite3_test_control(testctrl);
            fprintf(p->out, "%d (0x%08x)\n", rc, rc);
          } else {
            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);
          }
          break;

        /* sqlite3_test_control(int, uint) */
        case SQLITE_TESTCTRL_PENDING_BYTE:        
          if( nArg==3 ){
            unsigned int opt = (unsigned int)integerValue(azArg[2]);
            rc = sqlite3_test_control(testctrl, opt);
            fprintf(p->out, "%d (0x%08x)\n", rc, rc);
          } else {
            fprintf(stderr,"Error: testctrl %s takes a single unsigned"
                           " int option\n", azArg[1]);
          }
          break;
          
        /* sqlite3_test_control(int, int) */
        case SQLITE_TESTCTRL_ASSERT:              
        case SQLITE_TESTCTRL_ALWAYS:              
          if( nArg==3 ){
            int opt = booleanValue(azArg[2]);        
            rc = sqlite3_test_control(testctrl, opt);
            fprintf(p->out, "%d (0x%08x)\n", rc, rc);
          } else {
            fprintf(stderr,"Error: testctrl %s takes a single int option\n",
                            azArg[1]);
          }
          break;

        /* sqlite3_test_control(int, char *) */
#ifdef SQLITE_N_KEYWORD
        case SQLITE_TESTCTRL_ISKEYWORD:           
          if( nArg==3 ){
            const char *opt = azArg[2];        
            rc = sqlite3_test_control(testctrl, opt);
            fprintf(p->out, "%d (0x%08x)\n", rc, rc);
          } else {
            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",
                            azArg[1]);
          }
          break;
#endif

        case SQLITE_TESTCTRL_BITVEC_TEST:         
        case SQLITE_TESTCTRL_FAULT_INSTALL:       
        case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: 
        case SQLITE_TESTCTRL_SCRATCHMALLOC:       
        default:
          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",
                  azArg[1]);
          break;
      }
    }
  }else

  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");
  
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));
  }else
    
  if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0
   && nArg==2
  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");
  
    printf("enableTimer = booleanValue(azArg[1]);\n");
enableTimer = booleanValue(azArg[1]);
  }else
  
  if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");
  
    printf("open_db(p, 0);\n");
    open_db(p, 0);
    printf("output_file_close(p->traceOut);\n");
    output_file_close(p->traceOut);
    printf("p->traceOut = output_file_open(azArg[1]);\n");
p->traceOut = output_file_open(azArg[1]);
#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)
    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");
    
      sqlite3_trace(p->db, 0, 0);
    }else{
      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);
    }
#endif
  }else

  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");
  
    printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");
    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,
        sqlite3_libversion(), sqlite3_sourceid());
  }else

  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");
  
    printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");
    const char *zDbName = nArg==2 ? azArg[1] : "main";
    printf("char *zVfsName = 0;\n");
    char *zVfsName = 0;
    if( p->db ){printf("if()\n");
    
      sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);
      if( zVfsName ){printf("if(zVfsName)\n");
      
        printf("fprintf(p->out, '_s ', zVfsName);\n");
        fprintf(p->out, "%s\n", zVfsName);
        printf("sqlite3_free(zVfsName);\n");
        sqlite3_free(zVfsName);
      }
    }
  }else

#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){
    extern int sqlite3WhereTrace;
    sqlite3WhereTrace = booleanValue(azArg[1]);
  }else
#endif

  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");
  
    printf("int j;\n");
    int j;
    printf("assert( nArg<=ArraySize(azArg) );\n");
    assert( nArg<=ArraySize(azArg) );
    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");
    
      p->colWidth[j-1] = (int)integerValue(azArg[j]);
    }
  }else

  {
    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");
    fprintf(stderr, "Error: unknown command or invalid arguments: "
      " \"%s\". Enter \".help\" for help\n", azArg[0]);
    printf("rc = 1;\n");
rc = 1;
  }

  printf("return rc;\n");
  printf("------function end!------\n");
  return rc;
printf("------function end!------\n");
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
7,8
7,9
10,11
10,12
11,12
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
16,36
16,37
16,38
16,39
16,40
16,41
17,18
18,19
18,20
18,21
19,20
23,24
24,25
24,26
24,27
25,26
28,29
30,31
31,32
31,33
32,33
35,36
36,37
36,38
37,38
40,41
41,42
41,43
42,43
45,46
46,47
46,48
48,49
48,50
50,51
52,53
53,54
53,55
54,55
57,58
58,59
58,60
60,61
60,62
62,63
64,65
65,66
65,67
66,67
69,70
70,71
70,72
70,73
72,73
74,75
76,77
77,78
77,79
78,79
81,82
82,83
82,84
84,85
84,86
86,87
88,89
89,90
89,91
90,91
93,94
94,95
94,96
96,97
96,98
96,99
99,100
101,102
101,103
102,103
102,104
103,104
103,105
104,105
106,107
108,109
108,110
109,110
111,112
111,113
112,113
114,115
116,117
116,118
116,119
116,120
117,118
118,119
118,120
119,120
122,123
122,124
123,124
123,125
124,125
126,127
126,128
127,128
129,130
131,132
131,133
131,134
132,133
133,134
133,135
134,135
137,138
138,139
138,140
139,140
142,143
143,144
144,145
146,147
146,148
147,148
147,149
148,149
148,150
149,150
151,152
154,155
154,156
155,156
156,157
156,158
157,158
161,162
161,163
161,164
162,163
162,164
163,164
163,165
164,165
164,166
165,166
167,168
170,171
170,172
171,172
171,173
172,173
174,175
177,178
177,179
177,180
177,181
177,182
177,183
177,184
177,185
178,179
179,180
179,181
180,181
183,184
184,185
184,186
185,186
188,189
189,190
189,191
191,192
191,193
193,194
194,195
194,196
195,196
197,198
198,199
200,201
201,202
201,203
202,203
205,206
206,207
206,208
207,208
207,209
208,209
210,211
211,212
213,214
214,215
214,216
215,216
217,218
219,220
219,221
220,221
220,222
221,222
221,223
222,223
224,225
226,227
226,228
227,228
227,229
228,229
230,231
232,233
234,235
234,236
234,237
234,238
235,236
236,237
236,238
237,238
240,241
240,242
241,242
241,243
242,243
242,244
243,244
243,245
244,245
244,246
245,246
247,248
250,251
250,252
251,252
254,255
254,256
255,256
255,257
256,257
258,259
258,260
259,260
263,264
263,265
263,266
264,265
265,266
265,267
266,267
269,270
270,271
270,272
271,272
274,275
275,276
276,277
278,279
279,280
279,281
280,281
283,284
284,285
285,286
287,288
287,289
288,289
288,290
289,290
289,291
290,291
292,293
294,295
296,297
296,298
296,299
297,298
298,299
298,300
299,300
302,303
303,304
303,305
304,305
307,308
308,309
308,310
309,310
309,311
310,311
312,313
313,314
316,317
316,318
317,318
317,319
318,319
321,322
321,323
321,324
322,323
323,324
323,325
324,325
327,328
328,329
328,330
329,330
332,333
333,334
333,335
334,335
336,337
336,338
337,338
339,340
339,341
340,341
343,344
343,345
343,346
343,347
343,348
343,349
344,345
345,346
345,347
346,347
349,350
350,351
350,352
351,352
351,353
352,353
354,355
355,356
357,358
358,359
358,360
359,360
361,362
363,364
363,365
364,365
364,366
365,366
365,367
366,367
368,369
370,371
371,372
371,373
372,373
374,375
374,376
375,376
377,378
379,380
379,381
379,382
380,381
381,382
381,383
382,383
385,386
386,387
386,388
387,388
390,391
391,392
392,393
394,395
394,396
395,396
395,397
396,397
398,399
400,401
400,402
400,403
401,402
402,403
402,404
403,404
406,407
407,408
407,409
408,409
411,412
412,413
412,414
413,414
413,415
414,415
416,417
417,418
420,421
421,422
421,423
422,423
425,426
426,427
426,428
427,428
429,430
429,431
430,431
432,433
432,434
433,434
436,437
436,438
437,438
437,439
438,439
441,442
441,443
441,444
441,445
442,443
443,444
443,445
444,445
447,448
448,449
448,450
449,450
452,453
453,454
453,455
454,455
457,458
459,460
460,461
460,462
461,462
464,465
465,466
465,467
466,467
468,469
468,470
469,470
471,472
471,473
472,473
475,476
476,477
476,478
477,478
480,481
481,482
481,483
482,483
484,485
484,486
485,486
485,487
486,487
490,491
490,492
490,493
491,492
491,493
492,493
492,494
493,494
493,495
494,495
497,498
497,499
498,499
501,502
501,503
502,503
502,504
502,505
502,506
503,504
505,506
505,507
506,507
510,511
513,514
513,515
513,516
513,517
513,518
513,519
513,520
513,521
513,522
513,523
513,524
513,525
513,526
513,527
513,528
513,529
513,530
513,531
513,532
513,533
513,534
513,535
514,515
515,516
515,517
516,517
519,520
520,521
520,522
521,522
524,525
525,526
525,527
527,528
527,529
527,530
530,531
532,533
533,534
533,535
534,535
537,538
538,539
538,540
540,541
540,542
540,543
543,544
545,546
546,547
546,548
547,548
549,550
549,551
552,553
553,554
553,555
554,555
556,557
556,558
559,560
560,561
560,562
561,562
564,565
565,566
565,567
567,568
569,570
569,571
569,572
569,573
570,571
571,572
571,573
572,573
575,576
575,577
576,577
578,579
580,581
581,582
583,584
583,585
583,586
583,587
584,585
585,586
585,587
586,587
589,590
590,591
590,592
591,592
594,595
595,596
595,597
597,598
597,599
597,600
600,601
601,602
601,603
602,603
604,605
606,607
606,608
606,609
607,608
607,609
608,609
608,610
609,610
613,614
613,615
613,616
613,617
614,615
615,616
615,617
616,617
619,620
619,621
620,621
620,622
621,622
621,623
622,623
626,627
626,628
626,629
627,628
628,629
628,630
629,630
632,633
633,634
633,635
634,635
637,638
638,639
639,640
641,642
642,643
642,644
643,644
646,647
646,648
646,649
646,650
646,651
647,648
648,649
648,650
649,650
652,653
653,654
653,655
653,656
653,657
654,655
656,657
659,660
659,661
660,661
662,663
664,665
665,666
665,667
666,667
669,670
670,671
670,672
671,672
674,675
676,677
676,678
676,679
677,678
677,679
678,679
681,682
681,683
681,684
682,683
683,684
683,685
684,685
687,688
688,689
688,690
689,690
692,693
693,694
693,695
694,695
696,697
696,698
697,698
699,700
701,702
701,703
701,704
702,703
702,704
703,704
706,707
706,708
706,709
706,710
706,711
707,708
708,709
708,710
709,710
712,713
713,714
713,715
714,715
717,718
718,719
718,720
719,720
721,722
723,724
724,725
724,726
725,726
728,729
729,730
729,731
730,731
732,733
732,734
733,734
735,736
737,738
737,739
737,740
737,741
737,742
738,739
739,740
739,741
740,741
743,744
744,745
744,746
744,747
745,746
747,748
750,751
751,752
751,753
752,753
755,756
756,757
756,758
757,758
760,761
762,763
762,764
763,764
763,765
764,765
767,768
767,769
767,770
767,771
767,772
767,773
768,769
769,770
769,771
770,771
773,774
774,775
774,776
775,776
778,779
779,780
779,781
779,782
780,781
782,783
785,786
786,787
786,788
787,788
790,791
791,792
791,793
792,793
795,796
797,798
797,799
798,799
798,800
799,800
802,803
802,804
802,805
803,804
804,805
804,806
805,806
808,809
809,810
809,811
810,811
813,814
814,815
814,816
815,816
818,819
819,820
819,821
820,821
822,823
822,824
822,825
823,824
825,826
827,828
828,829
830,831
830,832
831,832
831,833
832,833
834,835
836,837
836,838
836,839
836,840
836,841
836,842
836,843
837,838
838,839
838,840
839,840
842,843
843,844
843,845
844,845
847,848
848,849
848,850
848,851
848,852
849,850
851,852
854,855
856,857
857,858
857,859
858,859
860,861
862,863
863,864
863,865
864,865
867,868
868,869
868,870
869,870
872,873
874,875
875,876
875,877
876,877
879,880
880,881
880,882
880,883
881,882
883,884
886,887
887,888
887,889
888,889
890,891
890,892
890,893
890,894
890,895
891,892
893,894
896,897
896,898
897,898
900,901
902,903
902,904
903,904
903,905
904,905
907,908
907,909
907,910
907,911
907,912
907,913
908,909
909,910
909,911
910,911
913,914
914,915
914,916
914,917
914,918
915,916
917,918
920,921
920,922
921,922
923,924
925,926
926,927
926,928
927,928
929,930
931,932
932,933
932,934
933,934
936,937
937,938
937,939
938,939
941,942
943,944
943,945
944,945
944,946
945,946
946,947
946,948
947,948
949,950
949,951
949,952
950,951
952,953
955,956
958,959
959,960
959,961
960,961
962,963
964,965
964,966
964,967
965,966
965,967
966,967
968,969
970,971
970,972
970,973
971,972
972,973
972,974
973,974
976,977
977,978
977,979
978,979
981,982
982,983
982,984
983,984
986,987
986,988
986,989
987,988
988,989
988,990
988,991
988,992
989,990
991,992
994,995
994,996
995,996
997,998
999,1000
1000,1001
1000,1002
1001,1002
1004,1005
1005,1006
1005,1007
1006,1007
1009,1010
1010,1011
1010,1012
1011,1012
1013,1014
1015,1016
1015,1017
1015,1018
1016,1017
1016,1018
1017,1018
1017,1019
1018,1019
1018,1020
1019,1020
1019,1021
1020,1021
1020,1022
1021,1022
1024,1025
1024,1026
1025,1026
1028,1029
1028,1030
1029,1030
1029,1031
1029,1032
1029,1033
1030,1031
1032,1033
1032,1034
1033,1034
1037,1038
1040,1041
1040,1042
1041,1042
1044,1045
1044,1046
1045,1046
1048,1049
1048,1050
1048,1051
1049,1050
1050,1051
1050,1052
1051,1052
1054,1055
1055,1056
1055,1057
1056,1057
1059,1060
1060,1061
1060,1062
1061,1062
1063,1064
1063,1065
1064,1065
1066,1067
1066,1068
1067,1068
1070,1071
1070,1072
1070,1073
1071,1072
1071,1073
1072,1073
1072,1074
1073,1074
1073,1075
1074,1075
1077,1078
1077,1079
1078,1079
1081,1082
1081,1083
1082,1083
1082,1084
1082,1085
1082,1086
1083,1084
1085,1086
1085,1087
1086,1087
1090,1091
1093,1094
1093,1095
1093,1096
1094,1095
1095,1096
1095,1097
1096,1097
1099,1100
1100,1101
1100,1102
1101,1102
1104,1105
1105,1106
1106,1107
1108,1109
1108,1110
1108,1111
1109,1110
1109,1111
1110,1111
1110,1112
1111,1112
1111,1113
1112,1113
1112,1114
1113,1114
1116,1117
1116,1118
1117,1118
1120,1121
1120,1122
1121,1122
1121,1123
1121,1124
1121,1125
1122,1123
1124,1125
1124,1126
1125,1126
1129,1130
1132,1133
1132,1134
1133,1134
1136,1137
1136,1138
1136,1139
1136,1140
1136,1141
1136,1142
1136,1143
1136,1144
1136,1145
1136,1146
1136,1147
1136,1148
1136,1149
1136,1150
1136,1151
1136,1152
1136,1153
1136,1154
1136,1155
1136,1156
1136,1157
1136,1158
1136,1159
1137,1138
1138,1139
1138,1140
1139,1140
1142,1143
1143,1144
1143,1145
1144,1145
1147,1148
1148,1149
1148,1150
1149,1150
1151,1152
1153,1154
1154,1155
1154,1156
1155,1156
1158,1159
1159,1160
1159,1161
1161,1162
1161,1163
1161,1164
1164,1165
1166,1167
1167,1168
1167,1169
1168,1169
1171,1172
1172,1173
1172,1174
1172,1175
1173,1174
1175,1176
1178,1179
1179,1180
1179,1181
1180,1181
1183,1184
1184,1185
1184,1186
1184,1187
1184,1188
1185,1186
1187,1188
1188,1189
1190,1191
1192,1193
1193,1194
1194,1195
1196,1197
1197,1198
1197,1199
1198,1199
1201,1202
1202,1203
1202,1204
1203,1204
1203,1205
1204,1205
1208,1209
1209,1210
1209,1211
1210,1211
1213,1214
1214,1215
1214,1216
1215,1216
1215,1217
1216,1217
1219,1220
1221,1222
1222,1223
1222,1224
1223,1224
1226,1227
1227,1228
1227,1229
1228,1229
1228,1230
1229,1230
1229,1231
1230,1231
1235,1236
1236,1237
1236,1238
1237,1238
1240,1241
1241,1242
1241,1243
1242,1243
1242,1244
1243,1244
1243,1245
1244,1245
1249,1250
1250,1251
1250,1252
1251,1252
1254,1255
1255,1256
1255,1257
1256,1257
1256,1258
1257,1258
1257,1259
1258,1259
1263,1264
1264,1265
1264,1266
1265,1266
1268,1269
1269,1270
1269,1271
1270,1271
1270,1272
1271,1272
1275,1276
1276,1277
1276,1278
1276,1279
1276,1280
1276,1281
1276,1282
1277,1278
1279,1280
1279,1281
1280,1281
1284,1285
1286,1287
1287,1288
1289,1290
1290,1291
1292,1293
1292,1294
1293,1294
1295,1296
1295,1297
1295,1298
1295,1299
1295,1300
1295,1301
1295,1302
1296,1297
1297,1298
1297,1299
1298,1299
1301,1302
1302,1303
1302,1304
1303,1304
1306,1307
1307,1308
1307,1309
1307,1310
1307,1311
1308,1309
1310,1311
1313,1314
1315,1316
1316,1317
1316,1318
1317,1318
1320,1321
1321,1322
1321,1323
1322,1323
1324,1325
1326,1327
1327,1328
1327,1329
1328,1329
1331,1332
1332,1333
1332,1334
1333,1334
1336,1337
1336,1338
1336,1339
1337,1338
1337,1339
1338,1339
1338,1340
1339,1340
1339,1341
1340,1341
1343,1344
1343,1345
1344,1345
1344,1346
1344,1347
1344,1348
1345,1346
1347,1348
1347,1349
1348,1349
1352,1353
1355,1356
1355,1357
1356,1357
1359,1360
1359,1361
1359,1362
1359,1363
1359,1364
1359,1365
1359,1366
1359,1367
1359,1368
1359,1369
1359,1370
1359,1371
1359,1372
1359,1373
1359,1374
1359,1375
1359,1376
1359,1377
1360,1361
1361,1362
1361,1363
1362,1363
1365,1366
1366,1367
1366,1368
1367,1368
1370,1371
1371,1372
1371,1373
1371,1374
1372,1373
1374,1375
1377,1378
1378,1379
1378,1380
1379,1380
1382,1383
1383,1384
1383,1385
1383,1386
1384,1385
1386,1387
1386,1388
1387,1388
1391,1392
1392,1393
1392,1394
1393,1394
1396,1397
1397,1398
1397,1399
1397,1400
1398,1399
1400,1401
1400,1402
1401,1402
1405,1406
1406,1407
1406,1408
1407,1408
1410,1411
1411,1412
1411,1413
1412,1413
1412,1414
1413,1414
1417,1418
1418,1419
1418,1420
1418,1421
1418,1422
1418,1423
1418,1424
1419,1420
1421,1422
1421,1423
1422,1423
1429,1430
1430,1431
1430,1432
1431,1432
1434,1435
1435,1436
1435,1437
1436,1437
1436,1438
1437,1438
1441,1442
1441,1443
1441,1444
1442,1443
1442,1444
1443,1444
1446,1447
1446,1448
1446,1449
1446,1450
1446,1451
1446,1452
1446,1453
1447,1448
1448,1449
1448,1450
1449,1450
1452,1453
1453,1454
1453,1455
1454,1455
1457,1458
1458,1459
1458,1460
1458,1461
1459,1460
1461,1462
1464,1465
1465,1466
1465,1467
1466,1467
1469,1470
1470,1471
1470,1472
1470,1473
1471,1472
1473,1474
1476,1477
1477,1478
1477,1479
1478,1479
1481,1482
1482,1483
1482,1484
1482,1485
1482,1486
1483,1484
1485,1486
1489,1490
1489,1491
1489,1492
1490,1491
1491,1492
1491,1493
1492,1493
1495,1496
1496,1497
1496,1498
1498,1499
1500,1501
1500,1502
1500,1503
1500,1504
1501,1502
1502,1503
1502,1504
1503,1504
1506,1507
1506,1508
1507,1508
1509,1510
1511,1512
1512,1513
1514,1515
1514,1516
1514,1517
1514,1518
1514,1519
1514,1520
1514,1521
1514,1522
1514,1523
1515,1516
1516,1517
1516,1518
1517,1518
1520,1521
1521,1522
1521,1523
1522,1523
1525,1526
1526,1527
1526,1528
1527,1528
1529,1530
1529,1531
1530,1531
1532,1533
1534,1535
1535,1536
1535,1537
1536,1537
1539,1540
1540,1541
1540,1542
1540,1543
1541,1542
1543,1544
1546,1547
1547,1548
1547,1549
1548,1549
1551,1552
1552,1553
1552,1554
1552,1555
1552,1556
1553,1554
1555,1556
1559,1560
1560,1561
1560,1562
1561,1562
1564,1565
1565,1566
1565,1567
1566,1567
1569,1570
1569,1571
1570,1571
1570,1572
1571,1572
1574,1575
1574,1576
1574,1577
1574,1578
1574,1579
1575,1576
1576,1577
1576,1578
1577,1578
1580,1581
1581,1582
1581,1583
1582,1583
1585,1586
1586,1587
1586,1588
1586,1589
1587,1588
1589,1590
1589,1591
1590,1591
1594,1595
1595,1596
1595,1597
1596,1597
1599,1600
1600,1601
1600,1602
1601,1602
1601,1603
1602,1603
1606,1607
1607,1608
1607,1609
1607,1610
1607,1611
1607,1612
1607,1613
1608,1609
1610,1611
1610,1612
1611,1612
1618,1619
1619,1620
1619,1621
1619,1622
1619,1623
1619,1624
1619,1625
1620,1621
1622,1623
1622,1624
1623,1624
1630,1631
1631,1632
1631,1633
1632,1633
1635,1636
1636,1637
1636,1638
1636,1639
1637,1638
1639,1640
1639,1641
1640,1641
1643,1644
1643,1645
1643,1646
1644,1645
1644,1646
1645,1646
1650,1651
1650,1652
1650,1653
1651,1652
1651,1653
1652,1653
1652,1654
1653,1654
1653,1655
1654,1655
1654,1656
1655,1656
1658,1659
1658,1660
1659,1660
1659,1661
1659,1662
1659,1663
1660,1661
1662,1663
1662,1664
1663,1664
1667,1668
1670,1671
1670,1672
1671,1672
1674,1675
1674,1676
1675,1676
1678,1679
1678,1680
1678,1681
1679,1680
1680,1681
1680,1682
1681,1682
1684,1685
1685,1686
1685,1687
1686,1687
1689,1690
1690,1691
1690,1692
1691,1692
1691,1693
1692,1693
1695,1696
1695,1697
1696,1697
1698,1699
1698,1700
1699,1700
1702,1703
1702,1704
1702,1705
1703,1704
1703,1705
1704,1705
1704,1706
1705,1706
1708,1709
1708,1710
1709,1710
1709,1711
1709,1712
1709,1713
1710,1711
1712,1713
1712,1714
1713,1714
1717,1718
1720,1721
1720,1722
1720,1723
1720,1724
1721,1722
1722,1723
1722,1724
1723,1724
1726,1727
1726,1728
1727,1728
1727,1729
1728,1729
1728,1730
1729,1730
1732,1733
1732,1734
1733,1734
1734,1735
1734,1736
1735,1736
1737,1738
1737,1739
1738,1739
1738,1740
1741,1742
1741,1743
1742,1743
1744,1745
1744,1746
1745,1746
1749,1750
1749,1751
1749,1752
1750,1751
1751,1752
1751,1753
1752,1753
1755,1756
1756,1757
1756,1758
1757,1758
1760,1761
1761,1762
1761,1763
1762,1763
1764,1765
1766,1767
1767,1768
1767,1769
1768,1769
1771,1772
1772,1773
1772,1774
1773,1774
1776,1777
1776,1778
1776,1779
1777,1778
1777,1779
1778,1779
1778,1780
1779,1780
1779,1781
1780,1781
1783,1784
1783,1785
1784,1785
1784,1786
1784,1787
1784,1788
1785,1786
1787,1788
1787,1789
1788,1789
1792,1793
1795,1796
1795,1797
1796,1797
1799,1800
1799,1801
1799,1802
1799,1803
1800,1801
1801,1802
1801,1803
1802,1803
1805,1806
1806,1807
1806,1808
1807,1808
1810,1811
1811,1812
1811,1813
1813,1814
1813,1815
1815,1816
1816,1817
1816,1818
1816,1819
1817,1818
1817,1819
1818,1819
1821,1822
1821,1823
1822,1823
1824,1825
1824,1826
1825,1826
1829,1830
1829,1831
1829,1832
1830,1831
1830,1832
1831,1832
1834,1835
1834,1836
1834,1837
1834,1838
1834,1839
1834,1840
1834,1841
1834,1842
1834,1843
1834,1844
1834,1845
1834,1846
1834,1847
1834,1848
1834,1849
1834,1850
1834,1851
1834,1852
1834,1853
1834,1854
1834,1855
1834,1856
1834,1857
1834,1858
1835,1836
1836,1837
1836,1838
1837,1838
1840,1841
1840,1842
1841,1842
1842,1843
1842,1844
1843,1844
1843,1845
1844,1845
1848,1849
1848,1850
1848,1851
1848,1852
1848,1853
1848,1854
1848,1855
1848,1856
1848,1857
1849,1850
1850,1851
1850,1852
1851,1852
1854,1855
1855,1856
1855,1857
1856,1857
1859,1860
1860,1861
1860,1862
1861,1862
1861,1863
1862,1863
1862,1864
1863,1864
1868,1869
1869,1870
1869,1871
1870,1871
1873,1874
1874,1875
1874,1876
1875,1876
1875,1877
1876,1877
1876,1878
1877,1878
1881,1882
1881,1883
1882,1883
1885,1886
1886,1887
1886,1888
1887,1888
1890,1891
1891,1892
1891,1893
1892,1893
1892,1894
1893,1894
1893,1895
1894,1895
1898,1899
1898,1900
1899,1900
1902,1903
1903,1904
1903,1905
1904,1905
1907,1908
1908,1909
1908,1910
1908,1911
1908,1912
1909,1910
1911,1912
1911,1913
1912,1913
1912,1914
1913,1914
1917,1918
1917,1919
1918,1919
1921,1922
1922,1923
1923,1924
1923,1925
1924,1925
1927,1928
1928,1929
1928,1930
1929,1930
1932,1933
1933,1934
1933,1935
1934,1935
1934,1936
1935,1936
1938,1939
1940,1941
1941,1942
1941,1943
1942,1943
1945,1946
1946,1947
1946,1948
1947,1948
1947,1949
1948,1949
1952,1953
1953,1954
1953,1955
1954,1955
1957,1958
1958,1959
1958,1960
1958,1961
1958,1962
1959,1960
1961,1962
1961,1963
1962,1963
1966,1967
1967,1968
1968,1969
1968,1970
1969,1970
1972,1973
1973,1974
1973,1975
1974,1975
1977,1978
1978,1979
1978,1980
1979,1980
1979,1981
1980,1981
1980,1982
1981,1982
1986,1987
1987,1988
1987,1989
1988,1989
1991,1992
1992,1993
1992,1994
1993,1994
1993,1995
1994,1995
1994,1996
1995,1996
2000,2001
2001,2002
2001,2003
2002,2003
2005,2006
2006,2007
2006,2008
2007,2008
2007,2009
2008,2009
2008,2010
2009,2010
2014,2015
2015,2016
2015,2017
2016,2017
2019,2020
2020,2021
2020,2022
2021,2022
2021,2023
2022,2023
2022,2024
2023,2024
2028,2029
2029,2030
2029,2031
2030,2031
2033,2034
2034,2035
2034,2036
2035,2036
2035,2037
2036,2037
2036,2038
2037,2038
2042,2043
2043,2044
2043,2045
2044,2045
2047,2048
2048,2049
2048,2050
2049,2050
2049,2051
2050,2051
2050,2052
2051,2052
2056,2057
2057,2058
2057,2059
2058,2059
2061,2062
2062,2063
2062,2064
2063,2064
2063,2065
2064,2065
2064,2066
2065,2066
2070,2071
2071,2072
2071,2073
2072,2073
2075,2076
2076,2077
2076,2078
2077,2078
2077,2079
2078,2079
2078,2080
2079,2080
2084,2085
2084,2086
2085,2086
2085,2087
2086,2087
2086,2088
2087,2088
2091,2092
2091,2093
2091,2094
2091,2095
2091,2096
2091,2097
2091,2098
2091,2099
2091,2100
2092,2093
2093,2094
2093,2095
2094,2095
2097,2098
2098,2099
2098,2100
2099,2100
2102,2103
2103,2104
2103,2105
2104,2105
2104,2106
2105,2106
2105,2107
2106,2107
2111,2112
2112,2113
2112,2114
2113,2114
2116,2117
2117,2118
2117,2119
2118,2119
2118,2120
2119,2120
2122,2123
2122,2124
2123,2124
2123,2125
2124,2125
2128,2129
2129,2130
2129,2131
2130,2131
2133,2134
2134,2135
2134,2136
2135,2136
2135,2137
2136,2137
2139,2140
2139,2141
2140,2141
2140,2142
2141,2142
2145,2146
2146,2147
2146,2148
2147,2148
2150,2151
2151,2152
2151,2153
2151,2154
2151,2155
2152,2153
2154,2155
2154,2156
2155,2156
2158,2159
2158,2160
2159,2160
2159,2161
2160,2161
2164,2165
2165,2166
2166,2167
2166,2168
2167,2168
2170,2171
2170,2172
2170,2173
2171,2172
2171,2173
2172,2173
2172,2174
2173,2174
2173,2175
2174,2175
2174,2176
2175,2176
2178,2179
2179,2180
2179,2181
2180,2181
2180,2182
2181,2182
2181,2183
2181,2184
2181,2185
2182,2183
2184,2185
2184,2186
2185,2186
2189,2190
2192,2193
2192,2194
2193,2194
2193,2195
2193,2196
2193,2197
2194,2195
2196,2197
2196,2198
2197,2198
2201,2202
2204,2205
2204,2206
2205,2206
2208,2209
2208,2210
2209,2210
2212,2213
2212,2214
2212,2215
2213,2214
2214,2215
2214,2216
2215,2216
2218,2219
2219,2220
2219,2221
2220,2221
2223,2224
2224,2225
2224,2226
2225,2226
2225,2227
2226,2227
2229,2230
2229,2231
2230,2231
2232,2233
2232,2234
2233,2234
2236,2237
2236,2238
2236,2239
2237,2238
2237,2239
2238,2239
2238,2240
2239,2240
2242,2243
2242,2244
2243,2244
2243,2245
2243,2246
2243,2247
2244,2245
2246,2247
2246,2248
2247,2248
2251,2252
2254,2255
2254,2256
2254,2257
2254,2258
2255,2256
2256,2257
2256,2258
2257,2258
2260,2261
2261,2262
2261,2263
2262,2263
2265,2266
2266,2267
2266,2268
2266,2269
2266,2270
2267,2268
2269,2270
2272,2273
2274,2275
2274,2276
2275,2276
2277,2278
2277,2279
2277,2280
2278,2279
2279,2280
2279,2281
2280,2281
2283,2284
2284,2285
2284,2286
2285,2286
2288,2289
2289,2290
2289,2291
2289,2292
2289,2293
2290,2291
2292,2293
2295,2296
2297,2298
2297,2299
2297,2300
2298,2299
2298,2300
2299,2300
2299,2301
2300,2301
2300,2302
2301,2302
2304,2305
2304,2306
2305,2306
2305,2307
2305,2308
2305,2309
2306,2307
2308,2309
2308,2310
2309,2310
2313,2314
2316,2317
2316,2318
2317,2318
2320,2321
2320,2322
2320,2323
2320,2324
2320,2325
2320,2326
2320,2327
2320,2328
2320,2329
2320,2330
2320,2331
2320,2332
2320,2333
2320,2334
2320,2335
2320,2336
2320,2337
2320,2338
2320,2339
2320,2340
2320,2341
2320,2342
2320,2343
2320,2344
2320,2345
2320,2346
2320,2347
2320,2348
2320,2349
2320,2350
2320,2351
2320,2352
2320,2353
2320,2354
2320,2355
2320,2356
2320,2357
2320,2358
2320,2359
2320,2360
2320,2361
2320,2362
2320,2363
2320,2364
2320,2365
2320,2366
2320,2367
2320,2368
2320,2369
2320,2370
2320,2371
2320,2372
2320,2373
2320,2374
2320,2375
2320,2376
2320,2377
2320,2378
2320,2379
2320,2380
2320,2381
2320,2382
2320,2383
2320,2384
2320,2385
2320,2386
2320,2387
2320,2388
2320,2389
2320,2390
2320,2391
2320,2392
2320,2393
2320,2394
2320,2395
2320,2396
2320,2397
2320,2398
2320,2399
2321,2322
2322,2323
2322,2324
2323,2324
2326,2327
2327,2328
2327,2329
2328,2329
2331,2332
2332,2333
2332,2334
2334,2335
2334,2336
2334,2337
2337,2338
2338,2339
2338,2340
2339,2340
2342,2343
2343,2344
2343,2345
2344,2345
2347,2348
2348,2349
2348,2350
2350,2351
2350,2352
2350,2353
2353,2354
2354,2355
2354,2356
2355,2356
2358,2359
2359,2360
2359,2361
2360,2361
2362,2363
2362,2364
2362,2365
2365,2366
2366,2367
2368,2369
2369,2370
2369,2371
2370,2371
2373,2374
2374,2375
2374,2376
2376,2377
2378,2379
2379,2380
2379,2381
2380,2381
2383,2384
2384,2385
2384,2386
2386,2387
2388,2389
2389,2390
2389,2391
2390,2391
2393,2394
2394,2395
2394,2396
2394,2397
2396,2397
2398,2399
2400,2401
2401,2402
2401,2403
2402,2403
2405,2406
2406,2407
2406,2408
2408,2409
2410,2411
2411,2412
2411,2413
2412,2413
2415,2416
2416,2417
2416,2418
2418,2419
2420,2421
2421,2422
2421,2423
2422,2423
2425,2426
2426,2427
2426,2428
2428,2429
2428,2430
2431,2432
2432,2433
2432,2434
2433,2434
2436,2437
2437,2438
2437,2439
2438,2439
2440,2441
2442,2443
2443,2444
2443,2445
2444,2445
2447,2448
2448,2449
2448,2450
2450,2451
2450,2452
2451,2452
2451,2453
2454,2455
2454,2456
2455,2456
2457,2458
2457,2459
2460,2461
2461,2462
2461,2463
2462,2463
2465,2466
2466,2467
2466,2468
2467,2468
2470,2471
2471,2472
2471,2473
2472,2473
2475,2476
2476,2477
2476,2478
2476,2479
2476,2480
2477,2478
2479,2480
2480,2481
2483,2484
2484,2485
2485,2486
2487,2488
2488,2489
2488,2490
2489,2490
2492,2493
2493,2494
2493,2495
2493,2496
2494,2495
2496,2497
2499,2500
2500,2501
2500,2502
2501,2502
2504,2505
2505,2506
2505,2507
2506,2507
2508,2509
2508,2510
2509,2510
2511,2512
2511,2513
2512,2513
2515,2516
2515,2517
2516,2517
2516,2518
2517,2518
2520,2521
2520,2522
2520,2523
2520,2524
2520,2525
2520,2526
2521,2522
2522,2523
2522,2524
2523,2524
2526,2527
2527,2528
2527,2529
2528,2529
2531,2532
2532,2533
2532,2534
2532,2535
2533,2534
2535,2536
2538,2539
2539,2540
2539,2541
2540,2541
2543,2544
2544,2545
2544,2546
2545,2546
2548,2549
2550,2551
2550,2552
2551,2552
2551,2553
2552,2553
2555,2556
2555,2557
2555,2558
2555,2559
2555,2560
2555,2561
2556,2557
2557,2558
2557,2559
2558,2559
2561,2562
2562,2563
2562,2564
2563,2564
2566,2567
2567,2568
2567,2569
2567,2570
2568,2569
2570,2571
2573,2574
2574,2575
2574,2576
2575,2576
2578,2579
2579,2580
2579,2581
2580,2581
2583,2584
2585,2586
2586,2587
2586,2588
2587,2588
2590,2591
2591,2592
2591,2593
2592,2593
2592,2594
2593,2594
2596,2597
2598,2599
2599,2600
2599,2601
2600,2601
2603,2604
2604,2605
2604,2606
2605,2606
2605,2607
2606,2607
2610,2611
2610,2612
2610,2613
2611,2612
2611,2613
2612,2613
2612,2614
2613,2614
2613,2615
2614,2615
2619,2620
2619,2621
2619,2622
2619,2623
2619,2624
2619,2625
2619,2626
2620,2621
2621,2622
2621,2623
2622,2623
2625,2626
2626,2627
2626,2628
2627,2628
2630,2631
2631,2632
2631,2633
2632,2633
2632,2634
2633,2634
2636,2637
2636,2638
2636,2639
2637,2638
2639,2640
2639,2641
2640,2641
2640,2642
2641,2642
2646,2647
2647,2648
2647,2649
2648,2649
2651,2652
2652,2653
2652,2654
2653,2654
2653,2655
2654,2655
2658,2659
2659,2660
2659,2661
2660,2661
2663,2664
2664,2665
2664,2666
2665,2666
2667,2668
2669,2670
2669,2671
2669,2672
2669,2673
2670,2671
2671,2672
2671,2673
2672,2673
2675,2676
2676,2677
2676,2678
2677,2678
2677,2679
2678,2679
2681,2682
2681,2683
2681,2684
2682,2683
2684,2685
2684,2686
2685,2686
2689,2690
2690,2691
2690,2692
2691,2692
2694,2695
2695,2696
2695,2697
2696,2697
2698,2699
2700,2701
2700,2702
2701,2702
2701,2703
2702,2703
2702,2704
2703,2704
2707,2708
2707,2709
2707,2710
2707,2711
2707,2712
2707,2713
2708,2709
2709,2710
2709,2711
2710,2711
2713,2714
2714,2715
2714,2716
2715,2716
2718,2719
2719,2720
2719,2721
2719,2722
2719,2723
2720,2721
2722,2723
2725,2726
2727,2728
2728,2729
2728,2730
2729,2730
2732,2733
2733,2734
2733,2735
2734,2735
2737,2738
2739,2740
2740,2741
2740,2742
2741,2742
2744,2745
2745,2746
2745,2747
2746,2747
2746,2748
2747,2748
2750,2751
2750,2752
2751,2752
2751,2753
2752,2753
2756,2757
2757,2758
2757,2759
2758,2759
2761,2762
2762,2763
2762,2764
2763,2764
2765,2766
2765,2767
2765,2768
2766,2767
2769,2770
2771,2772
2771,2773
2772,2773
2772,2774
2773,2774
2776,2777
2776,2778
2776,2779
2776,2780
2776,2781
2776,2782
2776,2783
2776,2784
2777,2778
2778,2779
2778,2780
2779,2780
2782,2783
2783,2784
2783,2785
2784,2785
2787,2788
2788,2789
2788,2790
2788,2791
2789,2790
2791,2792
2794,2795
2795,2796
2795,2797
2796,2797
2799,2800
2800,2801
2800,2802
2801,2802
2803,2804
2803,2805
2804,2805
2807,2808
2808,2809
2808,2810
2809,2810
2812,2813
2813,2814
2813,2815
2814,2815
2817,2818
2819,2820
2820,2821
2820,2822
2821,2822
2824,2825
2825,2826
2825,2827
2826,2827
2828,2829
2828,2830
2829,2830
2831,2832
2833,2834
2834,2835
2834,2836
2835,2836
2837,2838
2837,2839
2837,2840
2837,2841
2837,2842
2837,2843
2838,2839
2840,2841
2840,2842
2841,2842
2844,2845
2846,2847
2848,2849
2849,2850
2852,2853
2852,2854
2853,2854
2853,2855
2854,2855
2856,2857
2856,2858
2857,2858
2857,2859
2857,2860
2858,2859
2861,2862
2861,2863
2862,2863
2864,2865
2867,2868
2867,2869
2867,2870
2867,2871
2867,2872
2867,2873
2867,2874
2867,2875
2867,2876
2867,2877
2867,2878
2867,2879
2867,2880
2867,2881
2868,2869
2869,2870
2869,2871
2870,2871
2873,2874
2874,2875
2874,2876
2875,2876
2878,2879
2879,2880
2879,2881
2881,2882
2881,2883
2881,2884
2884,2885
2885,2886
2885,2887
2885,2888
2886,2887
2889,2890
2891,2892
2892,2893
2892,2894
2893,2894
2896,2897
2897,2898
2897,2899
2899,2900
2899,2901
2901,2902
2903,2904
2903,2905
2904,2905
2904,2906
2905,2906
2907,2908
2908,2909
2910,2911
2910,2912
2910,2913
2910,2914
2910,2915
2910,2916
2911,2912
2912,2913
2912,2914
2913,2914
2916,2917
2917,2918
2917,2919
2918,2919
2921,2922
2922,2923
2922,2924
2923,2924
2925,2926
2925,2927
2925,2928
2925,2929
2925,2930
2926,2927
2929,2930
2931,2932
2933,2934
2933,2935
2934,2935
2937,2938
2938,2939
2938,2940
2939,2940
2942,2943
2943,2944
2943,2945
2944,2945
2947,2948
2947,2949
2948,2949
2948,2950
2949,2950
2949,2951
2950,2951
2953,2954
2953,2955
2954,2955
2957,2958
2957,2959
2958,2959
2959,2960
2959,2961
2960,2961
2964,2965
2964,2966
2965,2966
2965,2967
2966,2967
2969,2970
2969,2971
2969,2972
2969,2973
2969,2974
2969,2975
2969,2976
2969,2977
2969,2978
2969,2979
2969,2980
2969,2981
2970,2971
2971,2972
2971,2973
2972,2973
2975,2976
2976,2977
2976,2978
2977,2978
2980,2981
2981,2982
2981,2983
2982,2983
2984,2985
2986,2987
2987,2988
2987,2989
2988,2989
2991,2992
2992,2993
2992,2994
2993,2994
2995,2996
2995,2997
2996,2997
2999,3000
3000,3001
3000,3002
3001,3002
3004,3005
3005,3006
3005,3007
3006,3007
3008,3009
3008,3010
3009,3010
3012,3013
3013,3014
3013,3015
3014,3015
3017,3018
3018,3019
3018,3020
3018,3021
3018,3022
3019,3020
3021,3022
3024,3025
3024,3026
3025,3026
3028,3029
3029,3030
3029,3031
3030,3031
3033,3034
3034,3035
3034,3036
3035,3036
3038,3039
3040,3041
3041,3042
3041,3043
3042,3043
3045,3046
3046,3047
3046,3048
3047,3048
3049,3050
3049,3051
3049,3052
3050,3051
3053,3054
3055,3056
3056,3057
3056,3058
3057,3058
3059,3060
3059,3061
3059,3062
3059,3063
3059,3064
3059,3065
3060,3061
3062,3063
3062,3064
3063,3064
3066,3067
3071,3072
3072,3073
3072,3074
3073,3074
3076,3077
3077,3078
3077,3079
3078,3079
3080,3081
3082,3083
3082,3084
3083,3084
3085,3086
3085,3087
3085,3088
3085,3089
3085,3090
3085,3091
3085,3092
3085,3093
3085,3094
3086,3087
3087,3088
3087,3089
3088,3089
3091,3092
3092,3093
3092,3094
3092,3095
3092,3096
3092,3097
3093,3094
3095,3096
3098,3099
3100,3101
3100,3102
3101,3102
3103,3104
3105,3106
3106,3107
3106,3108
3107,3108
3110,3111
3111,3112
3111,3113
3112,3113
3114,3115
3114,3116
3115,3116
3118,3119
3119,3120
3119,3121
3120,3121
3123,3124
3124,3125
3124,3126
3125,3126
3127,3128
3127,3129
3128,3129
3131,3132
3132,3133
3132,3134
3133,3134
3136,3137
3137,3138
3137,3139
3138,3139
3141,3142
3143,3144
3144,3145
3144,3146
3145,3146
3147,3148
3147,3149
3147,3150
3147,3151
3147,3152
3147,3153
3148,3149
3150,3151
3150,3152
3151,3152
3154,3155
3156,3157
3158,3159
3159,3160
3162,3163
3163,3164
3163,3165
3164,3165
3167,3168
3168,3169
3168,3170
3169,3170
3171,3172
3173,3174
3173,3175
3174,3175
3176,3177
3176,3178
3176,3179
3176,3180
3176,3181
3176,3182
3176,3183
3176,3184
3177,3178
3178,3179
3178,3180
3179,3180
3182,3183
3182,3184
3183,3184
3185,3186
3186,3187
3186,3188
3187,3188
3189,3190
3191,3192
3192,3193
3192,3194
3192,3195
3192,3196
3193,3194
3195,3196
3198,3199
3198,3200
3199,3200
3201,3202
3203,3204
3204,3205
3204,3206
3205,3206
3208,3209
3209,3210
3209,3211
3210,3211
3212,3213
3212,3214
3213,3214
3216,3217
3217,3218
3217,3219
3218,3219
3221,3222
3222,3223
3222,3224
3223,3224
3226,3227
3228,3229
3229,3230
3229,3231
3230,3231
3232,3233
3232,3234
3233,3234
3235,3236
3237,3238
3238,3239
3238,3240
3239,3240
3241,3242
3243,3244
3244,3245
3244,3246
3245,3246
3248,3249
3248,3250
3249,3250
3249,3251
3250,3251
3253,3254
3253,3255
3253,3256
3253,3257
3254,3255
3255,3256
3255,3257
3256,3257
3259,3260
3260,3261
3260,3262
3261,3262
3264,3265
3265,3266
3265,3267
3266,3267
3269,3270
3271,3272
3272,3273
3272,3274
3273,3274
3276,3277
3277,3278
3277,3279
3278,3279
3280,3281
3280,3282
3281,3282
3283,3284
3283,3285
3284,3285
3284,3286
3285,3286
3285,3287
3286,3287
3290,3291
3290,3292
3291,3292
3294,3295
3294,3296
3295,3296
3295,3297
3296,3297
3299,3300
3299,3301
3299,3302
3299,3303
3299,3304
3299,3305
3299,3306
3299,3307
3300,3301
3301,3302
3301,3303
3302,3303
3305,3306
3306,3307
3306,3308
3307,3308
3310,3311
3311,3312
3311,3313
3311,3314
3312,3313
3314,3315
3317,3318
3318,3319
3318,3320
3319,3320
3322,3323
3323,3324
3323,3325
3324,3325
3326,3327
3326,3328
3327,3328
3330,3331
3331,3332
3331,3333
3332,3333
3335,3336
3336,3337
3336,3338
3337,3338
3340,3341
3342,3343
3343,3344
3343,3345
3344,3345
3347,3348
3348,3349
3348,3350
3348,3351
3348,3352
3348,3353
3349,3350
3351,3352
3351,3353
3352,3353
3355,3356
3358,3359
3360,3361
3361,3362
3361,3363
3362,3363
3365,3366
3366,3367
3366,3368
3367,3368
3369,3370
3369,3371
3370,3371
3372,3373
3374,3375
3374,3376
3374,3377
3374,3378
3375,3376
3376,3377
3376,3378
3377,3378
3380,3381
3380,3382
3381,3382
3383,3384
3385,3386
3386,3387
3388,3389
3388,3390
3388,3391
3388,3392
3388,3393
3389,3390
3390,3391
3390,3392
3391,3392
3394,3395
3395,3396
3395,3397
3396,3397
3399,3400
3400,3401
3400,3402
3401,3402
3401,3403
3402,3403
3404,3405
3405,3406
3408,3409
3409,3410
3409,3411
3410,3411
3413,3414
3414,3415
3414,3416
3415,3416
3415,3417
3416,3417
3418,3419
3419,3420
3422,3423
3423,3424
3423,3425
3424,3425
3427,3428
3428,3429
3428,3430
3429,3430
3429,3431
3430,3431
3432,3433
3433,3434
3436,3437
3437,3438
3437,3439
3438,3439
3441,3442
3442,3443
3442,3444
3443,3444
3443,3445
3444,3445
3446,3447
3449,3450
3450,3451
3450,3452
3451,3452
3453,3454
3453,3455
3453,3456
3453,3457
3453,3458
3453,3459
3454,3455
3456,3457
3456,3458
3457,3458
3460,3461
3462,3463
3464,3465
3465,3466
3468,3469
3469,3470
3469,3471
3470,3471
3473,3474
3474,3475
3474,3476
3475,3476
3477,3478
3479,3480
3479,3481
3480,3481
3482,3483
3482,3484
3482,3485
3482,3486
3482,3487
3482,3488
3482,3489
3482,3490
3483,3484
3484,3485
3484,3486
3485,3486
3488,3489
3489,3490
3489,3491
3489,3492
3489,3493
3490,3491
3492,3493
3495,3496
3495,3497
3496,3497
3498,3499
3500,3501
3500,3502
3501,3502
3503,3504
3504,3505
3504,3506
3505,3506
3507,3508
3509,3510
3510,3511
3510,3512
3511,3512
3514,3515
3515,3516
3515,3517
3516,3517
3518,3519
3518,3520
3519,3520
3522,3523
3523,3524
3523,3525
3524,3525
3527,3528
3528,3529
3528,3530
3529,3530
3532,3533
3534,3535
3535,3536
3535,3537
3536,3537
3538,3539
3538,3540
3539,3540
3541,3542
3543,3544
3543,3545
3544,3545
3546,3547
3547,3548
3547,3549
3547,3550
3547,3551
3547,3552
3547,3553
3548,3549
3550,3551
3556,3557
3556,3558
3557,3558
3557,3559
3557,3560
3557,3561
3557,3562
3558,3559
3559,3560
3559,3561
3560,3561
3563,3564
3564,3565
3564,3566
3566,3567
3566,3568
3568,3569
3569,3570
3569,3571
3570,3571
3573,3574
3573,3575
3573,3576
3573,3577
3574,3575
3575,3576
3575,3577
3576,3577
3579,3580
3579,3581
3580,3581
3582,3583
3584,3585
3585,3586
3587,3588
3587,3589
3587,3590
3587,3591
3587,3592
3587,3593
3588,3589
3589,3590
3589,3591
3590,3591
3593,3594
3594,3595
3594,3596
3595,3596
3598,3599
3599,3600
3599,3601
3601,3602
3601,3603
3601,3604
3604,3605
3605,3606
3605,3607
3606,3607
3608,3609
3609,3610
3611,3612
3611,3613
3612,3613
3612,3614
3613,3614
3613,3615
3614,3615
3617,3618
3617,3619
3618,3619
3621,3622
3621,3623
3622,3623
3623,3624
3623,3625
3624,3625
3628,3629
3629,3630
3629,3631
3629,3632
3629,3633
3629,3634
3629,3635
3630,3631
3632,3633
3634,3635
3634,3636
3635,3636
3638,3639
3640,3641
3642,3643
3644,3645
3644,3646
3645,3646
3645,3647
3646,3647
3646,3648
3647,3648
3649,3650
3649,3651
3650,3651
3653,3654
3653,3655
3654,3655
3654,3656
3655,3656
3658,3659
3658,3660
3659,3660
3662,3663
3662,3664
3662,3665
3662,3666
3662,3667
3662,3668
3663,3664
3664,3665
3664,3666
3665,3666
3668,3669
3669,3670
3669,3671
3670,3671
3673,3674
3674,3675
3674,3676
3674,3677
3674,3678
3674,3679
3674,3680
3674,3681
3675,3676
3677,3678
3680,3681
3680,3682
3681,3682
3684,3685
3686,3687
3688,3689
3688,3690
3689,3690
3692,3693
3693,3694
3693,3695
3694,3695
3697,3698
3698,3699
3699,3700
3701,3702
3701,3703
3702,3703
3702,3704
3703,3704
3705,3706
3707,3708
3707,3709
3707,3710
3707,3711
3708,3709
3709,3710
3709,3711
3710,3711
3713,3714
3714,3715
3714,3716
3714,3717
3715,3716
3717,3718
3719,3720
3721,3722
3722,3723
3722,3724
3723,3724
3726,3727
3727,3728
3728,3729
3730,3731
3730,3732
3731,3732
3731,3733
3732,3733
3732,3734
3733,3734
3736,3737
3736,3738
3737,3738
3740,3741
3740,3742
3740,3743
3740,3744
3741,3742
3742,3743
3742,3744
3743,3744
3746,3747
3746,3748
3747,3748
3747,3749
3747,3750
3747,3751
3748,3749
3749,3750
3749,3751
3750,3751
3753,3754
3754,3755
3754,3756
3755,3756
3757,3758
3758,3759
3760,3761
3761,3762
3761,3763
3762,3763
3765,3766
3766,3767
3767,3768
3769,3770
3769,3771
3770,3771
3770,3772
3771,3772
3774,3775
3774,3776
3775,3776
3778,3779
3779,3780
3779,3781
3780,3781
3783,3784
3784,3785
3784,3786
3784,3787
3784,3788
3784,3789
3784,3790
3784,3791
3785,3786
3787,3788
3790,3791
3790,3792
3791,3792
3794,3795
3796,3797
3798,3799
3800,3801
3800,3802
3801,3802
3801,3803
3802,3803
3804,3805
3806,3807
3806,3808
3806,3809
3806,3810
3807,3808
3808,3809
3808,3810
3809,3810
3812,3813
3813,3814
3813,3815
3814,3815
3816,3817
3818,3819
3819,3820
3819,3821
3820,3821
3822,3823
3822,3824
3823,3824
3825,3826
3827,3828
3827,3829
3828,3829
3828,3830
3829,3830
3831,3832
3833,3834
3833,3835
3834,3835
3835,3836
3835,3837
3836,3837
3839,3840
3840,3841
3840,3842
3840,3843
3840,3844
3840,3845
3840,3846
3841,3842
3843,3844
3846,3847
3846,3848
3847,3848
3850,3851
3852,3853
3852,3854
3853,3854
3855,3856
3857,3858
3857,3859
3858,3859
3858,3860
3859,3860
3862,3863
3864,3865
3865,3866
3865,3867
3866,3867
3869,3870
3870,3871
3870,3872
3871,3872
3873,3874
3873,3875
3874,3875
3877,3878
3878,3879
3878,3880
3879,3880
3882,3883
3883,3884
3883,3885
3884,3885
3886,3887
3886,3888
3887,3888
3890,3891
3891,3892
3891,3893
3892,3893
3894,3895
3896,3897
3896,3898
3897,3898
3899,3900
3900,3901
3900,3902
3900,3903
3900,3904
3900,3905
3900,3906
3901,3902
3903,3904
3909,3910
3909,3911
3909,3912
3910,3911
3910,3912
3911,3912
3911,3913
3912,3913
3912,3914
3913,3914
3916,3917
3916,3918
3917,3918
3917,3919
3917,3920
3917,3921
3918,3919
3920,3921
3920,3922
3921,3922
3925,3926
3928,3929
3928,3930
3929,3930
3932,3933
3932,3934
3932,3935
3932,3936
3932,3937
3932,3938
3932,3939
3932,3940
3932,3941
3932,3942
3932,3943
3932,3944
3932,3945
3932,3946
3932,3947
3933,3934
3934,3935
3934,3936
3935,3936
3938,3939
3939,3940
3939,3941
3940,3941
3943,3944
3944,3945
3944,3946
3945,3946
3947,3948
3949,3950
3950,3951
3950,3952
3951,3952
3954,3955
3955,3956
3955,3957
3957,3958
3957,3959
3957,3960
3960,3961
3962,3963
3963,3964
3963,3965
3964,3965
3967,3968
3968,3969
3968,3970
3968,3971
3969,3970
3971,3972
3974,3975
3975,3976
3975,3977
3976,3977
3979,3980
3980,3981
3980,3982
3980,3983
3980,3984
3981,3982
3983,3984
3984,3985
3986,3987
3988,3989
3989,3990
3990,3991
3992,3993
3993,3994
3993,3995
3994,3995
3997,3998
3998,3999
3998,4000
3999,4000
3999,4001
4000,4001
4004,4005
4005,4006
4005,4007
4006,4007
4009,4010
4010,4011
4010,4012
4011,4012
4011,4013
4012,4013
4015,4016
4017,4018
4017,4019
4017,4020
4018,4019
4018,4020
4019,4020
4022,4023
4022,4024
4023,4024
4024,4025
4024,4026
4025,4026
4028,4029
4029,4030
4029,4031
4030,4031
4032,4033
4032,4034
4032,4035
4032,4036
4032,4037
4032,4038
4033,4034
4035,4036
4035,4037
4036,4037
4040,4041
4042,4043
4043,4044
4045,4046
4046,4047
4048,4049
4048,4050
4048,4051
4048,4052
4048,4053
4049,4050
4050,4051
4050,4052
4051,4052
4054,4055
4055,4056
4055,4057
4056,4057
4058,4059
4058,4060
4059,4060
4062,4063
4063,4064
4063,4065
4064,4065
4066,4067
4066,4068
4066,4069
4066,4070
4066,4071
4066,4072
4067,4068
4069,4070
4069,4071
4070,4071
4074,4075
4076,4077
4077,4078
4079,4080
4080,4081
4082,4083
4083,4084
4083,4085
4084,4085
4087,4088
4088,4089
4088,4090
4089,4090
4092,4093
4092,4094
4092,4095
4093,4094
4095,4096
4095,4097
4095,4098
4095,4099
4095,4100
4095,4101
4095,4102
4096,4097
4097,4098
4097,4099
4098,4099
4101,4102
4102,4103
4102,4104
4103,4104
4106,4107
4107,4108
4107,4109
4107,4110
4107,4111
4108,4109
4110,4111
4113,4114
4115,4116
4116,4117
4116,4118
4117,4118
4120,4121
4121,4122
4121,4123
4122,4123
4124,4125
4126,4127
4127,4128
4127,4129
4128,4129
4131,4132
4132,4133
4132,4134
4133,4134
4136,4137
4136,4138
4137,4138
4137,4139
4138,4139
4140,4141
4142,4143
4142,4144
4142,4145
4142,4146
4142,4147
4143,4144
4144,4145
4144,4146
4145,4146
4148,4149
4149,4150
4149,4151
4150,4151
4153,4154
4154,4155
4154,4156
4154,4157
4155,4156
4157,4158
4160,4161
4161,4162
4161,4163
4162,4163
4165,4166
4166,4167
4166,4168
4167,4168
4170,4171
4170,4172
4170,4173
4171,4172
4171,4173
4172,4173
4172,4174
4173,4174
4173,4175
4174,4175
4177,4178
4177,4179
4178,4179
4178,4180
4178,4181
4178,4182
4179,4180
4181,4182
4181,4183
4182,4183
4186,4187
4189,4190
4189,4191
4190,4191
4193,4194
4193,4195
4193,4196
4193,4197
4193,4198
4193,4199
4193,4200
4193,4201
4193,4202
4193,4203
4193,4204
4193,4205
4193,4206
4194,4195
4195,4196
4195,4197
4196,4197
4199,4200
4200,4201
4200,4202
4201,4202
4204,4205
4205,4206
4205,4207
4205,4208
4207,4208
4207,4209
4210,4211
4210,4212
4213,4214
4214,4215
4214,4216
4215,4216
4218,4219
4219,4220
4219,4221
4221,4222
4221,4223
4221,4224
4224,4225
4226,4227
4227,4228
4227,4229
4228,4229
4231,4232
4232,4233
4232,4234
4233,4234
4235,4236
4235,4237
4236,4237
4239,4240
4240,4241
4240,4242
4241,4242
4244,4245
4245,4246
4245,4247
4246,4247
4248,4249
4248,4250
4248,4251
4249,4250
4249,4251
4250,4251
4253,4254
4253,4255
4254,4255
4258,4259
4259,4260
4259,4261
4260,4261
4263,4264
4264,4265
4264,4266
4264,4267
4265,4266
4267,4268
4270,4271
4271,4272
4271,4273
4272,4273
4274,4275
4274,4276
4274,4277
4274,4278
4274,4279
4275,4276
4277,4278
4277,4279
4278,4279
4281,4282
4283,4284
4285,4286
4286,4287
4288,4289
4288,4290
4289,4290
4289,4291
4290,4291
4292,4293
4294,4295
4294,4296
4294,4297
4294,4298
4294,4299
4294,4300
4294,4301
4295,4296
4296,4297
4296,4298
4297,4298
4300,4301
4301,4302
4301,4303
4302,4303
4305,4306
4306,4307
4306,4308
4306,4309
4306,4310
4307,4308
4309,4310
4312,4313
4314,4315
4315,4316
4315,4317
4316,4317
4319,4320
4320,4321
4320,4322
4321,4322
4323,4324
4325,4326
4326,4327
4326,4328
4327,4328
4330,4331
4331,4332
4331,4333
4332,4333
4335,4336
4335,4337
4335,4338
4336,4337
4336,4338
4337,4338
4337,4339
4338,4339
4338,4340
4339,4340
4342,4343
4342,4344
4343,4344
4343,4345
4343,4346
4343,4347
4344,4345
4346,4347
4346,4348
4347,4348
4351,4352
4354,4355
4354,4356
4355,4356
4358,4359
4358,4360
4358,4361
4358,4362
4358,4363
4358,4364
4358,4365
4359,4360
4360,4361
4360,4362
4361,4362
4364,4365
4365,4366
4365,4367
4366,4367
4369,4370
4370,4371
4370,4372
4372,4373
4372,4374
4372,4375
4375,4376
4376,4377
4376,4378
4377,4378
4380,4381
4381,4382
4381,4383
4382,4383
4385,4386
4386,4387
4386,4388
4387,4388
4389,4390
4389,4391
4390,4391
4393,4394
4394,4395
4394,4396
4395,4396
4398,4399
4399,4400
4399,4401
4400,4401
4400,4402
4401,4402
4404,4405
4404,4406
4405,4406
4407,4408
4409,4410
4409,4411
4409,4412
4410,4411
4410,4412
4411,4412
4411,4413
4412,4413
4412,4414
4413,4414
4416,4417
4416,4418
4417,4418
4417,4419
4417,4420
4417,4421
4418,4419
4420,4421
4420,4422
4421,4422
4425,4426
4428,4429
4428,4430
4429,4430
4432,4433
4432,4434
4432,4435
4432,4436
4433,4434
4434,4435
4434,4436
4435,4436
4438,4439
4439,4440
4439,4441
4440,4441
4443,4444
4444,4445
4444,4446
4446,4447
4446,4448
4448,4449
4449,4450
4449,4451
4450,4451
4452,4453
4452,4454
4453,4454
4456,4457
4456,4458
4456,4459
4457,4458
4457,4459
4458,4459
4459,4460
4459,4461
4460,4461
4460,4462
4461,4462
4464,4465
4464,4466
4465,4466
4465,4467
4465,4468
4465,4469
4466,4467
4468,4469
4468,4470
4469,4470
4473,4474
4476,4477
4477,4478
4477,4479
4478,4479
4478,4480
4479,4480
4482,4483
4482,4484
4483,4484
4483,4485
4483,4486
4483,4487
4484,4485
4486,4487
4486,4488
4487,4488
4491,4492
4494,4495
4494,4496
4494,4497
4495,4496
4496,4497
4496,4498
4497,4498
4500,4501
4501,4502
4501,4503
4502,4503
4505,4506
4506,4507
4506,4508
4507,4508
4507,4509
4508,4509
4511,4512
4513,4514
4513,4515
4513,4516
4514,4515
4514,4516
4515,4516
4516,4517
4516,4518
4517,4518
4517,4519
4518,4519
4521,4522
4521,4523
4522,4523
4522,4524
4522,4525
4522,4526
4523,4524
4525,4526
4525,4527
4526,4527
4530,4531
4533,4534
4534,4535
4534,4536
4535,4536
4535,4537
4536,4537
4539,4540
4539,4541
4540,4541
4540,4542
4540,4543
4540,4544
4541,4542
4543,4544
4543,4545
4544,4545
4548,4549
4551,4552
4551,4553
4551,4554
4552,4553
4553,4554
4553,4555
4554,4555
4557,4558
4558,4559
4558,4560
4559,4560
4562,4563
4563,4564
4563,4565
4564,4565
4564,4566
4565,4566
4568,4569
4570,4571
4570,4572
4570,4573
4571,4572
4571,4573
4572,4573
4572,4574
4573,4574
4576,4577
4576,4578
4577,4578
4577,4579
4577,4580
4577,4581
4578,4579
4580,4581
4580,4582
4581,4582
4585,4586
4588,4589
4588,4590
4588,4591
4589,4590
4590,4591
4590,4592
4591,4592
4594,4595
4595,4596
4595,4597
4596,4597
4599,4600
4600,4601
4600,4602
4601,4602
4601,4603
4602,4603
4605,4606
4607,4608
4607,4609
4607,4610
4608,4609
4608,4610
4609,4610
4609,4611
4610,4611
4613,4614
4613,4615
4614,4615
4614,4616
4614,4617
4614,4618
4615,4616
4617,4618
4617,4619
4618,4619
4622,4623
4625,4626
4625,4627
4625,4628
4626,4627
4627,4628
4627,4629
4628,4629
4631,4632
4632,4633
4632,4634
4633,4634
4636,4637
4637,4638
4637,4639
4638,4639
4638,4640
4639,4640
4642,4643
4644,4645
4644,4646
4644,4647
4645,4646
4645,4647
4646,4647
4646,4648
4647,4648
4650,4651
4650,4652
4651,4652
4651,4653
4651,4654
4651,4655
4652,4653
4654,4655
4654,4656
4655,4656
4659,4660
4662,4663
4662,4664
4662,4665
4662,4666
4662,4667
4663,4664
4664,4665
4664,4666
4665,4666
4668,4669
4669,4670
4669,4671
4670,4671
4673,4674
4674,4675
4674,4676
4675,4676
4675,4677
4676,4677
4679,4680
4681,4682
4682,4683
4682,4684
4683,4684
4686,4687
4687,4688
4687,4689
4687,4690
4687,4691
4688,4689
4690,4691
4691,4692
4692,4693
4692,4694
4693,4694
4696,4697
4696,4698
4697,4698
4701,4702
4701,4703
4701,4704
4702,4703
4702,4704
4703,4704
4703,4705
4704,4705
4707,4708
4707,4709
4708,4709
4708,4710
4708,4711
4708,4712
4709,4710
4711,4712
4711,4713
4712,4713
4716,4717
4719,4720
4719,4721
4719,4722
4719,4723
4719,4724
4720,4721
4721,4722
4721,4723
4722,4723
4725,4726
4726,4727
4726,4728
4727,4728
4730,4731
4731,4732
4731,4733
4732,4733
4732,4734
4733,4734
4736,4737
4738,4739
4739,4740
4739,4741
4740,4741
4743,4744
4744,4745
4744,4746
4744,4747
4744,4748
4745,4746
4747,4748
4748,4749
4749,4750
4749,4751
4750,4751
4753,4754
4753,4755
4754,4755
4758,4759
4758,4760
4758,4761
4759,4760
4759,4761
4760,4761
4760,4762
4761,4762
4764,4765
4764,4766
4765,4766
4765,4767
4765,4768
4765,4769
4766,4767
4768,4769
4768,4770
4769,4770
4773,4774
4776,4777
4776,4778
4776,4779
4776,4780
4776,4781
4777,4778
4778,4779
4778,4780
4779,4780
4782,4783
4783,4784
4783,4785
4784,4785
4787,4788
4788,4789
4788,4790
4789,4790
4789,4791
4790,4791
4793,4794
4795,4796
4796,4797
4796,4798
4797,4798
4800,4801
4801,4802
4801,4803
4801,4804
4801,4805
4802,4803
4804,4805
4805,4806
4806,4807
4806,4808
4807,4808
4810,4811
4810,4812
4811,4812
4815,4816
4815,4817
4815,4818
4816,4817
4816,4818
4817,4818
4817,4819
4818,4819
4821,4822
4821,4823
4822,4823
4822,4824
4822,4825
4822,4826
4823,4824
4825,4826
4825,4827
4826,4827
4830,4831
4833,4834
4833,4835
4833,4836
4833,4837
4833,4838
4834,4835
4835,4836
4835,4837
4836,4837
4839,4840
4840,4841
4840,4842
4841,4842
4844,4845
4845,4846
4845,4847
4846,4847
4846,4848
4847,4848
4850,4851
4852,4853
4853,4854
4853,4855
4854,4855
4857,4858
4858,4859
4858,4860
4858,4861
4859,4860
4861,4862
4864,4865
4864,4866
4864,4867
4864,4868
4865,4866
4866,4867
4866,4868
4867,4868
4870,4871
4871,4872
4871,4873
4871,4874
4872,4873
4874,4875
4877,4878
4878,4879
4878,4880
4879,4880
4882,4883
4883,4884
4883,4885
4884,4885
4887,4888
4887,4889
4887,4890
4888,4889
4888,4890
4889,4890
4889,4891
4890,4891
4890,4892
4891,4892
4894,4895
4894,4896
4895,4896
4895,4897
4895,4898
4895,4899
4896,4897
4898,4899
4898,4900
4899,4900
4903,4904
4906,4907
4906,4908
4907,4908
4910,4911
4910,4912
4910,4913
4910,4914
4911,4912
4912,4913
4912,4914
4913,4914
4916,4917
4917,4918
4917,4919
4918,4919
4921,4922
4922,4923
4922,4924
4924,4925
4924,4926
4926,4927
4927,4928
4927,4929
4928,4929
4930,4931
4930,4932
4931,4932
4934,4935
4934,4936
4934,4937
4935,4936
4935,4937
4936,4937
4936,4938
4937,4938
4940,4941
4940,4942
4941,4942
4941,4943
4941,4944
4941,4945
4942,4943
4944,4945
4944,4946
4945,4946
4949,4950
4952,4953
4952,4954
4952,4955
4952,4956
4952,4957
4953,4954
4954,4955
4954,4956
4955,4956
4958,4959
4959,4960
4959,4961
4960,4961
4963,4964
4964,4965
4964,4966
4965,4966
4965,4967
4966,4967
4969,4970
4971,4972
4972,4973
4972,4974
4973,4974
4976,4977
4977,4978
4977,4979
4977,4980
4978,4979
4980,4981
4982,4983
4982,4984
4983,4984
4986,4987
4986,4988
4986,4989
4986,4990
4987,4988
4988,4989
4988,4990
4989,4990
4992,4993
4993,4994
4993,4995
4993,4996
4993,4997
4994,4995
4996,4997
4999,5000
4999,5001
5000,5001
5003,5004
5004,5005
5004,5006
5005,5006
5008,5009
5009,5010
5009,5011
5010,5011
5013,5014
5013,5015
5013,5016
5014,5015
5014,5016
5015,5016
5015,5017
5016,5017
5016,5018
5017,5018
5020,5021
5020,5022
5021,5022
5021,5023
5021,5024
5021,5025
5022,5023
5024,5025
5024,5026
5025,5026
5029,5030
5032,5033
5032,5034
5033,5034
5036,5037
5036,5038
5036,5039
5037,5038
5038,5039
5038,5040
5039,5040
5042,5043
5043,5044
5043,5045
5044,5045
5047,5048
5048,5049
5048,5050
5048,5051
5048,5052
5048,5053
5048,5054
5049,5050
5051,5052
5052,5053
5053,5054
5053,5055
5054,5055
5057,5058
5057,5059
5058,5059
5062,5063
5062,5064
5063,5064
5063,5065
5064,5065
5064,5066
5067,5068
5067,5069
5068,5069
5070,5071
5070,5072
5071,5072
5075,5076
5075,5077
5076,5077
5079,5080
5079,5081
5079,5082
5080,5081
5080,5082
5081,5082
5081,5083
5082,5083
5082,5084
5083,5084
5086,5087
5086,5088
5087,5088
5087,5089
5087,5090
5087,5091
5088,5089
5090,5091
5090,5092
5091,5092
5095,5096
5098,5099
5098,5100
5099,5100
5102,5103
5102,5104
5102,5105
5102,5106
5102,5107
5102,5108
5102,5109
5102,5110
5102,5111
5102,5112
5102,5113
5103,5104
5104,5105
5104,5106
5105,5106
5108,5109
5109,5110
5109,5111
5110,5111
5112,5113
5112,5114
5112,5115
5115,5116
5116,5117
5116,5118
5117,5118
5120,5121
5121,5122
5121,5123
5122,5123
5125,5126
5126,5127
5126,5128
5128,5129
5128,5130
5128,5131
5131,5132
5132,5133
5132,5134
5133,5134
5136,5137
5137,5138
5137,5139
5138,5139
5141,5142
5142,5143
5142,5144
5144,5145
5144,5146
5144,5147
5147,5148
5149,5150
5150,5151
5150,5152
5151,5152
5151,5153
5152,5153
5156,5157
5156,5158
5157,5158
5157,5159
5158,5159
5161,5162
5161,5163
5161,5164
5162,5163
5163,5164
5163,5165
5164,5165
5167,5168
5168,5169
5168,5170
5169,5170
5172,5173
5173,5174
5173,5175
5174,5175
5174,5176
5175,5176
5178,5179
5178,5180
5179,5180
5181,5182
5181,5183
5181,5184
5182,5183
5185,5186
5185,5187
5186,5187
5189,5190
5190,5191
5190,5192
5191,5192
5194,5195
5195,5196
5195,5197
5195,5198
5196,5197
5198,5199
5201,5202
5201,5203
5201,5204
5202,5203
5202,5204
5203,5204
5203,5205
5204,5205
5208,5209
5208,5210
5208,5211
5208,5212
5208,5213
5208,5214
5209,5210
5210,5211
5210,5212
5211,5212
5214,5215
5215,5216
5215,5217
5216,5217
5218,5219
5220,5221
5221,5222
5221,5223
5222,5223
5225,5226
5226,5227
5226,5228
5227,5228
5229,5230
5229,5231
5230,5231
5233,5234
5234,5235
5234,5236
5235,5236
5238,5239
5239,5240
5239,5241
5240,5241
5240,5242
5241,5242
5244,5245
5246,5247
5246,5248
5246,5249
5246,5250
5246,5251
5247,5248
5248,5249
5248,5250
5249,5250
5252,5253
5253,5254
5253,5255
5254,5255
5256,5257
5258,5259
5259,5260
5259,5261
5260,5261
5260,5262
5261,5262
5264,5265
5266,5267
5267,5268
5267,5269
5268,5269
5271,5272
5272,5273
5272,5274
5273,5274
5273,5275
5274,5275
5277,5278
5279,5280
5279,5281
5279,5282
5280,5281
5280,5282
5281,5282
5281,5283
5282,5283
5282,5284
5283,5284
5286,5287
5286,5288
5287,5288
5287,5289
5287,5290
5287,5291
5288,5289
5290,5291
5290,5292
5291,5292
5295,5296
5298,5299
5298,5300
5299,5300
5302,5303
5302,5304
5302,5305
5302,5306
5302,5307
5303,5304
5304,5305
5304,5306
5305,5306
5308,5309
5308,5310
5308,5311
5309,5310
5309,5311
5310,5311
5310,5312
5311,5312
5311,5313
5312,5313
5317,5318
5317,5319
5317,5320
5318,5319
5319,5320
5319,5321
5320,5321
5323,5324
5324,5325
5324,5326
5325,5326
5328,5329
5329,5330
5329,5331
5330,5331
5332,5333
5332,5334
5333,5334
5336,5337
5336,5338
5337,5338
5338,5339
5338,5340
5339,5340
5342,5343
5343,5344
5343,5345
5344,5345
5346,5347
5346,5348
5347,5348
5350,5351
5351,5352
5351,5353
5352,5353
5355,5356
5356,5357
5356,5358
5357,5358
5357,5359
5358,5359
5358,5360
5359,5360
5364,5365
5364,5366
5364,5367
5365,5366
5365,5367
5366,5367
5366,5368
5367,5368
5367,5369
5368,5369
5373,5374
5373,5375
5373,5376
5373,5377
5374,5375
5375,5376
5375,5377
5376,5377
5379,5380
5380,5381
5380,5382
5381,5382
5384,5385
5385,5386
5385,5387
5386,5387
5386,5388
5387,5388
5390,5391
5390,5392
5390,5393
5391,5392
5393,5394
5394,5395
5394,5396
5395,5396
5395,5397
5396,5397
5401,5402
5401,5403
5401,5404
5402,5403
5402,5404
5403,5404
5403,5405
5404,5405
5408,5409
5408,5410
5408,5411
5408,5412
5408,5413
5408,5414
5408,5415
5409,5410
5410,5411
5410,5412
5411,5412
5414,5415
5415,5416
5415,5417
5416,5417
5419,5420
5420,5421
5420,5422
5420,5423
5420,5424
5421,5422
5423,5424
5426,5427
5427,5428
5427,5429
5428,5429
5428,5430
5429,5430
5433,5434
5434,5435
5434,5436
5435,5436
5438,5439
5439,5440
5439,5441
5440,5441
5440,5442
5441,5442
5444,5445
5446,5447
5447,5448
5447,5449
5448,5449
5451,5452
5452,5453
5452,5454
5453,5454
5456,5457
5456,5458
5457,5458
5458,5459
5458,5460
5459,5460
5462,5463
5463,5464
5463,5465
5463,5466
5463,5467
5463,5468
5464,5465
5466,5467
5467,5468
5468,5469
5468,5470
5469,5470
5472,5473
5472,5474
5473,5474
5477,5478
5477,5479
5478,5479
5481,5482
5481,5483
5481,5484
5482,5483
5483,5484
5483,5485
5484,5485
5487,5488
5488,5489
5488,5490
5489,5490
5489,5491
5490,5491
5493,5494
5493,5495
5494,5495
5496,5497
5496,5498
5497,5498
5500,5501
5500,5502
5500,5503
5501,5502
5501,5503
5502,5503
5502,5504
5503,5504
5507,5508
5507,5509
5507,5510
5507,5511
5507,5512
5507,5513
5508,5509
5509,5510
5509,5511
5510,5511
5513,5514
5513,5515
5514,5515
5514,5516
5515,5516
5515,5517
5515,5518
5516,5517
5518,5519
5518,5520
5519,5520
5524,5525
5524,5526
5524,5527
5525,5526
5526,5527
5526,5528
5527,5528
5530,5531
5531,5532
5531,5533
5532,5533
5535,5536
5536,5537
5536,5538
5536,5539
5536,5540
5537,5538
5539,5540
5542,5543
5542,5544
5543,5544
5546,5547
5547,5548
5547,5549
5548,5549
5551,5552
5552,5553
5552,5554
5553,5554
5553,5555
5554,5555
5557,5558
5559,5560
5560,5561
5560,5562
5561,5562
5564,5565
5565,5566
5565,5567
5566,5567
5569,5570
5569,5571
5570,5571
5571,5572
5571,5573
5572,5573
5575,5576
5576,5577
5576,5578
5576,5579
5576,5580
5576,5581
5577,5578
5579,5580
5580,5581
5581,5582
5581,5583
5582,5583
5585,5586
5585,5587
5586,5587
5590,5591
5590,5592
5591,5592
5594,5595
5594,5596
5594,5597
5595,5596
5595,5597
5596,5597
5596,5598
5597,5598
5597,5599
5598,5599
5601,5602
5601,5603
5602,5603
5605,5606
5605,5607
5606,5607
5606,5608
5606,5609
5606,5610
5607,5608
5609,5610
5609,5611
5610,5611
5614,5615
5617,5618
5617,5619
5617,5620
5617,5621
5617,5622
5617,5623
5618,5619
5619,5620
5619,5621
5620,5621
5623,5624
5624,5625
5624,5626
5625,5626
5628,5629
5629,5630
5629,5631
5631,5632
5633,5634
5633,5635
5633,5636
5633,5637
5634,5635
5635,5636
5635,5637
5636,5637
5639,5640
5639,5641
5640,5641
5642,5643
5644,5645
5645,5646
5647,5648
5647,5649
5647,5650
5647,5651
5648,5649
5649,5650
5649,5651
5650,5651
5653,5654
5653,5655
5654,5655
5654,5656
5655,5656
5658,5659
5658,5660
5658,5661
5659,5660
5660,5661
5660,5662
5661,5662
5664,5665
5665,5666
5665,5667
5666,5667
5669,5670
5670,5671
5670,5672
5670,5673
5671,5672
5673,5674
5673,5675
5674,5675
5678,5679
5679,5680
5679,5681
5680,5681
5683,5684
5684,5685
5684,5686
5684,5687
5684,5688
5685,5686
5687,5688
5687,5689
5688,5689
5692,5693
5692,5694
5693,5694
5695,5696
5697,5698
5698,5699
5698,5700
5699,5700
5702,5703
5703,5704
5703,5705
5703,5706
5704,5705
5706,5707
5706,5708
5707,5708
5711,5712
5711,5713
5711,5714
5712,5713
5712,5714
5713,5714
5713,5715
5714,5715
5714,5716
5715,5716
5718,5719
5718,5720
5719,5720
5719,5721
5719,5722
5719,5723
5720,5721
5722,5723
5722,5724
5723,5724
5727,5728
5730,5731
5731,5732
5731,5733
5732,5733
5732,5734
5733,5734
5736,5737
5736,5738
5737,5738
5740,5741
5740,5742
5740,5743
5741,5742
5742,5743
5742,5744
5743,5744
5746,5747
5746,5748
5747,5748
5747,5749
5748,5749
5751,5752
5751,5753
5751,5754
5752,5753
5753,5754
5753,5755
5754,5755
5757,5758
5758,5759
5758,5760
5759,5760
5762,5763
5763,5764
5763,5765
5763,5766
5763,5767
5764,5765
5766,5767
5768,5769
5768,5770
5769,5770
5772,5773
5772,5774
5773,5774
5773,5775
5774,5775
5774,5776
5777,5778
5777,5779
5778,5779
5780,5781
5783,5784
5783,5785
5784,5785
5784,5786
5785,5786
5788,5789
5788,5790
5788,5791
5789,5790
5790,5791
5790,5792
5791,5792
5794,5795
5795,5796
5795,5797
5796,5797
5799,5800
5800,5801
5800,5802
5800,5803
5800,5804
5801,5802
5803,5804
5805,5806
5805,5807
5806,5807
5809,5810
5809,5811
5810,5811
5810,5812
5811,5812
5811,5813
5814,5815
5814,5816
5815,5816
5817,5818
5820,5821
5820,5822
5820,5823
5821,5822
5821,5823
5822,5823
5822,5824
5823,5824
5823,5825
5824,5825
5827,5828
5827,5829
5828,5829
5828,5830
5828,5831
5828,5832
5829,5830
5831,5832
5831,5833
5832,5833
5836,5837
5839,5840
5839,5841
5840,5841
5843,5844
5843,5845
5843,5846
5844,5845
5845,5846
5845,5847
5846,5847
5849,5850
5850,5851
5850,5852
5851,5852
5854,5855
5855,5856
5855,5857
5856,5857
5859,5860
5859,5861
5859,5862
5860,5861
5860,5862
5861,5862
5861,5863
5862,5863
5862,5864
5863,5864
5863,5865
5864,5865
5867,5868
5867,5869
5868,5869
5871,5872
5871,5873
5872,5873
5872,5874
5872,5875
5872,5876
5873,5874
5875,5876
5875,5877
5876,5877
5880,5881
5883,5884
5883,5885
5884,5885
5887,5888
5887,5889
5887,5890
5887,5891
5888,5889
5889,5890
5889,5891
5890,5891
5893,5894
5894,5895
5894,5896
5895,5896
5898,5899
5899,5900
5899,5901
5900,5901
5902,5903
5902,5904
5902,5905
5905,5906
5906,5907
5906,5908
5906,5909
5907,5908
5909,5910
5909,5911
5910,5911
5914,5915
5914,5916
5914,5917
5915,5916
5915,5917
5916,5917
5919,5920
5919,5921
5919,5922
5919,5923
5919,5924
5920,5921
5921,5922
5921,5923
5922,5923
5925,5926
5926,5927
5926,5928
5927,5928
5930,5931
5931,5932
5931,5933
5931,5934
5931,5935
5932,5933
5934,5935
5937,5938
5937,5939
5938,5939
5941,5942
5942,5943
5942,5944
5943,5944
5946,5947
5947,5948
5947,5949
5948,5949
5951,5952
5951,5953
5951,5954
5951,5955
5952,5953
5953,5954
5953,5955
5954,5955
5957,5958
5958,5959
5958,5960
5959,5960
5961,5962
5961,5963
5961,5964
5962,5963
5964,5965
5966,5967
5968,5969
5969,5970
5969,5971
5970,5971
5973,5974
5974,5975
5974,5976
5975,5976
5977,5978
5979,5980
5979,5981
5979,5982
5980,5981
5980,5982
5981,5982
5981,5983
5982,5983
5982,5984
5983,5984
5983,5985
5984,5985
5984,5986
5985,5986
5988,5989
5988,5990
5989,5990
5992,5993
5992,5994
5993,5994
5993,5995
5993,5996
5993,5997
5994,5995
5996,5997
5996,5998
5997,5998
6001,6002
6004,6005
6004,6006
6005,6006
6008,6009
6008,6010
6009,6010
6012,6013
6012,6014
6012,6015
6012,6016
6012,6017
6012,6018
6012,6019
6012,6020
6012,6021
6012,6022
6012,6023
6012,6024
6012,6025
6012,6026
6012,6027
6012,6028
6012,6029
6012,6030
6012,6031
6012,6032
6013,6014
6014,6015
6014,6016
6015,6016
6018,6019
6019,6020
6019,6021
6020,6021
6023,6024
6024,6025
6024,6026
6026,6027
6026,6028
6029,6030
6030,6031
6030,6032
6031,6032
6034,6035
6035,6036
6035,6037
6037,6038
6037,6039
6040,6041
6041,6042
6041,6043
6042,6043
6044,6045
6044,6046
6047,6048
6048,6049
6048,6050
6049,6050
6051,6052
6051,6053
6054,6055
6055,6056
6055,6057
6056,6057
6059,6060
6060,6061
6060,6062
6062,6063
6062,6064
6064,6065
6066,6067
6066,6068
6066,6069
6067,6068
6067,6069
6068,6069
6071,6072
6071,6073
6071,6074
6071,6075
6071,6076
6072,6073
6073,6074
6073,6075
6074,6075
6077,6078
6078,6079
6078,6080
6079,6080
6082,6083
6083,6084
6083,6085
6084,6085
6086,6087
6086,6088
6087,6088
6090,6091
6091,6092
6091,6093
6092,6093
6095,6096
6096,6097
6096,6098
6097,6098
6100,6101
6100,6102
6100,6103
6100,6104
6101,6102
6102,6103
6102,6104
6103,6104
6106,6107
6107,6108
6107,6109
6108,6109
6110,6111
6110,6112
6111,6112
6114,6115
6115,6116
6115,6117
6116,6117
6119,6120
6120,6121
6120,6122
6121,6122
6123,6124
6123,6125
6124,6125
6127,6128
6128,6129
6128,6130
6129,6130
6131,6132
6131,6133
6131,6134
6132,6133
6134,6135
6136,6137
6137,6138
6139,6140
6139,6141
6140,6141
6140,6142
6141,6142
6143,6144
6145,6146
6145,6147
6145,6148
6145,6149
6145,6150
6145,6151
6145,6152
6146,6147
6147,6148
6147,6149
6148,6149
6151,6152
6152,6153
6152,6154
6153,6154
6156,6157
6157,6158
6157,6159
6157,6160
6157,6161
6158,6159
6160,6161
6163,6164
6165,6166
6166,6167
6166,6168
6167,6168
6169,6170
6171,6172
6172,6173
6172,6174
6173,6174
6176,6177
6177,6178
6177,6179
6178,6179
6181,6182
6183,6184
6184,6185
6184,6186
6185,6186
6188,6189
6189,6190
6189,6191
6189,6192
6190,6191
6192,6193
6195,6196
6196,6197
6196,6198
6197,6198
6199,6200
6199,6201
6199,6202
6199,6203
6199,6204
6200,6201
6202,6203
6202,6204
6203,6204
6206,6207
6208,6209
6211,6212
6211,6213
6212,6213
6212,6214
6213,6214
6216,6217
6216,6218
6216,6219
6216,6220
6216,6221
6216,6222
6217,6218
6218,6219
6218,6220
6219,6220
6222,6223
6223,6224
6223,6225
6223,6226
6223,6227
6224,6225
6226,6227
6229,6230
6229,6231
6230,6231
6232,6233
6232,6234
6233,6234
6236,6237
6237,6238
6237,6239
6238,6239
6240,6241
6242,6243
6243,6244
6243,6245
6244,6245
6247,6248
6248,6249
6248,6250
6249,6250
6252,6253
6254,6255
6254,6256
6255,6256
6255,6257
6256,6257
6256,6258
6257,6258
6258,6259
6258,6260
6259,6260
6261,6262
6261,6263
6261,6264
6262,6263
6264,6265
6267,6268
6269,6270
6269,6271
6270,6271
6272,6273
6274,6275
6275,6276
6275,6277
6276,6277
6276,6278
6277,6278
6279,6280
6281,6282
6281,6283
6282,6283
6282,6284
6283,6284
6283,6285
6284,6285
6285,6286
6289,6290
6290,6291
6290,6292
6291,6292
6294,6295
6295,6296
6295,6297
6296,6297
6298,6299
6300,6301
6300,6302
6300,6303
6301,6302
6301,6303
6302,6303
6304,6305
6306,6307
6306,6308
6306,6309
6307,6308
6308,6309
6308,6310
6309,6310
6312,6313
6313,6314
6313,6315
6314,6315
6317,6318
6318,6319
6318,6320
6319,6320
6322,6323
6322,6324
6322,6325
6323,6324
6323,6325
6324,6325
6324,6326
6325,6326
6327,6328
6329,6330
6329,6331
6330,6331
6332,6333
6334,6335
6334,6336
6334,6337
6334,6338
6334,6339
6335,6336
6336,6337
6336,6338
6337,6338
6340,6341
6341,6342
6341,6343
6342,6343
6345,6346
6346,6347
6346,6348
6346,6349
6347,6348
6349,6350
6352,6353
6353,6354
6353,6355
6354,6355
6357,6358
6358,6359
6358,6360
6359,6360
6362,6363
6362,6364
6362,6365
6363,6364
6364,6365
6364,6366
6364,6367
6364,6368
6365,6366
6367,6368
6370,6371
6370,6372
6371,6372
6373,6374
6373,6375
6374,6375
6377,6378
6378,6379
6378,6380
6379,6380
6382,6383
6383,6384
6383,6385
6384,6385
6387,6388
6388,6389
6388,6390
6389,6390
6391,6392
6393,6394
6393,6395
6393,6396
6394,6395
6394,6396
6395,6396
6395,6397
6396,6397
6396,6398
6397,6398
6400,6401
6400,6402
6401,6402
6401,6403
6401,6404
6401,6405
6402,6403
6404,6405
6404,6406
6405,6406
6409,6410
6412,6413
6412,6414
6413,6414
6416,6417
6416,6418
6416,6419
6416,6420
6416,6421
6416,6422
6416,6423
6416,6424
6416,6425
6416,6426
6416,6427
6416,6428
6416,6429
6416,6430
6416,6431
6417,6418
6418,6419
6418,6420
6419,6420
6422,6423
6423,6424
6423,6425
6424,6425
6427,6428
6428,6429
6428,6430
6429,6430
6431,6432
6433,6434
6434,6435
6434,6436
6435,6436
6438,6439
6439,6440
6439,6441
6441,6442
6441,6443
6441,6444
6444,6445
6446,6447
6447,6448
6447,6449
6448,6449
6451,6452
6452,6453
6452,6454
6452,6455
6453,6454
6455,6456
6458,6459
6459,6460
6459,6461
6460,6461
6463,6464
6464,6465
6464,6466
6464,6467
6464,6468
6465,6466
6467,6468
6468,6469
6470,6471
6472,6473
6473,6474
6474,6475
6476,6477
6477,6478
6477,6479
6478,6479
6481,6482
6482,6483
6482,6484
6483,6484
6483,6485
6484,6485
6488,6489
6489,6490
6489,6491
6490,6491
6493,6494
6494,6495
6494,6496
6495,6496
6495,6497
6496,6497
6499,6500
6501,6502
6501,6503
6501,6504
6502,6503
6502,6504
6503,6504
6506,6507
6506,6508
6506,6509
6506,6510
6506,6511
6507,6508
6508,6509
6508,6510
6509,6510
6512,6513
6513,6514
6513,6515
6514,6515
6517,6518
6518,6519
6518,6520
6520,6521
6522,6523
6522,6524
6522,6525
6522,6526
6523,6524
6524,6525
6524,6526
6525,6526
6528,6529
6528,6530
6529,6530
6529,6531
6530,6531
6533,6534
6535,6536
6536,6537
6538,6539
6538,6540
6538,6541
6539,6540
6540,6541
6540,6542
6541,6542
6544,6545
6545,6546
6545,6547
6546,6547
6549,6550
6550,6551
6550,6552
6551,6552
6551,6553
6552,6553
6552,6554
6553,6554
6556,6557
6558,6559
6558,6560
6559,6560
6561,6562
6561,6563
6562,6563
6562,6564
6563,6564
6566,6567
6568,6569
6568,6570
6568,6571
6569,6570
6569,6571
6570,6571
6570,6572
6570,6573
6571,6572
6573,6574
6573,6575
6574,6575
6579,6580
6579,6581
6579,6582
6579,6583
6579,6584
6579,6585
6579,6586
6579,6587
6579,6588
6579,6589
6579,6590
6579,6591
6579,6592
6579,6593
6580,6581
6581,6582
6581,6583
6582,6583
6585,6586
6586,6587
6586,6588
6587,6588
6590,6591
6591,6592
6591,6593
6591,6594
6593,6594
6593,6595
6593,6596
6596,6597
6598,6599
6598,6600
6598,6601
6601,6602
6603,6604
6604,6605
6604,6606
6605,6606
6608,6609
6609,6610
6609,6611
6610,6611
6610,6612
6611,6612
6615,6616
6616,6617
6616,6618
6617,6618
6620,6621
6621,6622
6621,6623
6622,6623
6622,6624
6623,6624
6627,6628
6628,6629
6628,6630
6629,6630
6632,6633
6633,6634
6633,6635
6634,6635
6634,6636
6635,6636
6639,6640
6640,6641
6640,6642
6641,6642
6644,6645
6645,6646
6645,6647
6646,6647
6646,6648
6647,6648
6651,6652
6652,6653
6652,6654
6653,6654
6656,6657
6657,6658
6657,6659
6657,6660
6657,6661
6657,6662
6658,6659
6660,6661
6661,6662
6664,6665
6666,6667
6668,6669
6669,6670
6669,6671
6670,6671
6672,6673
6674,6675
6674,6676
6674,6677
6675,6676
6675,6677
6676,6677
6676,6678
6676,6679
6677,6678
6679,6680
6679,6681
6680,6681
6685,6686
6685,6687
6685,6688
6685,6689
6685,6690
6685,6691
6685,6692
6685,6693
6685,6694
6685,6695
6685,6696
6685,6697
6685,6698
6685,6699
6686,6687
6687,6688
6687,6689
6688,6689
6691,6692
6692,6693
6692,6694
6693,6694
6696,6697
6697,6698
6697,6699
6697,6700
6699,6700
6699,6701
6699,6702
6702,6703
6704,6705
6704,6706
6704,6707
6707,6708
6709,6710
6710,6711
6710,6712
6711,6712
6714,6715
6715,6716
6715,6717
6716,6717
6716,6718
6717,6718
6721,6722
6722,6723
6722,6724
6723,6724
6726,6727
6727,6728
6727,6729
6728,6729
6728,6730
6729,6730
6733,6734
6734,6735
6734,6736
6735,6736
6738,6739
6739,6740
6739,6741
6740,6741
6740,6742
6741,6742
6745,6746
6746,6747
6746,6748
6747,6748
6750,6751
6751,6752
6751,6753
6752,6753
6752,6754
6753,6754
6757,6758
6758,6759
6758,6760
6759,6760
6762,6763
6763,6764
6763,6765
6763,6766
6763,6767
6763,6768
6764,6765
6766,6767
6767,6768
6770,6771
6772,6773
6774,6775
6775,6776
6775,6777
6776,6777
6778,6779
6780,6781
6780,6782
6780,6783
6780,6784
6780,6785
6781,6782
6782,6783
6782,6784
6783,6784
6786,6787
6787,6788
6787,6789
6788,6789
6790,6791
6790,6792
6791,6792
6794,6795
6795,6796
6795,6797
6796,6797
6798,6799
6798,6800
6798,6801
6798,6802
6798,6803
6798,6804
6799,6800
6801,6802
6801,6803
6802,6803
6806,6807
6808,6809
6809,6810
6811,6812
6812,6813
6814,6815
6815,6816
6815,6817
6816,6817
6819,6820
6820,6821
6820,6822
6821,6822
6824,6825
6825,6826
6826,6827
6826,6828
6827,6828
6829,6830
6829,6831
6829,6832
6829,6833
6829,6834
6829,6835
6830,6831
6832,6833
6832,6834
6833,6834
6837,6838
6839,6840
6840,6841
6842,6843
6843,6844
6845,6846
6845,6847
6845,6848
6846,6847
6848,6849
6848,6850
6848,6851
6848,6852
6848,6853
6848,6854
6848,6855
6849,6850
6850,6851
6850,6852
6851,6852
6854,6855
6855,6856
6855,6857
6856,6857
6859,6860
6860,6861
6860,6862
6860,6863
6860,6864
6861,6862
6863,6864
6866,6867
6868,6869
6869,6870
6869,6871
6870,6871
6873,6874
6874,6875
6874,6876
6875,6876
6877,6878
6879,6880
6880,6881
6880,6882
6881,6882
6884,6885
6885,6886
6885,6887
6886,6887
6889,6890
6889,6891
6889,6892
6890,6891
6890,6892
6891,6892
6893,6894
6895,6896
6895,6897
6895,6898
6895,6899
6895,6900
6896,6897
6897,6898
6897,6899
6898,6899
6901,6902
6902,6903
6902,6904
6903,6904
6906,6907
6907,6908
6907,6909
6907,6910
6908,6909
6910,6911
6913,6914
6914,6915
6914,6916
6915,6916
6918,6919
6919,6920
6919,6921
6920,6921
6923,6924
6923,6925
6924,6925
6925,6926
6925,6927
6926,6927
6929,6930
6930,6931
6930,6932
6931,6932
6934,6935
6934,6936
6934,6937
6935,6936
6935,6937
6936,6937
6936,6938
6937,6938
6937,6939
6938,6939
6941,6942
6941,6943
6942,6943
6942,6944
6942,6945
6942,6946
6943,6944
6945,6946
6945,6947
6946,6947
6950,6951
6953,6954
6953,6955
6954,6955
6957,6958
6957,6959
6957,6960
6958,6959
6959,6960
6959,6961
6960,6961
6963,6964
6964,6965
6964,6966
6965,6966
6968,6969
6969,6970
6969,6971
6969,6972
6969,6973
6969,6974
6969,6975
6970,6971
6972,6973
6973,6974
6974,6975
6974,6976
6975,6976
6978,6979
6978,6980
6979,6980
6983,6984
6983,6985
6984,6985
6984,6986
6985,6986
6985,6987
6988,6989
6989,6990
6990,6991
6990,6992
6991,6992
6995,6996
6995,6997
6996,6997
6999,7000
6999,7001
6999,7002
7000,7001
7000,7002
7001,7002
7001,7003
7002,7003
7002,7004
7003,7004
7006,7007
7006,7008
7007,7008
7007,7009
7007,7010
7007,7011
7008,7009
7010,7011
7010,7012
7011,7012
7015,7016
7018,7019
7018,7020
7019,7020
7022,7023
7022,7024
7022,7025
7022,7026
7022,7027
7022,7028
7022,7029
7022,7030
7022,7031
7022,7032
7022,7033
7022,7034
7022,7035
7022,7036
7022,7037
7022,7038
7022,7039
7022,7040
7022,7041
7022,7042
7022,7043
7022,7044
7022,7045
7022,7046
7022,7047
7022,7048
7022,7049
7022,7050
7022,7051
7022,7052
7022,7053
7022,7054
7023,7024
7024,7025
7024,7026
7025,7026
7028,7029
7029,7030
7029,7031
7030,7031
7033,7034
7034,7035
7034,7036
7036,7037
7038,7039
7039,7040
7039,7041
7040,7041
7043,7044
7044,7045
7044,7046
7044,7047
7044,7048
7044,7049
7045,7046
7047,7048
7047,7049
7048,7049
7053,7054
7053,7055
7053,7056
7054,7055
7054,7056
7055,7056
7060,7061
7061,7062
7061,7063
7062,7063
7065,7066
7066,7067
7066,7068
7066,7069
7066,7070
7066,7071
7067,7068
7069,7070
7069,7071
7070,7071
7075,7076
7075,7077
7075,7078
7076,7077
7076,7078
7077,7078
7077,7079
7078,7079
7084,7085
7085,7086
7085,7087
7086,7087
7089,7090
7090,7091
7090,7092
7090,7093
7090,7094
7090,7095
7091,7092
7093,7094
7093,7095
7094,7095
7099,7100
7099,7101
7099,7102
7100,7101
7100,7102
7101,7102
7106,7107
7107,7108
7107,7109
7108,7109
7111,7112
7112,7113
7112,7114
7112,7115
7112,7116
7112,7117
7113,7114
7115,7116
7115,7117
7116,7117
7121,7122
7121,7123
7122,7123
7124,7125
7124,7126
7125,7126
7128,7129
7129,7130
7129,7131
7130,7131
7133,7134
7134,7135
7134,7136
7134,7137
7134,7138
7135,7136
7137,7138
7137,7139
7138,7139
7143,7144
7144,7145
7144,7146
7145,7146
7148,7149
7149,7150
7149,7151
7149,7152
7150,7151
7152,7153
7152,7154
7153,7154
7156,7157
7156,7158
7157,7158
7160,7161
7161,7162
7161,7163
7162,7163
7165,7166
7166,7167
7166,7168
7166,7169
7167,7168
7169,7170
7169,7171
7170,7171
7174,7175
7175,7176
7175,7177
7176,7177
7179,7180
7180,7181
7180,7182
7180,7183
7180,7184
7180,7185
7181,7182
7183,7184
7183,7185
7184,7185
7189,7190
7189,7191
7189,7192
7190,7191
7190,7192
7191,7192
7193,7194
7193,7195
7194,7195
7197,7198
7197,7199
7198,7199
7202,7203
7203,7204
7203,7205
7204,7205
7207,7208
7208,7209
7208,7210
7208,7211
7208,7212
7209,7210
7211,7212
7211,7213
7212,7213
7217,7218
7218,7219
7218,7220
7219,7220
7222,7223
7223,7224
7223,7225
7223,7226
7224,7225
7226,7227
7226,7228
7227,7228
7230,7231
7230,7232
7231,7232
7234,7235
7235,7236
7235,7237
7236,7237
7239,7240
7240,7241
7240,7242
7240,7243
7241,7242
7243,7244
7243,7245
7244,7245
7248,7249
7249,7250
7249,7251
7250,7251
7253,7254
7254,7255
7254,7256
7254,7257
7254,7258
7254,7259
7255,7256
7257,7258
7257,7259
7258,7259
7263,7264
7263,7265
7263,7266
7264,7265
7264,7266
7265,7266
7270,7271
7271,7272
7271,7273
7272,7273
7275,7276
7276,7277
7276,7278
7276,7279
7276,7280
7277,7278
7279,7280
7279,7281
7280,7281
7285,7286
7285,7287
7285,7288
7285,7289
7286,7287
7287,7288
7287,7289
7288,7289
7291,7292
7291,7293
7292,7293
7292,7294
7293,7294
7295,7296
7295,7297
7296,7297
7296,7298
7299,7300
7299,7301
7300,7301
7302,7303
7302,7304
7303,7304
7306,7307
7306,7308
7307,7308
7307,7309
7308,7309
7308,7310
7309,7310
7312,7313
7315,7316
7316,7317
7318,7319
7318,7320
7318,7321
7319,7320
7320,7321
7320,7322
7321,7322
7324,7325
7325,7326
7325,7327
7326,7327
7329,7330
7330,7331
7330,7332
7330,7333
7330,7334
7331,7332
7333,7334
7333,7335
7334,7335
7338,7339
7338,7340
7339,7340
7339,7341
7340,7341
7343,7344
7345,7346
7346,7347
7346,7348
7347,7348
7350,7351
7351,7352
7351,7353
7351,7354
7352,7353
7354,7355
7354,7356
7355,7356
7359,7360
7359,7361
7359,7362
7360,7361
7360,7362
7361,7362
7361,7363
7362,7363
7362,7364
7363,7364
7363,7365
7364,7365
7367,7368
7367,7369
7368,7369
7368,7370
7368,7371
7368,7372
7369,7370
7371,7372
7371,7373
7372,7373
7376,7377
7379,7380
7379,7381
7380,7381
7383,7384
7383,7385
7384,7385
7387,7388
7387,7389
7387,7390
7388,7389
7389,7390
7389,7391
7390,7391
7393,7394
7394,7395
7394,7396
7395,7396
7398,7399
7399,7400
7399,7401
7400,7401
7400,7402
7401,7402
7404,7405
7404,7406
7405,7406
7407,7408
7407,7409
7408,7409
7411,7412
7411,7413
7411,7414
7412,7413
7412,7414
7413,7414
7413,7415
7414,7415
7414,7416
7415,7416
7415,7417
7416,7417
7419,7420
7419,7421
7420,7421
7423,7424
7423,7425
7424,7425
7424,7426
7424,7427
7424,7428
7425,7426
7427,7428
7427,7429
7428,7429
7432,7433
7435,7436
7435,7437
7436,7437
7439,7440
7439,7441
7439,7442
7439,7443
7439,7444
7439,7445
7439,7446
7439,7447
7439,7448
7439,7449
7439,7450
7439,7451
7439,7452
7439,7453
7439,7454
7439,7455
7439,7456
7439,7457
7439,7458
7439,7459
7439,7460
7439,7461
7439,7462
7439,7463
7439,7464
7439,7465
7439,7466
7439,7467
7439,7468
7439,7469
7439,7470
7439,7471
7439,7472
7439,7473
7439,7474
7440,7441
7441,7442
7441,7443
7442,7443
7445,7446
7446,7447
7446,7448
7447,7448
7449,7450
7449,7451
7452,7453
7453,7454
7453,7455
7454,7455
7457,7458
7458,7459
7458,7460
7460,7461
7460,7462
7460,7463
7464,7465
7465,7466
7465,7467
7466,7467
7469,7470
7470,7471
7470,7472
7470,7473
7472,7473
7474,7475
7476,7477
7477,7478
7477,7479
7478,7479
7481,7482
7482,7483
7482,7484
7484,7485
7484,7486
7484,7487
7487,7488
7489,7490
7490,7491
7490,7492
7491,7492
7494,7495
7495,7496
7495,7497
7497,7498
7499,7500
7500,7501
7500,7502
7501,7502
7504,7505
7505,7506
7505,7507
7505,7508
7506,7507
7508,7509
7511,7512
7512,7513
7512,7514
7513,7514
7515,7516
7515,7517
7515,7518
7515,7519
7515,7520
7515,7521
7516,7517
7518,7519
7518,7520
7519,7520
7523,7524
7525,7526
7526,7527
7529,7530
7529,7531
7530,7531
7532,7533
7532,7534
7532,7535
7532,7536
7533,7534
7534,7535
7534,7536
7535,7536
7538,7539
7539,7540
7539,7541
7540,7541
7543,7544
7544,7545
7544,7546
7545,7546
7548,7549
7549,7550
7551,7552
7552,7553
7552,7554
7553,7554
7556,7557
7557,7558
7557,7559
7558,7559
7560,7561
7560,7562
7561,7562
7564,7565
7564,7566
7565,7566
7565,7567
7566,7567
7566,7568
7567,7568
7569,7570
7571,7572
7573,7574
7573,7575
7573,7576
7574,7575
7575,7576
7575,7577
7577,7578
7577,7579
7577,7580
7580,7581
7581,7582
7581,7583
7582,7583
7582,7584
7584,7585
7586,7587
7586,7588
7586,7589
7587,7588
7589,7590
7592,7593
7592,7594
7593,7594
7593,7595
7594,7595
7594,7596
7595,7596
7598,7599
7598,7600
7599,7600
7599,7601
7599,7602
7600,7601
7602,7603
7607,7608
7607,7609
7607,7610
7608,7609
7608,7610
7609,7610
7609,7611
7609,7612
7610,7611
7612,7613
7616,7617
7617,7618
7618,7619
7618,7620
7619,7620
7621,7622
7621,7623
7621,7624
7622,7623
7625,7626
7627,7628
7628,7629
7629,7630
7629,7631
7630,7631
7632,7633
7632,7634
7632,7635
7632,7636
7632,7637
7633,7634
7636,7637
7638,7639
7640,7641
7642,7643
7643,7644
7643,7645
7644,7645
7646,7647
7648,7649
7649,7650
7649,7651
7650,7651
7653,7654
7654,7655
7654,7656
7655,7656
7657,7658
7657,7659
7657,7660
7658,7659
7661,7662
7663,7664
7664,7665
7664,7666
7665,7666
7667,7668
7667,7669
7667,7670
7667,7671
7667,7672
7667,7673
7668,7669
7670,7671
7670,7672
7671,7672
7674,7675
7676,7677
7678,7679
7679,7680
7682,7683
7683,7684
7683,7685
7684,7685
7687,7688
7688,7689
7688,7690
7689,7690
7691,7692
7693,7694
7693,7695
7694,7695
7696,7697
7696,7698
7696,7699
7696,7700
7697,7698
7698,7699
7698,7700
7699,7700
7702,7703
7703,7704
7703,7705
7704,7705
7707,7708
7708,7709
7708,7710
7709,7710
7712,7713
7713,7714
7715,7716
7716,7717
7716,7718
7717,7718
7720,7721
7721,7722
7721,7723
7722,7723
7724,7725
7724,7726
7725,7726
7728,7729
7729,7730
7729,7731
7730,7731
7733,7734
7734,7735
7734,7736
7735,7736
7738,7739
7738,7740
7738,7741
7739,7740
7739,7741
7740,7741
7743,7744
7743,7745
7744,7745
7745,7746
7745,7747
7746,7747
7749,7750
7750,7751
7750,7752
7750,7753
7750,7754
7750,7755
7750,7756
7751,7752
7753,7754
7756,7757
7756,7758
7757,7758
7760,7761
7762,7763
7764,7765
7765,7766
7766,7767
7766,7768
7766,7769
7766,7770
7766,7771
7766,7772
7767,7768
7769,7770
7773,7774
7775,7776
7777,7778
7777,7779
7778,7779
7778,7780
7779,7780
7779,7781
7780,7781
7782,7783
7784,7785
7786,7787
7786,7788
7786,7789
7787,7788
7787,7789
7788,7789
7788,7790
7789,7790
7791,7792
7793,7794
7793,7795
7793,7796
7793,7797
7793,7798
7793,7799
7794,7795
7795,7796
7795,7797
7797,7798
7797,7799
7797,7800
7801,7802
7802,7803
7802,7804
7804,7805
7804,7806
7806,7807
7807,7808
7807,7809
7808,7809
7808,7810
7809,7810
7813,7814
7814,7815
7814,7816
7815,7816
7817,7818
7817,7819
7817,7820
7818,7819
7820,7821
7822,7823
7822,7824
7823,7824
7824,7825
7825,7826
7825,7827
7826,7827
7829,7830
7831,7832
7831,7833
7832,7833
7832,7834
7833,7834
7836,7837
7836,7838
7837,7838
7838,7839
7838,7840
7838,7841
7839,7840
7841,7842
7845,7846
7846,7847
7846,7848
7847,7848
7849,7850
7851,7852
7852,7853
7852,7854
7853,7854
7855,7856
7857,7858
7858,7859
7858,7860
7859,7860
7859,7861
7860,7861
7862,7863
7864,7865
7864,7866
7864,7867
7865,7866
7868,7869
7868,7870
7868,7871
7869,7870
7871,7872
7874,7875
7874,7876
7875,7876
7875,7877
7876,7877
7878,7879
7880,7881
7881,7882
7882,7883
7884,7885
7885,7886
7885,7887
7886,7887
7888,7889
7890,7891
7890,7892
7891,7892
7891,7893
7892,7893
7895,7896
7895,7897
7895,7898
7895,7899
7895,7900
7895,7901
7895,7902
7895,7903
7895,7904
7895,7905
7895,7906
7895,7907
7895,7908
7895,7909
7896,7897
7897,7898
7897,7899
7898,7899
7901,7902
7902,7903
7902,7904
7903,7904
7906,7907
7907,7908
7907,7909
7907,7910
7909,7910
7911,7912
7911,7913
7913,7914
7915,7916
7916,7917
7916,7918
7917,7918
7920,7921
7921,7922
7921,7923
7921,7924
7923,7924
7925,7926
7927,7928
7928,7929
7928,7930
7929,7930
7932,7933
7933,7934
7933,7935
7933,7936
7935,7936
7937,7938
7939,7940
7939,7941
7939,7942
7939,7943
7940,7941
7941,7942
7941,7943
7942,7943
7945,7946
7945,7947
7946,7947
7948,7949
7950,7951
7951,7952
7953,7954
7953,7955
7953,7956
7953,7957
7954,7955
7955,7956
7955,7957
7956,7957
7959,7960
7960,7961
7960,7962
7961,7962
7964,7965
7965,7966
7965,7967
7966,7967
7968,7969
7968,7970
7969,7970
7971,7972
7971,7973
7972,7973
7974,7975
7976,7977
7976,7978
7977,7978
7977,7979
7978,7979
7980,7981
7982,7983
7982,7984
7982,7985
7983,7984
7984,7985
7984,7986
7985,7986
7988,7989
7989,7990
7989,7991
7990,7991
7993,7994
7994,7995
7994,7996
7995,7996
7997,7998
7999,8000
8000,8001
8000,8002
8001,8002
8004,8005
8005,8006
8005,8007
8006,8007
8008,8009
8008,8010
8010,8011
8011,8012
8011,8013
8012,8013
8015,8016
8015,8017
8016,8017
8016,8018
8017,8018
8020,8021
8020,8022
8020,8023
8021,8022
8022,8023
8022,8024
8023,8024
8026,8027
8027,8028
8027,8029
8028,8029
8031,8032
8032,8033
8032,8034
8033,8034
8036,8037
8037,8038
8037,8039
8038,8039
8041,8042
8042,8043
8042,8044
8043,8044
8045,8046
8045,8047
8046,8047
8047,8048
8047,8049
8048,8049
8048,8050
8049,8050
8051,8052
8054,8055
8056,8057
8056,8058
8056,8059
8056,8060
8057,8058
8058,8059
8058,8060
8059,8060
8062,8063
8062,8064
8063,8064
8065,8066
8067,8068
8068,8069
8070,8071
8070,8072
8070,8073
8070,8074
8071,8072
8072,8073
8072,8074
8073,8074
8076,8077
8076,8078
8076,8079
8076,8080
8077,8078
8078,8079
8078,8080
8079,8080
8081,8082
8083,8084
8083,8085
8084,8085
8086,8087
8088,8089
8088,8090
8089,8090
8091,8092
8093,8094
8093,8095
8093,8096
8093,8097
8093,8098
8094,8095
8095,8096
8095,8097
8096,8097
8099,8100
8100,8101
8100,8102
8101,8102
8104,8105
8105,8106
8105,8107
8107,8108
8107,8109
8107,8110
8110,8111
8111,8112
8111,8113
8111,8114
8112,8113
8112,8114
8113,8114
8115,8116
8119,8120
8120,8121
8120,8122
8121,8122
8124,8125
8125,8126
8125,8127
8125,8128
8125,8129
8125,8130
8125,8131
8126,8127
8128,8129
8128,8130
8129,8130
8133,8134
8135,8136
8137,8138
8137,8139
8137,8140
8138,8139
8138,8140
8139,8140
8141,8142
8143,8144
8143,8145
8144,8145
8146,8147
8149,8150
8150,8151
8150,8152
8151,8152
8154,8155
8155,8156
8155,8157
8155,8158
8156,8157
8158,8159
8158,8160
8159,8160
8163,8164
8163,8165
8163,8166
8163,8167
8164,8165
8165,8166
8165,8167
8166,8167
8169,8170
8169,8171
8170,8171
8172,8173
8174,8175
8175,8176
8177,8178
8177,8179
8177,8180
8178,8179
8179,8180
8179,8181
8180,8181
8183,8184
8184,8185
8184,8186
8185,8186
8188,8189
8189,8190
8189,8191
8190,8191
8192,8193
8192,8194
8193,8194
8195,8196
8197,8198
8198,8199
8198,8200
8199,8200
8202,8203
8203,8204
8203,8205
8204,8205
8206,8207
8208,8209
8208,8210
8208,8211
8209,8210
8209,8211
8210,8211
8210,8212
8211,8212
8211,8213
8212,8213
8212,8214
8213,8214
8216,8217
8216,8218
8217,8218
8220,8221
8220,8222
8221,8222
8221,8223
8221,8224
8221,8225
8222,8223
8224,8225
8224,8226
8225,8226
8229,8230
8232,8233
8232,8234
8233,8234
8236,8237
8236,8238
8236,8239
8236,8240
8236,8241
8236,8242
8236,8243
8236,8244
8236,8245
8236,8246
8236,8247
8236,8248
8236,8249
8236,8250
8236,8251
8236,8252
8237,8238
8238,8239
8238,8240
8239,8240
8242,8243
8243,8244
8243,8245
8244,8245
8247,8248
8248,8249
8248,8250
8249,8250
8249,8251
8249,8252
8251,8252
8251,8253
8253,8254
8253,8255
8256,8257
8256,8258
8258,8259
8260,8261
8260,8262
8260,8263
8263,8264
8264,8265
8264,8266
8264,8267
8264,8268
8264,8269
8264,8270
8264,8271
8264,8272
8264,8273
8264,8274
8264,8275
8264,8276
8264,8277
8265,8266
8265,8267
8267,8268
8269,8270
8269,8271
8271,8272
8273,8274
8273,8275
8275,8276
8277,8278
8277,8279
8279,8280
8281,8282
8281,8283
8283,8284
8285,8286
8285,8287
8287,8288
8289,8290
8289,8291
8291,8292
8293,8294
8293,8295
8295,8296
8297,8298
8297,8299
8299,8300
8301,8302
8301,8303
8303,8304
8305,8306
8305,8307
8307,8308
8309,8310
8309,8311
8311,8312
8313,8314
8313,8315
8315,8316
8317,8318
8318,8319
8318,8320
8319,8320
8322,8323
8323,8324
8323,8325
8325,8326
8325,8327
8327,8328
8328,8329
8330,8331
8331,8332
8331,8333
8332,8333
8335,8336
8336,8337
8336,8338
8338,8339
8338,8340
8340,8341
8342,8343
8343,8344
8343,8345
8344,8345
8347,8348
8348,8349
8348,8350
8348,8351
8350,8351
8352,8353
8354,8355
8355,8356
8355,8357
8356,8357
8359,8360
8360,8361
8360,8362
8360,8363
8361,8362
8363,8364
8366,8367
8367,8368
8367,8369
8368,8369
8371,8372
8372,8373
8372,8374
8373,8374
8375,8376
8375,8377
8376,8377
8378,8379
8378,8380
8379,8380
8382,8383
8382,8384
8382,8385
8382,8386
8383,8384
8384,8385
8384,8386
8385,8386
8388,8389
8388,8390
8389,8390
8391,8392
8391,8393
8392,8393
8392,8394
8395,8396
8396,8397
8396,8398
8397,8398
8398,8399
8399,8400
8401,8402
8402,8403
8403,8404
8403,8405
8404,8405
8407,8408
8408,8409
8410,8411
8411,8412
8411,8413
8412,8413
8412,8414
8413,8414
8413,8415
8413,8416
8413,8417
8414,8415
8416,8417
8416,8418
8417,8418
8420,8421
8420,8422
8421,8422
8421,8423
8422,8423
8424,8425
8427,8428
8430,8431
8431,8432
8431,8433
8431,8434
8432,8433
8432,8434
8433,8434
8436,8437
8437,8438
8438,8439
8438,8440
8439,8440
8441,8442
8441,8443
8442,8443
8442,8444
8443,8444
8445,8446
8448,8449
8448,8450
8448,8451
8449,8450
8450,8451
8450,8452
8450,8453
8450,8454
8451,8452
8453,8454
8456,8457
8456,8458
8457,8458
8460,8461
8461,8462
8461,8463
8462,8463
8464,8465
8467,8468
8467,8469
8468,8469
8468,8470
8469,8470
8472,8473
8473,8474
8473,8475
8474,8475
8476,8477
8476,8478
8477,8478
8477,8479
8480,8481
8480,8482
8481,8482
8483,8484
8483,8485
8484,8485
8487,8488
8487,8489
8487,8490
8488,8489
8488,8490
8489,8490
8490,8491
8490,8492
8491,8492
8493,8494
8495,8496
8496,8497
8496,8498
8497,8498
8499,8500
8501,8502
8501,8503
8501,8504
8502,8503
8503,8504
8503,8505
8504,8505
8507,8508
8508,8509
8508,8510
8509,8510
8512,8513
8513,8514
8513,8515
8513,8516
8513,8517
8514,8515
8516,8517
8519,8520
8519,8521
8520,8521
8523,8524
8523,8525
8524,8525
8525,8526
8525,8527
8526,8527
8529,8530
8529,8531
8530,8531
8532,8533
8532,8534
8532,8535
8532,8536
8532,8537
8532,8538
8532,8539
8532,8540
8532,8541
8532,8542
8532,8543
8532,8544
8532,8545
8532,8546
8532,8547
8532,8548
8532,8549
8532,8550
8532,8551
8532,8552
8532,8553
8532,8554
8532,8555
8533,8534
8534,8535
8536,8537
8537,8538
8539,8540
8539,8541
8539,8542
8540,8541
8540,8542
8541,8542
8544,8545
8544,8546
8544,8547
8545,8546
8546,8547
8546,8548
8548,8549
8548,8550
8550,8551
8551,8552
8551,8553
8552,8553
8552,8554
8555,8556
8555,8557
8555,8558
8555,8559
8556,8557
8558,8559
8558,8560
8559,8560
8564,8565
8565,8566
8565,8567
8566,8567
8568,8569
8568,8570
8568,8571
8568,8572
8569,8570
8571,8572
8573,8574
8573,8575
8574,8575
8577,8578
8579,8580
8580,8581
8580,8582
8580,8583
8580,8584
8580,8585
8581,8582
8583,8584
8583,8585
8584,8585
8588,8589
8590,8591
8592,8593
8593,8594
8594,8595
8594,8596
8594,8597
8594,8598
8595,8596
8597,8598
8600,8601
8600,8602
8601,8602
8605,8606
8606,8607
8608,8609
8609,8610
8611,8612
8612,8613
8614,8615
8614,8616
8614,8617
8615,8616
8615,8617
8616,8617
8619,8620
8619,8621
8620,8621
8621,8622
8621,8623
8622,8623
8624,8625
8624,8626
8625,8626
8627,8628
8629,8630
8630,8631
8630,8632
8630,8633
8630,8634
8630,8635
8631,8632
8633,8634
8633,8635
8634,8635
8638,8639
8640,8641
8642,8643
8643,8644
8644,8645
8644,8646
8644,8647
8644,8648
8645,8646
8647,8648
8650,8651
8650,8652
8651,8652
8655,8656
8656,8657
8658,8659
8658,8660
8658,8661
8659,8660
8659,8661
8660,8661
8663,8664
8663,8665
8663,8666
8664,8665
8665,8666
8665,8667
8667,8668
8667,8669
8669,8670
8670,8671
8670,8672
8671,8672
8671,8673
8674,8675
8674,8676
8675,8676
8677,8678
8677,8679
8678,8679
8681,8682
8682,8683
8682,8684
8683,8684
8685,8686
8685,8687
8685,8688
8686,8687
8688,8689
8690,8691
8692,8693
8693,8694
8693,8695
8693,8696
8693,8697
8693,8698
8694,8695
8696,8697
8696,8698
8697,8698
8701,8702
8703,8704
8705,8706
8706,8707
8707,8708
8707,8709
8707,8710
8707,8711
8708,8709
8710,8711
8713,8714
8713,8715
8714,8715
8718,8719
8719,8720
8721,8722
8722,8723
8724,8725
8724,8726
8724,8727
8725,8726
8725,8727
8726,8727
8729,8730
8729,8731
8729,8732
8730,8731
8731,8732
8731,8733
8733,8734
8733,8735
8735,8736
8736,8737
8736,8738
8737,8738
8739,8740
8739,8741
8740,8741
8743,8744
8744,8745
8744,8746
8745,8746
8747,8748
8747,8749
8747,8750
8748,8749
8750,8751
8752,8753
8754,8755
8755,8756
8755,8757
8755,8758
8755,8759
8755,8760
8756,8757
8758,8759
8758,8760
8759,8760
8763,8764
8765,8766
8767,8768
8768,8769
8769,8770
8769,8771
8769,8772
8769,8773
8770,8771
8772,8773
8775,8776
8775,8777
8776,8777
8780,8781
8781,8782
8783,8784
8784,8785
8786,8787
8787,8788
8789,8790
8790,8791
8793,8794
8794,8795
8794,8796
8794,8797
8794,8798
8795,8796
8797,8798
8800,8801
8800,8802
8801,8802
8805,8806
8805,8807
8805,8808
8806,8807
8806,8808
8807,8808
8807,8809
8808,8809
8808,8810
8809,8810
8809,8811
8810,8811
8813,8814
8813,8815
8814,8815
8817,8818
8817,8819
8818,8819
8818,8820
8818,8821
8818,8822
8819,8820
8821,8822
8821,8823
8822,8823
8826,8827
8829,8830
8829,8831
8830,8831
8833,8834
8833,8835
8833,8836
8833,8837
8834,8835
8835,8836
8835,8837
8836,8837
8839,8840
8840,8841
8840,8842
8841,8842
8844,8845
8845,8846
8845,8847
8845,8848
8846,8847
8848,8849
8851,8852
8852,8853
8852,8854
8852,8855
8853,8854
8855,8856
8855,8857
8856,8857
8859,8860
8859,8861
8860,8861
8860,8862
8863,8864
8863,8865
8864,8865
8866,8867
8866,8868
8867,8868
8870,8871
8870,8872
8870,8873
8871,8872
8871,8873
8872,8873
8872,8874
8873,8874
8873,8875
8874,8875
8874,8876
8875,8876
8877,8878
8877,8879
8878,8879
8881,8882
8881,8883
8882,8883
8885,8886
8885,8887
8886,8887
8886,8888
8886,8889
8886,8890
8887,8888
8889,8890
8889,8891
8890,8891
8894,8895
8897,8898
8897,8899
8898,8899
8901,8902
8901,8903
8901,8904
8902,8903
8903,8904
8903,8905
8904,8905
8907,8908
8908,8909
8908,8910
8909,8910
8912,8913
8913,8914
8913,8915
8914,8915
8916,8917
8916,8918
8917,8918
8919,8920
8919,8921
8920,8921
8923,8924
8923,8925
8923,8926
8924,8925
8924,8926
8925,8926
8925,8927
8926,8927
8926,8928
8927,8928
8930,8931
8930,8932
8931,8932
8931,8933
8931,8934
8931,8935
8932,8933
8934,8935
8934,8936
8935,8936
8939,8940
8942,8943
8942,8944
8943,8944
8946,8947
8946,8948
8946,8949
8946,8950
8946,8951
8946,8952
8946,8953
8946,8954
8947,8948
8948,8949
8948,8950
8949,8950
8952,8953
8953,8954
8953,8955
8954,8955
8957,8958
8958,8959
8958,8960
8958,8961
8959,8960
8961,8962
8964,8965
8965,8966
8965,8967
8966,8967
8969,8970
8970,8971
8970,8972
8971,8972
8973,8974
8973,8975
8974,8975
8977,8978
8978,8979
8978,8980
8979,8980
8982,8983
8983,8984
8983,8985
8984,8985
8984,8986
8985,8986
8988,8989
8988,8990
8989,8990
8991,8992
8991,8993
8992,8993
8995,8996
8995,8997
8995,8998
8996,8997
8996,8998
8997,8998
8997,8999
8998,8999
9002,9003
9002,9004
9003,9004
9004,9005
9004,9006
9005,9006
9008,9009
9009,9010
9009,9011
9009,9012
9009,9013
9010,9011
9012,9013
9012,9014
9013,9014
9018,9019
9019,9020
9020,9021
9020,9022
9020,9023
9020,9024
9021,9022
9023,9024
9023,9025
9024,9025
9027,9028
9029,9030
9029,9031
9030,9031
9033,9034
9033,9035
9033,9036
9034,9035
9034,9036
9035,9036
9035,9037
9036,9037
9039,9040
9039,9041
9040,9041
9040,9042
9040,9043
9040,9044
9041,9042
9043,9044
9043,9045
9044,9045
9048,9049
9051,9052
9051,9053
9051,9054
9052,9053
9053,9054
9053,9055
9054,9055
9057,9058
9058,9059
9058,9060
9059,9060
9062,9063
9063,9064
9063,9065
9063,9066
9063,9067
9063,9068
9064,9065
9066,9067
9066,9068
9067,9068
9071,9072
9072,9073
9074,9075
9075,9076
9077,9078
9077,9079
9077,9080
9078,9079
9078,9080
9079,9080
9079,9081
9080,9081
9083,9084
9083,9085
9084,9085
9084,9086
9084,9087
9084,9088
9085,9086
9087,9088
9087,9089
9088,9089
9092,9093
9095,9096
9095,9097
9095,9098
9095,9099
9095,9100
9095,9101
9096,9097
9097,9098
9097,9099
9098,9099
9101,9102
9102,9103
9102,9104
9103,9104
9106,9107
9107,9108
9107,9109
9109,9110
9109,9111
9109,9112
9112,9113
9113,9114
9113,9115
9113,9116
9114,9115
9114,9116
9115,9116
9118,9119
9118,9120
9119,9120
9123,9124
9124,9125
9124,9126
9125,9126
9128,9129
9129,9130
9129,9131
9131,9132
9131,9133
9131,9134
9134,9135
9136,9137
9136,9138
9137,9138
9137,9139
9138,9139
9141,9142
9141,9143
9141,9144
9142,9143
9143,9144
9143,9145
9144,9145
9147,9148
9148,9149
9148,9150
9148,9151
9148,9152
9148,9153
9149,9150
9151,9152
9151,9153
9152,9153
9155,9156
9157,9158
9159,9160
9160,9161
9162,9163
9162,9164
9163,9164
9165,9166
9165,9167
9165,9168
9165,9169
9165,9170
9166,9167
9167,9168
9167,9169
9168,9169
9171,9172
9172,9173
9172,9174
9173,9174
9176,9177
9177,9178
9177,9179
9177,9180
9177,9181
9178,9179
9180,9181
9180,9182
9181,9182
9185,9186
9187,9188
9188,9189
9188,9190
9189,9190
9192,9193
9193,9194
9193,9195
9194,9195
9196,9197
9198,9199
9198,9200
9198,9201
9199,9200
9199,9201
9200,9201
9200,9202
9201,9202
9201,9203
9202,9203
9205,9206
9205,9207
9206,9207
9206,9208
9206,9209
9206,9210
9207,9208
9209,9210
9209,9211
9210,9211
9214,9215
9217,9218
9217,9219
9218,9219
9221,9222
9221,9223
9221,9224
9221,9225
9221,9226
9221,9227
9222,9223
9223,9224
9223,9225
9224,9225
9227,9228
9228,9229
9228,9230
9229,9230
9232,9233
9233,9234
9233,9235
9235,9236
9237,9238
9238,9239
9238,9240
9239,9240
9242,9243
9243,9244
9243,9245
9244,9245
9246,9247
9246,9248
9247,9248
9249,9250
9249,9251
9250,9251
9252,9253
9254,9255
9254,9256
9254,9257
9254,9258
9255,9256
9256,9257
9256,9258
9257,9258
9260,9261
9260,9262
9261,9262
9261,9263
9262,9263
9264,9265
9266,9267
9266,9268
9267,9268
9269,9270
9269,9271
9270,9271
9272,9273
9272,9274
9273,9274
9276,9277
9277,9278
9279,9280
9279,9281
9280,9281
9281,9282
9281,9283
9282,9283
9285,9286
9286,9287
9286,9288
9287,9288
9287,9289
9288,9289
9288,9290
9289,9290
9292,9293
9292,9294
9293,9294
9296,9297
9296,9298
9297,9298
9297,9299
9300,9301
9300,9302
9301,9302
9303,9304
9303,9305
9304,9305
9306,9307
9308,9309
9308,9310
9308,9311
9308,9312
9309,9310
9310,9311
9310,9312
9311,9312
9314,9315
9315,9316
9315,9317
9315,9318
9315,9319
9316,9317
9318,9319
9321,9322
9321,9323
9322,9323
9325,9326
9326,9327
9326,9328
9327,9328
9330,9331
9331,9332
9331,9333
9332,9333
9335,9336
9336,9337
9336,9338
9337,9338
9340,9341
9341,9342
9341,9343
9342,9343
9345,9346
9346,9347
9348,9349
9349,9350
9349,9351
9350,9351
-----nextToken-----
2,4,6,8,9,12,14,15,20,21,22,26,27,29,33,34,38,39,43,44,47,49,51,55,56,59,61,63,67,68,71,73,75,79,80,83,85,87,91,92,95,97,98,100,105,107,110,113,115,120,121,125,128,130,135,136,140,141,145,150,152,153,158,159,160,166,168,169,173,175,176,181,182,186,187,190,192,196,199,203,204,209,212,216,218,223,225,229,231,233,238,239,246,248,249,252,253,257,260,261,262,267,268,272,273,277,281,282,286,291,293,295,300,301,305,306,311,314,315,319,320,325,326,330,331,335,338,341,342,347,348,353,356,360,362,367,369,373,376,378,383,384,388,389,393,397,399,404,405,409,410,415,418,419,423,424,428,431,434,435,439,440,445,446,450,451,455,456,458,462,463,467,470,473,474,478,479,483,487,488,489,495,496,499,500,504,507,508,509,511,512,517,518,522,523,526,528,529,531,535,536,539,541,542,544,548,550,551,555,557,558,562,563,566,568,573,574,577,579,582,587,588,592,593,596,598,599,603,605,610,611,612,617,618,623,624,625,630,631,635,636,640,644,645,650,651,655,657,658,661,663,667,668,672,673,675,679,680,685,686,690,691,695,698,700,704,705,710,711,715,716,720,722,726,727,731,734,736,741,742,746,748,749,753,754,758,759,761,765,766,771,772,776,777,781,783,784,788,789,793,794,796,800,801,806,807,811,812,816,817,821,824,826,829,833,835,840,841,845,846,850,852,853,855,859,861,865,866,870,871,873,877,878,882,884,885,889,892,894,895,898,899,901,905,906,911,912,916,918,919,922,924,928,930,934,935,939,940,942,948,951,953,954,956,957,961,963,967,969,974,975,979,980,984,985,990,992,993,996,998,1002,1003,1007,1008,1012,1014,1022,1023,1026,1027,1031,1034,1035,1036,1038,1039,1042,1043,1046,1047,1052,1053,1057,1058,1062,1065,1068,1069,1075,1076,1079,1080,1084,1087,1088,1089,1091,1092,1097,1098,1102,1103,1107,1114,1115,1118,1119,1123,1126,1127,1128,1130,1131,1134,1135,1140,1141,1145,1146,1150,1152,1156,1157,1160,1162,1163,1165,1169,1170,1174,1176,1177,1181,1182,1186,1189,1191,1195,1199,1200,1205,1206,1207,1211,1212,1217,1218,1220,1224,1225,1231,1232,1233,1234,1238,1239,1245,1246,1247,1248,1252,1253,1259,1260,1261,1262,1266,1267,1272,1273,1274,1278,1281,1282,1283,1285,1288,1291,1294,1299,1300,1304,1305,1309,1311,1312,1314,1318,1319,1323,1325,1329,1330,1334,1335,1341,1342,1346,1349,1350,1351,1353,1354,1357,1358,1363,1364,1368,1369,1373,1375,1376,1380,1381,1385,1388,1389,1390,1394,1395,1399,1402,1403,1404,1408,1409,1414,1415,1416,1420,1423,1424,1425,1426,1427,1428,1432,1433,1438,1439,1440,1444,1445,1450,1451,1455,1456,1460,1462,1463,1467,1468,1472,1474,1475,1479,1480,1484,1486,1487,1488,1493,1494,1497,1499,1504,1505,1508,1510,1513,1518,1519,1523,1524,1528,1531,1533,1537,1538,1542,1544,1545,1549,1550,1554,1556,1557,1558,1562,1563,1567,1568,1572,1573,1578,1579,1583,1584,1588,1591,1592,1593,1597,1598,1603,1604,1605,1609,1612,1613,1614,1615,1616,1617,1621,1624,1625,1626,1627,1628,1629,1633,1634,1638,1641,1642,1646,1647,1648,1649,1656,1657,1661,1664,1665,1666,1668,1669,1672,1673,1676,1677,1682,1683,1687,1688,1693,1694,1697,1700,1701,1706,1707,1711,1714,1715,1716,1718,1719,1724,1725,1730,1731,1736,1739,1740,1743,1746,1747,1748,1753,1754,1758,1759,1763,1765,1769,1770,1774,1775,1781,1782,1786,1789,1790,1791,1793,1794,1797,1798,1803,1804,1808,1809,1812,1814,1819,1820,1823,1826,1827,1828,1832,1833,1838,1839,1845,1846,1847,1852,1853,1857,1858,1864,1865,1866,1867,1871,1872,1878,1879,1880,1883,1884,1888,1889,1895,1896,1897,1900,1901,1905,1906,1910,1914,1915,1916,1919,1920,1925,1926,1930,1931,1936,1937,1939,1943,1944,1949,1950,1951,1955,1956,1960,1963,1964,1965,1970,1971,1975,1976,1982,1983,1984,1985,1989,1990,1996,1997,1998,1999,2003,2004,2010,2011,2012,2013,2017,2018,2024,2025,2026,2027,2031,2032,2038,2039,2040,2041,2045,2046,2052,2053,2054,2055,2059,2060,2066,2067,2068,2069,2073,2074,2080,2081,2082,2083,2088,2089,2090,2095,2096,2100,2101,2107,2108,2109,2110,2114,2115,2120,2121,2125,2126,2127,2131,2132,2137,2138,2142,2143,2144,2148,2149,2153,2156,2157,2161,2162,2163,2168,2169,2176,2177,2183,2186,2187,2188,2190,2191,2195,2198,2199,2200,2202,2203,2206,2207,2210,2211,2216,2217,2221,2222,2227,2228,2231,2234,2235,2240,2241,2245,2248,2249,2250,2252,2253,2258,2259,2263,2264,2268,2270,2271,2273,2276,2281,2282,2286,2287,2291,2293,2294,2296,2302,2303,2307,2310,2311,2312,2314,2315,2318,2319,2324,2325,2329,2330,2333,2335,2336,2340,2341,2345,2346,2349,2351,2352,2356,2357,2361,2363,2364,2367,2371,2372,2375,2377,2381,2382,2385,2387,2391,2392,2395,2397,2399,2403,2404,2407,2409,2413,2414,2417,2419,2423,2424,2427,2429,2430,2434,2435,2439,2441,2445,2446,2449,2452,2453,2456,2458,2459,2463,2464,2468,2469,2473,2474,2478,2481,2482,2486,2490,2491,2495,2497,2498,2502,2503,2507,2510,2513,2514,2518,2519,2524,2525,2529,2530,2534,2536,2537,2541,2542,2546,2547,2549,2553,2554,2559,2560,2564,2565,2569,2571,2572,2576,2577,2581,2582,2584,2588,2589,2594,2595,2597,2601,2602,2607,2608,2609,2615,2616,2617,2618,2623,2624,2628,2629,2634,2635,2638,2642,2643,2644,2645,2649,2650,2655,2656,2657,2661,2662,2666,2668,2673,2674,2679,2680,2683,2686,2687,2688,2692,2693,2697,2699,2704,2705,2706,2711,2712,2716,2717,2721,2723,2724,2726,2730,2731,2735,2736,2738,2742,2743,2748,2749,2753,2754,2755,2759,2760,2764,2767,2768,2770,2774,2775,2780,2781,2785,2786,2790,2792,2793,2797,2798,2802,2805,2806,2810,2811,2815,2816,2818,2822,2823,2827,2830,2832,2836,2839,2842,2843,2845,2847,2850,2851,2855,2859,2860,2863,2865,2866,2871,2872,2876,2877,2880,2882,2883,2887,2888,2890,2894,2895,2898,2900,2902,2906,2909,2914,2915,2919,2920,2924,2927,2928,2930,2932,2935,2936,2940,2941,2945,2946,2951,2952,2955,2956,2961,2962,2963,2967,2968,2973,2974,2978,2979,2983,2985,2989,2990,2994,2997,2998,3002,3003,3007,3010,3011,3015,3016,3020,3022,3023,3026,3027,3031,3032,3036,3037,3039,3043,3044,3048,3051,3052,3054,3058,3061,3064,3065,3067,3068,3069,3070,3074,3075,3079,3081,3084,3089,3090,3094,3096,3097,3099,3102,3104,3108,3109,3113,3116,3117,3121,3122,3126,3129,3130,3134,3135,3139,3140,3142,3146,3149,3152,3153,3155,3157,3160,3161,3165,3166,3170,3172,3175,3180,3181,3184,3188,3190,3194,3196,3197,3200,3202,3206,3207,3211,3214,3215,3219,3220,3224,3225,3227,3231,3234,3236,3240,3242,3246,3247,3251,3252,3257,3258,3262,3263,3267,3268,3270,3274,3275,3279,3282,3287,3288,3289,3292,3293,3297,3298,3303,3304,3308,3309,3313,3315,3316,3320,3321,3325,3328,3329,3333,3334,3338,3339,3341,3345,3346,3350,3353,3354,3356,3357,3359,3363,3364,3368,3371,3373,3378,3379,3382,3384,3387,3392,3393,3397,3398,3403,3406,3407,3411,3412,3417,3420,3421,3425,3426,3431,3434,3435,3439,3440,3445,3447,3448,3452,3455,3458,3459,3461,3463,3466,3467,3471,3472,3476,3478,3481,3486,3487,3491,3493,3494,3497,3499,3502,3506,3508,3512,3513,3517,3520,3521,3525,3526,3530,3531,3533,3537,3540,3542,3545,3549,3551,3552,3553,3554,3555,3561,3562,3565,3567,3571,3572,3577,3578,3581,3583,3586,3591,3592,3596,3597,3600,3602,3603,3607,3610,3615,3616,3619,3620,3625,3626,3627,3631,3633,3636,3637,3639,3641,3643,3648,3651,3652,3656,3657,3660,3661,3666,3667,3671,3672,3676,3678,3679,3682,3683,3685,3687,3690,3691,3695,3696,3700,3704,3706,3711,3712,3716,3718,3720,3724,3725,3729,3734,3735,3738,3739,3744,3745,3751,3752,3756,3759,3763,3764,3768,3772,3773,3776,3777,3781,3782,3786,3788,3789,3792,3793,3795,3797,3799,3803,3805,3810,3811,3815,3817,3821,3824,3826,3830,3832,3837,3838,3842,3844,3845,3848,3849,3851,3854,3856,3860,3861,3863,3867,3868,3872,3875,3876,3880,3881,3885,3888,3889,3893,3895,3898,3902,3904,3905,3906,3907,3908,3914,3915,3919,3922,3923,3924,3926,3927,3930,3931,3936,3937,3941,3942,3946,3948,3952,3953,3956,3958,3959,3961,3965,3966,3970,3972,3973,3977,3978,3982,3985,3987,3991,3995,3996,4001,4002,4003,4007,4008,4013,4014,4016,4020,4021,4026,4027,4031,4034,4037,4038,4039,4041,4044,4047,4052,4053,4057,4060,4061,4065,4068,4071,4072,4073,4075,4078,4081,4085,4086,4090,4091,4094,4099,4100,4104,4105,4109,4111,4112,4114,4118,4119,4123,4125,4129,4130,4134,4135,4139,4141,4146,4147,4151,4152,4156,4158,4159,4163,4164,4168,4169,4175,4176,4180,4183,4184,4185,4187,4188,4191,4192,4197,4198,4202,4203,4206,4208,4209,4211,4212,4216,4217,4220,4222,4223,4225,4229,4230,4234,4237,4238,4242,4243,4247,4251,4252,4255,4256,4257,4261,4262,4266,4268,4269,4273,4276,4279,4280,4282,4284,4287,4291,4293,4298,4299,4303,4304,4308,4310,4311,4313,4317,4318,4322,4324,4328,4329,4333,4334,4340,4341,4345,4348,4349,4350,4352,4353,4356,4357,4362,4363,4367,4368,4371,4373,4374,4378,4379,4383,4384,4388,4391,4392,4396,4397,4402,4403,4406,4408,4414,4415,4419,4422,4423,4424,4426,4427,4430,4431,4436,4437,4441,4442,4445,4447,4451,4454,4455,4462,4463,4467,4470,4471,4472,4474,4475,4480,4481,4485,4488,4489,4490,4492,4493,4498,4499,4503,4504,4509,4510,4512,4519,4520,4524,4527,4528,4529,4531,4532,4537,4538,4542,4545,4546,4547,4549,4550,4555,4556,4560,4561,4566,4567,4569,4574,4575,4579,4582,4583,4584,4586,4587,4592,4593,4597,4598,4603,4604,4606,4611,4612,4616,4619,4620,4621,4623,4624,4629,4630,4634,4635,4640,4641,4643,4648,4649,4653,4656,4657,4658,4660,4661,4666,4667,4671,4672,4677,4678,4680,4684,4685,4689,4694,4695,4698,4699,4700,4705,4706,4710,4713,4714,4715,4717,4718,4723,4724,4728,4729,4734,4735,4737,4741,4742,4746,4751,4752,4755,4756,4757,4762,4763,4767,4770,4771,4772,4774,4775,4780,4781,4785,4786,4791,4792,4794,4798,4799,4803,4808,4809,4812,4813,4814,4819,4820,4824,4827,4828,4829,4831,4832,4837,4838,4842,4843,4848,4849,4851,4855,4856,4860,4862,4863,4868,4869,4873,4875,4876,4880,4881,4885,4886,4892,4893,4897,4900,4901,4902,4904,4905,4908,4909,4914,4915,4919,4920,4923,4925,4929,4932,4933,4938,4939,4943,4946,4947,4948,4950,4951,4956,4957,4961,4962,4967,4968,4970,4974,4975,4979,4981,4984,4985,4990,4991,4995,4997,4998,5001,5002,5006,5007,5011,5012,5018,5019,5023,5026,5027,5028,5030,5031,5034,5035,5040,5041,5045,5046,5050,5055,5056,5059,5060,5061,5065,5066,5069,5072,5073,5074,5077,5078,5084,5085,5089,5092,5093,5094,5096,5097,5100,5101,5106,5107,5111,5113,5114,5118,5119,5123,5124,5127,5129,5130,5134,5135,5139,5140,5143,5145,5146,5148,5153,5154,5155,5159,5160,5165,5166,5170,5171,5176,5177,5180,5183,5184,5187,5188,5192,5193,5197,5199,5200,5205,5206,5207,5212,5213,5217,5219,5223,5224,5228,5231,5232,5236,5237,5242,5243,5245,5250,5251,5255,5257,5262,5263,5265,5269,5270,5275,5276,5278,5284,5285,5289,5292,5293,5294,5296,5297,5300,5301,5306,5307,5313,5314,5315,5316,5321,5322,5326,5327,5331,5334,5335,5340,5341,5345,5348,5349,5353,5354,5360,5361,5362,5363,5369,5370,5371,5372,5377,5378,5382,5383,5388,5389,5392,5397,5398,5399,5400,5405,5406,5407,5412,5413,5417,5418,5422,5424,5425,5430,5431,5432,5436,5437,5442,5443,5445,5449,5450,5454,5455,5460,5461,5465,5470,5471,5474,5475,5476,5479,5480,5485,5486,5491,5492,5495,5498,5499,5504,5505,5506,5511,5512,5517,5520,5521,5522,5523,5528,5529,5533,5534,5538,5540,5541,5544,5545,5549,5550,5555,5556,5558,5562,5563,5567,5568,5573,5574,5578,5583,5584,5587,5588,5589,5592,5593,5599,5600,5603,5604,5608,5611,5612,5613,5615,5616,5621,5622,5626,5627,5630,5632,5637,5638,5641,5643,5646,5651,5652,5656,5657,5662,5663,5667,5668,5672,5675,5676,5677,5681,5682,5686,5689,5690,5691,5694,5696,5700,5701,5705,5708,5709,5710,5716,5717,5721,5724,5725,5726,5728,5729,5734,5735,5738,5739,5744,5745,5749,5750,5755,5756,5760,5761,5765,5767,5770,5771,5775,5776,5779,5781,5782,5786,5787,5792,5793,5797,5798,5802,5804,5807,5808,5812,5813,5816,5818,5819,5825,5826,5830,5833,5834,5835,5837,5838,5841,5842,5847,5848,5852,5853,5857,5858,5865,5866,5869,5870,5874,5877,5878,5879,5881,5882,5885,5886,5891,5892,5896,5897,5901,5903,5904,5908,5911,5912,5913,5917,5918,5923,5924,5928,5929,5933,5935,5936,5939,5940,5944,5945,5949,5950,5955,5956,5960,5963,5965,5967,5971,5972,5976,5978,5986,5987,5990,5991,5995,5998,5999,6000,6002,6003,6006,6007,6010,6011,6016,6017,6021,6022,6025,6027,6028,6032,6033,6036,6038,6039,6043,6045,6046,6050,6052,6053,6057,6058,6061,6063,6065,6069,6070,6075,6076,6080,6081,6085,6088,6089,6093,6094,6098,6099,6104,6105,6109,6112,6113,6117,6118,6122,6125,6126,6130,6133,6135,6138,6142,6144,6149,6150,6154,6155,6159,6161,6162,6164,6168,6170,6174,6175,6179,6180,6182,6186,6187,6191,6193,6194,6198,6201,6204,6205,6207,6209,6210,6214,6215,6220,6221,6225,6227,6228,6231,6234,6235,6239,6241,6245,6246,6250,6251,6253,6260,6263,6265,6266,6268,6271,6273,6278,6280,6286,6287,6288,6292,6293,6297,6299,6303,6305,6310,6311,6315,6316,6320,6321,6326,6328,6331,6333,6338,6339,6343,6344,6348,6350,6351,6355,6356,6360,6361,6366,6368,6369,6372,6375,6376,6380,6381,6385,6386,6390,6392,6398,6399,6403,6406,6407,6408,6410,6411,6414,6415,6420,6421,6425,6426,6430,6432,6436,6437,6440,6442,6443,6445,6449,6450,6454,6456,6457,6461,6462,6466,6469,6471,6475,6479,6480,6485,6486,6487,6491,6492,6497,6498,6500,6504,6505,6510,6511,6515,6516,6519,6521,6526,6527,6531,6532,6534,6537,6542,6543,6547,6548,6554,6555,6557,6560,6564,6565,6567,6572,6575,6576,6577,6578,6583,6584,6588,6589,6592,6594,6595,6597,6599,6600,6602,6606,6607,6612,6613,6614,6618,6619,6624,6625,6626,6630,6631,6636,6637,6638,6642,6643,6648,6649,6650,6654,6655,6659,6662,6663,6665,6667,6671,6673,6678,6681,6682,6683,6684,6689,6690,6694,6695,6698,6700,6701,6703,6705,6706,6708,6712,6713,6718,6719,6720,6724,6725,6730,6731,6732,6736,6737,6742,6743,6744,6748,6749,6754,6755,6756,6760,6761,6765,6768,6769,6771,6773,6777,6779,6784,6785,6789,6792,6793,6797,6800,6803,6804,6805,6807,6810,6813,6817,6818,6822,6823,6828,6831,6834,6835,6836,6838,6841,6844,6847,6852,6853,6857,6858,6862,6864,6865,6867,6871,6872,6876,6878,6882,6883,6887,6888,6892,6894,6899,6900,6904,6905,6909,6911,6912,6916,6917,6921,6922,6927,6928,6932,6933,6939,6940,6944,6947,6948,6949,6951,6952,6955,6956,6961,6962,6966,6967,6971,6976,6977,6980,6981,6982,6986,6987,6992,6993,6994,6997,6998,7004,7005,7009,7012,7013,7014,7016,7017,7020,7021,7026,7027,7031,7032,7035,7037,7041,7042,7046,7049,7050,7051,7052,7056,7057,7058,7059,7063,7064,7068,7071,7072,7073,7074,7079,7080,7081,7082,7083,7087,7088,7092,7095,7096,7097,7098,7102,7103,7104,7105,7109,7110,7114,7117,7118,7119,7120,7123,7126,7127,7131,7132,7136,7139,7140,7141,7142,7146,7147,7151,7154,7155,7158,7159,7163,7164,7168,7171,7172,7173,7177,7178,7182,7185,7186,7187,7188,7192,7195,7196,7199,7200,7201,7205,7206,7210,7213,7214,7215,7216,7220,7221,7225,7228,7229,7232,7233,7237,7238,7242,7245,7246,7247,7251,7252,7256,7259,7260,7261,7262,7266,7267,7268,7269,7273,7274,7278,7281,7282,7283,7284,7289,7290,7294,7297,7298,7301,7304,7305,7310,7311,7313,7314,7317,7322,7323,7327,7328,7332,7335,7336,7337,7341,7342,7344,7348,7349,7353,7356,7357,7358,7365,7366,7370,7373,7374,7375,7377,7378,7381,7382,7385,7386,7391,7392,7396,7397,7402,7403,7406,7409,7410,7417,7418,7421,7422,7426,7429,7430,7431,7433,7434,7437,7438,7443,7444,7448,7450,7451,7455,7456,7459,7461,7462,7463,7467,7468,7471,7473,7475,7479,7480,7483,7485,7486,7488,7492,7493,7496,7498,7502,7503,7507,7509,7510,7514,7517,7520,7521,7522,7524,7527,7528,7531,7536,7537,7541,7542,7546,7547,7550,7554,7555,7559,7562,7563,7568,7570,7572,7576,7578,7579,7583,7585,7588,7590,7591,7596,7597,7601,7603,7604,7605,7606,7611,7613,7614,7615,7620,7623,7624,7626,7631,7634,7635,7637,7639,7641,7645,7647,7651,7652,7656,7659,7660,7662,7666,7669,7672,7673,7675,7677,7680,7681,7685,7686,7690,7692,7695,7700,7701,7705,7706,7710,7711,7714,7718,7719,7723,7726,7727,7731,7732,7736,7737,7741,7742,7747,7748,7752,7754,7755,7758,7759,7761,7763,7768,7770,7771,7772,7774,7776,7781,7783,7785,7790,7792,7796,7798,7799,7800,7803,7805,7810,7811,7812,7816,7819,7821,7827,7828,7830,7834,7835,7840,7842,7843,7844,7848,7850,7854,7856,7861,7863,7866,7867,7870,7872,7873,7877,7879,7883,7887,7889,7893,7894,7899,7900,7904,7905,7908,7910,7912,7914,7918,7919,7922,7924,7926,7930,7931,7934,7936,7938,7943,7944,7947,7949,7952,7957,7958,7962,7963,7967,7970,7973,7975,7979,7981,7986,7987,7991,7992,7996,7998,8002,8003,8007,8009,8013,8014,8018,8019,8024,8025,8029,8030,8034,8035,8039,8040,8044,8050,8052,8053,8055,8060,8061,8064,8066,8069,8074,8075,8080,8082,8085,8087,8090,8092,8097,8098,8102,8103,8106,8108,8109,8114,8116,8117,8118,8122,8123,8127,8130,8131,8132,8134,8136,8140,8142,8145,8147,8148,8152,8153,8157,8160,8161,8162,8167,8168,8171,8173,8176,8181,8182,8186,8187,8191,8194,8196,8200,8201,8205,8207,8214,8215,8218,8219,8223,8226,8227,8228,8230,8231,8234,8235,8240,8241,8245,8246,8250,8252,8254,8255,8257,8259,8261,8262,8266,8268,8270,8272,8274,8276,8278,8280,8282,8284,8286,8288,8290,8292,8294,8296,8298,8300,8302,8304,8306,8308,8310,8312,8314,8316,8320,8321,8324,8326,8329,8333,8334,8337,8339,8341,8345,8346,8349,8351,8353,8357,8358,8362,8364,8365,8369,8370,8374,8377,8380,8381,8386,8387,8390,8393,8394,8400,8405,8406,8409,8415,8418,8419,8423,8425,8426,8428,8429,8434,8435,8440,8444,8446,8447,8452,8454,8455,8458,8459,8463,8465,8466,8470,8471,8475,8478,8479,8482,8485,8486,8492,8494,8498,8500,8505,8506,8510,8511,8515,8517,8518,8521,8522,8527,8528,8531,8535,8538,8542,8543,8547,8549,8553,8554,8557,8560,8561,8562,8563,8567,8570,8572,8575,8576,8578,8582,8585,8586,8587,8589,8591,8596,8598,8599,8602,8603,8604,8607,8610,8613,8617,8618,8623,8626,8628,8632,8635,8636,8637,8639,8641,8646,8648,8649,8652,8653,8654,8657,8661,8662,8666,8668,8672,8673,8676,8679,8680,8684,8687,8689,8691,8695,8698,8699,8700,8702,8704,8709,8711,8712,8715,8716,8717,8720,8723,8727,8728,8732,8734,8738,8741,8742,8746,8749,8751,8753,8757,8760,8761,8762,8764,8766,8771,8773,8774,8777,8778,8779,8782,8785,8788,8791,8792,8796,8798,8799,8802,8803,8804,8811,8812,8815,8816,8820,8823,8824,8825,8827,8828,8831,8832,8837,8838,8842,8843,8847,8849,8850,8854,8857,8858,8861,8862,8865,8868,8869,8876,8879,8880,8883,8884,8888,8891,8892,8893,8895,8896,8899,8900,8905,8906,8910,8911,8915,8918,8921,8922,8928,8929,8933,8936,8937,8938,8940,8941,8944,8945,8950,8951,8955,8956,8960,8962,8963,8967,8968,8972,8975,8976,8980,8981,8986,8987,8990,8993,8994,8999,9000,9001,9006,9007,9011,9014,9015,9016,9017,9022,9025,9026,9028,9031,9032,9037,9038,9042,9045,9046,9047,9049,9050,9055,9056,9060,9061,9065,9068,9069,9070,9073,9076,9081,9082,9086,9089,9090,9091,9093,9094,9099,9100,9104,9105,9108,9110,9111,9116,9117,9120,9121,9122,9126,9127,9130,9132,9133,9135,9139,9140,9145,9146,9150,9153,9154,9156,9158,9161,9164,9169,9170,9174,9175,9179,9182,9183,9184,9186,9190,9191,9195,9197,9203,9204,9208,9211,9212,9213,9215,9216,9219,9220,9225,9226,9230,9231,9234,9236,9240,9241,9245,9248,9251,9253,9258,9259,9263,9265,9268,9271,9274,9275,9278,9283,9284,9290,9291,9294,9295,9298,9299,9302,9305,9307,9312,9313,9317,9319,9320,9323,9324,9328,9329,9333,9334,9338,9339,9343,9344,9347,9351,9352
-----computeFrom-----
102,103
102,104
108,109
108,110
147,148
147,149
162,163
162,164
163,164
163,165
170,171
170,172
206,207
206,208
220,221
220,222
226,227
226,228
241,242
241,243
242,243
242,244
243,244
243,245
250,251
250,252
254,255
254,256
258,259
258,260
288,289
288,290
308,309
308,310
317,318
317,319
339,340
339,341
350,351
350,352
364,365
364,366
412,413
412,414
432,433
432,434
437,438
437,439
465,466
465,467
481,482
481,483
491,492
491,493
492,493
492,494
493,494
493,495
497,498
497,499
501,502
501,503
571,572
571,573
575,576
575,577
607,608
607,609
620,621
620,622
677,678
677,679
693,694
693,695
702,703
702,704
718,719
718,720
729,730
729,731
763,764
763,765
798,799
798,800
814,815
814,816
819,820
819,821
831,832
831,833
887,888
887,889
903,904
903,905
944,945
944,946
946,947
946,948
965,966
965,967
982,983
982,984
1005,1006
1005,1007
1016,1017
1016,1018
1017,1018
1017,1019
1018,1019
1018,1020
1019,1020
1019,1021
1020,1021
1020,1022
1024,1025
1024,1026
1028,1029
1028,1030
1040,1041
1040,1042
1044,1045
1044,1046
1060,1061
1060,1062
1071,1072
1071,1073
1072,1073
1072,1074
1073,1074
1073,1075
1077,1078
1077,1079
1081,1082
1081,1083
1109,1110
1109,1111
1110,1111
1110,1112
1111,1112
1111,1113
1112,1113
1112,1114
1116,1117
1116,1118
1120,1121
1120,1122
1132,1133
1132,1134
1202,1203
1202,1204
1214,1215
1214,1216
1227,1228
1227,1229
1241,1242
1241,1243
1255,1256
1255,1257
1269,1270
1269,1271
1332,1333
1332,1334
1337,1338
1337,1339
1338,1339
1338,1340
1339,1340
1339,1341
1343,1344
1343,1345
1355,1356
1355,1357
1411,1412
1411,1413
1435,1436
1435,1437
1442,1443
1442,1444
1502,1503
1502,1504
1506,1507
1506,1508
1526,1527
1526,1528
1565,1566
1565,1567
1600,1601
1600,1602
1651,1652
1651,1653
1652,1653
1652,1654
1653,1654
1653,1655
1654,1655
1654,1656
1658,1659
1658,1660
1670,1671
1670,1672
1674,1675
1674,1676
1690,1691
1690,1692
1703,1704
1703,1705
1704,1705
1704,1706
1708,1709
1708,1710
1727,1728
1727,1729
1728,1729
1728,1730
1732,1733
1732,1734
1734,1735
1734,1736
1772,1773
1772,1774
1777,1778
1777,1779
1778,1779
1778,1780
1779,1780
1779,1781
1783,1784
1783,1785
1795,1796
1795,1797
1817,1818
1817,1819
1830,1831
1830,1832
1860,1861
1860,1862
1874,1875
1874,1876
1891,1892
1891,1893
1933,1934
1933,1935
1946,1947
1946,1948
1978,1979
1978,1980
1992,1993
1992,1994
2006,2007
2006,2008
2020,2021
2020,2022
2034,2035
2034,2036
2048,2049
2048,2050
2062,2063
2062,2064
2076,2077
2076,2078
2103,2104
2103,2105
2117,2118
2117,2119
2134,2135
2134,2136
2171,2172
2171,2173
2172,2173
2172,2174
2173,2174
2173,2175
2174,2175
2174,2176
2179,2180
2179,2181
2180,2181
2180,2182
2192,2193
2192,2194
2204,2205
2204,2206
2208,2209
2208,2210
2224,2225
2224,2226
2237,2238
2237,2239
2238,2239
2238,2240
2242,2243
2242,2244
2298,2299
2298,2300
2299,2300
2299,2301
2300,2301
2300,2302
2304,2305
2304,2306
2316,2317
2316,2318
2466,2467
2466,2468
2505,2506
2505,2507
2516,2517
2516,2518
2551,2552
2551,2553
2591,2592
2591,2593
2604,2605
2604,2606
2611,2612
2611,2613
2631,2632
2631,2633
2639,2640
2639,2641
2652,2653
2652,2654
2664,2665
2664,2666
2676,2677
2676,2678
2695,2696
2695,2697
2701,2702
2701,2703
2745,2746
2745,2747
2762,2763
2762,2764
2772,2773
2772,2774
2825,2826
2825,2827
2834,2835
2834,2836
2853,2854
2853,2855
2856,2857
2856,2858
2922,2923
2922,2924
2943,2944
2943,2945
2948,2949
2948,2950
2965,2966
2965,2967
3046,3047
3046,3048
3056,3057
3056,3058
3144,3145
3144,3146
3229,3230
3229,3231
3244,3245
3244,3246
3249,3250
3249,3251
3277,3278
3277,3279
3283,3284
3283,3285
3284,3285
3284,3286
3285,3286
3285,3287
3290,3291
3290,3292
3295,3296
3295,3297
3351,3352
3351,3353
3366,3367
3366,3368
3376,3377
3376,3378
3380,3381
3380,3382
3400,3401
3400,3402
3414,3415
3414,3416
3428,3429
3428,3430
3442,3443
3442,3444
3450,3451
3450,3452
3535,3536
3535,3537
3575,3576
3575,3577
3579,3580
3579,3581
3612,3613
3612,3614
3613,3614
3613,3615
3617,3618
3617,3619
3634,3635
3634,3636
3645,3646
3645,3647
3646,3647
3646,3648
3649,3650
3649,3651
3653,3654
3653,3655
3688,3689
3688,3690
3702,3703
3702,3704
3731,3732
3731,3733
3769,3770
3769,3771
3801,3802
3801,3803
3819,3820
3819,3821
3828,3829
3828,3830
3857,3858
3857,3859
3910,3911
3910,3912
3911,3912
3911,3913
3912,3913
3912,3914
3916,3917
3916,3918
3928,3929
3928,3930
3998,3999
3998,4000
4010,4011
4010,4012
4018,4019
4018,4020
4029,4030
4029,4031
4055,4056
4055,4057
4063,4064
4063,4065
4088,4089
4088,4090
4132,4133
4132,4134
4137,4138
4137,4139
4166,4167
4166,4168
4171,4172
4171,4173
4172,4173
4172,4174
4173,4174
4173,4175
4177,4178
4177,4179
4189,4190
4189,4191
4232,4233
4232,4234
4245,4246
4245,4247
4249,4250
4249,4251
4271,4272
4271,4273
4289,4290
4289,4291
4331,4332
4331,4333
4336,4337
4336,4338
4337,4338
4337,4339
4338,4339
4338,4340
4342,4343
4342,4344
4354,4355
4354,4356
4399,4400
4399,4401
4410,4411
4410,4412
4411,4412
4411,4413
4412,4413
4412,4414
4416,4417
4416,4418
4428,4429
4428,4430
4457,4458
4457,4459
4459,4460
4459,4461
4460,4461
4460,4462
4464,4465
4464,4466
4477,4478
4477,4479
4478,4479
4478,4480
4482,4483
4482,4484
4506,4507
4506,4508
4514,4515
4514,4516
4516,4517
4516,4518
4517,4518
4517,4519
4521,4522
4521,4523
4534,4535
4534,4536
4535,4536
4535,4537
4539,4540
4539,4541
4563,4564
4563,4565
4571,4572
4571,4573
4572,4573
4572,4574
4576,4577
4576,4578
4600,4601
4600,4602
4608,4609
4608,4610
4609,4610
4609,4611
4613,4614
4613,4615
4637,4638
4637,4639
4645,4646
4645,4647
4646,4647
4646,4648
4650,4651
4650,4652
4674,4675
4674,4676
4702,4703
4702,4704
4703,4704
4703,4705
4707,4708
4707,4709
4731,4732
4731,4733
4759,4760
4759,4761
4760,4761
4760,4762
4764,4765
4764,4766
4788,4789
4788,4790
4816,4817
4816,4818
4817,4818
4817,4819
4821,4822
4821,4823
4845,4846
4845,4847
4883,4884
4883,4885
4888,4889
4888,4890
4889,4890
4889,4891
4890,4891
4890,4892
4894,4895
4894,4896
4906,4907
4906,4908
4935,4936
4935,4937
4936,4937
4936,4938
4940,4941
4940,4942
4964,4965
4964,4966
5009,5010
5009,5011
5014,5015
5014,5016
5015,5016
5015,5017
5016,5017
5016,5018
5020,5021
5020,5022
5032,5033
5032,5034
5062,5063
5062,5064
5080,5081
5080,5082
5081,5082
5081,5083
5082,5083
5082,5084
5086,5087
5086,5088
5098,5099
5098,5100
5150,5151
5150,5152
5157,5158
5157,5159
5173,5174
5173,5175
5178,5179
5178,5180
5202,5203
5202,5204
5239,5240
5239,5241
5259,5260
5259,5261
5272,5273
5272,5274
5280,5281
5280,5282
5281,5282
5281,5283
5282,5283
5282,5284
5286,5287
5286,5288
5298,5299
5298,5300
5309,5310
5309,5311
5356,5357
5356,5358
5365,5366
5365,5367
5385,5386
5385,5387
5402,5403
5402,5404
5439,5440
5439,5441
5452,5453
5452,5454
5488,5489
5488,5490
5501,5502
5501,5503
5514,5515
5514,5516
5552,5553
5552,5554
5565,5566
5565,5567
5595,5596
5595,5597
5596,5597
5596,5598
5597,5598
5597,5599
5601,5602
5601,5603
5605,5606
5605,5607
5635,5636
5635,5637
5639,5640
5639,5641
5654,5655
5654,5656
5712,5713
5712,5714
5713,5714
5713,5715
5714,5715
5714,5716
5718,5719
5718,5720
5731,5732
5731,5733
5732,5733
5732,5734
5736,5737
5736,5738
5747,5748
5747,5749
5772,5773
5772,5774
5784,5785
5784,5786
5809,5810
5809,5811
5821,5822
5821,5823
5822,5823
5822,5824
5823,5824
5823,5825
5827,5828
5827,5829
5839,5840
5839,5841
5855,5856
5855,5857
5860,5861
5860,5862
5861,5862
5861,5863
5862,5863
5862,5864
5863,5864
5863,5865
5867,5868
5867,5869
5871,5872
5871,5873
5883,5884
5883,5885
5915,5916
5915,5917
5947,5948
5947,5949
5958,5959
5958,5960
5980,5981
5980,5982
5981,5982
5981,5983
5982,5983
5982,5984
5983,5984
5983,5985
5984,5985
5984,5986
5988,5989
5988,5990
5992,5993
5992,5994
6004,6005
6004,6006
6008,6009
6008,6010
6067,6068
6067,6069
6083,6084
6083,6085
6096,6097
6096,6098
6107,6108
6107,6109
6120,6121
6120,6122
6128,6129
6128,6130
6140,6141
6140,6142
6196,6197
6196,6198
6212,6213
6212,6214
6255,6256
6255,6257
6256,6257
6256,6258
6258,6259
6258,6260
6269,6270
6269,6271
6276,6277
6276,6278
6283,6284
6283,6285
6301,6302
6301,6303
6318,6319
6318,6320
6323,6324
6323,6325
6324,6325
6324,6326
6329,6330
6329,6331
6358,6359
6358,6360
6383,6384
6383,6385
6394,6395
6394,6396
6395,6396
6395,6397
6396,6397
6396,6398
6400,6401
6400,6402
6412,6413
6412,6414
6482,6483
6482,6484
6494,6495
6494,6496
6502,6503
6502,6504
6524,6525
6524,6526
6550,6551
6550,6552
6569,6570
6569,6571
6609,6610
6609,6611
6621,6622
6621,6623
6633,6634
6633,6635
6645,6646
6645,6647
6669,6670
6669,6671
6675,6676
6675,6677
6715,6716
6715,6717
6727,6728
6727,6729
6739,6740
6739,6741
6751,6752
6751,6753
6775,6776
6775,6777
6787,6788
6787,6789
6795,6796
6795,6797
6820,6821
6820,6822
6826,6827
6826,6828
6885,6886
6885,6887
6890,6891
6890,6892
6919,6920
6919,6921
6930,6931
6930,6932
6935,6936
6935,6937
6936,6937
6936,6938
6937,6938
6937,6939
6941,6942
6941,6943
6953,6954
6953,6955
6983,6984
6983,6985
7000,7001
7000,7002
7001,7002
7001,7003
7002,7003
7002,7004
7006,7007
7006,7008
7018,7019
7018,7020
7287,7288
7287,7289
7291,7292
7291,7293
7292,7293
7292,7294
7306,7307
7306,7308
7360,7361
7360,7362
7361,7362
7361,7363
7362,7363
7362,7364
7363,7364
7363,7365
7367,7368
7367,7369
7379,7380
7379,7381
7383,7384
7383,7385
7399,7400
7399,7401
7412,7413
7412,7414
7413,7414
7413,7415
7414,7415
7414,7416
7415,7416
7415,7417
7419,7420
7419,7421
7423,7424
7423,7425
7435,7436
7435,7437
7512,7513
7512,7514
7557,7558
7557,7559
7565,7566
7565,7567
7593,7594
7593,7595
7594,7595
7594,7596
7598,7599
7598,7600
7608,7609
7608,7610
7618,7619
7618,7620
7629,7630
7629,7631
7654,7655
7654,7656
7664,7665
7664,7666
7721,7722
7721,7723
7724,7725
7724,7726
7734,7735
7734,7736
7739,7740
7739,7741
7778,7779
7778,7780
7788,7789
7788,7790
7807,7808
7807,7809
7808,7809
7808,7810
7814,7815
7814,7816
7822,7823
7822,7824
7832,7833
7832,7834
7846,7847
7846,7848
7852,7853
7852,7854
7858,7859
7858,7860
7891,7892
7891,7893
7941,7942
7941,7943
7945,7946
7945,7947
7965,7966
7965,7967
7977,7978
7977,7979
7994,7995
7994,7996
8005,8006
8005,8007
8008,8009
8008,8010
8011,8012
8011,8013
8016,8017
8016,8018
8032,8033
8032,8034
8042,8043
8042,8044
8045,8046
8045,8047
8047,8048
8047,8049
8048,8049
8048,8050
8058,8059
8058,8060
8062,8063
8062,8064
8078,8079
8078,8080
8083,8084
8083,8085
8088,8089
8088,8090
8112,8113
8112,8114
8165,8166
8165,8167
8169,8170
8169,8171
8209,8210
8209,8211
8210,8211
8210,8212
8211,8212
8211,8213
8212,8213
8212,8214
8216,8217
8216,8218
8220,8221
8220,8222
8232,8233
8232,8234
8372,8373
8372,8374
8384,8385
8384,8386
8388,8389
8388,8390
8396,8397
8396,8398
8412,8413
8412,8414
8432,8433
8432,8434
8438,8439
8438,8440
8461,8462
8461,8463
8468,8469
8468,8470
8473,8474
8473,8475
8488,8489
8488,8490
8490,8491
8490,8492
8496,8497
8496,8498
8540,8541
8540,8542
8565,8566
8565,8567
8615,8616
8615,8617
8621,8622
8621,8623
8659,8660
8659,8661
8682,8683
8682,8684
8725,8726
8725,8727
8744,8745
8744,8746
8806,8807
8806,8808
8807,8808
8807,8809
8808,8809
8808,8810
8809,8810
8809,8811
8813,8814
8813,8815
8817,8818
8817,8819
8829,8830
8829,8831
8871,8872
8871,8873
8872,8873
8872,8874
8873,8874
8873,8875
8874,8875
8874,8876
8877,8878
8877,8879
8881,8882
8881,8883
8885,8886
8885,8887
8897,8898
8897,8899
8913,8914
8913,8915
8924,8925
8924,8926
8925,8926
8925,8927
8926,8927
8926,8928
8930,8931
8930,8932
8942,8943
8942,8944
8983,8984
8983,8985
8996,8997
8996,8998
9034,9035
9034,9036
9035,9036
9035,9037
9039,9040
9039,9041
9078,9079
9078,9080
9079,9080
9079,9081
9083,9084
9083,9085
9114,9115
9114,9116
9199,9200
9199,9201
9200,9201
9200,9202
9201,9202
9201,9203
9205,9206
9205,9207
9217,9218
9217,9219
9246,9247
9246,9248
9256,9257
9256,9258
9260,9261
9260,9262
9261,9262
9261,9263
9266,9267
9266,9268
9286,9287
9286,9288
9292,9293
9292,9294
9331,9332
9331,9333
-----guardedBy-----
173,311
175,314
260,277
291,311
293,314
507,734
610,640
679,695
704,720
800,816
967,984
1034,1068
1349,1531
1357,1510
1664,1700
1714,1746
1736,1765
1789,1826
1797,1819
2198,2234
2310,2356
2615,2655
2616,2656
2855,3146
2863,3102
2865,3153
3651,3706
3660,3682
3648,3729
3739,3777
3735,3773
3738,3792
3922,4060
3930,4020
4139,4168
4183,4255
4191,4251
4291,4333
4348,4378
4419,4824
4422,4827
4897,4943
4900,5001
4946,4984
5026,5077
5092,5187
5205,5242
5292,5592
5313,5334
5369,5479
5405,5442
5406,5443
5504,5555
5505,5556
5520,5544
5611,5694
5724,5807
5738,5786
5877,5939
5998,6125
6010,6069
6303,6320
6331,6360
6406,6792
6414,6504
6892,6921
6947,6997
7373,7409
7429,7758
7437,7741
7433,7850
7792,7848
7893,8087
7979,7998
7981,7996
8018,8034
8223,8415
8226,8802
8234,8727
8230,8428
8418,8458
8425,8446
8423,8444
8434,8440
8470,8475
8823,8868
8891,8921
8936,8993
8999,9014
9089,9120
9211,9305
9219,9265
-----guardedByNegation-----
173,415
175,418
504,9208
507,9323
495,9203
511,9215
679,731
967,1007
1031,9208
1034,9323
1022,9203
1046,9265
1038,9215
1084,9208
1087,9323
1075,9203
1091,9215
1123,9208
1126,9323
1114,9203
1134,9265
1130,9215
1346,9208
1349,9323
1341,9203
1357,9265
1353,9215
1444,1510
1661,9208
1664,9323
1656,9203
1676,9265
1668,9215
1711,9208
1714,9323
1706,9203
1718,9215
1786,9208
1789,9323
1781,9203
1797,9265
1793,9215
2195,9208
2198,9323
2176,9203
2210,9265
2202,9215
2245,9208
2248,9323
2240,9203
2252,9215
2307,9208
2310,9323
2302,9203
2318,9265
2314,9215
2615,2686
2616,2687
3919,9208
3922,9323
3914,9203
3930,9265
3926,9215
4180,9208
4183,9323
4175,9203
4191,9265
4187,9215
4345,9208
4348,9323
4340,9203
4356,9265
4352,9215
4419,9208
4422,9323
4414,9203
4430,9265
4426,9215
4485,4824
4488,4827
4492,4831
4542,4824
4545,4827
4549,4831
4579,4824
4582,4827
4586,4831
4616,4824
4619,4827
4623,4831
4653,4824
4656,4827
4660,4831
4710,4824
4713,4827
4717,4831
4767,4824
4770,4827
4774,4831
4897,9208
4900,9323
4892,9203
4908,9265
4904,9215
4946,5001
5023,9208
5026,9323
5018,9203
5034,9265
5030,9215
5089,9208
5092,9323
5084,9203
5100,9215
5205,5275
5206,5263
5289,9208
5292,9323
5284,9203
5300,9265
5296,9215
5313,5348
5369,5592
5405,5474
5504,5587
5608,9208
5611,9323
5599,9203
5615,9215
5721,9208
5724,9323
5716,9203
5738,9265
5728,9215
5830,9208
5833,9323
5825,9203
5841,9265
5837,9215
5874,9208
5877,9323
5865,9203
5885,9265
5881,9215
5917,5978
5995,9208
5998,9323
5986,9203
6010,9265
6002,9215
6303,6385
6331,6385
6403,9208
6406,9323
6398,9203
6414,9265
6410,9215
6572,6678
6575,6792
6681,6792
6892,6932
6944,9208
6947,9323
6939,9203
6955,9265
6951,9215
7009,9208
7012,9323
7004,9203
7020,9265
7016,9215
7370,9208
7373,9323
7365,9203
7385,9265
7377,9215
7426,9208
7429,9323
7417,9203
7437,9265
7433,9215
7613,7641
8223,9208
8226,9323
8214,9203
8234,9265
8230,9215
8434,8463
8498,8751
8820,9208
8823,9323
8811,9203
8831,9265
8827,9215
8888,9208
8891,9323
8879,9203
8899,9265
8895,9215
8933,9208
8936,9323
8928,9203
8944,9265
8940,9215
8999,9031
9000,9032
9042,9208
9045,9323
9037,9203
9049,9215
9086,9208
9089,9323
9081,9203
9093,9215
9211,9323
-----lastLexicalUse-----
173,415
175,418
507,9323
679,731
967,1007
1034,9323
1349,9323
1357,9265
1664,9323
1714,9323
1789,9323
1797,9265
2198,9323
2310,9323
2615,2686
2616,2687
3922,9323
3930,9265
4183,9323
4191,9265
4348,9323
4419,9208
4422,9323
4897,9208
4900,9323
4946,5001
5026,9323
5092,9323
5205,5275
5292,9323
5313,5348
5369,5592
5405,5474
5504,5587
5611,9323
5724,9323
5738,9265
5877,9323
5998,9323
6010,9265
6303,6385
6331,6385
6406,9323
6414,9265
6892,6932
6947,9323
7373,9323
7429,9323
7433,9215
7437,9265
8223,9208
8226,9323
8230,9215
8234,9265
8434,8463
8823,9323
8891,9323
8936,9323
8999,9031
9089,9323
9211,9323
-----jump-----
173,415
175,418
507,9323
679,731
967,1007
1034,9323
1349,9323
1357,9265
1664,9323
1714,9323
1789,9323
1797,9265
2198,9323
2310,9323
2615,2686
2616,2687
3922,9323
3930,9265
4183,9323
4191,9265
4348,9323
4419,9208
4422,9323
4897,9208
4900,9323
4946,5001
5026,9323
5092,9323
5205,5275
5292,9323
5313,5348
5369,5592
5405,5474
5504,5587
5611,9323
5724,9323
5738,9265
5877,9323
5998,9323
6010,9265
6303,6385
6331,6385
6406,9323
6414,9265
6892,6932
6947,9323
7373,9323
7429,9323
7433,9215
7437,9265
8223,9208
8226,9323
8230,9215
8234,9265
8434,8463
8823,9323
8891,9323
8936,9323
8999,9031
9089,9323
9211,9323
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Pointer;Name;ArrayModifier;LiteralExpression;WhileStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;WhileStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;WhileStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ConditionalExpression;BinaryExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;FunctionDeclarator;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;WhileStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;DoStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;WhileStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DoStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;WhileStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Pointer;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Pointer;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Pointer;Name;ArrayModifier;LiteralExpression;ArrayDeclarator;Pointer;Name;ArrayModifier;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ConditionalExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ContinueStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;LiteralExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;UnaryExpression;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;LiteralExpression;IdExpression;Name;WhileStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;ConditionalExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ConditionalExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;CompositeTypeSpecifier;Name;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;InitializerList;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;InitializerList;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;UnaryExpression;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;ConditionalExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static int do_meta_command(char *zLine, struct callback_data *p){printf("\nfile_name:%s\n",__FILE__);printf("function_name:%s\n",__func__);printf("------function start!------\n");printf("static int do_meta_command(char *zLine, struct callback_data *p){\n");  printf("int i = 1;\n");  int i = 1;  printf("int nArg = 0;\n");  int nArg = 0;  printf("int n, c;\n");  int n, c;  printf("int rc = 0;\n");  int rc = 0;  printf("char *azArg[50];\n");  char *azArg[50];  /* Parse the input line into tokens.  */  while( zLine[i] && nArg<ArraySize(azArg) ){printf("while(zLine[i] && nArg<ArraySize(azArg))\n");      while( IsSpace(zLine[i]) ){printf("while(IsSpace(zLine[i]))\n");     printf("i++;\n");i++; }    if( zLine[i]==0 ) {printf("if(zLine[i]==0)\n");    break;}    if( zLine[i]=='\'' || zLine[i]=='"' ){printf("if(zLine[i]=='\'' || zLine[i]==''')\n");          printf("int delim = zLine[i++];\n");      int delim = zLine[i++];      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }      if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}    }else{      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }      if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);    }  }  /* Process the input line.  */  if( nArg==0 ) {printf("if(nArg==0)\n");  printf("return 0;\n");  printf("------function end!------\n");  return 0;} /* no tokens, no error */  printf("n = strlen30(azArg[0]);\n");n = strlen30(azArg[0]);  printf("c = azArg[0][0];\n");c = azArg[0][0];  if( c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n");      printf("const char *zDestFile = 0;\n");    const char *zDestFile = 0;    printf("const char *zDb = 0;\n");    const char *zDb = 0;    sqlite3 *pDest;    sqlite3_backup *pBackup;    printf("int j;\n");    int j;    for(j=1; j<nArg; j++){printf("for(j=1;j<nArg;j++)\n");          printf("const char *z = azArg[j];\n");      const char *z = azArg[j];      if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }    }    if( zDestFile==0 ){printf("if(zDestFile==0)\n");          printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");      fprintf(stderr, "missing FILENAME argument on .backup\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( zDb==0 ) {printf("if(zDb==0)\n");    printf("zDb = 'main';\n");zDb = "main";}    rc = sqlite3_open(zDestFile, &pDest);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pDest);  }else  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");      printf("bail_on_error = booleanValue(azArg[1]);\n");bail_on_error = booleanValue(azArg[1]);  }else  /* The undocumented ".breakpoint" command causes a call to the no-op  ** routine named test_breakpoint().  */  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");      printf("test_breakpoint();\n");    test_breakpoint();  }else  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }  printf("return rc;\n");  printf("------function end!------\n");  return rc;printf("------function end!------\n");}
static int
do_meta_command(char *zLine, struct callback_data *p)
do_meta_command
char *zLine
char
*zLine
*
zLine
struct callback_data *p
struct callback_data
callback_data
*p
*
p
{printf("\nfile_name:%s\n",__FILE__);printf("function_name:%s\n",__func__);printf("------function start!------\n");printf("static int do_meta_command(char *zLine, struct callback_data *p){\n");  printf("int i = 1;\n");  int i = 1;  printf("int nArg = 0;\n");  int nArg = 0;  printf("int n, c;\n");  int n, c;  printf("int rc = 0;\n");  int rc = 0;  printf("char *azArg[50];\n");  char *azArg[50];  /* Parse the input line into tokens.  */  while( zLine[i] && nArg<ArraySize(azArg) ){printf("while(zLine[i] && nArg<ArraySize(azArg))\n");      while( IsSpace(zLine[i]) ){printf("while(IsSpace(zLine[i]))\n");     printf("i++;\n");i++; }    if( zLine[i]==0 ) {printf("if(zLine[i]==0)\n");    break;}    if( zLine[i]=='\'' || zLine[i]=='"' ){printf("if(zLine[i]=='\'' || zLine[i]==''')\n");          printf("int delim = zLine[i++];\n");      int delim = zLine[i++];      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }      if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}    }else{      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }      if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);    }  }  /* Process the input line.  */  if( nArg==0 ) {printf("if(nArg==0)\n");  printf("return 0;\n");  printf("------function end!------\n");  return 0;} /* no tokens, no error */  printf("n = strlen30(azArg[0]);\n");n = strlen30(azArg[0]);  printf("c = azArg[0][0];\n");c = azArg[0][0];  if( c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n");      printf("const char *zDestFile = 0;\n");    const char *zDestFile = 0;    printf("const char *zDb = 0;\n");    const char *zDb = 0;    sqlite3 *pDest;    sqlite3_backup *pBackup;    printf("int j;\n");    int j;    for(j=1; j<nArg; j++){printf("for(j=1;j<nArg;j++)\n");          printf("const char *z = azArg[j];\n");      const char *z = azArg[j];      if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }    }    if( zDestFile==0 ){printf("if(zDestFile==0)\n");          printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");      fprintf(stderr, "missing FILENAME argument on .backup\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( zDb==0 ) {printf("if(zDb==0)\n");    printf("zDb = 'main';\n");zDb = "main";}    rc = sqlite3_open(zDestFile, &pDest);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pDest);  }else  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");      printf("bail_on_error = booleanValue(azArg[1]);\n");bail_on_error = booleanValue(azArg[1]);  }else  /* The undocumented ".breakpoint" command causes a call to the no-op  ** routine named test_breakpoint().  */  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");      printf("test_breakpoint();\n");    test_breakpoint();  }else  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }  printf("return rc;\n");  printf("------function end!------\n");  return rc;printf("------function end!------\n");}
printf("\nfile_name:%s\n",__FILE__);
printf("\nfile_name:%s\n",__FILE__)
printf
printf
"\nfile_name:%s\n"
__FILE__
printf("function_name:%s\n",__func__);
printf("function_name:%s\n",__func__)
printf
printf
"function_name:%s\n"
__func__
__func__
printf("------function start!------\n");
printf("------function start!------\n")
printf
printf
"------function start!------\n"
printf("static int do_meta_command(char *zLine, struct callback_data *p){\n");
printf("static int do_meta_command(char *zLine, struct callback_data *p){\n")
printf
printf
"static int do_meta_command(char *zLine, struct callback_data *p){\n"
printf("int i = 1;\n");
printf("int i = 1;\n")
printf
printf
"int i = 1;\n"
int i = 1;
int i = 1;
int
i = 1
i
= 1
1
printf("int nArg = 0;\n");
printf("int nArg = 0;\n")
printf
printf
"int nArg = 0;\n"
int nArg = 0;
int nArg = 0;
int
nArg = 0
nArg
= 0
0
printf("int n, c;\n");
printf("int n, c;\n")
printf
printf
"int n, c;\n"
int n, c;
int n, c;
int
n
n
c
c
printf("int rc = 0;\n");
printf("int rc = 0;\n")
printf
printf
"int rc = 0;\n"
int rc = 0;
int rc = 0;
int
rc = 0
rc
= 0
0
printf("char *azArg[50];\n");
printf("char *azArg[50];\n")
printf
printf
"char *azArg[50];\n"
char *azArg[50];
char *azArg[50];
char
*azArg[50]
*
azArg
[50]
50
while( zLine[i] && nArg<ArraySize(azArg) ){printf("while(zLine[i] && nArg<ArraySize(azArg))\n");      while( IsSpace(zLine[i]) ){printf("while(IsSpace(zLine[i]))\n");     printf("i++;\n");i++; }    if( zLine[i]==0 ) {printf("if(zLine[i]==0)\n");    break;}    if( zLine[i]=='\'' || zLine[i]=='"' ){printf("if(zLine[i]=='\'' || zLine[i]==''')\n");          printf("int delim = zLine[i++];\n");      int delim = zLine[i++];      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }      if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}    }else{      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }      if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);    }  }
zLine[i] && nArg<ArraySize(azArg)
zLine[i]
zLine
zLine
i
i
nArg<ArraySize(azArg)
nArg
nArg
ArraySize(azArg)
ArraySize
ArraySize
azArg
azArg
{printf("while(zLine[i] && nArg<ArraySize(azArg))\n");      while( IsSpace(zLine[i]) ){printf("while(IsSpace(zLine[i]))\n");     printf("i++;\n");i++; }    if( zLine[i]==0 ) {printf("if(zLine[i]==0)\n");    break;}    if( zLine[i]=='\'' || zLine[i]=='"' ){printf("if(zLine[i]=='\'' || zLine[i]==''')\n");          printf("int delim = zLine[i++];\n");      int delim = zLine[i++];      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }      if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}    }else{      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }      if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);    }  }
printf("while(zLine[i] && nArg<ArraySize(azArg))\n");
printf("while(zLine[i] && nArg<ArraySize(azArg))\n")
printf
printf
"while(zLine[i] && nArg<ArraySize(azArg))\n"
while( IsSpace(zLine[i]) ){printf("while(IsSpace(zLine[i]))\n");     printf("i++;\n");i++; }
IsSpace(zLine[i])
IsSpace
IsSpace
zLine[i]
zLine
zLine
i
i
{printf("while(IsSpace(zLine[i]))\n");     printf("i++;\n");i++; }
printf("while(IsSpace(zLine[i]))\n");
printf("while(IsSpace(zLine[i]))\n")
printf
printf
"while(IsSpace(zLine[i]))\n"
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
if( zLine[i]==0 ) {printf("if(zLine[i]==0)\n");    break;}
zLine[i]==0
zLine[i]
zLine
zLine
i
i
0
{printf("if(zLine[i]==0)\n");    break;}
printf("if(zLine[i]==0)\n");
printf("if(zLine[i]==0)\n")
printf
printf
"if(zLine[i]==0)\n"
break;
if( zLine[i]=='\'' || zLine[i]=='"' ){printf("if(zLine[i]=='\'' || zLine[i]==''')\n");          printf("int delim = zLine[i++];\n");      int delim = zLine[i++];      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }      if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}    }else{      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }      if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);    }
zLine[i]=='\'' || zLine[i]=='"'
zLine[i]=='\''
zLine[i]
zLine
zLine
i
i
'\''
zLine[i]=='"'
zLine[i]
zLine
zLine
i
i
'"'
{printf("if(zLine[i]=='\'' || zLine[i]==''')\n");          printf("int delim = zLine[i++];\n");      int delim = zLine[i++];      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }      if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }      if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}    }
printf("if(zLine[i]=='\'' || zLine[i]==''')\n");
printf("if(zLine[i]=='\'' || zLine[i]==''')\n")
printf
printf
"if(zLine[i]=='\'' || zLine[i]==''')\n"
printf("int delim = zLine[i++];\n");
printf("int delim = zLine[i++];\n")
printf
printf
"int delim = zLine[i++];\n"
int delim = zLine[i++];
int delim = zLine[i++];
int
delim = zLine[i++]
delim
= zLine[i++]
zLine[i++]
zLine
zLine
i++
i
i
printf("azArg[nArg++] = &zLine[i];\n");
printf("azArg[nArg++] = &zLine[i];\n")
printf
printf
"azArg[nArg++] = &zLine[i];\n"
azArg[nArg++] = &zLine[i];
azArg[nArg++] = &zLine[i]
azArg[nArg++]
azArg
azArg
nArg++
nArg
nArg
&zLine[i]
zLine[i]
zLine
zLine
i
i
while( zLine[i] && zLine[i]!=delim ){printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }
zLine[i] && zLine[i]!=delim
zLine[i]
zLine
zLine
i
i
zLine[i]!=delim
zLine[i]
zLine
zLine
i
i
delim
delim
{printf("while(zLine[i] && zLine[i]!=delim)\n");               if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}        printf("i++;\n");i++;       }
printf("while(zLine[i] && zLine[i]!=delim)\n");
printf("while(zLine[i] && zLine[i]!=delim)\n")
printf
printf
"while(zLine[i] && zLine[i]!=delim)\n"
if( zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0 ) {printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}
zLine[i]=='\\' && delim=='"' && zLine[i+1]!=0
zLine[i]=='\\' && delim=='"'
zLine[i]=='\\'
zLine[i]
zLine
zLine
i
i
'\\'
delim=='"'
delim
delim
'"'
zLine[i+1]!=0
zLine[i+1]
zLine
zLine
i+1
i
i
1
0
{printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");        printf("i++;\n");i++;}
printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n");
printf("if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n")
printf
printf
"if(zLine[i]=='\\' && delim==''' && zLine[i+1]!=0)\n"
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
if( zLine[i]==delim ){printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }
zLine[i]==delim
zLine[i]
zLine
zLine
i
i
delim
delim
{printf("if(zLine[i]==delim)\n");              printf("zLine[i++] = 0;\n");zLine[i++] = 0;      }
printf("if(zLine[i]==delim)\n");
printf("if(zLine[i]==delim)\n")
printf
printf
"if(zLine[i]==delim)\n"
printf("zLine[i++] = 0;\n");
printf("zLine[i++] = 0;\n")
printf
printf
"zLine[i++] = 0;\n"
zLine[i++] = 0;
zLine[i++] = 0
zLine[i++]
zLine
zLine
i++
i
i
0
if( delim=='"' ) {printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}
delim=='"'
delim
delim
'"'
{printf("if(delim==''')\n");      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);}
printf("if(delim==''')\n");
printf("if(delim==''')\n")
printf
printf
"if(delim==''')\n"
printf("resolve_backslashes(azArg[nArg-1]);\n");
printf("resolve_backslashes(azArg[nArg-1]);\n")
printf
printf
"resolve_backslashes(azArg[nArg-1]);\n"
resolve_backslashes(azArg[nArg-1]);
resolve_backslashes(azArg[nArg-1])
resolve_backslashes
resolve_backslashes
azArg[nArg-1]
azArg
azArg
nArg-1
nArg
nArg
1
{      printf("azArg[nArg++] = &zLine[i];\n");azArg[nArg++] = &zLine[i];      while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }      if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}      printf("resolve_backslashes(azArg[nArg-1]);\n");      resolve_backslashes(azArg[nArg-1]);    }
printf("azArg[nArg++] = &zLine[i];\n");
printf("azArg[nArg++] = &zLine[i];\n")
printf
printf
"azArg[nArg++] = &zLine[i];\n"
azArg[nArg++] = &zLine[i];
azArg[nArg++] = &zLine[i]
azArg[nArg++]
azArg
azArg
nArg++
nArg
nArg
&zLine[i]
zLine[i]
zLine
zLine
i
i
while( zLine[i] && !IsSpace(zLine[i]) ){printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }
zLine[i] && !IsSpace(zLine[i])
zLine[i]
zLine
zLine
i
i
!IsSpace(zLine[i])
IsSpace(zLine[i])
IsSpace
IsSpace
zLine[i]
zLine
zLine
i
i
{printf("while(zLine[i] && !IsSpace(zLine[i]))\n");       printf("i++;\n");i++; }
printf("while(zLine[i] && !IsSpace(zLine[i]))\n");
printf("while(zLine[i] && !IsSpace(zLine[i]))\n")
printf
printf
"while(zLine[i] && !IsSpace(zLine[i]))\n"
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
if( zLine[i] ) {printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}
zLine[i]
zLine
zLine
i
i
{printf("if(zLine[i])\n");      printf("zLine[i++] = 0;\n");zLine[i++] = 0;}
printf("if(zLine[i])\n");
printf("if(zLine[i])\n")
printf
printf
"if(zLine[i])\n"
printf("zLine[i++] = 0;\n");
printf("zLine[i++] = 0;\n")
printf
printf
"zLine[i++] = 0;\n"
zLine[i++] = 0;
zLine[i++] = 0
zLine[i++]
zLine
zLine
i++
i
i
0
printf("resolve_backslashes(azArg[nArg-1]);\n");
printf("resolve_backslashes(azArg[nArg-1]);\n")
printf
printf
"resolve_backslashes(azArg[nArg-1]);\n"
resolve_backslashes(azArg[nArg-1]);
resolve_backslashes(azArg[nArg-1])
resolve_backslashes
resolve_backslashes
azArg[nArg-1]
azArg
azArg
nArg-1
nArg
nArg
1
if( nArg==0 ) {printf("if(nArg==0)\n");  printf("return 0;\n");  printf("------function end!------\n");  return 0;}
nArg==0
nArg
nArg
0
{printf("if(nArg==0)\n");  printf("return 0;\n");  printf("------function end!------\n");  return 0;}
printf("if(nArg==0)\n");
printf("if(nArg==0)\n")
printf
printf
"if(nArg==0)\n"
printf("return 0;\n");
printf("return 0;\n")
printf
printf
"return 0;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 0;
0
printf("n = strlen30(azArg[0]);\n");
printf("n = strlen30(azArg[0]);\n")
printf
printf
"n = strlen30(azArg[0]);\n"
n = strlen30(azArg[0]);
n = strlen30(azArg[0])
n
n
strlen30(azArg[0])
strlen30
strlen30
azArg[0]
azArg
azArg
0
printf("c = azArg[0][0];\n");
printf("c = azArg[0][0];\n")
printf
printf
"c = azArg[0][0];\n"
c = azArg[0][0];
c = azArg[0][0]
c
c
azArg[0][0]
azArg[0]
azArg
azArg
0
0
if( c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n");      printf("const char *zDestFile = 0;\n");    const char *zDestFile = 0;    printf("const char *zDb = 0;\n");    const char *zDb = 0;    sqlite3 *pDest;    sqlite3_backup *pBackup;    printf("int j;\n");    int j;    for(j=1; j<nArg; j++){printf("for(j=1;j<nArg;j++)\n");          printf("const char *z = azArg[j];\n");      const char *z = azArg[j];      if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }    }    if( zDestFile==0 ){printf("if(zDestFile==0)\n");          printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");      fprintf(stderr, "missing FILENAME argument on .backup\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( zDb==0 ) {printf("if(zDb==0)\n");    printf("zDb = 'main';\n");zDb = "main";}    rc = sqlite3_open(zDestFile, &pDest);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pDest);  }else  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");      printf("bail_on_error = booleanValue(azArg[1]);\n");bail_on_error = booleanValue(azArg[1]);  }else  /* The undocumented ".breakpoint" command causes a call to the no-op  ** routine named test_breakpoint().  */  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");      printf("test_breakpoint();\n");    test_breakpoint();  }else  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0
c=='b' && n>=3
c=='b'
c
c
'b'
n>=3
n
n
3
strncmp(azArg[0], "backup", n)==0
strncmp(azArg[0], "backup", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"backup"
n
n
0
{printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n");      printf("const char *zDestFile = 0;\n");    const char *zDestFile = 0;    printf("const char *zDb = 0;\n");    const char *zDb = 0;    sqlite3 *pDest;    sqlite3_backup *pBackup;    printf("int j;\n");    int j;    for(j=1; j<nArg; j++){printf("for(j=1;j<nArg;j++)\n");          printf("const char *z = azArg[j];\n");      const char *z = azArg[j];      if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }    }    if( zDestFile==0 ){printf("if(zDestFile==0)\n");          printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");      fprintf(stderr, "missing FILENAME argument on .backup\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( zDb==0 ) {printf("if(zDb==0)\n");    printf("zDb = 'main';\n");zDb = "main";}    rc = sqlite3_open(zDestFile, &pDest);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pDest);  }
printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n");
printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n")
printf
printf
"if(c=='b' && n>=3 && strncmp(azArg[0], 'backup', n)==0)\n"
printf("const char *zDestFile = 0;\n");
printf("const char *zDestFile = 0;\n")
printf
printf
"const char *zDestFile = 0;\n"
const char *zDestFile = 0;
const char *zDestFile = 0;
const char
*zDestFile = 0
*
zDestFile
= 0
0
printf("const char *zDb = 0;\n");
printf("const char *zDb = 0;\n")
printf
printf
"const char *zDb = 0;\n"
const char *zDb = 0;
const char *zDb = 0;
const char
*zDb = 0
*
zDb
= 0
0
sqlite3 *pDest;
sqlite3 *pDest;
sqlite3
sqlite3
*pDest
*
pDest
sqlite3_backup *pBackup;
sqlite3_backup *pBackup;
sqlite3_backup
sqlite3_backup
*pBackup
*
pBackup
printf("int j;\n");
printf("int j;\n")
printf
printf
"int j;\n"
int j;
int j;
int
j
j
for(j=1; j<nArg; j++){printf("for(j=1;j<nArg;j++)\n");          printf("const char *z = azArg[j];\n");      const char *z = azArg[j];      if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }    }
j=1;
j=1
j
j
1
j<nArg
j
j
nArg
nArg
j++
j
j
{printf("for(j=1;j<nArg;j++)\n");          printf("const char *z = azArg[j];\n");      const char *z = azArg[j];      if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }    }
printf("for(j=1;j<nArg;j++)\n");
printf("for(j=1;j<nArg;j++)\n")
printf
printf
"for(j=1;j<nArg;j++)\n"
printf("const char *z = azArg[j];\n");
printf("const char *z = azArg[j];\n")
printf
printf
"const char *z = azArg[j];\n"
const char *z = azArg[j];
const char *z = azArg[j];
const char
*z = azArg[j]
*
z
= azArg[j]
azArg[j]
azArg
azArg
j
j
if( z[0]=='-' ){printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }else if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
z[0]=='-'
z[0]
z
z
0
'-'
{printf("if(z[0]=='-')\n");              while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}        /* No options to process at this time */        printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");        {          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }      }
printf("if(z[0]=='-')\n");
printf("if(z[0]=='-')\n")
printf
printf
"if(z[0]=='-')\n"
while( z[0]=='-' ) {printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}
z[0]=='-'
z[0]
z
z
0
'-'
{printf("while(z[0]=='-')\n");        printf("z++;\n");z++;}
printf("while(z[0]=='-')\n");
printf("while(z[0]=='-')\n")
printf
printf
"while(z[0]=='-')\n"
printf("z++;\n");
printf("z++;\n")
printf
printf
"z++;\n"
z++;
z++
z
z
printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n");
printf("{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n")
printf
printf
"{           fprintf(stderr, 'unknown option: _s ', azArg[j]);           return 1;         };\n"
{          printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");          fprintf(stderr, "unknown option: %s\n", azArg[j]);          printf("return 1;\n");          printf("------function end!------\n");          return 1;        }
printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n");
printf("fprintf(stderr, 'unknown option: _s ', azArg[j]);\n")
printf
printf
"fprintf(stderr, 'unknown option: _s ', azArg[j]);\n"
fprintf(stderr, "unknown option: %s\n", azArg[j]);
fprintf(stderr, "unknown option: %s\n", azArg[j])
fprintf
fprintf
stderr
stderr
"unknown option: %s\n"
azArg[j]
azArg
azArg
j
j
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
if( zDestFile==0 ){printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
zDestFile==0
zDestFile
zDestFile
0
{printf("if(zDestFile==0)\n");              printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }
printf("if(zDestFile==0)\n");
printf("if(zDestFile==0)\n")
printf
printf
"if(zDestFile==0)\n"
printf("zDestFile = azArg[j];\n");
printf("zDestFile = azArg[j];\n")
printf
printf
"zDestFile = azArg[j];\n"
zDestFile = azArg[j];
zDestFile = azArg[j]
zDestFile
zDestFile
azArg[j]
azArg
azArg
j
j
if( zDb==0 ){printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }else{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
zDb==0
zDb
zDb
0
{printf("if(zDb==0)\n");              printf("zDb = zDestFile;\n");zDb = zDestFile;        printf("zDestFile = azArg[j];\n");zDestFile = azArg[j];      }
printf("if(zDb==0)\n");
printf("if(zDb==0)\n")
printf
printf
"if(zDb==0)\n"
printf("zDb = zDestFile;\n");
printf("zDb = zDestFile;\n")
printf
printf
"zDb = zDestFile;\n"
zDb = zDestFile;
zDb = zDestFile
zDb
zDb
zDestFile
zDestFile
printf("zDestFile = azArg[j];\n");
printf("zDestFile = azArg[j];\n")
printf
printf
"zDestFile = azArg[j];\n"
zDestFile = azArg[j];
zDestFile = azArg[j]
zDestFile
zDestFile
azArg[j]
azArg
azArg
j
j
{        printf("fprintf(stderr, 'too many arguments to .backup ');\n");        fprintf(stderr, "too many arguments to .backup\n");        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
printf("fprintf(stderr, 'too many arguments to .backup ');\n");
printf("fprintf(stderr, 'too many arguments to .backup ');\n")
printf
printf
"fprintf(stderr, 'too many arguments to .backup ');\n"
fprintf(stderr, "too many arguments to .backup\n");
fprintf(stderr, "too many arguments to .backup\n")
fprintf
fprintf
stderr
stderr
"too many arguments to .backup\n"
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
if( zDestFile==0 ){printf("if(zDestFile==0)\n");          printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");      fprintf(stderr, "missing FILENAME argument on .backup\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
zDestFile==0
zDestFile
zDestFile
0
{printf("if(zDestFile==0)\n");          printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");      fprintf(stderr, "missing FILENAME argument on .backup\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(zDestFile==0)\n");
printf("if(zDestFile==0)\n")
printf
printf
"if(zDestFile==0)\n"
printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n");
printf("fprintf(stderr, 'missing FILENAME argument on .backup ');\n")
printf
printf
"fprintf(stderr, 'missing FILENAME argument on .backup ');\n"
fprintf(stderr, "missing FILENAME argument on .backup\n");
fprintf(stderr, "missing FILENAME argument on .backup\n")
fprintf
fprintf
stderr
stderr
"missing FILENAME argument on .backup\n"
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
if( zDb==0 ) {printf("if(zDb==0)\n");    printf("zDb = 'main';\n");zDb = "main";}
zDb==0
zDb
zDb
0
{printf("if(zDb==0)\n");    printf("zDb = 'main';\n");zDb = "main";}
printf("if(zDb==0)\n");
printf("if(zDb==0)\n")
printf
printf
"if(zDb==0)\n"
printf("zDb = 'main';\n");
printf("zDb = 'main';\n")
printf
printf
"zDb = 'main';\n"
zDb = "main";
zDb = "main"
zDb
zDb
"main"
rc = sqlite3_open(zDestFile, &pDest);
rc = sqlite3_open(zDestFile, &pDest)
rc
rc
sqlite3_open(zDestFile, &pDest)
sqlite3_open
sqlite3_open
zDestFile
zDestFile
&pDest
pDest
pDest
if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
rc!=SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n");
printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n")
printf
printf
"fprintf(stderr, 'Error: cannot open \'_s\' ', zDestFile);\n"
fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile);
fprintf(stderr, "Error: cannot open \"%s\"\n", zDestFile)
fprintf
fprintf
stderr
stderr
"Error: cannot open \"%s\"\n"
zDestFile
zDestFile
sqlite3_close(pDest);
sqlite3_close(pDest)
sqlite3_close
sqlite3_close
pDest
pDest
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);
pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb)
pBackup
pBackup
sqlite3_backup_init(pDest, "main", p->db, zDb)
sqlite3_backup_init
sqlite3_backup_init
pDest
pDest
"main"
p->db
p
p
db
zDb
zDb
if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
pBackup==0
pBackup
pBackup
0
{printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      sqlite3_close(pDest);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest))
fprintf
fprintf
stderr
stderr
"Error: %s\n"
sqlite3_errmsg(pDest)
sqlite3_errmsg
sqlite3_errmsg
pDest
pDest
sqlite3_close(pDest);
sqlite3_close(pDest)
sqlite3_close
sqlite3_close
pDest
pDest
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}
(rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
(rc = sqlite3_backup_step(pBackup,100))
rc = sqlite3_backup_step(pBackup,100)
rc
rc
sqlite3_backup_step(pBackup,100)
sqlite3_backup_step
sqlite3_backup_step
pBackup
pBackup
100
SQLITE_OK
SQLITE_OK
{}
sqlite3_backup_finish(pBackup);
sqlite3_backup_finish(pBackup)
sqlite3_backup_finish
sqlite3_backup_finish
pBackup
pBackup
if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      printf("rc = 1;\n");rc = 1;    }
rc==SQLITE_DONE
rc
rc
SQLITE_DONE
SQLITE_DONE
{printf("if()\n");          printf("rc = 0;\n");rc = 0;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("rc = 0;\n");
printf("rc = 0;\n")
printf
printf
"rc = 0;\n"
rc = 0;
rc = 0
rc
rc
0
{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));      printf("rc = 1;\n");rc = 1;    }
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(pDest))
fprintf
fprintf
stderr
stderr
"Error: %s\n"
sqlite3_errmsg(pDest)
sqlite3_errmsg
sqlite3_errmsg
pDest
pDest
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
sqlite3_close(pDest);
sqlite3_close(pDest)
sqlite3_close
sqlite3_close
pDest
pDest
if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");      printf("bail_on_error = booleanValue(azArg[1]);\n");bail_on_error = booleanValue(azArg[1]);  }else  /* The undocumented ".breakpoint" command causes a call to the no-op  ** routine named test_breakpoint().  */  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");      printf("test_breakpoint();\n");    test_breakpoint();  }else  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1 && nArg<3
c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 && nArg>1
c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0
c=='b' && n>=3
c=='b'
c
c
'b'
n>=3
n
n
3
strncmp(azArg[0], "bail", n)==0
strncmp(azArg[0], "bail", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"bail"
n
n
0
nArg>1
nArg
nArg
1
nArg<3
nArg
nArg
3
{printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");      printf("bail_on_error = booleanValue(azArg[1]);\n");bail_on_error = booleanValue(azArg[1]);  }
printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n");
printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n")
printf
printf
"if(c=='b' && n>=3 && strncmp(azArg[0], 'bail', n)==0 && nArg>1 && nArg<3)\n"
printf("bail_on_error = booleanValue(azArg[1]);\n");
printf("bail_on_error = booleanValue(azArg[1]);\n")
printf
printf
"bail_on_error = booleanValue(azArg[1]);\n"
bail_on_error = booleanValue(azArg[1]);
bail_on_error = booleanValue(azArg[1])
bail_on_error
bail_on_error
booleanValue(azArg[1])
booleanValue
booleanValue
azArg[1]
azArg
azArg
1
if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");      printf("test_breakpoint();\n");    test_breakpoint();  }else  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0
c=='b' && n>=3
c=='b'
c
c
'b'
n>=3
n
n
3
strncmp(azArg[0], "breakpoint", n)==0
strncmp(azArg[0], "breakpoint", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"breakpoint"
n
n
0
{printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");      printf("test_breakpoint();\n");    test_breakpoint();  }
printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n");
printf("if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n")
printf
printf
"if(c=='b' && n>=3 && strncmp(azArg[0], 'breakpoint', n)==0)\n"
printf("test_breakpoint();\n");
printf("test_breakpoint();\n")
printf
printf
"test_breakpoint();\n"
test_breakpoint();
test_breakpoint()
test_breakpoint
test_breakpoint
if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1 ){printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 && nArg==1
c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0
c=='d' && n>1
c=='d'
c
c
'd'
n>1
n
n
1
strncmp(azArg[0], "databases", n)==0
strncmp(azArg[0], "databases", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"databases"
n
n
0
nArg==1
nArg
nArg
1
{printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 1;\n");data.showHeader = 1;    printf("data.mode = MODE_Column;\n");data.mode = MODE_Column;    printf("data.colWidth[0] = 3;\n");data.colWidth[0] = 3;    printf("data.colWidth[1] = 15;\n");data.colWidth[1] = 15;    printf("data.colWidth[2] = 58;\n");data.colWidth[2] = 58;    printf("data.cnt = 0;\n");data.cnt = 0;    sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }
printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n");
printf("if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n")
printf
printf
"if(c=='d' && n>1 && strncmp(azArg[0], 'databases', n)==0 && nArg==1)\n"
printf("struct callback_data data;\n");
printf("struct callback_data data;\n")
printf
printf
"struct callback_data data;\n"
struct callback_data data;
struct callback_data data;
struct callback_data
callback_data
data
data
printf("char *zErrMsg = 0;\n");
printf("char *zErrMsg = 0;\n")
printf
printf
"char *zErrMsg = 0;\n"
char *zErrMsg = 0;
char *zErrMsg = 0;
char
*zErrMsg = 0
*
zErrMsg
= 0
0
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("memcpy(&data, p, sizeof(data));\n");
printf("memcpy(&data, p, sizeof(data));\n")
printf
printf
"memcpy(&data, p, sizeof(data));\n"
memcpy(&data, p, sizeof(data));
memcpy(&data, p, sizeof(data))
memcpy
memcpy
&data
data
data
p
p
sizeof(data)
(data)
data
data
printf("data.showHeader = 1;\n");
printf("data.showHeader = 1;\n")
printf
printf
"data.showHeader = 1;\n"
data.showHeader = 1;
data.showHeader = 1
data.showHeader
data
data
showHeader
1
printf("data.mode = MODE_Column;\n");
printf("data.mode = MODE_Column;\n")
printf
printf
"data.mode = MODE_Column;\n"
data.mode = MODE_Column;
data.mode = MODE_Column
data.mode
data
data
mode
MODE_Column
MODE_Column
printf("data.colWidth[0] = 3;\n");
printf("data.colWidth[0] = 3;\n")
printf
printf
"data.colWidth[0] = 3;\n"
data.colWidth[0] = 3;
data.colWidth[0] = 3
data.colWidth[0]
data.colWidth
data
data
colWidth
0
3
printf("data.colWidth[1] = 15;\n");
printf("data.colWidth[1] = 15;\n")
printf
printf
"data.colWidth[1] = 15;\n"
data.colWidth[1] = 15;
data.colWidth[1] = 15
data.colWidth[1]
data.colWidth
data
data
colWidth
1
15
printf("data.colWidth[2] = 58;\n");
printf("data.colWidth[2] = 58;\n")
printf
printf
"data.colWidth[2] = 58;\n"
data.colWidth[2] = 58;
data.colWidth[2] = 58
data.colWidth[2]
data.colWidth
data
data
colWidth
2
58
printf("data.cnt = 0;\n");
printf("data.cnt = 0;\n")
printf
printf
"data.cnt = 0;\n"
data.cnt = 0;
data.cnt = 0
data.cnt
data
data
cnt
0
sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg);
sqlite3_exec(p->db, "PRAGMA database_list; ", callback, &data, &zErrMsg)
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"PRAGMA database_list; "
callback
callback
&data
data
data
&zErrMsg
zErrMsg
zErrMsg
if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }
zErrMsg
zErrMsg
{printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }
printf("if(zErrMsg)\n");
printf("if(zErrMsg)\n")
printf
printf
"if(zErrMsg)\n"
printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");
printf("fprintf(stderr,'Error: _s ', zErrMsg);\n")
printf
printf
"fprintf(stderr,'Error: _s ', zErrMsg);\n"
fprintf(stderr,"Error: %s\n", zErrMsg);
fprintf(stderr,"Error: %s\n", zErrMsg)
fprintf
fprintf
stderr
stderr
"Error: %s\n"
zErrMsg
zErrMsg
printf("sqlite3_free(zErrMsg);\n");
printf("sqlite3_free(zErrMsg);\n")
printf
printf
"sqlite3_free(zErrMsg);\n"
sqlite3_free(zErrMsg);
sqlite3_free(zErrMsg)
sqlite3_free
sqlite3_free
zErrMsg
zErrMsg
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3 ){printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }else  if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='d' && strncmp(azArg[0], "dump", n)==0 && nArg<3
c=='d' && strncmp(azArg[0], "dump", n)==0
c=='d'
c
c
'd'
strncmp(azArg[0], "dump", n)==0
strncmp(azArg[0], "dump", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"dump"
n
n
0
nArg<3
nArg
nArg
3
{printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    /* When playing back a "dump", the content might appear in an order    ** which causes immediate foreign key constraints to be violated.    ** So disable foreign-key constraint enforcement to prevent problems. */    printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");    fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");    printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");    fprintf(p->out, "BEGIN TRANSACTION;\n");    printf("p->writableSchema = 0;\n");p->writableSchema = 0;    sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);    printf("p->nErr = 0;\n");p->nErr = 0;    if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }    if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }    sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);    sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);    printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");    fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");  }
printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n");
printf("if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n")
printf
printf
"if(c=='d' && strncmp(azArg[0], 'dump', n)==0 && nArg<3)\n"
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n");
printf("fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n")
printf
printf
"fprintf(p->out, 'PRAGMA foreign_keys=OFF; ');\n"
fprintf(p->out, "PRAGMA foreign_keys=OFF;\n");
fprintf(p->out, "PRAGMA foreign_keys=OFF;\n")
fprintf
fprintf
p->out
p
p
out
"PRAGMA foreign_keys=OFF;\n"
printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n");
printf("fprintf(p->out, 'BEGIN TRANSACTION; ');\n")
printf
printf
"fprintf(p->out, 'BEGIN TRANSACTION; ');\n"
fprintf(p->out, "BEGIN TRANSACTION;\n");
fprintf(p->out, "BEGIN TRANSACTION;\n")
fprintf
fprintf
p->out
p
p
out
"BEGIN TRANSACTION;\n"
printf("p->writableSchema = 0;\n");
printf("p->writableSchema = 0;\n")
printf
printf
"p->writableSchema = 0;\n"
p->writableSchema = 0;
p->writableSchema = 0
p->writableSchema
p
p
writableSchema
0
sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);
sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0)
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"SAVEPOINT dump; PRAGMA writable_schema=ON"
0
0
0
printf("p->nErr = 0;\n");
printf("p->nErr = 0;\n")
printf
printf
"p->nErr = 0;\n"
p->nErr = 0;
p->nErr = 0
p->nErr
p
p
nErr
0
if( nArg==1 ){printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }else{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }
nArg==1
nArg
nArg
1
{printf("if(nArg==1)\n");          printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );      printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");      run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );      printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");      run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );    }
printf("if(nArg==1)\n");
printf("if(nArg==1)\n")
printf
printf
"if(nArg==1)\n"
printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n");
printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n")
printf
printf
"run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence''       );\n"
run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      );
run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"      )
run_schema_dump_query
run_schema_dump_query
p
p
"SELECT name, type, sql FROM sqlite_master "        "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"
printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n");
printf("run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n")
printf
printf
"run_schema_dump_query(p,          'SELECT name, type, sql FROM sqlite_master '         'WHERE name=='sqlite_sequence''       );\n"
run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      );
run_schema_dump_query(p,         "SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"      )
run_schema_dump_query
run_schema_dump_query
p
p
"SELECT name, type, sql FROM sqlite_master "        "WHERE name=='sqlite_sequence'"
printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n");
printf("run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n")
printf
printf
"run_table_dump_query(p,         'SELECT sql FROM sqlite_master '         'WHERE sql NOT NULL AND type IN ('index','trigger','view')', 0       );\n"
run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      );
run_table_dump_query(p,        "SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0      )
run_table_dump_query
run_table_dump_query
p
p
"SELECT sql FROM sqlite_master "        "WHERE sql NOT NULL AND type IN ('index','trigger','view')"
0
{      printf("int i;\n");      int i;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }
printf("int i;\n");
printf("int i;\n")
printf
printf
"int i;\n"
int i;
int i;
int
i
i
for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }
i=1;
i=1
i
i
1
i<nArg
i
i
nArg
nArg
i++
i
i
{printf("for(i=1;i<nArg;i++)\n");              printf("zShellStatic = azArg[i];\n");zShellStatic = azArg[i];        printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");        run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");        printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");        run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );        printf("zShellStatic = 0;\n");zShellStatic = 0;      }
printf("for(i=1;i<nArg;i++)\n");
printf("for(i=1;i<nArg;i++)\n")
printf
printf
"for(i=1;i<nArg;i++)\n"
printf("zShellStatic = azArg[i];\n");
printf("zShellStatic = azArg[i];\n")
printf
printf
"zShellStatic = azArg[i];\n"
zShellStatic = azArg[i];
zShellStatic = azArg[i]
zShellStatic
zShellStatic
azArg[i]
azArg
azArg
i
i
printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n");
printf("run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n")
printf
printf
"run_schema_dump_query(p,           'SELECT name, type, sql FROM sqlite_master '           'WHERE tbl_name LIKE shellstatic() AND type=='table''           '  AND sql NOT NULL');\n"
run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL");
run_schema_dump_query(p,          "SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL")
run_schema_dump_query
run_schema_dump_query
p
p
"SELECT name, type, sql FROM sqlite_master "          "WHERE tbl_name LIKE shellstatic() AND type=='table'"          "  AND sql NOT NULL"
printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n");
printf("run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n")
printf
printf
"run_table_dump_query(p,           'SELECT sql FROM sqlite_master '           'WHERE sql NOT NULL'           '  AND type IN ('index','trigger','view')'           '  AND tbl_name LIKE shellstatic()', 0         );\n"
run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        );
run_table_dump_query(p,          "SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()", 0        )
run_table_dump_query
run_table_dump_query
p
p
"SELECT sql FROM sqlite_master "          "WHERE sql NOT NULL"          "  AND type IN ('index','trigger','view')"          "  AND tbl_name LIKE shellstatic()"
0
printf("zShellStatic = 0;\n");
printf("zShellStatic = 0;\n")
printf
printf
"zShellStatic = 0;\n"
zShellStatic = 0;
zShellStatic = 0
zShellStatic
zShellStatic
0
if( p->writableSchema ){printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }
p->writableSchema
p
p
writableSchema
{printf("if(p->writableSchema)\n");          printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");      fprintf(p->out, "PRAGMA writable_schema=OFF;\n");      printf("p->writableSchema = 0;\n");p->writableSchema = 0;    }
printf("if(p->writableSchema)\n");
printf("if(p->writableSchema)\n")
printf
printf
"if(p->writableSchema)\n"
printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n");
printf("fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n")
printf
printf
"fprintf(p->out, 'PRAGMA writable_schema=OFF; ');\n"
fprintf(p->out, "PRAGMA writable_schema=OFF;\n");
fprintf(p->out, "PRAGMA writable_schema=OFF;\n")
fprintf
fprintf
p->out
p
p
out
"PRAGMA writable_schema=OFF;\n"
printf("p->writableSchema = 0;\n");
printf("p->writableSchema = 0;\n")
printf
printf
"p->writableSchema = 0;\n"
p->writableSchema = 0;
p->writableSchema = 0
p->writableSchema
p
p
writableSchema
0
sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);
sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0)
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"PRAGMA writable_schema=OFF;"
0
0
0
sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);
sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0)
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"RELEASE dump;"
0
0
0
printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n");
printf("fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n")
printf
printf
"fprintf(p->out, p->nErr ? 'ROLLBACK; -- due to errors ' : 'COMMIT; ');\n"
fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");
fprintf(p->out, p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n")
fprintf
fprintf
p->out
p
p
out
p->nErr ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n"
p->nErr
p
p
nErr
"ROLLBACK; -- due to errors\n"
"COMMIT;\n"
if( c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }else  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1 && nArg<3
c=='e' && strncmp(azArg[0], "echo", n)==0 && nArg>1
c=='e' && strncmp(azArg[0], "echo", n)==0
c=='e'
c
c
'e'
strncmp(azArg[0], "echo", n)==0
strncmp(azArg[0], "echo", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"echo"
n
n
0
nArg>1
nArg
nArg
1
nArg<3
nArg
nArg
3
{printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");      printf("p->echoOn = booleanValue(azArg[1]);\n");p->echoOn = booleanValue(azArg[1]);  }
printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n");
printf("if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n")
printf
printf
"if(c=='e' && strncmp(azArg[0], 'echo', n)==0 && nArg>1 && nArg<3)\n"
printf("p->echoOn = booleanValue(azArg[1]);\n");
printf("p->echoOn = booleanValue(azArg[1]);\n")
printf
printf
"p->echoOn = booleanValue(azArg[1]);\n"
p->echoOn = booleanValue(azArg[1]);
p->echoOn = booleanValue(azArg[1])
p->echoOn
p
p
echoOn
booleanValue(azArg[1])
booleanValue
booleanValue
azArg[1]
azArg
azArg
1
if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }else  if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='e' && strncmp(azArg[0], "exit", n)==0
c=='e'
c
c
'e'
strncmp(azArg[0], "exit", n)==0
strncmp(azArg[0], "exit", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"exit"
n
n
0
{printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");      if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}    printf("rc = 2;\n");rc = 2;  }
printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n");
printf("if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n")
printf
printf
"if(c=='e' && strncmp(azArg[0], 'exit', n)==0)\n"
if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) {printf("if()\n");    printf("exit(rc);\n");    exit(rc);}
nArg>1 && (rc = (int)integerValue(azArg[1]))!=0
nArg>1
nArg
nArg
1
(rc = (int)integerValue(azArg[1]))!=0
(rc = (int)integerValue(azArg[1]))
rc = (int)integerValue(azArg[1])
rc
rc
(int)integerValue(azArg[1])
int
int

integerValue(azArg[1])
integerValue
integerValue
azArg[1]
azArg
azArg
1
0
{printf("if()\n");    printf("exit(rc);\n");    exit(rc);}
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("exit(rc);\n");
printf("exit(rc);\n")
printf
printf
"exit(rc);\n"
exit(rc);
exit(rc)
exit
exit
rc
rc
printf("rc = 2;\n");
printf("rc = 2;\n")
printf
printf
"rc = 2;\n"
rc = 2;
rc = 2
rc
rc
2
if( c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3 ){printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }else  if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='e' && strncmp(azArg[0], "explain", n)==0 && nArg<3
c=='e' && strncmp(azArg[0], "explain", n)==0
c=='e'
c
c
'e'
strncmp(azArg[0], "explain", n)==0
strncmp(azArg[0], "explain", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"explain"
n
n
0
nArg<3
nArg
nArg
3
{printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");      printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");    int val = nArg>=2 ? booleanValue(azArg[1]) : 1;    if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }  }
printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n");
printf("if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n")
printf
printf
"if(c=='e' && strncmp(azArg[0], 'explain', n)==0 && nArg<3)\n"
printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n");
printf("int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n")
printf
printf
"int val = nArg>=2 ? booleanValue(azArg[1]) : 1;\n"
int val = nArg>=2 ? booleanValue(azArg[1]) : 1;
int val = nArg>=2 ? booleanValue(azArg[1]) : 1;
int
val = nArg>=2 ? booleanValue(azArg[1]) : 1
val
= nArg>=2 ? booleanValue(azArg[1]) : 1
nArg>=2 ? booleanValue(azArg[1]) : 1
nArg>=2
nArg
nArg
2
booleanValue(azArg[1])
booleanValue
booleanValue
azArg[1]
azArg
azArg
1
1
if(val == 1) {printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }else if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }
val == 1
val
val
1
{printf("if(val == 1)\n");          if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }      /* We could put this code under the !p->explainValid      ** condition so that it does not execute if we are already in      ** explain mode. However, always executing it allows us an easy      ** was to reset to explain mode in case the user previously      ** did an .explain followed by a .width, .mode or .header      ** command.      */      printf("p->mode = MODE_Explain;\n");p->mode = MODE_Explain;      printf("p->showHeader = 1;\n");p->showHeader = 1;      printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");      memset(p->colWidth,0,sizeof(p->colWidth));      printf("p->colWidth[0] = 4;\n");p->colWidth[0] = 4;                  /* addr */      printf("p->colWidth[1] = 13;\n");p->colWidth[1] = 13;                 /* opcode */      printf("p->colWidth[2] = 4;\n");p->colWidth[2] = 4;                  /* P1 */      printf("p->colWidth[3] = 4;\n");p->colWidth[3] = 4;                  /* P2 */      printf("p->colWidth[4] = 4;\n");p->colWidth[4] = 4;                  /* P3 */      printf("p->colWidth[5] = 13;\n");p->colWidth[5] = 13;                 /* P4 */      printf("p->colWidth[6] = 2;\n");p->colWidth[6] = 2;                  /* P5 */      printf("p->colWidth[7] = 13;\n");p->colWidth[7] = 13;                  /* Comment */    }
printf("if(val == 1)\n");
printf("if(val == 1)\n")
printf
printf
"if(val == 1)\n"
if(!p->explainPrev.valid) {printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }
!p->explainPrev.valid
p->explainPrev.valid
p->explainPrev
p
p
explainPrev
valid
{printf("if(!p->explainPrev.valid)\n");              printf("p->explainPrev.valid = 1;\n");p->explainPrev.valid = 1;        printf("p->explainPrev.mode = p->mode;\n");p->explainPrev.mode = p->mode;        printf("p->explainPrev.showHeader = p->showHeader;\n");p->explainPrev.showHeader = p->showHeader;        printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");        memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));      }
printf("if(!p->explainPrev.valid)\n");
printf("if(!p->explainPrev.valid)\n")
printf
printf
"if(!p->explainPrev.valid)\n"
printf("p->explainPrev.valid = 1;\n");
printf("p->explainPrev.valid = 1;\n")
printf
printf
"p->explainPrev.valid = 1;\n"
p->explainPrev.valid = 1;
p->explainPrev.valid = 1
p->explainPrev.valid
p->explainPrev
p
p
explainPrev
valid
1
printf("p->explainPrev.mode = p->mode;\n");
printf("p->explainPrev.mode = p->mode;\n")
printf
printf
"p->explainPrev.mode = p->mode;\n"
p->explainPrev.mode = p->mode;
p->explainPrev.mode = p->mode
p->explainPrev.mode
p->explainPrev
p
p
explainPrev
mode
p->mode
p
p
mode
printf("p->explainPrev.showHeader = p->showHeader;\n");
printf("p->explainPrev.showHeader = p->showHeader;\n")
printf
printf
"p->explainPrev.showHeader = p->showHeader;\n"
p->explainPrev.showHeader = p->showHeader;
p->explainPrev.showHeader = p->showHeader
p->explainPrev.showHeader
p->explainPrev
p
p
explainPrev
showHeader
p->showHeader
p
p
showHeader
printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n");
printf("memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n")
printf
printf
"memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));\n"
memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth));
memcpy(p->explainPrev.colWidth,p->colWidth,sizeof(p->colWidth))
memcpy
memcpy
p->explainPrev.colWidth
p->explainPrev
p
p
explainPrev
colWidth
p->colWidth
p
p
colWidth
sizeof(p->colWidth)
(p->colWidth)
p->colWidth
p
p
colWidth
printf("p->mode = MODE_Explain;\n");
printf("p->mode = MODE_Explain;\n")
printf
printf
"p->mode = MODE_Explain;\n"
p->mode = MODE_Explain;
p->mode = MODE_Explain
p->mode
p
p
mode
MODE_Explain
MODE_Explain
printf("p->showHeader = 1;\n");
printf("p->showHeader = 1;\n")
printf
printf
"p->showHeader = 1;\n"
p->showHeader = 1;
p->showHeader = 1
p->showHeader
p
p
showHeader
1
printf("memset(p->colWidth,0,sizeof(p->colWidth));\n");
printf("memset(p->colWidth,0,sizeof(p->colWidth));\n")
printf
printf
"memset(p->colWidth,0,sizeof(p->colWidth));\n"
memset(p->colWidth,0,sizeof(p->colWidth));
memset(p->colWidth,0,sizeof(p->colWidth))
memset
memset
p->colWidth
p
p
colWidth
0
sizeof(p->colWidth)
(p->colWidth)
p->colWidth
p
p
colWidth
printf("p->colWidth[0] = 4;\n");
printf("p->colWidth[0] = 4;\n")
printf
printf
"p->colWidth[0] = 4;\n"
p->colWidth[0] = 4;
p->colWidth[0] = 4
p->colWidth[0]
p->colWidth
p
p
colWidth
0
4
printf("p->colWidth[1] = 13;\n");
printf("p->colWidth[1] = 13;\n")
printf
printf
"p->colWidth[1] = 13;\n"
p->colWidth[1] = 13;
p->colWidth[1] = 13
p->colWidth[1]
p->colWidth
p
p
colWidth
1
13
printf("p->colWidth[2] = 4;\n");
printf("p->colWidth[2] = 4;\n")
printf
printf
"p->colWidth[2] = 4;\n"
p->colWidth[2] = 4;
p->colWidth[2] = 4
p->colWidth[2]
p->colWidth
p
p
colWidth
2
4
printf("p->colWidth[3] = 4;\n");
printf("p->colWidth[3] = 4;\n")
printf
printf
"p->colWidth[3] = 4;\n"
p->colWidth[3] = 4;
p->colWidth[3] = 4
p->colWidth[3]
p->colWidth
p
p
colWidth
3
4
printf("p->colWidth[4] = 4;\n");
printf("p->colWidth[4] = 4;\n")
printf
printf
"p->colWidth[4] = 4;\n"
p->colWidth[4] = 4;
p->colWidth[4] = 4
p->colWidth[4]
p->colWidth
p
p
colWidth
4
4
printf("p->colWidth[5] = 13;\n");
printf("p->colWidth[5] = 13;\n")
printf
printf
"p->colWidth[5] = 13;\n"
p->colWidth[5] = 13;
p->colWidth[5] = 13
p->colWidth[5]
p->colWidth
p
p
colWidth
5
13
printf("p->colWidth[6] = 2;\n");
printf("p->colWidth[6] = 2;\n")
printf
printf
"p->colWidth[6] = 2;\n"
p->colWidth[6] = 2;
p->colWidth[6] = 2
p->colWidth[6]
p->colWidth
p
p
colWidth
6
2
printf("p->colWidth[7] = 13;\n");
printf("p->colWidth[7] = 13;\n")
printf
printf
"p->colWidth[7] = 13;\n"
p->colWidth[7] = 13;
p->colWidth[7] = 13
p->colWidth[7]
p->colWidth
p
p
colWidth
7
13
if (p->explainPrev.valid) {printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }
p->explainPrev.valid
p->explainPrev
p
p
explainPrev
valid
{printf("if(p->explainPrev.valid)\n");          printf("p->explainPrev.valid = 0;\n");p->explainPrev.valid = 0;      printf("p->mode = p->explainPrev.mode;\n");p->mode = p->explainPrev.mode;      printf("p->showHeader = p->explainPrev.showHeader;\n");p->showHeader = p->explainPrev.showHeader;      printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");      memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));    }
printf("if(p->explainPrev.valid)\n");
printf("if(p->explainPrev.valid)\n")
printf
printf
"if(p->explainPrev.valid)\n"
printf("p->explainPrev.valid = 0;\n");
printf("p->explainPrev.valid = 0;\n")
printf
printf
"p->explainPrev.valid = 0;\n"
p->explainPrev.valid = 0;
p->explainPrev.valid = 0
p->explainPrev.valid
p->explainPrev
p
p
explainPrev
valid
0
printf("p->mode = p->explainPrev.mode;\n");
printf("p->mode = p->explainPrev.mode;\n")
printf
printf
"p->mode = p->explainPrev.mode;\n"
p->mode = p->explainPrev.mode;
p->mode = p->explainPrev.mode
p->mode
p
p
mode
p->explainPrev.mode
p->explainPrev
p
p
explainPrev
mode
printf("p->showHeader = p->explainPrev.showHeader;\n");
printf("p->showHeader = p->explainPrev.showHeader;\n")
printf
printf
"p->showHeader = p->explainPrev.showHeader;\n"
p->showHeader = p->explainPrev.showHeader;
p->showHeader = p->explainPrev.showHeader
p->showHeader
p
p
showHeader
p->explainPrev.showHeader
p->explainPrev
p
p
explainPrev
showHeader
printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n");
printf("memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n")
printf
printf
"memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));\n"
memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth));
memcpy(p->colWidth,p->explainPrev.colWidth,sizeof(p->colWidth))
memcpy
memcpy
p->colWidth
p
p
colWidth
p->explainPrev.colWidth
p->explainPrev
p
p
explainPrev
colWidth
sizeof(p->colWidth)
(p->colWidth)
p->colWidth
p
p
colWidth
if( c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3 ){printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }else  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1 && nArg<3
c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0) && nArg>1
c=='h' && (strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0)
c=='h'
c
c
'h'
(strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0)
strncmp(azArg[0], "header", n)==0 ||                 strncmp(azArg[0], "headers", n)==0
strncmp(azArg[0], "header", n)==0
strncmp(azArg[0], "header", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"header"
n
n
0
strncmp(azArg[0], "headers", n)==0
strncmp(azArg[0], "headers", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"headers"
n
n
0
nArg>1
nArg
nArg
1
nArg<3
nArg
nArg
3
{printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");                     printf("p->showHeader = booleanValue(azArg[1]);\n");p->showHeader = booleanValue(azArg[1]);  }
printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n");
printf("if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n")
printf
printf
"if(c=='h' && (strncmp(azArg[0], 'header', n)==0 ||                  strncmp(azArg[0], 'headers', n)==0) && nArg>1 && nArg<3)\n"
printf("p->showHeader = booleanValue(azArg[1]);\n");
printf("p->showHeader = booleanValue(azArg[1]);\n")
printf
printf
"p->showHeader = booleanValue(azArg[1]);\n"
p->showHeader = booleanValue(azArg[1]);
p->showHeader = booleanValue(azArg[1])
p->showHeader
p
p
showHeader
booleanValue(azArg[1])
booleanValue
booleanValue
azArg[1]
azArg
azArg
1
if( c=='h' && strncmp(azArg[0], "help", n)==0 ){printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }else  if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='h' && strncmp(azArg[0], "help", n)==0
c=='h'
c
c
'h'
strncmp(azArg[0], "help", n)==0
strncmp(azArg[0], "help", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"help"
n
n
0
{printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");      printf("fprintf(stderr,'_s',zHelp);\n");    fprintf(stderr,"%s",zHelp);    if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }  }
printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n");
printf("if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n")
printf
printf
"if(c=='h' && strncmp(azArg[0], 'help', n)==0)\n"
printf("fprintf(stderr,'_s',zHelp);\n");
printf("fprintf(stderr,'_s',zHelp);\n")
printf
printf
"fprintf(stderr,'_s',zHelp);\n"
fprintf(stderr,"%s",zHelp);
fprintf(stderr,"%s",zHelp)
fprintf
fprintf
stderr
stderr
"%s"
zHelp
zHelp
if( HAS_TIMER ){printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }
HAS_TIMER
HAS_TIMER
{printf("if(HAS_TIMER)\n");          printf("fprintf(stderr,'_s',zTimerHelp);\n");      fprintf(stderr,"%s",zTimerHelp);    }
printf("if(HAS_TIMER)\n");
printf("if(HAS_TIMER)\n")
printf
printf
"if(HAS_TIMER)\n"
printf("fprintf(stderr,'_s',zTimerHelp);\n");
printf("fprintf(stderr,'_s',zTimerHelp);\n")
printf
printf
"fprintf(stderr,'_s',zTimerHelp);\n"
fprintf(stderr,"%s",zTimerHelp);
fprintf(stderr,"%s",zTimerHelp)
fprintf
fprintf
stderr
stderr
"%s"
zTimerHelp
zTimerHelp
if( c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3 ){printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }else  if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='i' && strncmp(azArg[0], "import", n)==0 && nArg==3
c=='i' && strncmp(azArg[0], "import", n)==0
c=='i'
c
c
'i'
strncmp(azArg[0], "import", n)==0
strncmp(azArg[0], "import", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"import"
n
n
0
nArg==3
nArg
nArg
3
{printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");      printf("char *zTable = azArg[2];\n");    char *zTable = azArg[2];    /* Insert data into this table */    printf("char *zFile = azArg[1];\n");    char *zFile = azArg[1];     /* Name of file to extra content from */    sqlite3_stmt *pStmt = NULL; /* A statement */    printf("int nCol;\n");    int nCol;                   /* Number of columns in the table */    printf("int nByte;\n");    int nByte;                  /* Number of bytes in an SQL string */    printf("int i, j;\n");    int i, j;                   /* Loop counters */    printf("int needCommit;\n");    int needCommit;             /* True to COMMIT or ROLLBACK at end */    printf("int nSep;\n");    int nSep;                   /* Number of bytes in p->separator[] */    printf("char *zSql;\n");    char *zSql;                 /* An SQL statement */    printf("CSVReader sCsv;\n");    CSVReader sCsv;             /* Reader context */    printf("int (*xCloser)(FILE*);\n");    int (*xCloser)(FILE*);      /* Procedure to close th3 connection */    printf("seenInterrupt = 0;\n");seenInterrupt = 0;    printf("memset(&sCsv, 0, sizeof(sCsv));\n");    memset(&sCsv, 0, sizeof(sCsv));    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("nSep = strlen30(p->separator);\n");nSep = strlen30(p->separator);    if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.zFile = zFile;\n");sCsv.zFile = zFile;    printf("sCsv.nLine = 1;\n");sCsv.nLine = 1;    if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }    if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sCsv.cSeparator = p->separator[0];\n");sCsv.cSeparator = p->separator[0];    printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("nByte = strlen30(zSql);\n");nByte = strlen30(zSql);    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    nCol = sqlite3_column_count(pStmt);    sqlite3_finalize(pStmt);    pStmt = 0;    if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;} /* no columns, no error */    printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );    if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");    sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);    printf("j = strlen30(zSql);\n");j = strlen30(zSql);    for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }    printf("zSql[j++] = ')';\n");zSql[j++] = ')';    printf("zSql[j] = 0;\n");zSql[j] = 0;    rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    needCommit = sqlite3_get_autocommit(db);    if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);    do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );    printf("xCloser(sCsv.in);\n");    xCloser(sCsv.in);    printf("sqlite3_free(sCsv.z);\n");    sqlite3_free(sCsv.z);    sqlite3_finalize(pStmt);    if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);  }
printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n");
printf("if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n")
printf
printf
"if(c=='i' && strncmp(azArg[0], 'import', n)==0 && nArg==3)\n"
printf("char *zTable = azArg[2];\n");
printf("char *zTable = azArg[2];\n")
printf
printf
"char *zTable = azArg[2];\n"
char *zTable = azArg[2];
char *zTable = azArg[2];
char
*zTable = azArg[2]
*
zTable
= azArg[2]
azArg[2]
azArg
azArg
2
printf("char *zFile = azArg[1];\n");
printf("char *zFile = azArg[1];\n")
printf
printf
"char *zFile = azArg[1];\n"
char *zFile = azArg[1];
char *zFile = azArg[1];
char
*zFile = azArg[1]
*
zFile
= azArg[1]
azArg[1]
azArg
azArg
1
sqlite3_stmt *pStmt = NULL;
sqlite3_stmt *pStmt = NULL;
sqlite3_stmt
sqlite3_stmt
*pStmt = NULL
*
pStmt
= NULL
NULL
NULL
printf("int nCol;\n");
printf("int nCol;\n")
printf
printf
"int nCol;\n"
int nCol;
int nCol;
int
nCol
nCol
printf("int nByte;\n");
printf("int nByte;\n")
printf
printf
"int nByte;\n"
int nByte;
int nByte;
int
nByte
nByte
printf("int i, j;\n");
printf("int i, j;\n")
printf
printf
"int i, j;\n"
int i, j;
int i, j;
int
i
i
j
j
printf("int needCommit;\n");
printf("int needCommit;\n")
printf
printf
"int needCommit;\n"
int needCommit;
int needCommit;
int
needCommit
needCommit
printf("int nSep;\n");
printf("int nSep;\n")
printf
printf
"int nSep;\n"
int nSep;
int nSep;
int
nSep
nSep
printf("char *zSql;\n");
printf("char *zSql;\n")
printf
printf
"char *zSql;\n"
char *zSql;
char *zSql;
char
*zSql
*
zSql
printf("CSVReader sCsv;\n");
printf("CSVReader sCsv;\n")
printf
printf
"CSVReader sCsv;\n"
CSVReader sCsv;
CSVReader sCsv;
CSVReader
CSVReader
sCsv
sCsv
printf("int (*xCloser)(FILE*);\n");
printf("int (*xCloser)(FILE*);\n")
printf
printf
"int (*xCloser)(FILE*);\n"
int (*xCloser)(FILE*);
int (*xCloser)(FILE*);
int
(*xCloser)(FILE*)
*xCloser
*
xCloser
FILE*
FILE
FILE
*
*

printf("seenInterrupt = 0;\n");
printf("seenInterrupt = 0;\n")
printf
printf
"seenInterrupt = 0;\n"
seenInterrupt = 0;
seenInterrupt = 0
seenInterrupt
seenInterrupt
0
printf("memset(&sCsv, 0, sizeof(sCsv));\n");
printf("memset(&sCsv, 0, sizeof(sCsv));\n")
printf
printf
"memset(&sCsv, 0, sizeof(sCsv));\n"
memset(&sCsv, 0, sizeof(sCsv));
memset(&sCsv, 0, sizeof(sCsv))
memset
memset
&sCsv
sCsv
sCsv
0
sizeof(sCsv)
(sCsv)
sCsv
sCsv
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("nSep = strlen30(p->separator);\n");
printf("nSep = strlen30(p->separator);\n")
printf
printf
"nSep = strlen30(p->separator);\n"
nSep = strlen30(p->separator);
nSep = strlen30(p->separator)
nSep
nSep
strlen30(p->separator)
strlen30
strlen30
p->separator
p
p
separator
if( nSep==0 ){printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
nSep==0
nSep
nSep
0
{printf("if(nSep==0)\n");          printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");      fprintf(stderr, "Error: non-null separator required for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(nSep==0)\n");
printf("if(nSep==0)\n")
printf
printf
"if(nSep==0)\n"
printf("fprintf(stderr, 'Error: non-null separator required for import ');\n");
printf("fprintf(stderr, 'Error: non-null separator required for import ');\n")
printf
printf
"fprintf(stderr, 'Error: non-null separator required for import ');\n"
fprintf(stderr, "Error: non-null separator required for import\n");
fprintf(stderr, "Error: non-null separator required for import\n")
fprintf
fprintf
stderr
stderr
"Error: non-null separator required for import\n"
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
if( nSep>1 ){printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
nSep>1
nSep
nSep
1
{printf("if(nSep>1)\n");          printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");      fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(nSep>1)\n");
printf("if(nSep>1)\n")
printf
printf
"if(nSep>1)\n"
printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n");
printf("fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n")
printf
printf
"fprintf(stderr, 'Error: multi-character separators not allowed'                       ' for import ');\n"
fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n");
fprintf(stderr, "Error: multi-character separators not allowed"                      " for import\n")
fprintf
fprintf
stderr
stderr
"Error: multi-character separators not allowed"                      " for import\n"
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("sCsv.zFile = zFile;\n");
printf("sCsv.zFile = zFile;\n")
printf
printf
"sCsv.zFile = zFile;\n"
sCsv.zFile = zFile;
sCsv.zFile = zFile
sCsv.zFile
sCsv
sCsv
zFile
zFile
zFile
printf("sCsv.nLine = 1;\n");
printf("sCsv.nLine = 1;\n")
printf
printf
"sCsv.nLine = 1;\n"
sCsv.nLine = 1;
sCsv.nLine = 1
sCsv.nLine
sCsv
sCsv
nLine
1
if( sCsv.zFile[0]=='|' ){printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }else{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }
sCsv.zFile[0]=='|'
sCsv.zFile[0]
sCsv.zFile
sCsv
sCsv
zFile
0
'|'
{printf("if(sCsv.zFile[0]=='|')\n");          printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");sCsv.in = popen(sCsv.zFile+1, "r");      printf("sCsv.zFile = '<pipe>';\n");sCsv.zFile = "<pipe>";      printf("xCloser = pclose;\n");xCloser = pclose;    }
printf("if(sCsv.zFile[0]=='|')\n");
printf("if(sCsv.zFile[0]=='|')\n")
printf
printf
"if(sCsv.zFile[0]=='|')\n"
printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n");
printf("sCsv.in = popen(sCsv.zFile+1, 'r');\n")
printf
printf
"sCsv.in = popen(sCsv.zFile+1, 'r');\n"
sCsv.in = popen(sCsv.zFile+1, "r");
sCsv.in = popen(sCsv.zFile+1, "r")
sCsv.in
sCsv
sCsv
in
popen(sCsv.zFile+1, "r")
popen
popen
sCsv.zFile+1
sCsv.zFile
sCsv
sCsv
zFile
1
"r"
printf("sCsv.zFile = '<pipe>';\n");
printf("sCsv.zFile = '<pipe>';\n")
printf
printf
"sCsv.zFile = '<pipe>';\n"
sCsv.zFile = "<pipe>";
sCsv.zFile = "<pipe>"
sCsv.zFile
sCsv
sCsv
zFile
"<pipe>"
printf("xCloser = pclose;\n");
printf("xCloser = pclose;\n")
printf
printf
"xCloser = pclose;\n"
xCloser = pclose;
xCloser = pclose
xCloser
xCloser
pclose
pclose
{      printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");sCsv.in = fopen(sCsv.zFile, "rb");      printf("xCloser = fclose;\n");xCloser = fclose;    }
printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n");
printf("sCsv.in = fopen(sCsv.zFile, 'rb');\n")
printf
printf
"sCsv.in = fopen(sCsv.zFile, 'rb');\n"
sCsv.in = fopen(sCsv.zFile, "rb");
sCsv.in = fopen(sCsv.zFile, "rb")
sCsv.in
sCsv
sCsv
in
fopen(sCsv.zFile, "rb")
fopen
fopen
sCsv.zFile
sCsv
sCsv
zFile
"rb"
printf("xCloser = fclose;\n");
printf("xCloser = fclose;\n")
printf
printf
"xCloser = fclose;\n"
xCloser = fclose;
xCloser = fclose
xCloser
xCloser
fclose
fclose
if( sCsv.in==0 ){printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
sCsv.in==0
sCsv.in
sCsv
sCsv
in
0
{printf("if(sCsv.in==0)\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(sCsv.in==0)\n");
printf("if(sCsv.in==0)\n")
printf
printf
"if(sCsv.in==0)\n"
printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n");
printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n")
printf
printf
"fprintf(stderr, 'Error: cannot open \'_s\' ', zFile);\n"
fprintf(stderr, "Error: cannot open \"%s\"\n", zFile);
fprintf(stderr, "Error: cannot open \"%s\"\n", zFile)
fprintf
fprintf
stderr
stderr
"Error: cannot open \"%s\"\n"
zFile
zFile
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("sCsv.cSeparator = p->separator[0];\n");
printf("sCsv.cSeparator = p->separator[0];\n")
printf
printf
"sCsv.cSeparator = p->separator[0];\n"
sCsv.cSeparator = p->separator[0];
sCsv.cSeparator = p->separator[0]
sCsv.cSeparator
sCsv
sCsv
cSeparator
p->separator[0]
p->separator
p
p
separator
0
printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n");
printf("zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n")
printf
printf
"zSql = sqlite3_mprintf('SELECT * FROM _s', zTable);\n"
zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);
zSql = sqlite3_mprintf("SELECT * FROM %s", zTable)
zSql
zSql
sqlite3_mprintf("SELECT * FROM %s", zTable)
sqlite3_mprintf
sqlite3_mprintf
"SELECT * FROM %s"
zTable
zTable
if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
zSql==0
zSql
zSql
0
{printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(zSql==0)\n");
printf("if(zSql==0)\n")
printf
printf
"if(zSql==0)\n"
printf("fprintf(stderr, 'Error: out of memory ');\n");
printf("fprintf(stderr, 'Error: out of memory ');\n")
printf
printf
"fprintf(stderr, 'Error: out of memory ');\n"
fprintf(stderr, "Error: out of memory\n");
fprintf(stderr, "Error: out of memory\n")
fprintf
fprintf
stderr
stderr
"Error: out of memory\n"
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("nByte = strlen30(zSql);\n");
printf("nByte = strlen30(zSql);\n")
printf
printf
"nByte = strlen30(zSql);\n"
nByte = strlen30(zSql);
nByte = strlen30(zSql)
nByte
nByte
strlen30(zSql)
strlen30
strlen30
zSql
zSql
rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0)
rc
rc
sqlite3_prepare(p->db, zSql, -1, &pStmt, 0)
sqlite3_prepare
sqlite3_prepare
p->db
p
p
db
zSql
zSql
-1
1
&pStmt
pStmt
pStmt
0
if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0 ){printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }
rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0
rc
rc
sqlite3_strglob("no such table: *", sqlite3_errmsg(db))==0
sqlite3_strglob("no such table: *", sqlite3_errmsg(db))
sqlite3_strglob
sqlite3_strglob
"no such table: *"
sqlite3_errmsg(db)
sqlite3_errmsg
sqlite3_errmsg
db
db
0
{printf("if()\n");          printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");      char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);      printf("char cSep = '(';\n");      char cSep = '(';      while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }      if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");zCreate = sqlite3_mprintf("%z\n)", zCreate);      rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);      printf("sqlite3_free(zCreate);\n");      sqlite3_free(zCreate);      if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n");
printf("char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n")
printf
printf
"char *zCreate = sqlite3_mprintf('CREATE TABLE _s', zTable);\n"
char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);
char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);
char
*zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable)
*
zCreate
= sqlite3_mprintf("CREATE TABLE %s", zTable)
sqlite3_mprintf("CREATE TABLE %s", zTable)
sqlite3_mprintf
sqlite3_mprintf
"CREATE TABLE %s"
zTable
zTable
printf("char cSep = '(';\n");
printf("char cSep = '(';\n")
printf
printf
"char cSep = '(';\n"
char cSep = '(';
char cSep = '(';
char
cSep = '('
cSep
= '('
'('
while( csv_read_one_field(&sCsv) ){printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }
csv_read_one_field(&sCsv)
csv_read_one_field
csv_read_one_field
&sCsv
sCsv
sCsv
{printf("while(csv_read_one_field(&sCsv))\n");              printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);        printf("cSep = ',';\n");cSep = ',';        if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}      }
printf("while(csv_read_one_field(&sCsv))\n");
printf("while(csv_read_one_field(&sCsv))\n")
printf
printf
"while(csv_read_one_field(&sCsv))\n"
printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n");
printf("zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n")
printf
printf
"zCreate = sqlite3_mprintf('_z_c   \'_s\' TEXT', zCreate, cSep, sCsv.z);\n"
zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z);
zCreate = sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z)
zCreate
zCreate
sqlite3_mprintf("%z%c\n  \"%s\" TEXT", zCreate, cSep, sCsv.z)
sqlite3_mprintf
sqlite3_mprintf
"%z%c\n  \"%s\" TEXT"
zCreate
zCreate
cSep
cSep
sCsv.z
sCsv
sCsv
z
printf("cSep = ',';\n");
printf("cSep = ',';\n")
printf
printf
"cSep = ',';\n"
cSep = ',';
cSep = ','
cSep
cSep
','
if( sCsv.cTerm!=sCsv.cSeparator ) {printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}
sCsv.cTerm!=sCsv.cSeparator
sCsv.cTerm
sCsv
sCsv
cTerm
sCsv.cSeparator
sCsv
sCsv
cSeparator
{printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");        break;}
printf("if(sCsv.cTerm!=sCsv.cSeparator)\n");
printf("if(sCsv.cTerm!=sCsv.cSeparator)\n")
printf
printf
"if(sCsv.cTerm!=sCsv.cSeparator)\n"
break;
if( cSep=='(' ){printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
cSep=='('
cSep
cSep
'('
{printf("if(cSep=='(')\n");              printf("sqlite3_free(zCreate);\n");        sqlite3_free(zCreate);        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");        fprintf(stderr,"%s: empty file\n", sCsv.zFile);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
printf("if(cSep=='(')\n");
printf("if(cSep=='(')\n")
printf
printf
"if(cSep=='(')\n"
printf("sqlite3_free(zCreate);\n");
printf("sqlite3_free(zCreate);\n")
printf
printf
"sqlite3_free(zCreate);\n"
sqlite3_free(zCreate);
sqlite3_free(zCreate)
sqlite3_free
sqlite3_free
zCreate
zCreate
printf("sqlite3_free(sCsv.z);\n");
printf("sqlite3_free(sCsv.z);\n")
printf
printf
"sqlite3_free(sCsv.z);\n"
sqlite3_free(sCsv.z);
sqlite3_free(sCsv.z)
sqlite3_free
sqlite3_free
sCsv.z
sCsv
sCsv
z
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n");
printf("fprintf(stderr,'_s: empty file ', sCsv.zFile);\n")
printf
printf
"fprintf(stderr,'_s: empty file ', sCsv.zFile);\n"
fprintf(stderr,"%s: empty file\n", sCsv.zFile);
fprintf(stderr,"%s: empty file\n", sCsv.zFile)
fprintf
fprintf
stderr
stderr
"%s: empty file\n"
sCsv.zFile
sCsv
sCsv
zFile
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n");
printf("zCreate = sqlite3_mprintf('_z )', zCreate);\n")
printf
printf
"zCreate = sqlite3_mprintf('_z )', zCreate);\n"
zCreate = sqlite3_mprintf("%z\n)", zCreate);
zCreate = sqlite3_mprintf("%z\n)", zCreate)
zCreate
zCreate
sqlite3_mprintf("%z\n)", zCreate)
sqlite3_mprintf
sqlite3_mprintf
"%z\n)"
zCreate
zCreate
rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);
rc = sqlite3_exec(p->db, zCreate, 0, 0, 0)
rc
rc
sqlite3_exec(p->db, zCreate, 0, 0, 0)
sqlite3_exec
sqlite3_exec
p->db
p
p
db
zCreate
zCreate
0
0
0
printf("sqlite3_free(zCreate);\n");
printf("sqlite3_free(zCreate);\n")
printf
printf
"sqlite3_free(zCreate);\n"
sqlite3_free(zCreate);
sqlite3_free(zCreate)
sqlite3_free
sqlite3_free
zCreate
zCreate
if( rc ){printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
rc
rc
{printf("if(rc)\n");              fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));        printf("sqlite3_free(sCsv.z);\n");        sqlite3_free(sCsv.z);        printf("xCloser(sCsv.in);\n");        xCloser(sCsv.in);        printf("return 1;\n");        printf("------function end!------\n");        return 1;      }
printf("if(rc)\n");
printf("if(rc)\n")
printf
printf
"if(rc)\n"
fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db));
fprintf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,                sqlite3_errmsg(db))
fprintf
fprintf
stderr
stderr
"CREATE TABLE %s(...) failed: %s\n"
zTable
zTable
sqlite3_errmsg(db)
sqlite3_errmsg
sqlite3_errmsg
db
db
printf("sqlite3_free(sCsv.z);\n");
printf("sqlite3_free(sCsv.z);\n")
printf
printf
"sqlite3_free(sCsv.z);\n"
sqlite3_free(sCsv.z);
sqlite3_free(sCsv.z)
sqlite3_free
sqlite3_free
sCsv.z
sCsv
sCsv
z
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0)
rc
rc
sqlite3_prepare(p->db, zSql, -1, &pStmt, 0)
sqlite3_prepare
sqlite3_prepare
p->db
p
p
db
zSql
zSql
-1
1
&pStmt
pStmt
pStmt
0
printf("sqlite3_free(zSql);\n");
printf("sqlite3_free(zSql);\n")
printf
printf
"sqlite3_free(zSql);\n"
sqlite3_free(zSql);
sqlite3_free(zSql)
sqlite3_free
sqlite3_free
zSql
zSql
if( rc ){printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
rc
rc
{printf("if(rc)\n");          if (pStmt) sqlite3_finalize(pStmt);      fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(rc)\n");
printf("if(rc)\n")
printf
printf
"if(rc)\n"
if (pStmt) sqlite3_finalize(pStmt);
pStmt
pStmt
sqlite3_finalize(pStmt);
sqlite3_finalize(pStmt)
sqlite3_finalize
sqlite3_finalize
pStmt
pStmt
fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db));
fprintf(stderr,"Error: %s\n", sqlite3_errmsg(db))
fprintf
fprintf
stderr
stderr
"Error: %s\n"
sqlite3_errmsg(db)
sqlite3_errmsg
sqlite3_errmsg
db
db
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
nCol = sqlite3_column_count(pStmt);
nCol = sqlite3_column_count(pStmt)
nCol
nCol
sqlite3_column_count(pStmt)
sqlite3_column_count
sqlite3_column_count
pStmt
pStmt
sqlite3_finalize(pStmt);
sqlite3_finalize(pStmt)
sqlite3_finalize
sqlite3_finalize
pStmt
pStmt
pStmt = 0;
pStmt = 0
pStmt
pStmt
0
if( nCol==0 ) {printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;}
nCol==0
nCol
nCol
0
{printf("if(nCol==0)\n");    printf("return 0;\n");    printf("------function end!------\n");    return 0;}
printf("if(nCol==0)\n");
printf("if(nCol==0)\n")
printf
printf
"if(nCol==0)\n"
printf("return 0;\n");
printf("return 0;\n")
printf
printf
"return 0;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 0;
0
printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n");
printf("zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n")
printf
printf
"zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );\n"
zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 );
zSql = sqlite3_malloc( nByte*2 + 20 + nCol*2 )
zSql
zSql
sqlite3_malloc( nByte*2 + 20 + nCol*2 )
sqlite3_malloc
sqlite3_malloc
nByte*2 + 20 + nCol*2
nByte*2 + 20
nByte*2
nByte
nByte
2
20
nCol*2
nCol
nCol
2
if( zSql==0 ){printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
zSql==0
zSql
zSql
0
{printf("if(zSql==0)\n");          printf("fprintf(stderr, 'Error: out of memory ');\n");      fprintf(stderr, "Error: out of memory\n");      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(zSql==0)\n");
printf("if(zSql==0)\n")
printf
printf
"if(zSql==0)\n"
printf("fprintf(stderr, 'Error: out of memory ');\n");
printf("fprintf(stderr, 'Error: out of memory ');\n")
printf
printf
"fprintf(stderr, 'Error: out of memory ');\n"
fprintf(stderr, "Error: out of memory\n");
fprintf(stderr, "Error: out of memory\n")
fprintf
fprintf
stderr
stderr
"Error: out of memory\n"
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n");
printf("sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n")
printf
printf
"sqlite3_snprintf(nByte+20, zSql, 'INSERT INTO \'_w\' VALUES(?', zTable);\n"
sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);
sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable)
sqlite3_snprintf
sqlite3_snprintf
nByte+20
nByte
nByte
20
zSql
zSql
"INSERT INTO \"%w\" VALUES(?"
zTable
zTable
printf("j = strlen30(zSql);\n");
printf("j = strlen30(zSql);\n")
printf
printf
"j = strlen30(zSql);\n"
j = strlen30(zSql);
j = strlen30(zSql)
j
j
strlen30(zSql)
strlen30
strlen30
zSql
zSql
for(i=1; i<nCol; i++){printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }
i=1;
i=1
i
i
1
i<nCol
i
i
nCol
nCol
i++
i
i
{printf("for(i=1;i<nCol;i++)\n");          printf("zSql[j++] = ',';\n");zSql[j++] = ',';      printf("zSql[j++] = '?';\n");zSql[j++] = '?';    }
printf("for(i=1;i<nCol;i++)\n");
printf("for(i=1;i<nCol;i++)\n")
printf
printf
"for(i=1;i<nCol;i++)\n"
printf("zSql[j++] = ',';\n");
printf("zSql[j++] = ',';\n")
printf
printf
"zSql[j++] = ',';\n"
zSql[j++] = ',';
zSql[j++] = ','
zSql[j++]
zSql
zSql
j++
j
j
','
printf("zSql[j++] = '?';\n");
printf("zSql[j++] = '?';\n")
printf
printf
"zSql[j++] = '?';\n"
zSql[j++] = '?';
zSql[j++] = '?'
zSql[j++]
zSql
zSql
j++
j
j
'?'
printf("zSql[j++] = ')';\n");
printf("zSql[j++] = ')';\n")
printf
printf
"zSql[j++] = ')';\n"
zSql[j++] = ')';
zSql[j++] = ')'
zSql[j++]
zSql
zSql
j++
j
j
')'
printf("zSql[j] = 0;\n");
printf("zSql[j] = 0;\n")
printf
printf
"zSql[j] = 0;\n"
zSql[j] = 0;
zSql[j] = 0
zSql[j]
zSql
zSql
j
j
0
rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0)
rc
rc
sqlite3_prepare(p->db, zSql, -1, &pStmt, 0)
sqlite3_prepare
sqlite3_prepare
p->db
p
p
db
zSql
zSql
-1
1
&pStmt
pStmt
pStmt
0
printf("sqlite3_free(zSql);\n");
printf("sqlite3_free(zSql);\n")
printf
printf
"sqlite3_free(zSql);\n"
sqlite3_free(zSql);
sqlite3_free(zSql)
sqlite3_free
sqlite3_free
zSql
zSql
if( rc ){printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
rc
rc
{printf("if(rc)\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));      if (pStmt) sqlite3_finalize(pStmt);      printf("xCloser(sCsv.in);\n");      xCloser(sCsv.in);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if(rc)\n");
printf("if(rc)\n")
printf
printf
"if(rc)\n"
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db))
fprintf
fprintf
stderr
stderr
"Error: %s\n"
sqlite3_errmsg(db)
sqlite3_errmsg
sqlite3_errmsg
db
db
if (pStmt) sqlite3_finalize(pStmt);
pStmt
pStmt
sqlite3_finalize(pStmt);
sqlite3_finalize(pStmt)
sqlite3_finalize
sqlite3_finalize
pStmt
pStmt
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
needCommit = sqlite3_get_autocommit(db);
needCommit = sqlite3_get_autocommit(db)
needCommit
needCommit
sqlite3_get_autocommit(db)
sqlite3_get_autocommit
sqlite3_get_autocommit
db
db
if( needCommit ) sqlite3_exec(db, "BEGIN", 0, 0, 0);
needCommit
needCommit
sqlite3_exec(db, "BEGIN", 0, 0, 0);
sqlite3_exec(db, "BEGIN", 0, 0, 0)
sqlite3_exec
sqlite3_exec
db
db
"BEGIN"
0
0
0
do{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }while( sCsv.cTerm!=EOF );
{      printf("int startLine = sCsv.nLine;\n");      int startLine = sCsv.nLine;      for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }      if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }      if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }    }
printf("int startLine = sCsv.nLine;\n");
printf("int startLine = sCsv.nLine;\n")
printf
printf
"int startLine = sCsv.nLine;\n"
int startLine = sCsv.nLine;
int startLine = sCsv.nLine;
int
startLine = sCsv.nLine
startLine
= sCsv.nLine
sCsv.nLine
sCsv
sCsv
nLine
for(i=0; i<nCol; i++){printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }
i=0;
i=0
i
i
0
i<nCol
i
i
nCol
nCol
i++
i
i
{printf("for(i=0;i<nCol;i++)\n");              printf("char *z = csv_read_one_field(&sCsv);\n");        char *z = csv_read_one_field(&sCsv);        if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}        sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);        if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }      }
printf("for(i=0;i<nCol;i++)\n");
printf("for(i=0;i<nCol;i++)\n")
printf
printf
"for(i=0;i<nCol;i++)\n"
printf("char *z = csv_read_one_field(&sCsv);\n");
printf("char *z = csv_read_one_field(&sCsv);\n")
printf
printf
"char *z = csv_read_one_field(&sCsv);\n"
char *z = csv_read_one_field(&sCsv);
char *z = csv_read_one_field(&sCsv);
char
*z = csv_read_one_field(&sCsv)
*
z
= csv_read_one_field(&sCsv)
csv_read_one_field(&sCsv)
csv_read_one_field
csv_read_one_field
&sCsv
sCsv
sCsv
if( z==0 && i==0 ) {printf("if(z==0 && i==0)\n");        break;}
z==0 && i==0
z==0
z
z
0
i==0
i
i
0
{printf("if(z==0 && i==0)\n");        break;}
printf("if(z==0 && i==0)\n");
printf("if(z==0 && i==0)\n")
printf
printf
"if(z==0 && i==0)\n"
break;
sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);
sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT)
sqlite3_bind_text
sqlite3_bind_text
pStmt
pStmt
i+1
i
i
1
z
z
-1
1
SQLITE_TRANSIENT
SQLITE_TRANSIENT
if( i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator ){printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }
i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator
i<nCol-1
i
i
nCol-1
nCol
nCol
1
sCsv.cTerm!=sCsv.cSeparator
sCsv.cTerm
sCsv
sCsv
cTerm
sCsv.cSeparator
sCsv
sCsv
cSeparator
{printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");                  printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");          fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);          printf("i++;\n");i++;          while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }        }
printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n");
printf("if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n")
printf
printf
"if(i<nCol-1 && sCsv.cTerm!=sCsv.cSeparator)\n"
printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n");
printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n")
printf
printf
"fprintf(stderr, '_s:_d: expected _d columns but found _d - '                           'filling the rest with NULL ',                           sCsv.zFile, startLine, nCol, i+1);\n"
fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1);
fprintf(stderr, "%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n",                          sCsv.zFile, startLine, nCol, i+1)
fprintf
fprintf
stderr
stderr
"%s:%d: expected %d columns but found %d - "                          "filling the rest with NULL\n"
sCsv.zFile
sCsv
sCsv
zFile
startLine
startLine
nCol
nCol
i+1
i
i
1
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
while( i<nCol ){printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }
i<nCol
i
i
nCol
nCol
{printf("while(i<nCol)\n");           sqlite3_bind_null(pStmt, i); printf("i++;\n");i++; }
printf("while(i<nCol)\n");
printf("while(i<nCol)\n")
printf
printf
"while(i<nCol)\n"
sqlite3_bind_null(pStmt, i);
sqlite3_bind_null(pStmt, i)
sqlite3_bind_null
sqlite3_bind_null
pStmt
pStmt
i
i
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
if( sCsv.cTerm==sCsv.cSeparator ){printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }
sCsv.cTerm==sCsv.cSeparator
sCsv.cTerm
sCsv
sCsv
cTerm
sCsv.cSeparator
sCsv
sCsv
cSeparator
{printf("if(sCsv.cTerm==sCsv.cSeparator)\n");              do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );        printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");        fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);      }
printf("if(sCsv.cTerm==sCsv.cSeparator)\n");
printf("if(sCsv.cTerm==sCsv.cSeparator)\n")
printf
printf
"if(sCsv.cTerm==sCsv.cSeparator)\n"
do{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }while( sCsv.cTerm==sCsv.cSeparator );
{          printf("csv_read_one_field(&sCsv);\n");          csv_read_one_field(&sCsv);          printf("i++;\n");i++;        }
printf("csv_read_one_field(&sCsv);\n");
printf("csv_read_one_field(&sCsv);\n")
printf
printf
"csv_read_one_field(&sCsv);\n"
csv_read_one_field(&sCsv);
csv_read_one_field(&sCsv)
csv_read_one_field
csv_read_one_field
&sCsv
sCsv
sCsv
printf("i++;\n");
printf("i++;\n")
printf
printf
"i++;\n"
i++;
i++
i
i
sCsv.cTerm==sCsv.cSeparator
sCsv.cTerm
sCsv
sCsv
cTerm
sCsv.cSeparator
sCsv
sCsv
cSeparator
printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n");
printf("fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n")
printf
printf
"fprintf(stderr, '_s:_d: expected _d columns but found _d - '                         'extras ignored ',                         sCsv.zFile, startLine, nCol, i);\n"
fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i);
fprintf(stderr, "%s:%d: expected %d columns but found %d - "                        "extras ignored\n",                        sCsv.zFile, startLine, nCol, i)
fprintf
fprintf
stderr
stderr
"%s:%d: expected %d columns but found %d - "                        "extras ignored\n"
sCsv.zFile
sCsv
sCsv
zFile
startLine
startLine
nCol
nCol
i
i
if( i>=nCol ){printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }
i>=nCol
i
i
nCol
nCol
{printf("if(i>=nCol)\n");              sqlite3_step(pStmt);        rc = sqlite3_reset(pStmt);        if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }      }
printf("if(i>=nCol)\n");
printf("if(i>=nCol)\n")
printf
printf
"if(i>=nCol)\n"
sqlite3_step(pStmt);
sqlite3_step(pStmt)
sqlite3_step
sqlite3_step
pStmt
pStmt
rc = sqlite3_reset(pStmt);
rc = sqlite3_reset(pStmt)
rc
rc
sqlite3_reset(pStmt)
sqlite3_reset
sqlite3_reset
pStmt
pStmt
if( rc!=SQLITE_OK ){printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }
rc!=SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{printf("if()\n");                  fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));        }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db));
fprintf(stderr, "%s:%d: INSERT failed: %s\n", sCsv.zFile, startLine,                  sqlite3_errmsg(db))
fprintf
fprintf
stderr
stderr
"%s:%d: INSERT failed: %s\n"
sCsv.zFile
sCsv
sCsv
zFile
startLine
startLine
sqlite3_errmsg(db)
sqlite3_errmsg
sqlite3_errmsg
db
db
sCsv.cTerm!=EOF
sCsv.cTerm
sCsv
sCsv
cTerm
EOF
EOF
printf("xCloser(sCsv.in);\n");
printf("xCloser(sCsv.in);\n")
printf
printf
"xCloser(sCsv.in);\n"
xCloser(sCsv.in);
xCloser(sCsv.in)
xCloser
xCloser
sCsv.in
sCsv
sCsv
in
printf("sqlite3_free(sCsv.z);\n");
printf("sqlite3_free(sCsv.z);\n")
printf
printf
"sqlite3_free(sCsv.z);\n"
sqlite3_free(sCsv.z);
sqlite3_free(sCsv.z)
sqlite3_free
sqlite3_free
sCsv.z
sCsv
sCsv
z
sqlite3_finalize(pStmt);
sqlite3_finalize(pStmt)
sqlite3_finalize
sqlite3_finalize
pStmt
pStmt
if( needCommit ) sqlite3_exec(db, "COMMIT", 0, 0, 0);
needCommit
needCommit
sqlite3_exec(db, "COMMIT", 0, 0, 0);
sqlite3_exec(db, "COMMIT", 0, 0, 0)
sqlite3_exec
sqlite3_exec
db
db
"COMMIT"
0
0
0
if( c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3 ){printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }else#ifdef SQLITE_ENABLE_IOTRACE  if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){printf("if(c=='i' && strncmp(azArg[0], 'iotrace', n)==0)\n");      printf("extern void (*sqlite3IoTrace)(const char*, ...);\n");    extern void (*sqlite3IoTrace)(const char*, ...);    if( iotrace && iotrace!=stdout ) {printf("if(iotrace && iotrace!=stdout)\n");    printf("fclose(iotrace);\n");    fclose(iotrace);}    printf("iotrace = 0;\n");iotrace = 0;    if( nArg<2 ){printf("if(nArg<2)\n");          printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;    }else if( strcmp(azArg[1], "-")==0 ){printf("if(strcmp(azArg[1], '-')==0)\n");          printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      printf("iotrace = stdout;\n");iotrace = stdout;    }else{      printf("iotrace = fopen(azArg[1], 'w');\n");iotrace = fopen(azArg[1], "w");      if( iotrace==0 ){printf("if(iotrace==0)\n");              printf("fprintf(stderr, 'Error: cannot open \'_s\' ', azArg[1]);\n");        fprintf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);        printf("sqlite3IoTrace = 0;\n");sqlite3IoTrace = 0;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3IoTrace = iotracePrintf;\n");sqlite3IoTrace = iotracePrintf;      }    }  }else#endif#ifndef SQLITE_OMIT_LOAD_EXTENSION  if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='i' && strncmp(azArg[0], "indices", n)==0 && nArg<3
c=='i' && strncmp(azArg[0], "indices", n)==0
c=='i'
c
c
'i'
strncmp(azArg[0], "indices", n)==0
strncmp(azArg[0], "indices", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"indices"
n
n
0
nArg<3
nArg
nArg
3
{printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_List;\n");data.mode = MODE_List;    if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }  }
printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n");
printf("if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n")
printf
printf
"if(c=='i' && strncmp(azArg[0], 'indices', n)==0 && nArg<3)\n"
printf("struct callback_data data;\n");
printf("struct callback_data data;\n")
printf
printf
"struct callback_data data;\n"
struct callback_data data;
struct callback_data data;
struct callback_data
callback_data
data
data
printf("char *zErrMsg = 0;\n");
printf("char *zErrMsg = 0;\n")
printf
printf
"char *zErrMsg = 0;\n"
char *zErrMsg = 0;
char *zErrMsg = 0;
char
*zErrMsg = 0
*
zErrMsg
= 0
0
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("memcpy(&data, p, sizeof(data));\n");
printf("memcpy(&data, p, sizeof(data));\n")
printf
printf
"memcpy(&data, p, sizeof(data));\n"
memcpy(&data, p, sizeof(data));
memcpy(&data, p, sizeof(data))
memcpy
memcpy
&data
data
data
p
p
sizeof(data)
(data)
data
data
printf("data.showHeader = 0;\n");
printf("data.showHeader = 0;\n")
printf
printf
"data.showHeader = 0;\n"
data.showHeader = 0;
data.showHeader = 0
data.showHeader
data
data
showHeader
0
printf("data.mode = MODE_List;\n");
printf("data.mode = MODE_List;\n")
printf
printf
"data.mode = MODE_List;\n"
data.mode = MODE_List;
data.mode = MODE_List
data.mode
data
data
mode
MODE_List
MODE_List
if( nArg==1 ){printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }else{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }
nArg==1
nArg
nArg
1
{printf("if(nArg==1)\n");          rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );    }
printf("if(nArg==1)\n");
printf("if(nArg==1)\n")
printf
printf
"if(nArg==1)\n"
rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      );
rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      )
rc
rc
sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1",        callback, &data, &zErrMsg      )
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"SELECT name FROM sqlite_master "        "WHERE type='index' AND name NOT LIKE 'sqlite_%' "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' "        "ORDER BY 1"
callback
callback
&data
data
data
&zErrMsg
zErrMsg
zErrMsg
{      printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];      rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );      printf("zShellStatic = 0;\n");zShellStatic = 0;    }
printf("zShellStatic = azArg[1];\n");
printf("zShellStatic = azArg[1];\n")
printf
printf
"zShellStatic = azArg[1];\n"
zShellStatic = azArg[1];
zShellStatic = azArg[1]
zShellStatic
zShellStatic
azArg[1]
azArg
azArg
1
rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      );
rc = sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      )
rc
rc
sqlite3_exec(p->db,        "SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1",        callback, &data, &zErrMsg      )
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"SELECT name FROM sqlite_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "UNION ALL "        "SELECT name FROM sqlite_temp_master "        "WHERE type='index' AND tbl_name LIKE shellstatic() "        "ORDER BY 1"
callback
callback
&data
data
data
&zErrMsg
zErrMsg
zErrMsg
printf("zShellStatic = 0;\n");
printf("zShellStatic = 0;\n")
printf
printf
"zShellStatic = 0;\n"
zShellStatic = 0;
zShellStatic = 0
zShellStatic
zShellStatic
0
if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }
zErrMsg
zErrMsg
{printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }
printf("if(zErrMsg)\n");
printf("if(zErrMsg)\n")
printf
printf
"if(zErrMsg)\n"
printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");
printf("fprintf(stderr,'Error: _s ', zErrMsg);\n")
printf
printf
"fprintf(stderr,'Error: _s ', zErrMsg);\n"
fprintf(stderr,"Error: %s\n", zErrMsg);
fprintf(stderr,"Error: %s\n", zErrMsg)
fprintf
fprintf
stderr
stderr
"Error: %s\n"
zErrMsg
zErrMsg
printf("sqlite3_free(zErrMsg);\n");
printf("sqlite3_free(zErrMsg);\n")
printf
printf
"sqlite3_free(zErrMsg);\n"
sqlite3_free(zErrMsg);
sqlite3_free(zErrMsg)
sqlite3_free
sqlite3_free
zErrMsg
zErrMsg
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }
rc != SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{printf("if()\n");          printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");      fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");      printf("rc = 1;\n");rc = 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n");
printf("fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n")
printf
printf
"fprintf(stderr,'Error: querying sqlite_master and sqlite_temp_master ');\n"
fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n");
fprintf(stderr,"Error: querying sqlite_master and sqlite_temp_master\n")
fprintf
fprintf
stderr
stderr
"Error: querying sqlite_master and sqlite_temp_master\n"
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }else#endif  if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='l' && strncmp(azArg[0], "load", n)==0 && nArg>=2
c=='l' && strncmp(azArg[0], "load", n)==0
c=='l'
c
c
'l'
strncmp(azArg[0], "load", n)==0
strncmp(azArg[0], "load", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"load"
n
n
0
nArg>=2
nArg
nArg
2
{printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");      printf("const char *zFile, *zProc;\n");    const char *zFile, *zProc;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("zFile = azArg[1];\n");zFile = azArg[1];    printf("zProc = nArg>=3 ? azArg[2] : 0;\n");zProc = nArg>=3 ? azArg[2] : 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }  }
printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n");
printf("if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n")
printf
printf
"if(c=='l' && strncmp(azArg[0], 'load', n)==0 && nArg>=2)\n"
printf("const char *zFile, *zProc;\n");
printf("const char *zFile, *zProc;\n")
printf
printf
"const char *zFile, *zProc;\n"
const char *zFile, *zProc;
const char *zFile, *zProc;
const char
*zFile
*
zFile
*zProc
*
zProc
printf("char *zErrMsg = 0;\n");
printf("char *zErrMsg = 0;\n")
printf
printf
"char *zErrMsg = 0;\n"
char *zErrMsg = 0;
char *zErrMsg = 0;
char
*zErrMsg = 0
*
zErrMsg
= 0
0
printf("zFile = azArg[1];\n");
printf("zFile = azArg[1];\n")
printf
printf
"zFile = azArg[1];\n"
zFile = azArg[1];
zFile = azArg[1]
zFile
zFile
azArg[1]
azArg
azArg
1
printf("zProc = nArg>=3 ? azArg[2] : 0;\n");
printf("zProc = nArg>=3 ? azArg[2] : 0;\n")
printf
printf
"zProc = nArg>=3 ? azArg[2] : 0;\n"
zProc = nArg>=3 ? azArg[2] : 0;
zProc = nArg>=3 ? azArg[2] : 0
zProc
zProc
nArg>=3 ? azArg[2] : 0
nArg>=3
nArg
nArg
3
azArg[2]
azArg
azArg
2
0
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);
rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg)
rc
rc
sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg)
sqlite3_load_extension
sqlite3_load_extension
p->db
p
p
db
zFile
zFile
zProc
zProc
&zErrMsg
zErrMsg
zErrMsg
if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }
rc!=SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{printf("if()\n");          printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");      fprintf(stderr, "Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n");
printf("fprintf(stderr, 'Error: _s ', zErrMsg);\n")
printf
printf
"fprintf(stderr, 'Error: _s ', zErrMsg);\n"
fprintf(stderr, "Error: %s\n", zErrMsg);
fprintf(stderr, "Error: %s\n", zErrMsg)
fprintf
fprintf
stderr
stderr
"Error: %s\n"
zErrMsg
zErrMsg
printf("sqlite3_free(zErrMsg);\n");
printf("sqlite3_free(zErrMsg);\n")
printf
printf
"sqlite3_free(zErrMsg);\n"
sqlite3_free(zErrMsg);
sqlite3_free(zErrMsg)
sqlite3_free
sqlite3_free
zErrMsg
zErrMsg
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2 ){printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='l' && strncmp(azArg[0], "log", n)==0 && nArg>=2
c=='l' && strncmp(azArg[0], "log", n)==0
c=='l'
c
c
'l'
strncmp(azArg[0], "log", n)==0
strncmp(azArg[0], "log", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"log"
n
n
0
nArg>=2
nArg
nArg
2
{printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");      printf("const char *zFile = azArg[1];\n");    const char *zFile = azArg[1];    printf("output_file_close(p->pLog);\n");    output_file_close(p->pLog);    printf("p->pLog = output_file_open(zFile);\n");p->pLog = output_file_open(zFile);  }
printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n");
printf("if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n")
printf
printf
"if(c=='l' && strncmp(azArg[0], 'log', n)==0 && nArg>=2)\n"
printf("const char *zFile = azArg[1];\n");
printf("const char *zFile = azArg[1];\n")
printf
printf
"const char *zFile = azArg[1];\n"
const char *zFile = azArg[1];
const char *zFile = azArg[1];
const char
*zFile = azArg[1]
*
zFile
= azArg[1]
azArg[1]
azArg
azArg
1
printf("output_file_close(p->pLog);\n");
printf("output_file_close(p->pLog);\n")
printf
printf
"output_file_close(p->pLog);\n"
output_file_close(p->pLog);
output_file_close(p->pLog)
output_file_close
output_file_close
p->pLog
p
p
pLog
printf("p->pLog = output_file_open(zFile);\n");
printf("p->pLog = output_file_open(zFile);\n")
printf
printf
"p->pLog = output_file_open(zFile);\n"
p->pLog = output_file_open(zFile);
p->pLog = output_file_open(zFile)
p->pLog
p
p
pLog
output_file_open(zFile)
output_file_open
output_file_open
zFile
zFile
if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==2
c=='m' && strncmp(azArg[0], "mode", n)==0
c=='m'
c
c
'm'
strncmp(azArg[0], "mode", n)==0
strncmp(azArg[0], "mode", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"mode"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }  }
printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n");
printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n")
printf
printf
"if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==2)\n"
printf("int n2 = strlen30(azArg[1]);\n");
printf("int n2 = strlen30(azArg[1]);\n")
printf
printf
"int n2 = strlen30(azArg[1]);\n"
int n2 = strlen30(azArg[1]);
int n2 = strlen30(azArg[1]);
int
n2 = strlen30(azArg[1])
n2
= strlen30(azArg[1])
strlen30(azArg[1])
strlen30
strlen30
azArg[1]
azArg
azArg
1
if( (n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0) ){printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }else if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
(n2==4 && strncmp(azArg[1],"line",n2)==0)        ||        (n2==5 && strncmp(azArg[1],"lines",n2)==0)
(n2==4 && strncmp(azArg[1],"line",n2)==0)
n2==4 && strncmp(azArg[1],"line",n2)==0
n2==4
n2
n2
4
strncmp(azArg[1],"line",n2)==0
strncmp(azArg[1],"line",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"line"
n2
n2
0
(n2==5 && strncmp(azArg[1],"lines",n2)==0)
n2==5 && strncmp(azArg[1],"lines",n2)==0
n2==5
n2
n2
5
strncmp(azArg[1],"lines",n2)==0
strncmp(azArg[1],"lines",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"lines"
n2
n2
0
{printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");              printf("p->mode = MODE_Line;\n");p->mode = MODE_Line;    }
printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n");
printf("if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n")
printf
printf
"if((n2==4 && strncmp(azArg[1],'line',n2)==0)         ||         (n2==5 && strncmp(azArg[1],'lines',n2)==0))\n"
printf("p->mode = MODE_Line;\n");
printf("p->mode = MODE_Line;\n")
printf
printf
"p->mode = MODE_Line;\n"
p->mode = MODE_Line;
p->mode = MODE_Line
p->mode
p
p
mode
MODE_Line
MODE_Line
if( (n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0) ){printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }else if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
(n2==6 && strncmp(azArg[1],"column",n2)==0)              ||              (n2==7 && strncmp(azArg[1],"columns",n2)==0)
(n2==6 && strncmp(azArg[1],"column",n2)==0)
n2==6 && strncmp(azArg[1],"column",n2)==0
n2==6
n2
n2
6
strncmp(azArg[1],"column",n2)==0
strncmp(azArg[1],"column",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"column"
n2
n2
0
(n2==7 && strncmp(azArg[1],"columns",n2)==0)
n2==7 && strncmp(azArg[1],"columns",n2)==0
n2==7
n2
n2
7
strncmp(azArg[1],"columns",n2)==0
strncmp(azArg[1],"columns",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"columns"
n2
n2
0
{printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");                    printf("p->mode = MODE_Column;\n");p->mode = MODE_Column;    }
printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n");
printf("if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n")
printf
printf
"if((n2==6 && strncmp(azArg[1],'column',n2)==0)               ||               (n2==7 && strncmp(azArg[1],'columns',n2)==0))\n"
printf("p->mode = MODE_Column;\n");
printf("p->mode = MODE_Column;\n")
printf
printf
"p->mode = MODE_Column;\n"
p->mode = MODE_Column;
p->mode = MODE_Column
p->mode
p
p
mode
MODE_Column
MODE_Column
if( n2==4 && strncmp(azArg[1],"list",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }else if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
n2==4 && strncmp(azArg[1],"list",n2)==0
n2==4
n2
n2
4
strncmp(azArg[1],"list",n2)==0
strncmp(azArg[1],"list",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"list"
n2
n2
0
{printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;    }
printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n");
printf("if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n")
printf
printf
"if(n2==4 && strncmp(azArg[1],'list',n2)==0)\n"
printf("p->mode = MODE_List;\n");
printf("p->mode = MODE_List;\n")
printf
printf
"p->mode = MODE_List;\n"
p->mode = MODE_List;
p->mode = MODE_List
p->mode
p
p
mode
MODE_List
MODE_List
if( n2==4 && strncmp(azArg[1],"html",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }else if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
n2==4 && strncmp(azArg[1],"html",n2)==0
n2==4
n2
n2
4
strncmp(azArg[1],"html",n2)==0
strncmp(azArg[1],"html",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"html"
n2
n2
0
{printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");          printf("p->mode = MODE_Html;\n");p->mode = MODE_Html;    }
printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n");
printf("if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n")
printf
printf
"if(n2==4 && strncmp(azArg[1],'html',n2)==0)\n"
printf("p->mode = MODE_Html;\n");
printf("p->mode = MODE_Html;\n")
printf
printf
"p->mode = MODE_Html;\n"
p->mode = MODE_Html;
p->mode = MODE_Html
p->mode
p
p
mode
MODE_Html
MODE_Html
if( n2==3 && strncmp(azArg[1],"tcl",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }else if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
n2==3 && strncmp(azArg[1],"tcl",n2)==0
n2==3
n2
n2
3
strncmp(azArg[1],"tcl",n2)==0
strncmp(azArg[1],"tcl",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"tcl"
n2
n2
0
{printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");          printf("p->mode = MODE_Tcl;\n");p->mode = MODE_Tcl;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, " ");    }
printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n");
printf("if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n")
printf
printf
"if(n2==3 && strncmp(azArg[1],'tcl',n2)==0)\n"
printf("p->mode = MODE_Tcl;\n");
printf("p->mode = MODE_Tcl;\n")
printf
printf
"p->mode = MODE_Tcl;\n"
p->mode = MODE_Tcl;
p->mode = MODE_Tcl
p->mode
p
p
mode
MODE_Tcl
MODE_Tcl
printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n");
printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n")
printf
printf
"sqlite3_snprintf(sizeof(p->separator), p->separator, ' ');\n"
sqlite3_snprintf(sizeof(p->separator), p->separator, " ");
sqlite3_snprintf(sizeof(p->separator), p->separator, " ")
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->separator)
(p->separator)
p->separator
p
p
separator
p->separator
p
p
separator
" "
if( n2==3 && strncmp(azArg[1],"csv",n2)==0 ){printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }else if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
n2==3 && strncmp(azArg[1],"csv",n2)==0
n2==3
n2
n2
3
strncmp(azArg[1],"csv",n2)==0
strncmp(azArg[1],"csv",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"csv"
n2
n2
0
{printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");          printf("p->mode = MODE_Csv;\n");p->mode = MODE_Csv;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, ",");    }
printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n");
printf("if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n")
printf
printf
"if(n2==3 && strncmp(azArg[1],'csv',n2)==0)\n"
printf("p->mode = MODE_Csv;\n");
printf("p->mode = MODE_Csv;\n")
printf
printf
"p->mode = MODE_Csv;\n"
p->mode = MODE_Csv;
p->mode = MODE_Csv
p->mode
p
p
mode
MODE_Csv
MODE_Csv
printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n");
printf("sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n")
printf
printf
"sqlite3_snprintf(sizeof(p->separator), p->separator, ',');\n"
sqlite3_snprintf(sizeof(p->separator), p->separator, ",");
sqlite3_snprintf(sizeof(p->separator), p->separator, ",")
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->separator)
(p->separator)
p->separator
p
p
separator
p->separator
p
p
separator
","
if( n2==4 && strncmp(azArg[1],"tabs",n2)==0 ){printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }else if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
n2==4 && strncmp(azArg[1],"tabs",n2)==0
n2==4
n2
n2
4
strncmp(azArg[1],"tabs",n2)==0
strncmp(azArg[1],"tabs",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"tabs"
n2
n2
0
{printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");          printf("p->mode = MODE_List;\n");p->mode = MODE_List;      printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");      sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");    }
printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n");
printf("if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n")
printf
printf
"if(n2==4 && strncmp(azArg[1],'tabs',n2)==0)\n"
printf("p->mode = MODE_List;\n");
printf("p->mode = MODE_List;\n")
printf
printf
"p->mode = MODE_List;\n"
p->mode = MODE_List;
p->mode = MODE_List
p->mode
p
p
mode
MODE_List
MODE_List
printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n");
printf("sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n")
printf
printf
"sqlite3_snprintf(sizeof(p->separator), p->separator, '\t');\n"
sqlite3_snprintf(sizeof(p->separator), p->separator, "\t");
sqlite3_snprintf(sizeof(p->separator), p->separator, "\t")
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->separator)
(p->separator)
p->separator
p
p
separator
p->separator
p
p
separator
"\t"
if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }else {      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
n2==6 && strncmp(azArg[1],"insert",n2)==0
n2==6
n2
n2
6
strncmp(azArg[1],"insert",n2)==0
strncmp(azArg[1],"insert",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"insert"
n2
n2
0
{printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, 'table');\n");      set_table_name(p, "table");    }
printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");
printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n")
printf
printf
"if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n"
printf("p->mode = MODE_Insert;\n");
printf("p->mode = MODE_Insert;\n")
printf
printf
"p->mode = MODE_Insert;\n"
p->mode = MODE_Insert;
p->mode = MODE_Insert
p->mode
p
p
mode
MODE_Insert
MODE_Insert
printf("set_table_name(p, 'table');\n");
printf("set_table_name(p, 'table');\n")
printf
printf
"set_table_name(p, 'table');\n"
set_table_name(p, "table");
set_table_name(p, "table")
set_table_name
set_table_name
p
p
"table"
{      printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");      fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");      printf("rc = 1;\n");rc = 1;    }
printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n");
printf("fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n")
printf
printf
"fprintf(stderr,'Error: mode should be one of: '          'column csv html insert line list tabs tcl ');\n"
fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n");
fprintf(stderr,"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n")
fprintf
fprintf
stderr
stderr
"Error: mode should be one of: "         "column csv html insert line list tabs tcl\n"
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3 ){printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }else  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='m' && strncmp(azArg[0], "mode", n)==0 && nArg==3
c=='m' && strncmp(azArg[0], "mode", n)==0
c=='m'
c
c
'm'
strncmp(azArg[0], "mode", n)==0
strncmp(azArg[0], "mode", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"mode"
n
n
0
nArg==3
nArg
nArg
3
{printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");      printf("int n2 = strlen30(azArg[1]);\n");    int n2 = strlen30(azArg[1]);    if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }  }
printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n");
printf("if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n")
printf
printf
"if(c=='m' && strncmp(azArg[0], 'mode', n)==0 && nArg==3)\n"
printf("int n2 = strlen30(azArg[1]);\n");
printf("int n2 = strlen30(azArg[1]);\n")
printf
printf
"int n2 = strlen30(azArg[1]);\n"
int n2 = strlen30(azArg[1]);
int n2 = strlen30(azArg[1]);
int
n2 = strlen30(azArg[1])
n2
= strlen30(azArg[1])
strlen30(azArg[1])
strlen30
strlen30
azArg[1]
azArg
azArg
1
if( n2==6 && strncmp(azArg[1],"insert",n2)==0 ){printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }else {      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }
n2==6 && strncmp(azArg[1],"insert",n2)==0
n2==6
n2
n2
6
strncmp(azArg[1],"insert",n2)==0
strncmp(azArg[1],"insert",n2)
strncmp
strncmp
azArg[1]
azArg
azArg
1
"insert"
n2
n2
0
{printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");          printf("p->mode = MODE_Insert;\n");p->mode = MODE_Insert;      printf("set_table_name(p, azArg[2]);\n");      set_table_name(p, azArg[2]);    }
printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n");
printf("if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n")
printf
printf
"if(n2==6 && strncmp(azArg[1],'insert',n2)==0)\n"
printf("p->mode = MODE_Insert;\n");
printf("p->mode = MODE_Insert;\n")
printf
printf
"p->mode = MODE_Insert;\n"
p->mode = MODE_Insert;
p->mode = MODE_Insert
p->mode
p
p
mode
MODE_Insert
MODE_Insert
printf("set_table_name(p, azArg[2]);\n");
printf("set_table_name(p, azArg[2]);\n")
printf
printf
"set_table_name(p, azArg[2]);\n"
set_table_name(p, azArg[2]);
set_table_name(p, azArg[2])
set_table_name
set_table_name
p
p
azArg[2]
azArg
azArg
2
{      printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");      fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);      printf("rc = 1;\n");rc = 1;    }
printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n");
printf("fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n")
printf
printf
"fprintf(stderr, 'Error: invalid arguments: '         ' \'_s\'. Enter \'.help\' for help ', azArg[2]);\n"
fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2]);
fprintf(stderr, "Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n", azArg[2])
fprintf
fprintf
stderr
stderr
"Error: invalid arguments: "        " \"%s\". Enter \".help\" for help\n"
azArg[2]
azArg
azArg
2
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2 ) {printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }else  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='n' && strncmp(azArg[0], "nullvalue", n)==0 && nArg==2
c=='n' && strncmp(azArg[0], "nullvalue", n)==0
c=='n'
c
c
'n'
strncmp(azArg[0], "nullvalue", n)==0
strncmp(azArg[0], "nullvalue", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"nullvalue"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);  }
printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n");
printf("if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n")
printf
printf
"if(c=='n' && strncmp(azArg[0], 'nullvalue', n)==0 && nArg==2)\n"
printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n");
printf("sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n")
printf
printf
"sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                      '_.*s', (int)ArraySize(p->nullvalue)-1, azArg[1]);\n"
sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1]);
sqlite3_snprintf(sizeof(p->nullvalue), p->nullvalue,                     "%.*s", (int)ArraySize(p->nullvalue)-1, azArg[1])
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->nullvalue)
(p->nullvalue)
p->nullvalue
p
p
nullvalue
p->nullvalue
p
p
nullvalue
"%.*s"
(int)ArraySize(p->nullvalue)-1
(int)ArraySize(p->nullvalue)
int
int

ArraySize(p->nullvalue)
ArraySize
ArraySize
p->nullvalue
p
p
nullvalue
1
azArg[1]
azArg
azArg
1
if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }else  if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2
c=='o' && strncmp(azArg[0], "open", n)==0
c=='o'
c
c
'o'
strncmp(azArg[0], "open", n)==0
strncmp(azArg[0], "open", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"open"
n
n
0
n>=2
n
n
2
{printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");      sqlite3 *savedDb = p->db;    printf("const char *zSavedFilename = p->zDbFilename;\n");    const char *zSavedFilename = p->zDbFilename;    printf("char *zNewFilename = 0;\n");    char *zNewFilename = 0;    p->db = 0;    if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }    printf("open_db(p, 1);\n");    open_db(p, 1);    if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }  }
printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n");
printf("if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n")
printf
printf
"if(c=='o' && strncmp(azArg[0], 'open', n)==0 && n>=2)\n"
sqlite3 *savedDb = p->db;
sqlite3 *savedDb = p->db;
sqlite3
sqlite3
*savedDb = p->db
*
savedDb
= p->db
p->db
p
p
db
printf("const char *zSavedFilename = p->zDbFilename;\n");
printf("const char *zSavedFilename = p->zDbFilename;\n")
printf
printf
"const char *zSavedFilename = p->zDbFilename;\n"
const char *zSavedFilename = p->zDbFilename;
const char *zSavedFilename = p->zDbFilename;
const char
*zSavedFilename = p->zDbFilename
*
zSavedFilename
= p->zDbFilename
p->zDbFilename
p
p
zDbFilename
printf("char *zNewFilename = 0;\n");
printf("char *zNewFilename = 0;\n")
printf
printf
"char *zNewFilename = 0;\n"
char *zNewFilename = 0;
char *zNewFilename = 0;
char
*zNewFilename = 0
*
zNewFilename
= 0
0
p->db = 0;
p->db = 0
p->db
p
p
db
0
if( nArg>=2 ){printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }
nArg>=2
nArg
nArg
2
{printf("if(nArg>=2)\n");          printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);    }
printf("if(nArg>=2)\n");
printf("if(nArg>=2)\n")
printf
printf
"if(nArg>=2)\n"
printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n");
printf("p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n")
printf
printf
"p->zDbFilename = zNewFilename = sqlite3_mprintf('_s', azArg[1]);\n"
p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1]);
p->zDbFilename = zNewFilename = sqlite3_mprintf("%s", azArg[1])
p->zDbFilename
p
p
zDbFilename
zNewFilename = sqlite3_mprintf("%s", azArg[1])
zNewFilename
zNewFilename
sqlite3_mprintf("%s", azArg[1])
sqlite3_mprintf
sqlite3_mprintf
"%s"
azArg[1]
azArg
azArg
1
printf("open_db(p, 1);\n");
printf("open_db(p, 1);\n")
printf
printf
"open_db(p, 1);\n"
open_db(p, 1);
open_db(p, 1)
open_db
open_db
p
p
1
if( p->db!=0 ){printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }else{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }
p->db!=0
p->db
p
p
db
0
{printf("if()\n");          sqlite3_close(savedDb);      printf("sqlite3_free(p->zFreeOnClose);\n");      sqlite3_free(p->zFreeOnClose);      printf("p->zFreeOnClose = zNewFilename;\n");p->zFreeOnClose = zNewFilename;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
sqlite3_close(savedDb);
sqlite3_close(savedDb)
sqlite3_close
sqlite3_close
savedDb
savedDb
printf("sqlite3_free(p->zFreeOnClose);\n");
printf("sqlite3_free(p->zFreeOnClose);\n")
printf
printf
"sqlite3_free(p->zFreeOnClose);\n"
sqlite3_free(p->zFreeOnClose);
sqlite3_free(p->zFreeOnClose)
sqlite3_free
sqlite3_free
p->zFreeOnClose
p
p
zFreeOnClose
printf("p->zFreeOnClose = zNewFilename;\n");
printf("p->zFreeOnClose = zNewFilename;\n")
printf
printf
"p->zFreeOnClose = zNewFilename;\n"
p->zFreeOnClose = zNewFilename;
p->zFreeOnClose = zNewFilename
p->zFreeOnClose
p
p
zFreeOnClose
zNewFilename
zNewFilename
{      printf("sqlite3_free(zNewFilename);\n");      sqlite3_free(zNewFilename);      p->db = savedDb;      printf("p->zDbFilename = zSavedFilename;\n");p->zDbFilename = zSavedFilename;    }
printf("sqlite3_free(zNewFilename);\n");
printf("sqlite3_free(zNewFilename);\n")
printf
printf
"sqlite3_free(zNewFilename);\n"
sqlite3_free(zNewFilename);
sqlite3_free(zNewFilename)
sqlite3_free
sqlite3_free
zNewFilename
zNewFilename
p->db = savedDb;
p->db = savedDb
p->db
p
p
db
savedDb
savedDb
printf("p->zDbFilename = zSavedFilename;\n");
printf("p->zDbFilename = zSavedFilename;\n")
printf
printf
"p->zDbFilename = zSavedFilename;\n"
p->zDbFilename = zSavedFilename;
p->zDbFilename = zSavedFilename
p->zDbFilename
p
p
zDbFilename
zSavedFilename
zSavedFilename
if( c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2 ){printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }else  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='o' && strncmp(azArg[0], "output", n)==0 && nArg==2
c=='o' && strncmp(azArg[0], "output", n)==0
c=='o'
c
c
'o'
strncmp(azArg[0], "output", n)==0
strncmp(azArg[0], "output", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"output"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");      if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }    printf("p->outfile[0] = 0;\n");p->outfile[0] = 0;    if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }  }
printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n");
printf("if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n")
printf
printf
"if(c=='o' && strncmp(azArg[0], 'output', n)==0 && nArg==2)\n"
if( p->outfile[0]=='|' ){printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }else{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }
p->outfile[0]=='|'
p->outfile[0]
p->outfile
p
p
outfile
0
'|'
{printf("if(p->outfile[0]=='|')\n");          printf("pclose(p->out);\n");      pclose(p->out);    }
printf("if(p->outfile[0]=='|')\n");
printf("if(p->outfile[0]=='|')\n")
printf
printf
"if(p->outfile[0]=='|')\n"
printf("pclose(p->out);\n");
printf("pclose(p->out);\n")
printf
printf
"pclose(p->out);\n"
pclose(p->out);
pclose(p->out)
pclose
pclose
p->out
p
p
out
{      printf("output_file_close(p->out);\n");      output_file_close(p->out);    }
printf("output_file_close(p->out);\n");
printf("output_file_close(p->out);\n")
printf
printf
"output_file_close(p->out);\n"
output_file_close(p->out);
output_file_close(p->out)
output_file_close
output_file_close
p->out
p
p
out
printf("p->outfile[0] = 0;\n");
printf("p->outfile[0] = 0;\n")
printf
printf
"p->outfile[0] = 0;\n"
p->outfile[0] = 0;
p->outfile[0] = 0
p->outfile[0]
p->outfile
p
p
outfile
0
0
if( azArg[1][0]=='|' ){printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }else{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }
azArg[1][0]=='|'
azArg[1][0]
azArg[1]
azArg
azArg
1
0
'|'
{printf("if(azArg[1][0]=='|')\n");          printf("p->out = popen(&azArg[1][1], 'w');\n");p->out = popen(&azArg[1][1], "w");      if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }
printf("if(azArg[1][0]=='|')\n");
printf("if(azArg[1][0]=='|')\n")
printf
printf
"if(azArg[1][0]=='|')\n"
printf("p->out = popen(&azArg[1][1], 'w');\n");
printf("p->out = popen(&azArg[1][1], 'w');\n")
printf
printf
"p->out = popen(&azArg[1][1], 'w');\n"
p->out = popen(&azArg[1][1], "w");
p->out = popen(&azArg[1][1], "w")
p->out
p
p
out
popen(&azArg[1][1], "w")
popen
popen
&azArg[1][1]
azArg[1][1]
azArg[1]
azArg
azArg
1
1
"w"
if( p->out==0 ){printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }else{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }
p->out==0
p->out
p
p
out
0
{printf("if(p->out==0)\n");              printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");        fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }
printf("if(p->out==0)\n");
printf("if(p->out==0)\n")
printf
printf
"if(p->out==0)\n"
printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n");
printf("fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n")
printf
printf
"fprintf(stderr,'Error: cannot open pipe \'_s\' ', &azArg[1][1]);\n"
fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1]);
fprintf(stderr,"Error: cannot open pipe \"%s\"\n", &azArg[1][1])
fprintf
fprintf
stderr
stderr
"Error: cannot open pipe \"%s\"\n"
&azArg[1][1]
azArg[1][1]
azArg[1]
azArg
azArg
1
1
printf("p->out = stdout;\n");
printf("p->out = stdout;\n")
printf
printf
"p->out = stdout;\n"
p->out = stdout;
p->out = stdout
p->out
p
p
out
stdout
stdout
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }
printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");
printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n")
printf
printf
"sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n"
sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);
sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1])
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->outfile)
(p->outfile)
p->outfile
p
p
outfile
p->outfile
p
p
outfile
"%s"
azArg[1]
azArg
azArg
1
{      printf("p->out = output_file_open(azArg[1]);\n");p->out = output_file_open(azArg[1]);      if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }    }
printf("p->out = output_file_open(azArg[1]);\n");
printf("p->out = output_file_open(azArg[1]);\n")
printf
printf
"p->out = output_file_open(azArg[1]);\n"
p->out = output_file_open(azArg[1]);
p->out = output_file_open(azArg[1])
p->out
p
p
out
output_file_open(azArg[1])
output_file_open
output_file_open
azArg[1]
azArg
azArg
1
if( p->out==0 ){printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      } else {        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }
p->out==0
p->out
p
p
out
0
{printf("if(p->out==0)\n");              if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }        printf("p->out = stdout;\n");p->out = stdout;        printf("rc = 1;\n");rc = 1;      }
printf("if(p->out==0)\n");
printf("if(p->out==0)\n")
printf
printf
"if(p->out==0)\n"
if( strcmp(azArg[1],"off")!=0 ){printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }
strcmp(azArg[1],"off")!=0
strcmp(azArg[1],"off")
strcmp
strcmp
azArg[1]
azArg
azArg
1
"off"
0
{printf("if(strcmp(azArg[1],'off')!=0)\n");                  printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");          fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);        }
printf("if(strcmp(azArg[1],'off')!=0)\n");
printf("if(strcmp(azArg[1],'off')!=0)\n")
printf
printf
"if(strcmp(azArg[1],'off')!=0)\n"
printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n");
printf("fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n")
printf
printf
"fprintf(stderr,'Error: cannot write to \'_s\' ', azArg[1]);\n"
fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1]);
fprintf(stderr,"Error: cannot write to \"%s\"\n", azArg[1])
fprintf
fprintf
stderr
stderr
"Error: cannot write to \"%s\"\n"
azArg[1]
azArg
azArg
1
printf("p->out = stdout;\n");
printf("p->out = stdout;\n")
printf
printf
"p->out = stdout;\n"
p->out = stdout;
p->out = stdout
p->out
p
p
out
stdout
stdout
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
{        printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");        sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);      }
printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n");
printf("sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n")
printf
printf
"sqlite3_snprintf(sizeof(p->outfile), p->outfile, '_s', azArg[1]);\n"
sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1]);
sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", azArg[1])
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->outfile)
(p->outfile)
p->outfile
p
p
outfile
p->outfile
p
p
outfile
"%s"
azArg[1]
azArg
azArg
1
if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }else  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0
c=='p' && n>=3
c=='p'
c
c
'p'
n>=3
n
n
3
strncmp(azArg[0], "print", n)==0
strncmp(azArg[0], "print", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"print"
n
n
0
{printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");      printf("int i;\n");    int i;    for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }    printf("fprintf(p->out, ' ');\n");    fprintf(p->out, "\n");  }
printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n");
printf("if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n")
printf
printf
"if(c=='p' && n>=3 && strncmp(azArg[0], 'print', n)==0)\n"
printf("int i;\n");
printf("int i;\n")
printf
printf
"int i;\n"
int i;
int i;
int
i
i
for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }
i=1;
i=1
i
i
1
i<nArg
i
i
nArg
nArg
i++
i
i
{printf("for(i=1;i<nArg;i++)\n");          if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}      printf("fprintf(p->out, '_s', azArg[i]);\n");      fprintf(p->out, "%s", azArg[i]);    }
printf("for(i=1;i<nArg;i++)\n");
printf("for(i=1;i<nArg;i++)\n")
printf
printf
"for(i=1;i<nArg;i++)\n"
if( i>1 ) {printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}
i>1
i
i
1
{printf("if(i>1)\n");      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, " ");}
printf("if(i>1)\n");
printf("if(i>1)\n")
printf
printf
"if(i>1)\n"
printf("fprintf(p->out, ' ');\n");
printf("fprintf(p->out, ' ');\n")
printf
printf
"fprintf(p->out, ' ');\n"
fprintf(p->out, " ");
fprintf(p->out, " ")
fprintf
fprintf
p->out
p
p
out
" "
printf("fprintf(p->out, '_s', azArg[i]);\n");
printf("fprintf(p->out, '_s', azArg[i]);\n")
printf
printf
"fprintf(p->out, '_s', azArg[i]);\n"
fprintf(p->out, "%s", azArg[i]);
fprintf(p->out, "%s", azArg[i])
fprintf
fprintf
p->out
p
p
out
"%s"
azArg[i]
azArg
azArg
i
i
printf("fprintf(p->out, ' ');\n");
printf("fprintf(p->out, ' ');\n")
printf
printf
"fprintf(p->out, ' ');\n"
fprintf(p->out, "\n");
fprintf(p->out, "\n")
fprintf
fprintf
p->out
p
p
out
"\n"
if( c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)){printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }else  if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='p' && strncmp(azArg[0], "prompt", n)==0 && (nArg==2 || nArg==3)
c=='p' && strncmp(azArg[0], "prompt", n)==0
c=='p'
c
c
'p'
strncmp(azArg[0], "prompt", n)==0
strncmp(azArg[0], "prompt", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"prompt"
n
n
0
(nArg==2 || nArg==3)
nArg==2 || nArg==3
nArg==2
nArg
nArg
2
nArg==3
nArg
nArg
3
{printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");      if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }    if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }  }
printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n");
printf("if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n")
printf
printf
"if(c=='p' && strncmp(azArg[0], 'prompt', n)==0 && (nArg==2 || nArg==3))\n"
if( nArg >= 2) {printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }
nArg >= 2
nArg
nArg
2
{printf("if(nArg >= 2)\n");          printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);    }
printf("if(nArg >= 2)\n");
printf("if(nArg >= 2)\n")
printf
printf
"if(nArg >= 2)\n"
printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n");
printf("strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n")
printf
printf
"strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\n"
strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);
strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1)
strncpy
strncpy
mainPrompt
mainPrompt
azArg[1]
azArg
azArg
1
(int)ArraySize(mainPrompt)-1
(int)ArraySize(mainPrompt)
int
int

ArraySize(mainPrompt)
ArraySize
ArraySize
mainPrompt
mainPrompt
1
if( nArg >= 3) {printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }
nArg >= 3
nArg
nArg
3
{printf("if(nArg >= 3)\n");          printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);    }
printf("if(nArg >= 3)\n");
printf("if(nArg >= 3)\n")
printf
printf
"if(nArg >= 3)\n"
printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n");
printf("strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n")
printf
printf
"strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\n"
strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);
strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1)
strncpy
strncpy
continuePrompt
continuePrompt
azArg[2]
azArg
azArg
2
(int)ArraySize(continuePrompt)-1
(int)ArraySize(continuePrompt)
int
int

ArraySize(continuePrompt)
ArraySize
ArraySize
continuePrompt
continuePrompt
1
if( c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1 ){printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='q' && strncmp(azArg[0], "quit", n)==0 && nArg==1
c=='q' && strncmp(azArg[0], "quit", n)==0
c=='q'
c
c
'q'
strncmp(azArg[0], "quit", n)==0
strncmp(azArg[0], "quit", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"quit"
n
n
0
nArg==1
nArg
nArg
1
{printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");      printf("rc = 2;\n");rc = 2;  }
printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n");
printf("if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n")
printf
printf
"if(c=='q' && strncmp(azArg[0], 'quit', n)==0 && nArg==1)\n"
printf("rc = 2;\n");
printf("rc = 2;\n")
printf
printf
"rc = 2;\n"
rc = 2;
rc = 2
rc
rc
2
if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2 ){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }else  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 && nArg==2
c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0
c=='r' && n>=3
c=='r'
c
c
'r'
n>=3
n
n
3
strncmp(azArg[0], "read", n)==0
strncmp(azArg[0], "read", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"read"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");      printf("FILE *alt = fopen(azArg[1], 'rb');\n");    FILE *alt = fopen(azArg[1], "rb");    if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }  }
printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n");
printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n")
printf
printf
"if(c=='r' && n>=3 && strncmp(azArg[0], 'read', n)==0 && nArg==2)\n"
printf("FILE *alt = fopen(azArg[1], 'rb');\n");
printf("FILE *alt = fopen(azArg[1], 'rb');\n")
printf
printf
"FILE *alt = fopen(azArg[1], 'rb');\n"
FILE *alt = fopen(azArg[1], "rb");
FILE *alt = fopen(azArg[1], "rb");
FILE
FILE
*alt = fopen(azArg[1], "rb")
*
alt
= fopen(azArg[1], "rb")
fopen(azArg[1], "rb")
fopen
fopen
azArg[1]
azArg
azArg
1
"rb"
if( alt==0 ){printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }
alt==0
alt
alt
0
{printf("if(alt==0)\n");          printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");      fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);      printf("rc = 1;\n");rc = 1;    }
printf("if(alt==0)\n");
printf("if(alt==0)\n")
printf
printf
"if(alt==0)\n"
printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n");
printf("fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n")
printf
printf
"fprintf(stderr,'Error: cannot open \'_s\' ', azArg[1]);\n"
fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);
fprintf(stderr,"Error: cannot open \"%s\"\n", azArg[1])
fprintf
fprintf
stderr
stderr
"Error: cannot open \"%s\"\n"
azArg[1]
azArg
azArg
1
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
{      printf("rc = process_input(p, alt);\n");rc = process_input(p, alt);      printf("fclose(alt);\n");      fclose(alt);    }
printf("rc = process_input(p, alt);\n");
printf("rc = process_input(p, alt);\n")
printf
printf
"rc = process_input(p, alt);\n"
rc = process_input(p, alt);
rc = process_input(p, alt)
rc
rc
process_input(p, alt)
process_input
process_input
p
p
alt
alt
printf("fclose(alt);\n");
printf("fclose(alt);\n")
printf
printf
"fclose(alt);\n"
fclose(alt);
fclose(alt)
fclose
fclose
alt
alt
if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4){printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }else  if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1 && nArg<4
c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 && nArg>1
c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0
c=='r' && n>=3
c=='r'
c
c
'r'
n>=3
n
n
3
strncmp(azArg[0], "restore", n)==0
strncmp(azArg[0], "restore", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"restore"
n
n
0
nArg>1
nArg
nArg
1
nArg<4
nArg
nArg
4
{printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");      printf("const char *zSrcFile;\n");    const char *zSrcFile;    printf("const char *zDb;\n");    const char *zDb;    sqlite3 *pSrc;    sqlite3_backup *pBackup;    printf("int nTimeout = 0;\n");    int nTimeout = 0;    if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }    rc = sqlite3_open(zSrcFile, &pSrc);    if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    printf("open_db(p, 0);\n");    open_db(p, 0);    pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");    if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }    sqlite3_backup_finish(pBackup);    if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }    sqlite3_close(pSrc);  }
printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n");
printf("if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n")
printf
printf
"if(c=='r' && n>=3 && strncmp(azArg[0], 'restore', n)==0 && nArg>1 && nArg<4)\n"
printf("const char *zSrcFile;\n");
printf("const char *zSrcFile;\n")
printf
printf
"const char *zSrcFile;\n"
const char *zSrcFile;
const char *zSrcFile;
const char
*zSrcFile
*
zSrcFile
printf("const char *zDb;\n");
printf("const char *zDb;\n")
printf
printf
"const char *zDb;\n"
const char *zDb;
const char *zDb;
const char
*zDb
*
zDb
sqlite3 *pSrc;
sqlite3 *pSrc;
sqlite3
sqlite3
*pSrc
*
pSrc
sqlite3_backup *pBackup;
sqlite3_backup *pBackup;
sqlite3_backup
sqlite3_backup
*pBackup
*
pBackup
printf("int nTimeout = 0;\n");
printf("int nTimeout = 0;\n")
printf
printf
"int nTimeout = 0;\n"
int nTimeout = 0;
int nTimeout = 0;
int
nTimeout = 0
nTimeout
= 0
0
if( nArg==2 ){printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }else{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }
nArg==2
nArg
nArg
2
{printf("if(nArg==2)\n");          printf("zSrcFile = azArg[1];\n");zSrcFile = azArg[1];      printf("zDb = 'main';\n");zDb = "main";    }
printf("if(nArg==2)\n");
printf("if(nArg==2)\n")
printf
printf
"if(nArg==2)\n"
printf("zSrcFile = azArg[1];\n");
printf("zSrcFile = azArg[1];\n")
printf
printf
"zSrcFile = azArg[1];\n"
zSrcFile = azArg[1];
zSrcFile = azArg[1]
zSrcFile
zSrcFile
azArg[1]
azArg
azArg
1
printf("zDb = 'main';\n");
printf("zDb = 'main';\n")
printf
printf
"zDb = 'main';\n"
zDb = "main";
zDb = "main"
zDb
zDb
"main"
{      printf("zSrcFile = azArg[2];\n");zSrcFile = azArg[2];      printf("zDb = azArg[1];\n");zDb = azArg[1];    }
printf("zSrcFile = azArg[2];\n");
printf("zSrcFile = azArg[2];\n")
printf
printf
"zSrcFile = azArg[2];\n"
zSrcFile = azArg[2];
zSrcFile = azArg[2]
zSrcFile
zSrcFile
azArg[2]
azArg
azArg
2
printf("zDb = azArg[1];\n");
printf("zDb = azArg[1];\n")
printf
printf
"zDb = azArg[1];\n"
zDb = azArg[1];
zDb = azArg[1]
zDb
zDb
azArg[1]
azArg
azArg
1
rc = sqlite3_open(zSrcFile, &pSrc);
rc = sqlite3_open(zSrcFile, &pSrc)
rc
rc
sqlite3_open(zSrcFile, &pSrc)
sqlite3_open
sqlite3_open
zSrcFile
zSrcFile
&pSrc
pSrc
pSrc
if( rc!=SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
rc!=SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{printf("if()\n");          printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");      fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n");
printf("fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n")
printf
printf
"fprintf(stderr, 'Error: cannot open \'_s\' ', zSrcFile);\n"
fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);
fprintf(stderr, "Error: cannot open \"%s\"\n", zSrcFile)
fprintf
fprintf
stderr
stderr
"Error: cannot open \"%s\"\n"
zSrcFile
zSrcFile
sqlite3_close(pSrc);
sqlite3_close(pSrc)
sqlite3_close
sqlite3_close
pSrc
pSrc
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");
pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main")
pBackup
pBackup
sqlite3_backup_init(p->db, zDb, pSrc, "main")
sqlite3_backup_init
sqlite3_backup_init
p->db
p
p
db
zDb
zDb
pSrc
pSrc
"main"
if( pBackup==0 ){printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
pBackup==0
pBackup
pBackup
0
{printf("if()\n");          fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      sqlite3_close(pSrc);      printf("return 1;\n");      printf("------function end!------\n");      return 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db))
fprintf
fprintf
stderr
stderr
"Error: %s\n"
sqlite3_errmsg(p->db)
sqlite3_errmsg
sqlite3_errmsg
p->db
p
p
db
sqlite3_close(pSrc);
sqlite3_close(pSrc)
sqlite3_close
sqlite3_close
pSrc
pSrc
printf("return 1;\n");
printf("return 1;\n")
printf
printf
"return 1;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return 1;
1
while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY  ){      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }
(rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK          || rc==SQLITE_BUSY
(rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
(rc = sqlite3_backup_step(pBackup,100))
rc = sqlite3_backup_step(pBackup,100)
rc
rc
sqlite3_backup_step(pBackup,100)
sqlite3_backup_step
sqlite3_backup_step
pBackup
pBackup
100
SQLITE_OK
SQLITE_OK
rc==SQLITE_BUSY
rc
rc
SQLITE_BUSY
SQLITE_BUSY
{      if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }    }
if( rc==SQLITE_BUSY ){        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }
rc==SQLITE_BUSY
rc
rc
SQLITE_BUSY
SQLITE_BUSY
{        if( nTimeout++ >= 3 ) break;        sqlite3_sleep(100);      }
if( nTimeout++ >= 3 ) break;
nTimeout++ >= 3
nTimeout++
nTimeout
nTimeout
3
break;
sqlite3_sleep(100);
sqlite3_sleep(100)
sqlite3_sleep
sqlite3_sleep
100
sqlite3_backup_finish(pBackup);
sqlite3_backup_finish(pBackup)
sqlite3_backup_finish
sqlite3_backup_finish
pBackup
pBackup
if( rc==SQLITE_DONE ){printf("if()\n");          printf("rc = 0;\n");rc = 0;    }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }
rc==SQLITE_DONE
rc
rc
SQLITE_DONE
SQLITE_DONE
{printf("if()\n");          printf("rc = 0;\n");rc = 0;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("rc = 0;\n");
printf("rc = 0;\n")
printf
printf
"rc = 0;\n"
rc = 0;
rc = 0
rc
rc
0
if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }else{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }
rc==SQLITE_BUSY || rc==SQLITE_LOCKED
rc==SQLITE_BUSY
rc
rc
SQLITE_BUSY
SQLITE_BUSY
rc==SQLITE_LOCKED
rc
rc
SQLITE_LOCKED
SQLITE_LOCKED
{printf("if()\n");          printf("fprintf(stderr, 'Error: source database is busy ');\n");      fprintf(stderr, "Error: source database is busy\n");      printf("rc = 1;\n");rc = 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr, 'Error: source database is busy ');\n");
printf("fprintf(stderr, 'Error: source database is busy ');\n")
printf
printf
"fprintf(stderr, 'Error: source database is busy ');\n"
fprintf(stderr, "Error: source database is busy\n");
fprintf(stderr, "Error: source database is busy\n")
fprintf
fprintf
stderr
stderr
"Error: source database is busy\n"
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
{      fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));      printf("rc = 1;\n");rc = 1;    }
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
fprintf(stderr, "Error: %s\n", sqlite3_errmsg(p->db))
fprintf
fprintf
stderr
stderr
"Error: %s\n"
sqlite3_errmsg(p->db)
sqlite3_errmsg
sqlite3_errmsg
p->db
p
p
db
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
sqlite3_close(pSrc);
sqlite3_close(pSrc)
sqlite3_close
sqlite3_close
pSrc
pSrc
if( c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }else#ifdef SQLITE_DEBUG  /* Undocumented commands for internal testing.  Subject to change  ** without notice. */  if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){printf("if(c=='s' && n>=10 && strncmp(azArg[0], 'selftest-', 9)==0)\n");      if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'boolean', n-9)==0)\n");          printf("int i, v;\n");      int i, v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("v = booleanValue(azArg[i]);\n");v = booleanValue(azArg[i]);        printf("fprintf(p->out, '_s: _d 0x_x ', azArg[i], v, v);\n");        fprintf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);      }    }    if( strncmp(azArg[0]+9, "integer", n-9)==0 ){printf("if(strncmp(azArg[0]+9, 'integer', n-9)==0)\n");          printf("int i;\n");      int i; sqlite3_int64 v;      for(i=1; i<nArg; i++){printf("for(i=1;i<nArg;i++)\n");              printf("char zBuf[200];\n");        char zBuf[200];        v = integerValue(azArg[i]);        sqlite3_snprintf(sizeof(zBuf), zBuf, "%s: %lld 0x%llx\n", azArg[i], v, v);        printf("fprintf(p->out, '_s', zBuf);\n");        fprintf(p->out, "%s", zBuf);      }    }  }else#endif  if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='s' && strncmp(azArg[0], "schema", n)==0 && nArg<3
c=='s' && strncmp(azArg[0], "schema", n)==0
c=='s'
c
c
's'
strncmp(azArg[0], "schema", n)==0
strncmp(azArg[0], "schema", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"schema"
n
n
0
nArg<3
nArg
nArg
3
{printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");      printf("struct callback_data data;\n");    struct callback_data data;    printf("char *zErrMsg = 0;\n");    char *zErrMsg = 0;    printf("open_db(p, 0);\n");    open_db(p, 0);    printf("memcpy(&data, p, sizeof(data));\n");    memcpy(&data, p, sizeof(data));    printf("data.showHeader = 0;\n");data.showHeader = 0;    printf("data.mode = MODE_Semi;\n");data.mode = MODE_Semi;    if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }    if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }  }
printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n");
printf("if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n")
printf
printf
"if(c=='s' && strncmp(azArg[0], 'schema', n)==0 && nArg<3)\n"
printf("struct callback_data data;\n");
printf("struct callback_data data;\n")
printf
printf
"struct callback_data data;\n"
struct callback_data data;
struct callback_data data;
struct callback_data
callback_data
data
data
printf("char *zErrMsg = 0;\n");
printf("char *zErrMsg = 0;\n")
printf
printf
"char *zErrMsg = 0;\n"
char *zErrMsg = 0;
char *zErrMsg = 0;
char
*zErrMsg = 0
*
zErrMsg
= 0
0
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("memcpy(&data, p, sizeof(data));\n");
printf("memcpy(&data, p, sizeof(data));\n")
printf
printf
"memcpy(&data, p, sizeof(data));\n"
memcpy(&data, p, sizeof(data));
memcpy(&data, p, sizeof(data))
memcpy
memcpy
&data
data
data
p
p
sizeof(data)
(data)
data
data
printf("data.showHeader = 0;\n");
printf("data.showHeader = 0;\n")
printf
printf
"data.showHeader = 0;\n"
data.showHeader = 0;
data.showHeader = 0
data.showHeader
data
data
showHeader
0
printf("data.mode = MODE_Semi;\n");
printf("data.mode = MODE_Semi;\n")
printf
printf
"data.mode = MODE_Semi;\n"
data.mode = MODE_Semi;
data.mode = MODE_Semi
data.mode
data
data
mode
MODE_Semi
MODE_Semi
if( nArg>1 ){printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }else{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }
nArg>1
nArg
nArg
1
{printf("if(nArg>1)\n");          printf("int i;\n");      int i;      for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}      if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }    }
printf("if(nArg>1)\n");
printf("if(nArg>1)\n")
printf
printf
"if(nArg>1)\n"
printf("int i;\n");
printf("int i;\n")
printf
printf
"int i;\n"
int i;
int i;
int
i
i
for(i=0; azArg[1][i]; i++) {printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}
i=0;
i=0
i
i
0
azArg[1][i]
azArg[1]
azArg
azArg
1
i
i
i++
i
i
{printf("for(i=0;azArg[1][i];i++)\n");      printf("azArg[1][i] = ToLower(azArg[1][i]);\n");azArg[1][i] = ToLower(azArg[1][i]);}
printf("for(i=0;azArg[1][i];i++)\n");
printf("for(i=0;azArg[1][i];i++)\n")
printf
printf
"for(i=0;azArg[1][i];i++)\n"
printf("azArg[1][i] = ToLower(azArg[1][i]);\n");
printf("azArg[1][i] = ToLower(azArg[1][i]);\n")
printf
printf
"azArg[1][i] = ToLower(azArg[1][i]);\n"
azArg[1][i] = ToLower(azArg[1][i]);
azArg[1][i] = ToLower(azArg[1][i])
azArg[1][i]
azArg[1]
azArg
azArg
1
i
i
ToLower(azArg[1][i])
ToLower
ToLower
azArg[1][i]
azArg[1]
azArg
azArg
1
i
i
if( strcmp(azArg[1],"sqlite_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }
strcmp(azArg[1],"sqlite_master")==0
strcmp(azArg[1],"sqlite_master")
strcmp
strcmp
azArg[1]
azArg
azArg
1
"sqlite_master"
0
{printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }
printf("if(strcmp(azArg[1],'sqlite_master')==0)\n");
printf("if(strcmp(azArg[1],'sqlite_master')==0)\n")
printf
printf
"if(strcmp(azArg[1],'sqlite_master')==0)\n"
printf("char *new_argv[2], *new_colv[2];\n");
printf("char *new_argv[2], *new_colv[2];\n")
printf
printf
"char *new_argv[2], *new_colv[2];\n"
char *new_argv[2], *new_colv[2];
char *new_argv[2], *new_colv[2];
char
*new_argv[2]
*
new_argv
[2]
2
*new_colv[2]
*
new_colv
[2]
2
printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");
printf("new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n")
printf
printf
"new_argv[0] = 'CREATE TABLE sqlite_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n"
new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";
new_argv[0] = "CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")"
new_argv[0]
new_argv
new_argv
0
"CREATE TABLE sqlite_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")"
printf("new_argv[1] = 0;\n");
printf("new_argv[1] = 0;\n")
printf
printf
"new_argv[1] = 0;\n"
new_argv[1] = 0;
new_argv[1] = 0
new_argv[1]
new_argv
new_argv
1
0
printf("new_colv[0] = 'sql';\n");
printf("new_colv[0] = 'sql';\n")
printf
printf
"new_colv[0] = 'sql';\n"
new_colv[0] = "sql";
new_colv[0] = "sql"
new_colv[0]
new_colv
new_colv
0
"sql"
printf("new_colv[1] = 0;\n");
printf("new_colv[1] = 0;\n")
printf
printf
"new_colv[1] = 0;\n"
new_colv[1] = 0;
new_colv[1] = 0
new_colv[1]
new_colv
new_colv
1
0
printf("callback(&data, 1, new_argv, new_colv);\n");
printf("callback(&data, 1, new_argv, new_colv);\n")
printf
printf
"callback(&data, 1, new_argv, new_colv);\n"
callback(&data, 1, new_argv, new_colv);
callback(&data, 1, new_argv, new_colv)
callback
callback
&data
data
data
1
new_argv
new_argv
new_colv
new_colv
rc = SQLITE_OK;
rc = SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
if( strcmp(azArg[1],"sqlite_temp_master")==0 ){printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }else{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }
strcmp(azArg[1],"sqlite_temp_master")==0
strcmp(azArg[1],"sqlite_temp_master")
strcmp
strcmp
azArg[1]
azArg
azArg
1
"sqlite_temp_master"
0
{printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");              printf("char *new_argv[2], *new_colv[2];\n");        char *new_argv[2], *new_colv[2];        printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";        printf("new_argv[1] = 0;\n");new_argv[1] = 0;        printf("new_colv[0] = 'sql';\n");new_colv[0] = "sql";        printf("new_colv[1] = 0;\n");new_colv[1] = 0;        printf("callback(&data, 1, new_argv, new_colv);\n");        callback(&data, 1, new_argv, new_colv);        rc = SQLITE_OK;      }
printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n");
printf("if(strcmp(azArg[1],'sqlite_temp_master')==0)\n")
printf
printf
"if(strcmp(azArg[1],'sqlite_temp_master')==0)\n"
printf("char *new_argv[2], *new_colv[2];\n");
printf("char *new_argv[2], *new_colv[2];\n")
printf
printf
"char *new_argv[2], *new_colv[2];\n"
char *new_argv[2], *new_colv[2];
char *new_argv[2], *new_colv[2];
char
*new_argv[2]
*
new_argv
[2]
2
*new_colv[2]
*
new_colv
[2]
2
printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n");
printf("new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n")
printf
printf
"new_argv[0] = 'CREATE TEMP TABLE sqlite_temp_master ( '                       '  type text, '                       '  name text, '                       '  tbl_name text, '                       '  rootpage integer, '                       '  sql text '                       ')';\n"
new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")";
new_argv[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")"
new_argv[0]
new_argv
new_argv
0
"CREATE TEMP TABLE sqlite_temp_master (\n"                      "  type text,\n"                      "  name text,\n"                      "  tbl_name text,\n"                      "  rootpage integer,\n"                      "  sql text\n"                      ")"
printf("new_argv[1] = 0;\n");
printf("new_argv[1] = 0;\n")
printf
printf
"new_argv[1] = 0;\n"
new_argv[1] = 0;
new_argv[1] = 0
new_argv[1]
new_argv
new_argv
1
0
printf("new_colv[0] = 'sql';\n");
printf("new_colv[0] = 'sql';\n")
printf
printf
"new_colv[0] = 'sql';\n"
new_colv[0] = "sql";
new_colv[0] = "sql"
new_colv[0]
new_colv
new_colv
0
"sql"
printf("new_colv[1] = 0;\n");
printf("new_colv[1] = 0;\n")
printf
printf
"new_colv[1] = 0;\n"
new_colv[1] = 0;
new_colv[1] = 0
new_colv[1]
new_colv
new_colv
1
0
printf("callback(&data, 1, new_argv, new_colv);\n");
printf("callback(&data, 1, new_argv, new_colv);\n")
printf
printf
"callback(&data, 1, new_argv, new_colv);\n"
callback(&data, 1, new_argv, new_colv);
callback(&data, 1, new_argv, new_colv)
callback
callback
&data
data
data
1
new_argv
new_argv
new_colv
new_colv
rc = SQLITE_OK;
rc = SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{        printf("zShellStatic = azArg[1];\n");zShellStatic = azArg[1];        rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);        printf("zShellStatic = 0;\n");zShellStatic = 0;      }
printf("zShellStatic = azArg[1];\n");
printf("zShellStatic = azArg[1];\n")
printf
printf
"zShellStatic = azArg[1];\n"
zShellStatic = azArg[1];
zShellStatic = azArg[1]
zShellStatic
zShellStatic
azArg[1]
azArg
azArg
1
rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg);
rc = sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg)
rc
rc
sqlite3_exec(p->db,          "SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid",          callback, &data, &zErrMsg)
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"SELECT sql FROM "          "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"          "     FROM sqlite_master UNION ALL"          "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "          "WHERE lower(tbl_name) LIKE shellstatic()"          "  AND type!='meta' AND sql NOTNULL "          "ORDER BY rowid"
callback
callback
&data
data
data
&zErrMsg
zErrMsg
zErrMsg
printf("zShellStatic = 0;\n");
printf("zShellStatic = 0;\n")
printf
printf
"zShellStatic = 0;\n"
zShellStatic = 0;
zShellStatic = 0
zShellStatic
zShellStatic
0
{      rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );    }
rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      );
rc = sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      )
rc
rc
sqlite3_exec(p->db,         "SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid",         callback, &data, &zErrMsg      )
sqlite3_exec
sqlite3_exec
p->db
p
p
db
"SELECT sql FROM "         "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"         "     FROM sqlite_master UNION ALL"         "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"         "ORDER BY rowid"
callback
callback
&data
data
data
&zErrMsg
zErrMsg
zErrMsg
if( zErrMsg ){printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }else if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }
zErrMsg
zErrMsg
{printf("if(zErrMsg)\n");          printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");      fprintf(stderr,"Error: %s\n", zErrMsg);      printf("sqlite3_free(zErrMsg);\n");      sqlite3_free(zErrMsg);      printf("rc = 1;\n");rc = 1;    }
printf("if(zErrMsg)\n");
printf("if(zErrMsg)\n")
printf
printf
"if(zErrMsg)\n"
printf("fprintf(stderr,'Error: _s ', zErrMsg);\n");
printf("fprintf(stderr,'Error: _s ', zErrMsg);\n")
printf
printf
"fprintf(stderr,'Error: _s ', zErrMsg);\n"
fprintf(stderr,"Error: %s\n", zErrMsg);
fprintf(stderr,"Error: %s\n", zErrMsg)
fprintf
fprintf
stderr
stderr
"Error: %s\n"
zErrMsg
zErrMsg
printf("sqlite3_free(zErrMsg);\n");
printf("sqlite3_free(zErrMsg);\n")
printf
printf
"sqlite3_free(zErrMsg);\n"
sqlite3_free(zErrMsg);
sqlite3_free(zErrMsg)
sqlite3_free
sqlite3_free
zErrMsg
zErrMsg
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
if( rc != SQLITE_OK ){printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }else{      printf("rc = 0;\n");rc = 0;    }
rc != SQLITE_OK
rc
rc
SQLITE_OK
SQLITE_OK
{printf("if()\n");          printf("fprintf(stderr,'Error: querying schema information ');\n");      fprintf(stderr,"Error: querying schema information\n");      printf("rc = 1;\n");rc = 1;    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr,'Error: querying schema information ');\n");
printf("fprintf(stderr,'Error: querying schema information ');\n")
printf
printf
"fprintf(stderr,'Error: querying schema information ');\n"
fprintf(stderr,"Error: querying schema information\n");
fprintf(stderr,"Error: querying schema information\n")
fprintf
fprintf
stderr
stderr
"Error: querying schema information\n"
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
{      printf("rc = 0;\n");rc = 0;    }
printf("rc = 0;\n");
printf("rc = 0;\n")
printf
printf
"rc = 0;\n"
rc = 0;
rc = 0
rc
rc
0
if( c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2 ){printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }else  if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='s' && strncmp(azArg[0], "separator", n)==0 && nArg==2
c=='s' && strncmp(azArg[0], "separator", n)==0
c=='s'
c
c
's'
strncmp(azArg[0], "separator", n)==0
strncmp(azArg[0], "separator", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"separator"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");      printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");    sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);  }
printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n");
printf("if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n")
printf
printf
"if(c=='s' && strncmp(azArg[0], 'separator', n)==0 && nArg==2)\n"
printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n");
printf("sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n")
printf
printf
"sqlite3_snprintf(sizeof(p->separator), p->separator,                      '_.*s', (int)sizeof(p->separator)-1, azArg[1]);\n"
sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1]);
sqlite3_snprintf(sizeof(p->separator), p->separator,                     "%.*s", (int)sizeof(p->separator)-1, azArg[1])
sqlite3_snprintf
sqlite3_snprintf
sizeof(p->separator)
(p->separator)
p->separator
p
p
separator
p->separator
p
p
separator
"%.*s"
(int)sizeof(p->separator)-1
(int)sizeof(p->separator)
int
int

sizeof(p->separator)
(p->separator)
p->separator
p
p
separator
1
azArg[1]
azArg
azArg
1
if( c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1 ){printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }else  if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='s' && strncmp(azArg[0], "show", n)==0 && nArg==1
c=='s' && strncmp(azArg[0], "show", n)==0
c=='s'
c
c
's'
strncmp(azArg[0], "show", n)==0
strncmp(azArg[0], "show", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"show"
n
n
0
nArg==1
nArg
nArg
1
{printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");      printf("int i;\n");    int i;    printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");    fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");    printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");    printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");    fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);    printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");    fprintf(p->out,"%9.9s: ", "nullvalue");      printf("output_c_string(p->out, p->nullvalue);\n");      output_c_string(p->out, p->nullvalue);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");    fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");    printf("fprintf(p->out,'_9.9s: ', 'separator');\n");    fprintf(p->out,"%9.9s: ", "separator");      printf("output_c_string(p->out, p->separator);\n");      output_c_string(p->out, p->separator);      printf("fprintf(p->out, ' ');\n");      fprintf(p->out, "\n");    printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");    fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");    printf("fprintf(p->out,'_9.9s: ','width');\n");    fprintf(p->out,"%9.9s: ","width");    for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }    printf("fprintf(p->out,' ');\n");    fprintf(p->out,"\n");  }
printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n");
printf("if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n")
printf
printf
"if(c=='s' && strncmp(azArg[0], 'show', n)==0 && nArg==1)\n"
printf("int i;\n");
printf("int i;\n")
printf
printf
"int i;\n"
int i;
int i;
int
i
i
printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n");
printf("fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n")
printf
printf
"fprintf(p->out,'_9.9s: _s ','echo', p->echoOn ? 'on' : 'off');\n"
fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off");
fprintf(p->out,"%9.9s: %s\n","echo", p->echoOn ? "on" : "off")
fprintf
fprintf
p->out
p
p
out
"%9.9s: %s\n"
"echo"
p->echoOn ? "on" : "off"
p->echoOn
p
p
echoOn
"on"
"off"
printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n");
printf("fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n")
printf
printf
"fprintf(p->out,'_9.9s: _s ','explain', p->explainPrev.valid ? 'on' :'off');\n"
fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off");
fprintf(p->out,"%9.9s: %s\n","explain", p->explainPrev.valid ? "on" :"off")
fprintf
fprintf
p->out
p
p
out
"%9.9s: %s\n"
"explain"
p->explainPrev.valid ? "on" :"off"
p->explainPrev.valid
p->explainPrev
p
p
explainPrev
valid
"on"
"off"
printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n");
printf("fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n")
printf
printf
"fprintf(p->out,'_9.9s: _s ','headers', p->showHeader ? 'on' : 'off');\n"
fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off");
fprintf(p->out,"%9.9s: %s\n","headers", p->showHeader ? "on" : "off")
fprintf
fprintf
p->out
p
p
out
"%9.9s: %s\n"
"headers"
p->showHeader ? "on" : "off"
p->showHeader
p
p
showHeader
"on"
"off"
printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n");
printf("fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n")
printf
printf
"fprintf(p->out,'_9.9s: _s ','mode', modeDescr[p->mode]);\n"
fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode]);
fprintf(p->out,"%9.9s: %s\n","mode", modeDescr[p->mode])
fprintf
fprintf
p->out
p
p
out
"%9.9s: %s\n"
"mode"
modeDescr[p->mode]
modeDescr
modeDescr
p->mode
p
p
mode
printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n");
printf("fprintf(p->out,'_9.9s: ', 'nullvalue');\n")
printf
printf
"fprintf(p->out,'_9.9s: ', 'nullvalue');\n"
fprintf(p->out,"%9.9s: ", "nullvalue");
fprintf(p->out,"%9.9s: ", "nullvalue")
fprintf
fprintf
p->out
p
p
out
"%9.9s: "
"nullvalue"
printf("output_c_string(p->out, p->nullvalue);\n");
printf("output_c_string(p->out, p->nullvalue);\n")
printf
printf
"output_c_string(p->out, p->nullvalue);\n"
output_c_string(p->out, p->nullvalue);
output_c_string(p->out, p->nullvalue)
output_c_string
output_c_string
p->out
p
p
out
p->nullvalue
p
p
nullvalue
printf("fprintf(p->out, ' ');\n");
printf("fprintf(p->out, ' ');\n")
printf
printf
"fprintf(p->out, ' ');\n"
fprintf(p->out, "\n");
fprintf(p->out, "\n")
fprintf
fprintf
p->out
p
p
out
"\n"
printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n");
printf("fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n")
printf
printf
"fprintf(p->out,'_9.9s: _s ','output',             strlen30(p->outfile) ? p->outfile : 'stdout');\n"
fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout");
fprintf(p->out,"%9.9s: %s\n","output",            strlen30(p->outfile) ? p->outfile : "stdout")
fprintf
fprintf
p->out
p
p
out
"%9.9s: %s\n"
"output"
strlen30(p->outfile) ? p->outfile : "stdout"
strlen30(p->outfile)
strlen30
strlen30
p->outfile
p
p
outfile
p->outfile
p
p
outfile
"stdout"
printf("fprintf(p->out,'_9.9s: ', 'separator');\n");
printf("fprintf(p->out,'_9.9s: ', 'separator');\n")
printf
printf
"fprintf(p->out,'_9.9s: ', 'separator');\n"
fprintf(p->out,"%9.9s: ", "separator");
fprintf(p->out,"%9.9s: ", "separator")
fprintf
fprintf
p->out
p
p
out
"%9.9s: "
"separator"
printf("output_c_string(p->out, p->separator);\n");
printf("output_c_string(p->out, p->separator);\n")
printf
printf
"output_c_string(p->out, p->separator);\n"
output_c_string(p->out, p->separator);
output_c_string(p->out, p->separator)
output_c_string
output_c_string
p->out
p
p
out
p->separator
p
p
separator
printf("fprintf(p->out, ' ');\n");
printf("fprintf(p->out, ' ');\n")
printf
printf
"fprintf(p->out, ' ');\n"
fprintf(p->out, "\n");
fprintf(p->out, "\n")
fprintf
fprintf
p->out
p
p
out
"\n"
printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n");
printf("fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n")
printf
printf
"fprintf(p->out,'_9.9s: _s ','stats', p->statsOn ? 'on' : 'off');\n"
fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off");
fprintf(p->out,"%9.9s: %s\n","stats", p->statsOn ? "on" : "off")
fprintf
fprintf
p->out
p
p
out
"%9.9s: %s\n"
"stats"
p->statsOn ? "on" : "off"
p->statsOn
p
p
statsOn
"on"
"off"
printf("fprintf(p->out,'_9.9s: ','width');\n");
printf("fprintf(p->out,'_9.9s: ','width');\n")
printf
printf
"fprintf(p->out,'_9.9s: ','width');\n"
fprintf(p->out,"%9.9s: ","width");
fprintf(p->out,"%9.9s: ","width")
fprintf
fprintf
p->out
p
p
out
"%9.9s: "
"width"
for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) {printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }
i=0;
i=0
i
i
0
i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0
i<(int)ArraySize(p->colWidth)
i
i
(int)ArraySize(p->colWidth)
int
int

ArraySize(p->colWidth)
ArraySize
ArraySize
p->colWidth
p
p
colWidth
p->colWidth[i] != 0
p->colWidth[i]
p->colWidth
p
p
colWidth
i
i
0
i++
i
i
{printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");          printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");      fprintf(p->out,"%d ",p->colWidth[i]);    }
printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n");
printf("for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n")
printf
printf
"for(i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++)\n"
printf("fprintf(p->out,'_d ',p->colWidth[i]);\n");
printf("fprintf(p->out,'_d ',p->colWidth[i]);\n")
printf
printf
"fprintf(p->out,'_d ',p->colWidth[i]);\n"
fprintf(p->out,"%d ",p->colWidth[i]);
fprintf(p->out,"%d ",p->colWidth[i])
fprintf
fprintf
p->out
p
p
out
"%d "
p->colWidth[i]
p->colWidth
p
p
colWidth
i
i
printf("fprintf(p->out,' ');\n");
printf("fprintf(p->out,' ');\n")
printf
printf
"fprintf(p->out,' ');\n"
fprintf(p->out,"\n");
fprintf(p->out,"\n")
fprintf
fprintf
p->out
p
p
out
"\n"
if( c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3 ){printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }else  if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1 && nArg<3
c=='s' && strncmp(azArg[0], "stats", n)==0 && nArg>1
c=='s' && strncmp(azArg[0], "stats", n)==0
c=='s'
c
c
's'
strncmp(azArg[0], "stats", n)==0
strncmp(azArg[0], "stats", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"stats"
n
n
0
nArg>1
nArg
nArg
1
nArg<3
nArg
nArg
3
{printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");      printf("p->statsOn = booleanValue(azArg[1]);\n");p->statsOn = booleanValue(azArg[1]);  }
printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n");
printf("if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n")
printf
printf
"if(c=='s' && strncmp(azArg[0], 'stats', n)==0 && nArg>1 && nArg<3)\n"
printf("p->statsOn = booleanValue(azArg[1]);\n");
printf("p->statsOn = booleanValue(azArg[1]);\n")
printf
printf
"p->statsOn = booleanValue(azArg[1]);\n"
p->statsOn = booleanValue(azArg[1]);
p->statsOn = booleanValue(azArg[1])
p->statsOn
p
p
statsOn
booleanValue(azArg[1])
booleanValue
booleanValue
azArg[1]
azArg
azArg
1
if( c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3 ){printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }else  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0 && nArg<3
c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0
c=='t' && n>1
c=='t'
c
c
't'
n>1
n
n
1
strncmp(azArg[0], "tables", n)==0
strncmp(azArg[0], "tables", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"tables"
n
n
0
nArg<3
nArg
nArg
3
{printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");      sqlite3_stmt *pStmt;    printf("char **azResult;\n");    char **azResult;    printf("int nRow, nAlloc;\n");    int nRow, nAlloc;    printf("char *zSql = 0;\n");    char *zSql = 0;    printf("int ii;\n");    int ii;    printf("open_db(p, 0);\n");    open_db(p, 0);    rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");    while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }    sqlite3_finalize(pStmt);    printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);    printf("sqlite3_free(zSql);\n");    sqlite3_free(zSql);    if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}    printf("nRow = nAlloc = 0;\n");nRow = nAlloc = 0;    printf("azResult = 0;\n");azResult = 0;    if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }    while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }    sqlite3_finalize(pStmt);            if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }    for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}    printf("sqlite3_free(azResult);\n");    sqlite3_free(azResult);  }
printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n");
printf("if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n")
printf
printf
"if(c=='t' && n>1 && strncmp(azArg[0], 'tables', n)==0 && nArg<3)\n"
sqlite3_stmt *pStmt;
sqlite3_stmt *pStmt;
sqlite3_stmt
sqlite3_stmt
*pStmt
*
pStmt
printf("char **azResult;\n");
printf("char **azResult;\n")
printf
printf
"char **azResult;\n"
char **azResult;
char **azResult;
char
**azResult
*
*
azResult
printf("int nRow, nAlloc;\n");
printf("int nRow, nAlloc;\n")
printf
printf
"int nRow, nAlloc;\n"
int nRow, nAlloc;
int nRow, nAlloc;
int
nRow
nRow
nAlloc
nAlloc
printf("char *zSql = 0;\n");
printf("char *zSql = 0;\n")
printf
printf
"char *zSql = 0;\n"
char *zSql = 0;
char *zSql = 0;
char
*zSql = 0
*
zSql
= 0
0
printf("int ii;\n");
printf("int ii;\n")
printf
printf
"int ii;\n"
int ii;
int ii;
int
ii
ii
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);
rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0)
rc
rc
sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0)
sqlite3_prepare_v2
sqlite3_prepare_v2
p->db
p
p
db
"PRAGMA database_list"
-1
1
&pStmt
pStmt
pStmt
0
if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}
rc
rc
{printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}
printf("if(rc)\n");
printf("if(rc)\n")
printf
printf
"if(rc)\n"
printf("return rc;\n");
printf("return rc;\n")
printf
printf
"return rc;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return rc;
rc
rc
printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n");
printf("zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n")
printf
printf
"zSql = sqlite3_mprintf(         'SELECT name FROM sqlite_master'         ' WHERE type IN ('table','view')'         '   AND name NOT LIKE 'sqlite___''         '   AND name LIKE ?1');\n"
zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1");
zSql = sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1")
zSql
zSql
sqlite3_mprintf(        "SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1")
sqlite3_mprintf
sqlite3_mprintf
"SELECT name FROM sqlite_master"        " WHERE type IN ('table','view')"        "   AND name NOT LIKE 'sqlite_%%'"        "   AND name LIKE ?1"
while( sqlite3_step(pStmt)==SQLITE_ROW ){      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }
sqlite3_step(pStmt)==SQLITE_ROW
sqlite3_step(pStmt)
sqlite3_step
sqlite3_step
pStmt
pStmt
SQLITE_ROW
SQLITE_ROW
{      const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);      if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;      if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }    }
const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);
const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);
const char
*zDbName = (const char*)sqlite3_column_text(pStmt, 1)
*
zDbName
= (const char*)sqlite3_column_text(pStmt, 1)
(const char*)sqlite3_column_text(pStmt, 1)
const char*
const char
*
*
sqlite3_column_text(pStmt, 1)
sqlite3_column_text
sqlite3_column_text
pStmt
pStmt
1
if( zDbName==0 || strcmp(zDbName,"main")==0 ) continue;
zDbName==0 || strcmp(zDbName,"main")==0
zDbName==0
zDbName
zDbName
0
strcmp(zDbName,"main")==0
strcmp(zDbName,"main")
strcmp
strcmp
zDbName
zDbName
"main"
0
continue;
if( strcmp(zDbName,"temp")==0 ){        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }else{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }
strcmp(zDbName,"temp")==0
strcmp(zDbName,"temp")
strcmp
strcmp
zDbName
zDbName
"temp"
0
{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);      }
zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql);
zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql)
zSql
zSql
sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql)
sqlite3_mprintf
sqlite3_mprintf
"%z UNION ALL "                 "SELECT 'temp.' || name FROM sqlite_temp_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1"
zSql
zSql
{        zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);      }
zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName);
zSql = sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName)
zSql
zSql
sqlite3_mprintf(                 "%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1", zSql, zDbName, zDbName)
sqlite3_mprintf
sqlite3_mprintf
"%z UNION ALL "                 "SELECT '%q.' || name FROM \"%w\".sqlite_master"                 " WHERE type IN ('table','view')"                 "   AND name NOT LIKE 'sqlite_%%'"                 "   AND name LIKE ?1"
zSql
zSql
zDbName
zDbName
zDbName
zDbName
sqlite3_finalize(pStmt);
sqlite3_finalize(pStmt)
sqlite3_finalize
sqlite3_finalize
pStmt
pStmt
printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n");
printf("zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n")
printf
printf
"zSql = sqlite3_mprintf('_z ORDER BY 1', zSql);\n"
zSql = sqlite3_mprintf("%z ORDER BY 1", zSql);
zSql = sqlite3_mprintf("%z ORDER BY 1", zSql)
zSql
zSql
sqlite3_mprintf("%z ORDER BY 1", zSql)
sqlite3_mprintf
sqlite3_mprintf
"%z ORDER BY 1"
zSql
zSql
rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0)
rc
rc
sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0)
sqlite3_prepare_v2
sqlite3_prepare_v2
p->db
p
p
db
zSql
zSql
-1
1
&pStmt
pStmt
pStmt
0
printf("sqlite3_free(zSql);\n");
printf("sqlite3_free(zSql);\n")
printf
printf
"sqlite3_free(zSql);\n"
sqlite3_free(zSql);
sqlite3_free(zSql)
sqlite3_free
sqlite3_free
zSql
zSql
if( rc ) {printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}
rc
rc
{printf("if(rc)\n");    printf("return rc;\n");    printf("------function end!------\n");    return rc;}
printf("if(rc)\n");
printf("if(rc)\n")
printf
printf
"if(rc)\n"
printf("return rc;\n");
printf("return rc;\n")
printf
printf
"return rc;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return rc;
rc
rc
printf("nRow = nAlloc = 0;\n");
printf("nRow = nAlloc = 0;\n")
printf
printf
"nRow = nAlloc = 0;\n"
nRow = nAlloc = 0;
nRow = nAlloc = 0
nRow
nRow
nAlloc = 0
nAlloc
nAlloc
0
printf("azResult = 0;\n");
printf("azResult = 0;\n")
printf
printf
"azResult = 0;\n"
azResult = 0;
azResult = 0
azResult
azResult
0
if( nArg>1 ){printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }else{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }
nArg>1
nArg
nArg
1
{printf("if(nArg>1)\n");          sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);    }
printf("if(nArg>1)\n");
printf("if(nArg>1)\n")
printf
printf
"if(nArg>1)\n"
sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);
sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT)
sqlite3_bind_text
sqlite3_bind_text
pStmt
pStmt
1
azArg[1]
azArg
azArg
1
-1
1
SQLITE_TRANSIENT
SQLITE_TRANSIENT
{      sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);    }
sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);
sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC)
sqlite3_bind_text
sqlite3_bind_text
pStmt
pStmt
1
"%"
-1
1
SQLITE_STATIC
SQLITE_STATIC
while( sqlite3_step(pStmt)==SQLITE_ROW ){      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }
sqlite3_step(pStmt)==SQLITE_ROW
sqlite3_step(pStmt)
sqlite3_step
sqlite3_step
pStmt
pStmt
SQLITE_ROW
SQLITE_ROW
{      if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }      azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));      if( azResult[nRow] ) nRow++;    }
if( nRow>=nAlloc ){        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }
nRow>=nAlloc
nRow
nRow
nAlloc
nAlloc
{        char **azNew;        int n = nAlloc*2 + 10;        azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);        if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }        nAlloc = n;        azResult = azNew;      }
char **azNew;
char **azNew;
char
**azNew
*
*
azNew
int n = nAlloc*2 + 10;
int n = nAlloc*2 + 10;
int
n = nAlloc*2 + 10
n
= nAlloc*2 + 10
nAlloc*2 + 10
nAlloc*2
nAlloc
nAlloc
2
10
azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n);
azNew = sqlite3_realloc(azResult, sizeof(azResult[0])*n)
azNew
azNew
sqlite3_realloc(azResult, sizeof(azResult[0])*n)
sqlite3_realloc
sqlite3_realloc
azResult
azResult
sizeof(azResult[0])*n
sizeof(azResult[0])
(azResult[0])
azResult[0]
azResult
azResult
0
n
n
if( azNew==0 ){          fprintf(stderr, "Error: out of memory\n");          break;        }
azNew==0
azNew
azNew
0
{          fprintf(stderr, "Error: out of memory\n");          break;        }
fprintf(stderr, "Error: out of memory\n");
fprintf(stderr, "Error: out of memory\n")
fprintf
fprintf
stderr
stderr
"Error: out of memory\n"
break;
nAlloc = n;
nAlloc = n
nAlloc
nAlloc
n
n
azResult = azNew;
azResult = azNew
azResult
azResult
azNew
azNew
azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));
azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0))
azResult[nRow]
azResult
azResult
nRow
nRow
sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0))
sqlite3_mprintf
sqlite3_mprintf
"%s"
sqlite3_column_text(pStmt, 0)
sqlite3_column_text
sqlite3_column_text
pStmt
pStmt
0
if( azResult[nRow] ) nRow++;
azResult[nRow]
azResult
azResult
nRow
nRow
nRow++;
nRow++
nRow
nRow
sqlite3_finalize(pStmt);
sqlite3_finalize(pStmt)
sqlite3_finalize
sqlite3_finalize
pStmt
pStmt
if( nRow>0 ){printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }
nRow>0
nRow
nRow
0
{printf("if(nRow>0)\n");          printf("int len, maxlen = 0;\n");      int len, maxlen = 0;      printf("int i, j;\n");      int i, j;      printf("int nPrintCol, nPrintRow;\n");      int nPrintCol, nPrintRow;      for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }      printf("nPrintCol = 80/(maxlen+2);\n");nPrintCol = 80/(maxlen+2);      if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}      printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;      for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }    }
printf("if(nRow>0)\n");
printf("if(nRow>0)\n")
printf
printf
"if(nRow>0)\n"
printf("int len, maxlen = 0;\n");
printf("int len, maxlen = 0;\n")
printf
printf
"int len, maxlen = 0;\n"
int len, maxlen = 0;
int len, maxlen = 0;
int
len
len
maxlen = 0
maxlen
= 0
0
printf("int i, j;\n");
printf("int i, j;\n")
printf
printf
"int i, j;\n"
int i, j;
int i, j;
int
i
i
j
j
printf("int nPrintCol, nPrintRow;\n");
printf("int nPrintCol, nPrintRow;\n")
printf
printf
"int nPrintCol, nPrintRow;\n"
int nPrintCol, nPrintRow;
int nPrintCol, nPrintRow;
int
nPrintCol
nPrintCol
nPrintRow
nPrintRow
for(i=0; i<nRow; i++){printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }
i=0;
i=0
i
i
0
i<nRow
i
i
nRow
nRow
i++
i
i
{printf("for(i=0;i<nRow;i++)\n");              printf("len = strlen30(azResult[i]);\n");len = strlen30(azResult[i]);        if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}      }
printf("for(i=0;i<nRow;i++)\n");
printf("for(i=0;i<nRow;i++)\n")
printf
printf
"for(i=0;i<nRow;i++)\n"
printf("len = strlen30(azResult[i]);\n");
printf("len = strlen30(azResult[i]);\n")
printf
printf
"len = strlen30(azResult[i]);\n"
len = strlen30(azResult[i]);
len = strlen30(azResult[i])
len
len
strlen30(azResult[i])
strlen30
strlen30
azResult[i]
azResult
azResult
i
i
if( len>maxlen ) {printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}
len>maxlen
len
len
maxlen
maxlen
{printf("if(len>maxlen)\n");        printf("maxlen = len;\n");maxlen = len;}
printf("if(len>maxlen)\n");
printf("if(len>maxlen)\n")
printf
printf
"if(len>maxlen)\n"
printf("maxlen = len;\n");
printf("maxlen = len;\n")
printf
printf
"maxlen = len;\n"
maxlen = len;
maxlen = len
maxlen
maxlen
len
len
printf("nPrintCol = 80/(maxlen+2);\n");
printf("nPrintCol = 80/(maxlen+2);\n")
printf
printf
"nPrintCol = 80/(maxlen+2);\n"
nPrintCol = 80/(maxlen+2);
nPrintCol = 80/(maxlen+2)
nPrintCol
nPrintCol
80/(maxlen+2)
80
(maxlen+2)
maxlen+2
maxlen
maxlen
2
if( nPrintCol<1 ) {printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}
nPrintCol<1
nPrintCol
nPrintCol
1
{printf("if(nPrintCol<1)\n");      printf("nPrintCol = 1;\n");nPrintCol = 1;}
printf("if(nPrintCol<1)\n");
printf("if(nPrintCol<1)\n")
printf
printf
"if(nPrintCol<1)\n"
printf("nPrintCol = 1;\n");
printf("nPrintCol = 1;\n")
printf
printf
"nPrintCol = 1;\n"
nPrintCol = 1;
nPrintCol = 1
nPrintCol
nPrintCol
1
printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n");
printf("nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n")
printf
printf
"nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\n"
nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;
nPrintRow = (nRow + nPrintCol - 1)/nPrintCol
nPrintRow
nPrintRow
(nRow + nPrintCol - 1)/nPrintCol
(nRow + nPrintCol - 1)
nRow + nPrintCol - 1
nRow + nPrintCol
nRow
nRow
nPrintCol
nPrintCol
1
nPrintCol
nPrintCol
for(i=0; i<nPrintRow; i++){printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }
i=0;
i=0
i
i
0
i<nPrintRow
i
i
nPrintRow
nPrintRow
i++
i
i
{printf("for(i=0;i<nPrintRow;i++)\n");              for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }        printf("fprintf(p->out, ' ');\n");        fprintf(p->out, "\n");      }
printf("for(i=0;i<nPrintRow;i++)\n");
printf("for(i=0;i<nPrintRow;i++)\n")
printf
printf
"for(i=0;i<nPrintRow;i++)\n"
for(j=i; j<nRow; j+=nPrintRow){printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }
j=i;
j=i
j
j
i
i
j<nRow
j
j
nRow
nRow
j+=nPrintRow
j
j
nPrintRow
nPrintRow
{printf("for(j=i;j<nRow;j+=nPrintRow)\n");                  printf("char *zSp = j<nPrintRow ? '' : '  ';\n");          char *zSp = j<nPrintRow ? "" : "  ";          printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");          fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");        }
printf("for(j=i;j<nRow;j+=nPrintRow)\n");
printf("for(j=i;j<nRow;j+=nPrintRow)\n")
printf
printf
"for(j=i;j<nRow;j+=nPrintRow)\n"
printf("char *zSp = j<nPrintRow ? '' : '  ';\n");
printf("char *zSp = j<nPrintRow ? '' : '  ';\n")
printf
printf
"char *zSp = j<nPrintRow ? '' : '  ';\n"
char *zSp = j<nPrintRow ? "" : "  ";
char *zSp = j<nPrintRow ? "" : "  ";
char
*zSp = j<nPrintRow ? "" : "  "
*
zSp
= j<nPrintRow ? "" : "  "
j<nPrintRow ? "" : "  "
j<nPrintRow
j
j
nPrintRow
nPrintRow
""
"  "
printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n");
printf("fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n")
printf
printf
"fprintf(p->out, '_s_-*s', zSp, maxlen, azResult[j] ? azResult[j] : '');\n"
fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "");
fprintf(p->out, "%s%-*s", zSp, maxlen, azResult[j] ? azResult[j] : "")
fprintf
fprintf
p->out
p
p
out
"%s%-*s"
zSp
zSp
maxlen
maxlen
azResult[j] ? azResult[j] : ""
azResult[j]
azResult
azResult
j
j
azResult[j]
azResult
azResult
j
j
""
printf("fprintf(p->out, ' ');\n");
printf("fprintf(p->out, ' ');\n")
printf
printf
"fprintf(p->out, ' ');\n"
fprintf(p->out, "\n");
fprintf(p->out, "\n")
fprintf
fprintf
p->out
p
p
out
"\n"
for(ii=0; ii<nRow; ii++) {printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}
ii=0;
ii=0
ii
ii
0
ii<nRow
ii
ii
nRow
nRow
ii++
ii
ii
{printf("for(ii=0;ii<nRow;ii++)\n");    printf("sqlite3_free(azResult[ii]);\n");    sqlite3_free(azResult[ii]);}
printf("for(ii=0;ii<nRow;ii++)\n");
printf("for(ii=0;ii<nRow;ii++)\n")
printf
printf
"for(ii=0;ii<nRow;ii++)\n"
printf("sqlite3_free(azResult[ii]);\n");
printf("sqlite3_free(azResult[ii]);\n")
printf
printf
"sqlite3_free(azResult[ii]);\n"
sqlite3_free(azResult[ii]);
sqlite3_free(azResult[ii])
sqlite3_free
sqlite3_free
azResult[ii]
azResult
azResult
ii
ii
printf("sqlite3_free(azResult);\n");
printf("sqlite3_free(azResult);\n")
printf
printf
"sqlite3_free(azResult);\n"
sqlite3_free(azResult);
sqlite3_free(azResult)
sqlite3_free
sqlite3_free
azResult
azResult
if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2 ){printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }else  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 && nArg>=2
c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0
c=='t' && n>=8
c=='t'
c
c
't'
n>=8
n
n
8
strncmp(azArg[0], "testctrl", n)==0
strncmp(azArg[0], "testctrl", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"testctrl"
n
n
0
nArg>=2
nArg
nArg
2
{printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");      printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");    static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };    printf("int testctrl = -1;\n");    int testctrl = -1;    printf("int rc = 0;\n");    int rc = 0;    printf("int i, n;\n");    int i, n;    printf("open_db(p, 0);\n");    open_db(p, 0);    /* convert testctrl text option to value. allow any unique prefix    ** of the option name, or a numerical value. */    printf("n = strlen30(azArg[1]);\n");n = strlen30(azArg[1]);    for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }    if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);    if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }  }
printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n");
printf("if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n")
printf
printf
"if(c=='t' && n>=8 && strncmp(azArg[0], 'testctrl', n)==0 && nArg>=2)\n"
printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n");
printf("static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n")
printf
printf
"static const struct {        const char *zCtrlName;   /* Name of a test-control option */        int ctrlCode;            /* Integer code for that option */     } aCtrl[] = {       { 'prng_save',             SQLITE_TESTCTRL_PRNG_SAVE              },       { 'prng_restore',          SQLITE_TESTCTRL_PRNG_RESTORE           },       { 'prng_reset',            SQLITE_TESTCTRL_PRNG_RESET             },       { 'bitvec_test',           SQLITE_TESTCTRL_BITVEC_TEST            },       { 'fault_install',         SQLITE_TESTCTRL_FAULT_INSTALL          },       { 'benign_malloc_hooks',   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },       { 'pending_byte',          SQLITE_TESTCTRL_PENDING_BYTE           },       { 'assert',                SQLITE_TESTCTRL_ASSERT                 },       { 'always',                SQLITE_TESTCTRL_ALWAYS                 },       { 'reserve',               SQLITE_TESTCTRL_RESERVE                },       { 'optimizations',         SQLITE_TESTCTRL_OPTIMIZATIONS          },       { 'iskeyword',             SQLITE_TESTCTRL_ISKEYWORD              },       { 'scratchmalloc',         SQLITE_TESTCTRL_SCRATCHMALLOC          },     };\n"
static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };
static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    } aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    };
static const struct {       const char *zCtrlName;   /* Name of a test-control option */       int ctrlCode;            /* Integer code for that option */    }

const char *zCtrlName;
const char
*zCtrlName
*
zCtrlName
int ctrlCode;
int
ctrlCode
ctrlCode
aCtrl[] = {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    }
aCtrl
[]
= {      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    }
{      { "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              },      { "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           },      { "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             },      { "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            },      { "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          },      { "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    },      { "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           },      { "assert",                SQLITE_TESTCTRL_ASSERT                 },      { "always",                SQLITE_TESTCTRL_ALWAYS                 },      { "reserve",               SQLITE_TESTCTRL_RESERVE                },      { "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          },      { "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              },      { "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          },    }
{ "prng_save",             SQLITE_TESTCTRL_PRNG_SAVE              }
"prng_save"
SQLITE_TESTCTRL_PRNG_SAVE
SQLITE_TESTCTRL_PRNG_SAVE
{ "prng_restore",          SQLITE_TESTCTRL_PRNG_RESTORE           }
"prng_restore"
SQLITE_TESTCTRL_PRNG_RESTORE
SQLITE_TESTCTRL_PRNG_RESTORE
{ "prng_reset",            SQLITE_TESTCTRL_PRNG_RESET             }
"prng_reset"
SQLITE_TESTCTRL_PRNG_RESET
SQLITE_TESTCTRL_PRNG_RESET
{ "bitvec_test",           SQLITE_TESTCTRL_BITVEC_TEST            }
"bitvec_test"
SQLITE_TESTCTRL_BITVEC_TEST
SQLITE_TESTCTRL_BITVEC_TEST
{ "fault_install",         SQLITE_TESTCTRL_FAULT_INSTALL          }
"fault_install"
SQLITE_TESTCTRL_FAULT_INSTALL
SQLITE_TESTCTRL_FAULT_INSTALL
{ "benign_malloc_hooks",   SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS    }
"benign_malloc_hooks"
SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
{ "pending_byte",          SQLITE_TESTCTRL_PENDING_BYTE           }
"pending_byte"
SQLITE_TESTCTRL_PENDING_BYTE
SQLITE_TESTCTRL_PENDING_BYTE
{ "assert",                SQLITE_TESTCTRL_ASSERT                 }
"assert"
SQLITE_TESTCTRL_ASSERT
SQLITE_TESTCTRL_ASSERT
{ "always",                SQLITE_TESTCTRL_ALWAYS                 }
"always"
SQLITE_TESTCTRL_ALWAYS
SQLITE_TESTCTRL_ALWAYS
{ "reserve",               SQLITE_TESTCTRL_RESERVE                }
"reserve"
SQLITE_TESTCTRL_RESERVE
SQLITE_TESTCTRL_RESERVE
{ "optimizations",         SQLITE_TESTCTRL_OPTIMIZATIONS          }
"optimizations"
SQLITE_TESTCTRL_OPTIMIZATIONS
SQLITE_TESTCTRL_OPTIMIZATIONS
{ "iskeyword",             SQLITE_TESTCTRL_ISKEYWORD              }
"iskeyword"
SQLITE_TESTCTRL_ISKEYWORD
SQLITE_TESTCTRL_ISKEYWORD
{ "scratchmalloc",         SQLITE_TESTCTRL_SCRATCHMALLOC          }
"scratchmalloc"
SQLITE_TESTCTRL_SCRATCHMALLOC
SQLITE_TESTCTRL_SCRATCHMALLOC
printf("int testctrl = -1;\n");
printf("int testctrl = -1;\n")
printf
printf
"int testctrl = -1;\n"
int testctrl = -1;
int testctrl = -1;
int
testctrl = -1
testctrl
= -1
-1
1
printf("int rc = 0;\n");
printf("int rc = 0;\n")
printf
printf
"int rc = 0;\n"
int rc = 0;
int rc = 0;
int
rc = 0
rc
= 0
0
printf("int i, n;\n");
printf("int i, n;\n")
printf
printf
"int i, n;\n"
int i, n;
int i, n;
int
i
i
n
n
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("n = strlen30(azArg[1]);\n");
printf("n = strlen30(azArg[1]);\n")
printf
printf
"n = strlen30(azArg[1]);\n"
n = strlen30(azArg[1]);
n = strlen30(azArg[1])
n
n
strlen30(azArg[1])
strlen30
strlen30
azArg[1]
azArg
azArg
1
for(i=0; i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0])); i++){      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }
i=0;
i=0
i
i
0
i<(int)(sizeof(aCtrl)/sizeof(aCtrl[0]))
i
i
(int)(sizeof(aCtrl)/sizeof(aCtrl[0]))
int
int

(sizeof(aCtrl)/sizeof(aCtrl[0]))
sizeof(aCtrl)/sizeof(aCtrl[0])
sizeof(aCtrl)
(aCtrl)
aCtrl
aCtrl
sizeof(aCtrl[0])
(aCtrl[0])
aCtrl[0]
aCtrl
aCtrl
0
i++
i
i
{      if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }    }
if( strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0 ){        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }
strncmp(azArg[1], aCtrl[i].zCtrlName, n)==0
strncmp(azArg[1], aCtrl[i].zCtrlName, n)
strncmp
strncmp
azArg[1]
azArg
azArg
1
aCtrl[i].zCtrlName
aCtrl[i]
aCtrl
aCtrl
i
i
zCtrlName
n
n
0
{        if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }      }
if( testctrl<0 ){          testctrl = aCtrl[i].ctrlCode;        }else{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }
testctrl<0
testctrl
testctrl
0
{          testctrl = aCtrl[i].ctrlCode;        }
testctrl = aCtrl[i].ctrlCode;
testctrl = aCtrl[i].ctrlCode
testctrl
testctrl
aCtrl[i].ctrlCode
aCtrl[i]
aCtrl
aCtrl
i
i
ctrlCode
{          fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);          testctrl = -1;          break;        }
fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1]);
fprintf(stderr, "ambiguous option name: \"%s\"\n", azArg[1])
fprintf
fprintf
stderr
stderr
"ambiguous option name: \"%s\"\n"
azArg[1]
azArg
azArg
1
testctrl = -1;
testctrl = -1
testctrl
testctrl
-1
1
break;
if( testctrl<0 ) testctrl = (int)integerValue(azArg[1]);
testctrl<0
testctrl
testctrl
0
testctrl = (int)integerValue(azArg[1]);
testctrl = (int)integerValue(azArg[1])
testctrl
testctrl
(int)integerValue(azArg[1])
int
int

integerValue(azArg[1])
integerValue
integerValue
azArg[1]
azArg
azArg
1
if( (testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST) ){printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }else{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }
(testctrl<SQLITE_TESTCTRL_FIRST) || (testctrl>SQLITE_TESTCTRL_LAST)
(testctrl<SQLITE_TESTCTRL_FIRST)
testctrl<SQLITE_TESTCTRL_FIRST
testctrl
testctrl
SQLITE_TESTCTRL_FIRST
SQLITE_TESTCTRL_FIRST
(testctrl>SQLITE_TESTCTRL_LAST)
testctrl>SQLITE_TESTCTRL_LAST
testctrl
testctrl
SQLITE_TESTCTRL_LAST
SQLITE_TESTCTRL_LAST
{printf("if()\n");          printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");      fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n");
printf("fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n")
printf
printf
"fprintf(stderr,'Error: invalid testctrl option: _s ', azArg[1]);\n"
fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1]);
fprintf(stderr,"Error: invalid testctrl option: %s\n", azArg[1])
fprintf
fprintf
stderr
stderr
"Error: invalid testctrl option: %s\n"
azArg[1]
azArg
azArg
1
{      printf("switch(testctrl)\n");      switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }    }
printf("switch(testctrl)\n");
printf("switch(testctrl)\n")
printf
printf
"switch(testctrl)\n"
switch(testctrl){        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }
testctrl
testctrl
{        /* sqlite3_test_control(int, db, int) */        case SQLITE_TESTCTRL_OPTIMIZATIONS:        case SQLITE_TESTCTRL_RESERVE:                       if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }          break;        /* sqlite3_test_control(int) */        case SQLITE_TESTCTRL_PRNG_SAVE:                   case SQLITE_TESTCTRL_PRNG_RESTORE:                case SQLITE_TESTCTRL_PRNG_RESET:          if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }          break;        /* sqlite3_test_control(int, uint) */        case SQLITE_TESTCTRL_PENDING_BYTE:                  if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }          break;                  /* sqlite3_test_control(int, int) */        case SQLITE_TESTCTRL_ASSERT:                      case SQLITE_TESTCTRL_ALWAYS:                        if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }          break;        /* sqlite3_test_control(int, char *) */#ifdef SQLITE_N_KEYWORD        case SQLITE_TESTCTRL_ISKEYWORD:                     if( nArg==3 ){            const char *opt = azArg[2];                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single char * option\n",                            azArg[1]);          }          break;#endif        case SQLITE_TESTCTRL_BITVEC_TEST:                 case SQLITE_TESTCTRL_FAULT_INSTALL:               case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:         case SQLITE_TESTCTRL_SCRATCHMALLOC:               default:          fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);          break;      }
case SQLITE_TESTCTRL_OPTIMIZATIONS:
SQLITE_TESTCTRL_OPTIMIZATIONS
SQLITE_TESTCTRL_OPTIMIZATIONS
case SQLITE_TESTCTRL_RESERVE:
SQLITE_TESTCTRL_RESERVE
SQLITE_TESTCTRL_RESERVE
if( nArg==3 ){            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }
nArg==3
nArg
nArg
3
{            int opt = (int)strtol(azArg[2], 0, 0);                    rc = sqlite3_test_control(testctrl, p->db, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          }
int opt = (int)strtol(azArg[2], 0, 0);
int opt = (int)strtol(azArg[2], 0, 0);
int
opt = (int)strtol(azArg[2], 0, 0)
opt
= (int)strtol(azArg[2], 0, 0)
(int)strtol(azArg[2], 0, 0)
int
int

strtol(azArg[2], 0, 0)
strtol
strtol
azArg[2]
azArg
azArg
2
0
0
rc = sqlite3_test_control(testctrl, p->db, opt);
rc = sqlite3_test_control(testctrl, p->db, opt)
rc
rc
sqlite3_test_control(testctrl, p->db, opt)
sqlite3_test_control
sqlite3_test_control
testctrl
testctrl
p->db
p
p
db
opt
opt
fprintf(p->out, "%d (0x%08x)\n", rc, rc);
fprintf(p->out, "%d (0x%08x)\n", rc, rc)
fprintf
fprintf
p->out
p
p
out
"%d (0x%08x)\n"
rc
rc
rc
rc
{            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);          }
fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1]);
fprintf(stderr,"Error: testctrl %s takes a single int option\n",                    azArg[1])
fprintf
fprintf
stderr
stderr
"Error: testctrl %s takes a single int option\n"
azArg[1]
azArg
azArg
1
break;
case SQLITE_TESTCTRL_PRNG_SAVE:
SQLITE_TESTCTRL_PRNG_SAVE
SQLITE_TESTCTRL_PRNG_SAVE
case SQLITE_TESTCTRL_PRNG_RESTORE:
SQLITE_TESTCTRL_PRNG_RESTORE
SQLITE_TESTCTRL_PRNG_RESTORE
case SQLITE_TESTCTRL_PRNG_RESET:
SQLITE_TESTCTRL_PRNG_RESET
SQLITE_TESTCTRL_PRNG_RESET
if( nArg==2 ){            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }
nArg==2
nArg
nArg
2
{            rc = sqlite3_test_control(testctrl);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          }
rc = sqlite3_test_control(testctrl);
rc = sqlite3_test_control(testctrl)
rc
rc
sqlite3_test_control(testctrl)
sqlite3_test_control
sqlite3_test_control
testctrl
testctrl
fprintf(p->out, "%d (0x%08x)\n", rc, rc);
fprintf(p->out, "%d (0x%08x)\n", rc, rc)
fprintf
fprintf
p->out
p
p
out
"%d (0x%08x)\n"
rc
rc
rc
rc
{            fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);          }
fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1]);
fprintf(stderr,"Error: testctrl %s takes no options\n", azArg[1])
fprintf
fprintf
stderr
stderr
"Error: testctrl %s takes no options\n"
azArg[1]
azArg
azArg
1
break;
case SQLITE_TESTCTRL_PENDING_BYTE:
SQLITE_TESTCTRL_PENDING_BYTE
SQLITE_TESTCTRL_PENDING_BYTE
if( nArg==3 ){            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }
nArg==3
nArg
nArg
3
{            unsigned int opt = (unsigned int)integerValue(azArg[2]);            rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          }
unsigned int opt = (unsigned int)integerValue(azArg[2]);
unsigned int opt = (unsigned int)integerValue(azArg[2]);
unsigned int
opt = (unsigned int)integerValue(azArg[2])
opt
= (unsigned int)integerValue(azArg[2])
(unsigned int)integerValue(azArg[2])
unsigned int
unsigned int

integerValue(azArg[2])
integerValue
integerValue
azArg[2]
azArg
azArg
2
rc = sqlite3_test_control(testctrl, opt);
rc = sqlite3_test_control(testctrl, opt)
rc
rc
sqlite3_test_control(testctrl, opt)
sqlite3_test_control
sqlite3_test_control
testctrl
testctrl
opt
opt
fprintf(p->out, "%d (0x%08x)\n", rc, rc);
fprintf(p->out, "%d (0x%08x)\n", rc, rc)
fprintf
fprintf
p->out
p
p
out
"%d (0x%08x)\n"
rc
rc
rc
rc
{            fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);          }
fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1]);
fprintf(stderr,"Error: testctrl %s takes a single unsigned"                           " int option\n", azArg[1])
fprintf
fprintf
stderr
stderr
"Error: testctrl %s takes a single unsigned"                           " int option\n"
azArg[1]
azArg
azArg
1
break;
case SQLITE_TESTCTRL_ASSERT:
SQLITE_TESTCTRL_ASSERT
SQLITE_TESTCTRL_ASSERT
case SQLITE_TESTCTRL_ALWAYS:
SQLITE_TESTCTRL_ALWAYS
SQLITE_TESTCTRL_ALWAYS
if( nArg==3 ){            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          } else {            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }
nArg==3
nArg
nArg
3
{            int opt = booleanValue(azArg[2]);                    rc = sqlite3_test_control(testctrl, opt);            fprintf(p->out, "%d (0x%08x)\n", rc, rc);          }
int opt = booleanValue(azArg[2]);
int opt = booleanValue(azArg[2]);
int
opt = booleanValue(azArg[2])
opt
= booleanValue(azArg[2])
booleanValue(azArg[2])
booleanValue
booleanValue
azArg[2]
azArg
azArg
2
rc = sqlite3_test_control(testctrl, opt);
rc = sqlite3_test_control(testctrl, opt)
rc
rc
sqlite3_test_control(testctrl, opt)
sqlite3_test_control
sqlite3_test_control
testctrl
testctrl
opt
opt
fprintf(p->out, "%d (0x%08x)\n", rc, rc);
fprintf(p->out, "%d (0x%08x)\n", rc, rc)
fprintf
fprintf
p->out
p
p
out
"%d (0x%08x)\n"
rc
rc
rc
rc
{            fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);          }
fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1]);
fprintf(stderr,"Error: testctrl %s takes a single int option\n",                            azArg[1])
fprintf
fprintf
stderr
stderr
"Error: testctrl %s takes a single int option\n"
azArg[1]
azArg
azArg
1
break;
case SQLITE_TESTCTRL_BITVEC_TEST:
SQLITE_TESTCTRL_BITVEC_TEST
SQLITE_TESTCTRL_BITVEC_TEST
case SQLITE_TESTCTRL_FAULT_INSTALL:
SQLITE_TESTCTRL_FAULT_INSTALL
SQLITE_TESTCTRL_FAULT_INSTALL
case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:
SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS
case SQLITE_TESTCTRL_SCRATCHMALLOC:
SQLITE_TESTCTRL_SCRATCHMALLOC
SQLITE_TESTCTRL_SCRATCHMALLOC
default:
fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1]);
fprintf(stderr,"Error: CLI support for testctrl %s not implemented\n",                  azArg[1])
fprintf
fprintf
stderr
stderr
"Error: CLI support for testctrl %s not implemented\n"
azArg[1]
azArg
azArg
1
break;
if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2 ){printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }else      if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 && nArg==2
c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0
c=='t' && n>4
c=='t'
c
c
't'
n>4
n
n
4
strncmp(azArg[0], "timeout", n)==0
strncmp(azArg[0], "timeout", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"timeout"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));  }
printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n");
printf("if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n")
printf
printf
"if(c=='t' && n>4 && strncmp(azArg[0], 'timeout', n)==0 && nArg==2)\n"
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]));
sqlite3_busy_timeout(p->db, (int)integerValue(azArg[1]))
sqlite3_busy_timeout
sqlite3_busy_timeout
p->db
p
p
db
(int)integerValue(azArg[1])
int
int

integerValue(azArg[1])
integerValue
integerValue
azArg[1]
azArg
azArg
1
if( HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2  ){printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }else    if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0   && nArg==2
HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0
HAS_TIMER && c=='t' && n>=5
HAS_TIMER && c=='t'
HAS_TIMER
HAS_TIMER
c=='t'
c
c
't'
n>=5
n
n
5
strncmp(azArg[0], "timer", n)==0
strncmp(azArg[0], "timer", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"timer"
n
n
0
nArg==2
nArg
nArg
2
{printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");      printf("enableTimer = booleanValue(azArg[1]);\n");enableTimer = booleanValue(azArg[1]);  }
printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n");
printf("if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n")
printf
printf
"if(HAS_TIMER && c=='t' && n>=5 && strncmp(azArg[0], 'timer', n)==0    && nArg==2)\n"
printf("enableTimer = booleanValue(azArg[1]);\n");
printf("enableTimer = booleanValue(azArg[1]);\n")
printf
printf
"enableTimer = booleanValue(azArg[1]);\n"
enableTimer = booleanValue(azArg[1]);
enableTimer = booleanValue(azArg[1])
enableTimer
enableTimer
booleanValue(azArg[1])
booleanValue
booleanValue
azArg[1]
azArg
azArg
1
if( c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1 ){printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }else  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='t' && strncmp(azArg[0], "trace", n)==0 && nArg>1
c=='t' && strncmp(azArg[0], "trace", n)==0
c=='t'
c
c
't'
strncmp(azArg[0], "trace", n)==0
strncmp(azArg[0], "trace", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"trace"
n
n
0
nArg>1
nArg
nArg
1
{printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");      printf("open_db(p, 0);\n");    open_db(p, 0);    printf("output_file_close(p->traceOut);\n");    output_file_close(p->traceOut);    printf("p->traceOut = output_file_open(azArg[1]);\n");p->traceOut = output_file_open(azArg[1]);#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)    if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }#endif  }
printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n");
printf("if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n")
printf
printf
"if(c=='t' && strncmp(azArg[0], 'trace', n)==0 && nArg>1)\n"
printf("open_db(p, 0);\n");
printf("open_db(p, 0);\n")
printf
printf
"open_db(p, 0);\n"
open_db(p, 0);
open_db(p, 0)
open_db
open_db
p
p
0
printf("output_file_close(p->traceOut);\n");
printf("output_file_close(p->traceOut);\n")
printf
printf
"output_file_close(p->traceOut);\n"
output_file_close(p->traceOut);
output_file_close(p->traceOut)
output_file_close
output_file_close
p->traceOut
p
p
traceOut
printf("p->traceOut = output_file_open(azArg[1]);\n");
printf("p->traceOut = output_file_open(azArg[1]);\n")
printf
printf
"p->traceOut = output_file_open(azArg[1]);\n"
p->traceOut = output_file_open(azArg[1]);
p->traceOut = output_file_open(azArg[1])
p->traceOut
p
p
traceOut
output_file_open(azArg[1])
output_file_open
output_file_open
azArg[1]
azArg
azArg
1
if( p->traceOut==0 ){printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }else{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }
p->traceOut==0
p->traceOut
p
p
traceOut
0
{printf("if(p->traceOut==0)\n");          sqlite3_trace(p->db, 0, 0);    }
printf("if(p->traceOut==0)\n");
printf("if(p->traceOut==0)\n")
printf
printf
"if(p->traceOut==0)\n"
sqlite3_trace(p->db, 0, 0);
sqlite3_trace(p->db, 0, 0)
sqlite3_trace
sqlite3_trace
p->db
p
p
db
0
0
{      sqlite3_trace(p->db, sql_trace_callback, p->traceOut);    }
sqlite3_trace(p->db, sql_trace_callback, p->traceOut);
sqlite3_trace(p->db, sql_trace_callback, p->traceOut)
sqlite3_trace
sqlite3_trace
p->db
p
p
db
sql_trace_callback
sql_trace_callback
p->traceOut
p
p
traceOut
if( c=='v' && strncmp(azArg[0], "version", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }else  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='v' && strncmp(azArg[0], "version", n)==0
c=='v'
c
c
'v'
strncmp(azArg[0], "version", n)==0
strncmp(azArg[0], "version", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"version"
n
n
0
{printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");      printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");    fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());  }
printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n");
printf("if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n")
printf
printf
"if(c=='v' && strncmp(azArg[0], 'version', n)==0)\n"
printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n");
printf("fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n")
printf
printf
"fprintf(p->out, 'SQLite _s _s ' /*extra-version-info*/,         sqlite3_libversion(), sqlite3_sourceid());\n"
fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid());
fprintf(p->out, "SQLite %s %s\n" /*extra-version-info*/,        sqlite3_libversion(), sqlite3_sourceid())
fprintf
fprintf
p->out
p
p
out
"SQLite %s %s\n"
sqlite3_libversion()
sqlite3_libversion
sqlite3_libversion
sqlite3_sourceid()
sqlite3_sourceid
sqlite3_sourceid
if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }else#if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){    extern int sqlite3WhereTrace;    sqlite3WhereTrace = booleanValue(azArg[1]);  }else#endif  if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='v' && strncmp(azArg[0], "vfsname", n)==0
c=='v'
c
c
'v'
strncmp(azArg[0], "vfsname", n)==0
strncmp(azArg[0], "vfsname", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"vfsname"
n
n
0
{printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");      printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");    const char *zDbName = nArg==2 ? azArg[1] : "main";    printf("char *zVfsName = 0;\n");    char *zVfsName = 0;    if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }  }
printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n");
printf("if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n")
printf
printf
"if(c=='v' && strncmp(azArg[0], 'vfsname', n)==0)\n"
printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n");
printf("const char *zDbName = nArg==2 ? azArg[1] : 'main';\n")
printf
printf
"const char *zDbName = nArg==2 ? azArg[1] : 'main';\n"
const char *zDbName = nArg==2 ? azArg[1] : "main";
const char *zDbName = nArg==2 ? azArg[1] : "main";
const char
*zDbName = nArg==2 ? azArg[1] : "main"
*
zDbName
= nArg==2 ? azArg[1] : "main"
nArg==2 ? azArg[1] : "main"
nArg==2
nArg
nArg
2
azArg[1]
azArg
azArg
1
"main"
printf("char *zVfsName = 0;\n");
printf("char *zVfsName = 0;\n")
printf
printf
"char *zVfsName = 0;\n"
char *zVfsName = 0;
char *zVfsName = 0;
char
*zVfsName = 0
*
zVfsName
= 0
0
if( p->db ){printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }
p->db
p
p
db
{printf("if()\n");          sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);      if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }    }
printf("if()\n");
printf("if()\n")
printf
printf
"if()\n"
sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);
sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName)
sqlite3_file_control
sqlite3_file_control
p->db
p
p
db
zDbName
zDbName
SQLITE_FCNTL_VFSNAME
SQLITE_FCNTL_VFSNAME
&zVfsName
zVfsName
zVfsName
if( zVfsName ){printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }
zVfsName
zVfsName
{printf("if(zVfsName)\n");              printf("fprintf(p->out, '_s ', zVfsName);\n");        fprintf(p->out, "%s\n", zVfsName);        printf("sqlite3_free(zVfsName);\n");        sqlite3_free(zVfsName);      }
printf("if(zVfsName)\n");
printf("if(zVfsName)\n")
printf
printf
"if(zVfsName)\n"
printf("fprintf(p->out, '_s ', zVfsName);\n");
printf("fprintf(p->out, '_s ', zVfsName);\n")
printf
printf
"fprintf(p->out, '_s ', zVfsName);\n"
fprintf(p->out, "%s\n", zVfsName);
fprintf(p->out, "%s\n", zVfsName)
fprintf
fprintf
p->out
p
p
out
"%s\n"
zVfsName
zVfsName
printf("sqlite3_free(zVfsName);\n");
printf("sqlite3_free(zVfsName);\n")
printf
printf
"sqlite3_free(zVfsName);\n"
sqlite3_free(zVfsName);
sqlite3_free(zVfsName)
sqlite3_free
sqlite3_free
zVfsName
zVfsName
if( c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1 ){printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }else  {    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
c=='w' && strncmp(azArg[0], "width", n)==0 && nArg>1
c=='w' && strncmp(azArg[0], "width", n)==0
c=='w'
c
c
'w'
strncmp(azArg[0], "width", n)==0
strncmp(azArg[0], "width", n)
strncmp
strncmp
azArg[0]
azArg
azArg
0
"width"
n
n
0
nArg>1
nArg
nArg
1
{printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");      printf("int j;\n");    int j;    printf("assert( nArg<=ArraySize(azArg) );\n");    assert( nArg<=ArraySize(azArg) );    for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }  }
printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n");
printf("if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n")
printf
printf
"if(c=='w' && strncmp(azArg[0], 'width', n)==0 && nArg>1)\n"
printf("int j;\n");
printf("int j;\n")
printf
printf
"int j;\n"
int j;
int j;
int
j
j
printf("assert( nArg<=ArraySize(azArg) );\n");
printf("assert( nArg<=ArraySize(azArg) );\n")
printf
printf
"assert( nArg<=ArraySize(azArg) );\n"
assert( nArg<=ArraySize(azArg) );
assert( nArg<=ArraySize(azArg) )
assert
assert
nArg<=ArraySize(azArg)
nArg
nArg
ArraySize(azArg)
ArraySize
ArraySize
azArg
azArg
for(j=1; j<nArg && j<ArraySize(p->colWidth); j++){printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }
j=1;
j=1
j
j
1
j<nArg && j<ArraySize(p->colWidth)
j<nArg
j
j
nArg
nArg
j<ArraySize(p->colWidth)
j
j
ArraySize(p->colWidth)
ArraySize
ArraySize
p->colWidth
p
p
colWidth
j++
j
j
{printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");          p->colWidth[j-1] = (int)integerValue(azArg[j]);    }
printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n");
printf("for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n")
printf
printf
"for(j=1;j<nArg && j<ArraySize(p->colWidth);j++)\n"
p->colWidth[j-1] = (int)integerValue(azArg[j]);
p->colWidth[j-1] = (int)integerValue(azArg[j])
p->colWidth[j-1]
p->colWidth
p
p
colWidth
j-1
j
j
1
(int)integerValue(azArg[j])
int
int

integerValue(azArg[j])
integerValue
integerValue
azArg[j]
azArg
azArg
j
j
{    printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");    fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);    printf("rc = 1;\n");rc = 1;  }
printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n");
printf("fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n")
printf
printf
"fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' \'_s\'. Enter \'.help\' for help ', azArg[0]);\n"
fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0]);
fprintf(stderr, "Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n", azArg[0])
fprintf
fprintf
stderr
stderr
"Error: unknown command or invalid arguments: "      " \"%s\". Enter \".help\" for help\n"
azArg[0]
azArg
azArg
0
printf("rc = 1;\n");
printf("rc = 1;\n")
printf
printf
"rc = 1;\n"
rc = 1;
rc = 1
rc
rc
1
printf("return rc;\n");
printf("return rc;\n")
printf
printf
"return rc;\n"
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
return rc;
rc
rc
printf("------function end!------\n");
printf("------function end!------\n")
printf
printf
"------function end!------\n"
-----joern-----
(30,46,0)
(33,18,0)
(27,24,0)
(22,28,0)
(41,37,0)
(36,46,0)
(5,42,0)
(53,24,0)
(36,29,0)
(28,43,0)
(48,24,0)
(15,18,0)
(40,18,0)
(37,41,0)
(46,36,0)
(30,45,0)
(52,29,0)
(4,1,0)
(54,37,0)
(34,25,0)
(28,45,0)
(17,40,0)
(49,55,0)
(42,18,0)
(23,15,0)
(8,50,0)
(3,45,0)
(16,25,0)
(54,35,0)
(20,28,0)
(19,13,0)
(6,24,0)
(21,31,0)
(50,55,0)
(45,28,0)
(51,53,0)
(11,31,0)
(30,24,0)
(38,24,0)
(45,30,0)
(50,24,0)
(7,6,0)
(31,18,0)
(13,18,0)
(1,41,0)
(43,24,0)
(30,37,0)
(26,15,0)
(37,54,0)
(46,44,0)
(46,30,0)
(9,35,0)
(29,36,0)
(35,54,0)
(44,25,0)
(44,46,0)
(10,27,0)
(14,30,0)
(43,39,0)
(56,43,0)
(25,44,0)
(37,30,0)
(32,29,0)
(12,35,0)
(39,43,0)
(55,50,0)
(2,1,0)
(41,1,0)
(54,35,1)
(45,28,1)
(20,14,1)
(43,39,1)
(32,37,1)
(23,26,1)
(34,16,1)
(1,2,1)
(30,37,1)
(53,51,1)
(55,49,1)
(51,43,1)
(15,23,1)
(35,12,1)
(16,36,1)
(27,10,1)
(45,3,1)
(41,1,1)
(26,31,1)
(46,36,1)
(37,54,1)
(22,20,1)
(9,45,1)
(44,25,1)
(13,19,1)
(40,17,1)
(28,43,1)
(3,28,1)
(29,52,1)
(6,7,1)
(39,56,1)
(46,44,1)
(10,6,1)
(28,22,1)
(47,13,1)
(4,54,1)
(52,32,1)
(31,21,1)
(30,46,1)
(19,42,1)
(12,9,1)
(8,53,1)
(14,50,1)
(17,47,1)
(56,27,1)
(36,29,1)
(30,45,1)
(0,40,1)
(37,41,1)
(2,4,1)
(17,30,1)
(42,5,1)
(25,34,1)
(7,47,1)
(50,55,1)
(49,8,1)
(21,11,1)
(5,15,1)
(35,47,2)
(41,1,2)
(45,28,2)
(41,47,2)
(30,45,2)
(46,44,2)
(28,43,2)
(46,36,2)
(32,47,2)
(30,47,2)
(43,47,2)
(50,55,2)
(9,47,2)
(54,47,2)
(36,47,2)
(55,47,2)
(10,47,2)
(50,47,2)
(16,47,2)
(44,47,2)
(28,47,2)
(54,35,2)
(39,47,2)
(30,37,2)
(36,29,2)
(3,47,2)
(29,47,2)
(27,47,2)
(51,47,2)
(52,47,2)
(2,47,2)
(4,47,2)
(1,47,2)
(37,54,2)
(7,47,2)
(56,47,2)
(49,47,2)
(53,47,2)
(30,46,2)
(6,47,2)
(12,47,2)
(22,47,2)
(37,41,2)
(14,47,2)
(20,47,2)
(44,25,2)
(37,47,2)
(8,47,2)
(43,39,2)
(46,47,2)
(45,47,2)
(25,47,2)
(34,47,2)
-----------------------------------
(0,RET)
(1,sEnd.ru_utime)
(2,ru_utime)
(3,0.001)
(4,sEnd)
(5,"------function start!------\\n")
(6,printf("if(enableTimer)
(7,"if(enableTimer)
(8,RUSAGE_SELF)
(9,sBegin)
(10,"struct rusage sEnd;\\n")
(11,"\\nfile_name:%s\\n")
(12,ru_utime)
(13,printf("static void endTimer(void)
(14,"Run Time: real %.3f user %f sys %f\\n")
(15,printf("function_name:%s\\n",__func__)
(16,sEnd)
(17,"------function end!------\\n")
(18,)
(19,"static void endTimer(void)
(20,iEnd)
(21,__FILE__)
(22,iBegin)
(23,__func__)
(24,)
(25,sEnd.ru_stime)
(26,"function_name:%s\\n")
(27,printf("struct rusage sEnd;\\n")
(28,iEnd - iBegin)
(29,sBegin.ru_stime)
(30,printf("Run Time: real %.3f user %f sys %f\\n",\\n       (iEnd - iBegin)
(31,printf("\\nfile_name:%s\\n",__FILE__)
(32,sBegin)
(33,if( enableTimer )
(34,ru_stime)
(35,sBegin.ru_utime)
(36,&sBegin.ru_stime)
(37,timeDiff(&sBegin.ru_utime, &sEnd.ru_utime)
(38,sEnd)
(39,timeOfDay()
(40,printf("------function end!------\\n")
(41,&sEnd.ru_utime)
(42,printf("------function start!------\\n")
(43,iEnd = timeOfDay()
(44,&sEnd.ru_stime)
(45,(iEnd - iBegin)
(46,timeDiff(&sBegin.ru_stime, &sEnd.ru_stime)
(47,enableTimer)
(48,iEnd)
(49,sEnd)
(50,getrusage(RUSAGE_SELF, &sEnd)
(51,"getrusage(RUSAGE_SELF, &sEnd)
(52,ru_stime)
(53,printf("getrusage(RUSAGE_SELF, &sEnd)
(54,&sBegin.ru_utime)
(55,&sEnd)
(56,iEnd)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
----------------dynamic----------------
=======testcase========
model_version:0x01000000
stdin-stat:0x000800000000000001000000ffffffff0100000000000000a4810000e8030000e8030000ffffffff0000000000000000ffffffffffffffff0010000000000000ffffffffffffffff2ff9366400000000ffffffffffffffff9ff8366400000000ffffffffffffffff9ff8366400000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
stdin:0x2e6d000000000000000000000000000000000000
=========trace=========
static int do_meta_command(char *zLine, struct callback_data *p){
int i = 1;
int nArg = 0;
int n, c;
int rc = 0;
char *azArg[50];
while(zLine[i] && nArg<ArraySize(azArg))
azArg[nArg++] = &zLine[i];
while(zLine[i] && !IsSpace(zLine[i]))
i++;
resolve_backslashes(azArg[nArg-1]);
n = strlen30(azArg[0]);
c = azArg[0][0];
fprintf(stderr, 'Error: unknown command or invalid arguments: '       ' '_s'. Enter '.help' for help ', azArg[0]);
rc = 1;
return rc;
=======================
