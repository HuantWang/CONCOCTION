-----label-----
1
-----code-----
int
TIFFReadDirectory(TIFF* tif)
{
	static const char module[] = "TIFFReadDirectory";
	TIFFDirEntry* dir;
	uint16 dircount;
	TIFFDirEntry* dp;
	uint16 di;
	const TIFFField* fip;
	uint32 fii=FAILED_FII;
        toff_t nextdiroff;
	tif->tif_diroff=tif->tif_nextdiroff;
	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
		return 0;           /* last offset or bad offset (IFD looping) */
	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
	tif->tif_curdir++;
        nextdiroff = tif->tif_nextdiroff;
	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
	if (!dircount)
	{
		TIFFErrorExt(tif->tif_clientdata,module,
		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);
		return 0;
	}
	TIFFReadDirectoryCheckOrder(tif,dir,dircount);

        /*
         * Mark duplicates of any tag to be ignored (bugzilla 1994)
         * to avoid certain pathological problems.
         */
	{
		TIFFDirEntry* ma;
		uint16 mb;
		for (ma=dir, mb=0; mb<dircount; ma++, mb++)
		{
			TIFFDirEntry* na;
			uint16 nb;
			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)
			{
				if (ma->tdir_tag==na->tdir_tag)
					na->tdir_tag=IGNORE;
			}
		}
	}
        
	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */
	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */
	/* free any old stuff and reinit */
	TIFFFreeDirectory(tif);
	TIFFDefaultDirectory(tif);
	/*
	 * Electronic Arts writes gray-scale TIFF files
	 * without a PlanarConfiguration directory entry.
	 * Thus we setup a default value here, even though
	 * the TIFF spec says there is no default value.
	 */
	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
	/*
	 * Setup default value and then make a pass over
	 * the fields to check type and tag information,
	 * and to extract info required to size data
	 * structures.  A second pass is made afterwards
	 * to read in everthing not taken in the first pass.
	 * But we must process the Compression tag first
	 * in order to merge in codec-private tag definitions (otherwise
	 * we may get complaints about unknown tags).  However, the
	 * Compression tag may be dependent on the SamplesPerPixel
	 * tag value because older TIFF specs permited Compression
	 * to be written as a SamplesPerPixel-count tag entry.
	 * Thus if we don't first figure out the correct SamplesPerPixel
	 * tag value then we may end up ignoring the Compression tag
	 * value because it has an incorrect count value (if the
	 * true value of SamplesPerPixel is not 1).
	 */
	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
	if (dp)
	{
		if (!TIFFFetchNormalTag(tif,dp,0))
			goto bad;
		dp->tdir_tag=IGNORE;
	}
	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
	if (dp)
	{
		/*
		 * The 5.0 spec says the Compression tag has one value, while
		 * earlier specs say it has one value per sample.  Because of
		 * this, we accept the tag if one value is supplied with either
		 * count.
		 */
		uint16 value;
		enum TIFFReadDirEntryErr err;
		err=TIFFReadDirEntryShort(tif,dp,&value);
		if (err==TIFFReadDirEntryErrCount)
			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
		if (err!=TIFFReadDirEntryErrOk)
		{
			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);
			goto bad;
		}
		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))
			goto bad;
		dp->tdir_tag=IGNORE;
	}
	else
	{
		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))
			goto bad;
	}
	/*
	 * First real pass over the directory.
	 */
	for (di=0, dp=dir; di<dircount; di++, dp++)
	{
		if (dp->tdir_tag!=IGNORE)
		{
			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
			if (fii == FAILED_FII)
			{
				TIFFWarningExt(tif->tif_clientdata, module,
				    "Unknown field with tag %d (0x%x) encountered",
				    dp->tdir_tag,dp->tdir_tag);
                                /* the following knowingly leaks the 
                                   anonymous field structure */
				if (!_TIFFMergeFields(tif,
					_TIFFCreateAnonField(tif,
						dp->tdir_tag,
						(TIFFDataType) dp->tdir_type),
					1)) {
					TIFFWarningExt(tif->tif_clientdata,
					    module,
					    "Registering anonymous field with tag %d (0x%x) failed",
					    dp->tdir_tag,
					    dp->tdir_tag);
					dp->tdir_tag=IGNORE;
				} else {
					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
					assert(fii != FAILED_FII);
				}
			}
		}
		if (dp->tdir_tag!=IGNORE)
		{
			fip=tif->tif_fields[fii];
			if (fip->field_bit==FIELD_IGNORE)
				dp->tdir_tag=IGNORE;
			else
			{
				switch (dp->tdir_tag)
				{
					case TIFFTAG_STRIPOFFSETS:
					case TIFFTAG_STRIPBYTECOUNTS:
					case TIFFTAG_TILEOFFSETS:
					case TIFFTAG_TILEBYTECOUNTS:
						TIFFSetFieldBit(tif,fip->field_bit);
						break;
					case TIFFTAG_IMAGEWIDTH:
					case TIFFTAG_IMAGELENGTH:
					case TIFFTAG_IMAGEDEPTH:
					case TIFFTAG_TILELENGTH:
					case TIFFTAG_TILEWIDTH:
					case TIFFTAG_TILEDEPTH:
					case TIFFTAG_PLANARCONFIG:
					case TIFFTAG_ROWSPERSTRIP:
					case TIFFTAG_EXTRASAMPLES:
						if (!TIFFFetchNormalTag(tif,dp,0))
							goto bad;
						dp->tdir_tag=IGNORE;
						break;
				}
			}
		}
	}
	/*
	 * XXX: OJPEG hack.
	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,
	 * c) strip offsets/bytecounts tag are both present and
	 * d) both contain exactly one value, then we consistently find
	 * that the buggy implementation of the buggy compression scheme
	 * matches contig planarconfig best. So we 'fix-up' the tag here
	 */
	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&
	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))
	{
        if (!_TIFFFillStriles(tif))
            goto bad;
		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
		if ((dp!=0)&&(dp->tdir_count==1))
		{
			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,
			    TIFFTAG_STRIPBYTECOUNTS);
			if ((dp!=0)&&(dp->tdir_count==1))
			{
				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
				TIFFWarningExt(tif->tif_clientdata,module,
				    "Planarconfig tag value assumed incorrect, "
				    "assuming data is contig instead of chunky");
			}
		}
	}
	/*
	 * Allocate directory structure and setup defaults.
	 */
	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))
	{
		MissingRequired(tif,"ImageLength");
		goto bad;
	}
	/*
	 * Setup appropriate structures (by strip or by tile)
	 */
	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  
		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
		tif->tif_flags &= ~TIFF_ISTILED;
	} else {
		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
		tif->tif_flags |= TIFF_ISTILED;
	}
	if (!tif->tif_dir.td_nstrips) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    "Cannot handle zero number of %s",
		    isTiled(tif) ? "tiles" : "strips");
		goto bad;
	}
	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)
		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&
		    (isTiled(tif)==0) &&
		    (tif->tif_dir.td_nstrips==1)) {
			/*
			 * XXX: OJPEG hack.
			 * If a) compression is OJPEG, b) it's not a tiled TIFF,
			 * and c) the number of strips is 1,
			 * then we tolerate the absence of stripoffsets tag,
			 * because, presumably, all required data is in the
			 * JpegInterchangeFormat stream.
			 */
			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
		} else {
			MissingRequired(tif,
				isTiled(tif) ? "TileOffsets" : "StripOffsets");
			goto bad;
		}
	}
	/*
	 * Second pass: extract other information.
	 */
	for (di=0, dp=dir; di<dircount; di++, dp++)
	{
		switch (dp->tdir_tag)
		{
			case IGNORE:
				break;
			case TIFFTAG_MINSAMPLEVALUE:
			case TIFFTAG_MAXSAMPLEVALUE:
			case TIFFTAG_BITSPERSAMPLE:
			case TIFFTAG_DATATYPE:
			case TIFFTAG_SAMPLEFORMAT:
				/*
				 * The MinSampleValue, MaxSampleValue, BitsPerSample
				 * DataType and SampleFormat tags are supposed to be
				 * written as one value/sample, but some vendors
				 * incorrectly write one value only -- so we accept
				 * that as well (yech). Other vendors write correct
				 * value for NumberOfSamples, but incorrect one for
				 * BitsPerSample and friends, and we will read this
				 * too.
				 */
				{
					uint16 value;
					enum TIFFReadDirEntryErr err;
					err=TIFFReadDirEntryShort(tif,dp,&value);
					if (err==TIFFReadDirEntryErrCount)
						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
					if (err!=TIFFReadDirEntryErrOk)
					{
						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
						goto bad;
					}
					if (!TIFFSetField(tif,dp->tdir_tag,value))
						goto bad;
				}
				break;
			case TIFFTAG_SMINSAMPLEVALUE:
			case TIFFTAG_SMAXSAMPLEVALUE:
				{

					double *data;
					enum TIFFReadDirEntryErr err;
					uint32 saved_flags;
					int m;
					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)
						err = TIFFReadDirEntryErrCount;
					else
						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
					if (err!=TIFFReadDirEntryErrOk)
					{
						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
						goto bad;
					}
					saved_flags = tif->tif_flags;
					tif->tif_flags |= TIFF_PERSAMPLE;
					m = TIFFSetField(tif,dp->tdir_tag,data);
					tif->tif_flags = saved_flags;
					_TIFFfree(data);
					if (!m)
						goto bad;
				}
				break;
			case TIFFTAG_STRIPOFFSETS:
			case TIFFTAG_TILEOFFSETS:
#if defined(DEFER_STRILE_LOAD)
                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),
                                             dp, sizeof(TIFFDirEntry) );
#else                          
				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  
					goto bad;
#endif                                
				break;
			case TIFFTAG_STRIPBYTECOUNTS:
			case TIFFTAG_TILEBYTECOUNTS:
#if defined(DEFER_STRILE_LOAD)
                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),
                                             dp, sizeof(TIFFDirEntry) );
#else                          
				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  
					goto bad;
#endif                                
				break;
			case TIFFTAG_COLORMAP:
			case TIFFTAG_TRANSFERFUNCTION:
				{
					enum TIFFReadDirEntryErr err;
					uint32 countpersample;
					uint32 countrequired;
					uint32 incrementpersample;
					uint16* value=NULL;
					countpersample=(1L<<tif->tif_dir.td_bitspersample);
					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))
					{
						countrequired=countpersample;
						incrementpersample=0;
					}
					else
					{
						countrequired=3*countpersample;
						incrementpersample=countpersample;
					}
					if (dp->tdir_count!=(uint64)countrequired)
						err=TIFFReadDirEntryErrCount;
					else
						err=TIFFReadDirEntryShortArray(tif,dp,&value);
					if (err!=TIFFReadDirEntryErrOk)
                    {
						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);
                    }
					else
					{
						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
						_TIFFfree(value);
					}
				}
				break;
/* BEGIN REV 4.0 COMPATIBILITY */
			case TIFFTAG_OSUBFILETYPE:
				{
					uint16 valueo;
					uint32 value;
					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)
					{
						switch (valueo)
						{
							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;
							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;
							default: value=0; break;
						}
						if (value!=0)
							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
					}
				}
				break;
/* END REV 4.0 COMPATIBILITY */
			default:
				(void) TIFFFetchNormalTag(tif, dp, TRUE);
				break;
		}
	}
	/*
	 * OJPEG hack:
	 * - If a) compression is OJPEG, and b) photometric tag is missing,
	 * then we consistently find that photometric should be YCbCr
	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,
	 * then we consistently find that the buggy implementation of the
	 * buggy compression scheme matches photometric YCbCr instead.
	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,
	 * then we consistently find bitspersample should be 8.
	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
	 * and c) photometric is RGB or YCbCr, then we consistently find
	 * samplesperpixel should be 3
	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently
	 * find samplesperpixel should be 3
	 */
	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)
	{
		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))
		{
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Photometric tag is missing, assuming data is YCbCr");
			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))
				goto bad;
		}
		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
		{
			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Photometric tag value assumed incorrect, "
			    "assuming data is YCbCr instead of RGB");
		}
		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
		{
			TIFFWarningExt(tif->tif_clientdata,module,
			    "BitsPerSample tag is missing, assuming 8 bits per sample");
			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))
				goto bad;
		}
		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
		{
			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
			{
				TIFFWarningExt(tif->tif_clientdata,module,
				    "SamplesPerPixel tag is missing, "
				    "assuming correct SamplesPerPixel value is 3");
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
					goto bad;
			}
			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)
			{
				TIFFWarningExt(tif->tif_clientdata,module,
				    "SamplesPerPixel tag is missing, "
				    "applying correct SamplesPerPixel value of 3");
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
					goto bad;
			}
			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))
			{
				/*
				 * SamplesPerPixel tag is missing, but is not required
				 * by spec.  Assume correct SamplesPerPixel value of 1.
				 */
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))
					goto bad;
			}
		}
	}
	/*
	 * Verify Palette image has a Colormap.
	 */
	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&
	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {
		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)
			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
		else if (tif->tif_dir.td_bitspersample>=8)
			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
		else {
			MissingRequired(tif, "Colormap");
			goto bad;
		}
	}
	/*
	 * OJPEG hack:
	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG
	 * TIFFs
	 */
	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)
	{
		/*
		 * Attempt to deal with a missing StripByteCounts tag.
		 */
		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
			/*
			 * Some manufacturers violate the spec by not giving
			 * the size of the strips.  In this case, assume there
			 * is one uncompressed strip of data.
			 */
			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
			    tif->tif_dir.td_nstrips > 1) ||
			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&
			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {
			    MissingRequired(tif, "StripByteCounts");
			    goto bad;
			}
			TIFFWarningExt(tif->tif_clientdata, module,
				"TIFF directory is missing required "
				"\"StripByteCounts\" field, calculating from imagelength");
			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;
		/*
		 * Assume we have wrong StripByteCount value (in case
		 * of single strip) in following cases:
		 *   - it is equal to zero along with StripOffset;
		 *   - it is larger than file itself (in case of uncompressed
		 *     image);
		 *   - it is smaller than the size of the bytes per row
		 *     multiplied on the number of rows.  The last case should
		 *     not be checked in the case of writing new image,
		 *     because we may do not know the exact strip size
		 *     until the whole image will be written and directory
		 *     dumped out.
		 */
		#define	BYTECOUNTLOOKSBAD \
		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \
		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \
		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \
		      (tif->tif_mode == O_RDONLY && \
		       tif->tif_dir.td_compression == COMPRESSION_NONE && \
		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )

		} else if (tif->tif_dir.td_nstrips == 1
                           && _TIFFFillStriles(tif)
			   && tif->tif_dir.td_stripoffset[0] != 0
			   && BYTECOUNTLOOKSBAD) {
			/*
			 * XXX: Plexus (and others) sometimes give a value of
			 * zero for a tag when they don't know what the
			 * correct value is!  Try and handle the simple case
			 * of estimating the size of a one strip image.
			 */
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");
			if(EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;

#if !defined(DEFER_STRILE_LOAD)
		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
			   && tif->tif_dir.td_nstrips > 2
			   && tif->tif_dir.td_compression == COMPRESSION_NONE
			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
			   && tif->tif_dir.td_stripbytecount[0] != 0
			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {
			/*
			 * XXX: Some vendors fill StripByteCount array with
			 * absolutely wrong values (it can be equal to
			 * StripOffset array, for example). Catch this case
			 * here.
                         *
                         * We avoid this check if deferring strile loading
                         * as it would always force us to load the strip/tile
                         * information.
			 */
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");
			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;
#endif /* !defined(DEFER_STRILE_LOAD) */                        
		}
	}
	if (dir)
	{
		_TIFFfree(dir);
		dir=NULL;
	}
	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
	{
		if (tif->tif_dir.td_bitspersample>=16)
			tif->tif_dir.td_maxsamplevalue=0xFFFF;
		else
			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
	}
	/*
	 * XXX: We can optimize checking for the strip bounds using the sorted
	 * bytecounts array. See also comments for TIFFAppendToStrip()
	 * function in tif_write.c.
	 */
#if !defined(DEFER_STRILE_LOAD)        
	if (tif->tif_dir.td_nstrips > 1) {
		uint32 strip;

		tif->tif_dir.td_stripbytecountsorted = 1;
		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
			if (tif->tif_dir.td_stripoffset[strip - 1] >
			    tif->tif_dir.td_stripoffset[strip]) {
				tif->tif_dir.td_stripbytecountsorted = 0;
				break;
			}
		}
	}
#endif /* !defined(DEFER_STRILE_LOAD) */
        
	/*
	 * An opportunity for compression mode dependent tag fixup
	 */
	(*tif->tif_fixuptags)(tif);

	/*
	 * Some manufacturers make life difficult by writing
	 * large amounts of uncompressed data as a single strip.
	 * This is contrary to the recommendations of the spec.
	 * The following makes an attempt at breaking such images
	 * into strips closer to the recommended 8k bytes.  A
	 * side effect, however, is that the RowsPerStrip tag
	 * value may be changed.
	 */
	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&
	    (tif->tif_dir.td_nstrips==1)&&
	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  
	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))
    {
        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )
            return 0;
		ChopUpSingleUncompressedStrip(tif);
    }

        /*
         * Clear the dirty directory flag. 
         */
	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
	tif->tif_flags &= ~TIFF_DIRTYSTRIP;

	/*
	 * Reinitialize i/o since we are starting on a new directory.
	 */
	tif->tif_row = (uint32) -1;
	tif->tif_curstrip = (uint32) -1;
	tif->tif_col = (uint32) -1;
	tif->tif_curtile = (uint32) -1;
	tif->tif_tilesize = (tmsize_t) -1;

	tif->tif_scanlinesize = TIFFScanlineSize(tif);
	if (!tif->tif_scanlinesize) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    "Cannot handle zero scanline size");
		return (0);
	}

	if (isTiled(tif)) {
		tif->tif_tilesize = TIFFTileSize(tif);
		if (!tif->tif_tilesize) {
			TIFFErrorExt(tif->tif_clientdata, module,
			     "Cannot handle zero tile size");
			return (0);
		}
	} else {
		if (!TIFFStripSize(tif)) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "Cannot handle zero strip size");
			return (0);
		}
	}
	return (1);
bad:
	if (dir)
		_TIFFfree(dir);
	return (0);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
11,30
11,31
11,32
11,33
11,34
11,35
11,36
11,37
11,38
11,39
11,40
11,41
11,42
11,43
11,44
11,45
11,46
11,47
11,48
11,49
11,50
11,51
11,52
11,53
11,54
11,55
11,56
11,57
11,58
11,59
11,60
11,61
11,62
11,63
11,64
11,65
11,66
11,67
12,13
13,14
13,15
15,16
15,17
15,18
18,19
20,21
21,22
21,23
22,23
24,25
24,26
27,28
28,29
28,30
29,30
31,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
55,56
57,58
57,59
59,60
60,61
62,63
63,64
63,65
64,65
66,67
68,69
69,70
69,71
70,71
70,72
71,72
74,75
74,76
75,76
78,79
78,80
79,80
80,81
80,82
80,83
81,82
83,84
85,86
85,87
86,87
89,90
91,92
92,93
92,94
93,94
94,95
95,96
95,97
96,97
99,100
101,102
102,103
103,104
103,105
104,105
107,108
108,109
108,110
109,110
111,112
111,113
112,113
115,116
116,117
116,118
117,118
119,120
119,121
119,122
119,123
119,124
120,121
122,123
124,125
126,127
127,128
129,130
130,131
130,132
131,132
134,135
134,136
135,136
136,137
138,139
138,140
139,140
140,141
142,143
143,144
143,145
143,146
143,147
144,145
146,147
148,149
150,151
152,153
152,154
152,155
153,154
154,155
154,156
155,156
157,158
157,159
160,161
161,162
161,163
162,163
164,165
166,167
166,168
166,169
166,170
167,168
168,169
168,170
169,170
169,171
170,171
172,173
174,175
174,176
175,176
178,179
178,180
179,180
181,182
183,184
183,185
184,185
185,186
187,188
188,189
190,191
190,192
190,193
191,192
192,193
192,194
193,194
195,196
195,197
198,199
199,200
199,201
200,201
202,203
204,205
204,206
204,207
204,208
205,206
206,207
206,208
207,208
207,209
208,209
210,211
210,212
211,212
214,215
214,216
215,216
217,218
217,219
218,219
221,222
221,223
222,223
224,225
226,227
226,228
227,228
228,229
230,231
231,232
233,234
234,235
234,236
235,236
235,237
236,237
236,238
237,238
240,241
240,242
241,242
244,245
245,246
245,247
246,247
246,248
247,248
250,251
252,253
253,254
253,255
254,255
254,256
255,256
258,259
259,260
261,262
262,263
262,264
263,264
263,265
264,265
267,268
268,269
270,271
271,272
271,273
272,273
274,275
276,277
277,278
277,279
278,279
280,281
282,283
283,284
283,285
283,286
283,287
284,285
286,287
288,289
290,291
292,293
293,294
293,295
294,295
296,297
296,298
296,299
296,300
296,301
297,298
299,300
301,302
303,304
305,306
307,308
307,309
308,309
310,311
310,312
311,312
311,313
312,313
313,314
313,315
313,316
313,317
314,315
316,317
318,319
321,322
323,324
324,325
324,326
325,326
325,327
326,327
329,330
331,332
332,333
332,334
333,334
335,336
335,337
335,338
335,339
335,340
336,337
338,339
340,341
342,343
344,345
346,347
346,348
346,349
347,348
349,350
349,351
349,352
349,353
349,354
349,355
349,356
350,351
351,352
351,353
352,353
354,355
356,357
357,358
357,359
358,359
360,361
362,363
363,364
363,365
364,365
366,367
366,368
366,369
366,370
367,368
369,370
371,372
373,374
374,375
376,377
376,378
377,378
377,379
378,379
380,381
382,383
383,384
383,385
384,385
386,387
386,388
386,389
386,390
387,388
389,390
391,392
393,394
394,395
396,397
396,398
397,398
397,399
398,399
400,401
402,403
402,404
403,404
404,405
404,406
404,407
404,408
404,409
404,410
405,406
407,408
409,410
411,412
415,416
417,418
417,419
418,419
419,420
419,421
419,422
419,423
420,421
422,423
424,425
426,427
428,429
430,431
431,432
431,433
432,433
432,434
433,434
436,437
438,439
439,440
439,441
440,441
441,442
441,443
441,444
441,445
442,443
444,445
446,447
448,449
450,451
452,453
452,454
452,455
452,456
453,454
454,455
454,456
455,456
455,457
456,457
459,460
459,461
460,461
462,463
464,465
464,466
465,466
467,468
469,470
469,471
470,471
471,472
473,474
474,475
476,477
476,478
477,478
477,479
478,479
478,480
479,480
479,481
480,481
483,484
485,486
485,487
486,487
487,488
487,489
487,490
487,491
488,489
490,491
492,493
492,494
493,494
496,497
497,498
499,500
499,501
500,501
500,502
501,502
503,504
505,506
505,507
506,507
507,508
507,509
507,510
507,511
507,512
507,513
508,509
510,511
510,512
511,512
514,515
517,518
517,519
518,519
521,522
521,523
522,523
525,526
525,527
525,528
526,527
527,528
527,529
527,530
527,531
528,529
530,531
532,533
532,534
532,535
532,536
533,534
535,536
537,538
537,539
538,539
541,542
541,543
542,543
542,544
543,544
546,547
546,548
547,548
551,552
551,553
552,553
553,554
553,555
553,556
553,557
553,558
553,559
554,555
556,557
556,558
557,558
560,561
563,564
563,565
564,565
567,568
567,569
568,569
571,572
572,573
572,574
573,574
573,575
574,575
577,578
579,580
579,581
580,581
581,582
581,583
581,584
581,585
582,583
584,585
586,587
586,588
587,588
590,591
591,592
593,594
594,595
594,596
595,596
597,598
597,599
598,599
600,601
602,603
602,604
603,604
603,605
604,605
604,606
605,606
608,609
610,611
610,612
611,612
612,613
612,614
613,614
615,616
615,617
616,617
616,618
617,618
620,621
622,623
622,624
622,625
623,624
623,625
624,625
624,626
625,626
628,629
630,631
631,632
631,633
632,633
632,634
633,634
636,637
638,639
639,640
639,641
640,641
640,642
641,642
644,645
644,646
644,647
644,648
644,649
644,650
644,651
644,652
644,653
644,654
644,655
644,656
644,657
644,658
644,659
644,660
644,661
644,662
645,646
646,647
648,649
649,650
651,652
652,653
654,655
655,656
657,658
658,659
658,660
658,661
659,660
661,662
663,664
663,665
664,665
668,669
669,670
671,672
672,673
674,675
675,676
677,678
678,679
680,681
681,682
683,684
684,685
686,687
687,688
689,690
690,691
692,693
693,694
695,696
695,697
696,697
697,698
697,699
697,700
697,701
698,699
700,701
702,703
705,706
707,708
708,709
708,710
709,710
709,711
710,711
713,714
716,717
716,718
717,718
717,719
718,719
719,720
719,721
720,721
720,722
721,722
721,723
722,723
726,727
728,729
729,730
729,731
730,731
730,732
731,732
731,733
732,733
736,737
738,739
738,740
738,741
739,740
739,741
740,741
741,742
741,743
742,743
744,745
746,747
748,749
749,750
749,751
750,751
752,753
752,754
752,755
752,756
752,757
753,754
755,756
757,758
759,760
761,762
763,764
763,765
764,765
764,766
765,766
766,767
766,768
767,768
770,771
771,772
771,773
772,773
772,774
773,774
777,778
777,779
778,779
779,780
779,781
780,781
782,783
782,784
782,785
782,786
782,787
783,784
785,786
787,788
789,790
791,792
793,794
793,795
794,795
794,796
795,796
796,797
796,798
797,798
800,801
801,802
801,803
802,803
802,804
803,804
807,808
807,809
808,809
809,810
809,811
810,811
810,812
811,812
811,813
812,813
816,817
818,819
819,820
819,821
819,822
819,823
820,821
822,823
822,824
823,824
826,827
829,830
829,831
830,831
831,832
831,833
831,834
832,833
834,835
836,837
838,839
838,840
839,840
840,841
840,842
840,843
841,842
843,844
846,847
848,849
848,850
848,851
849,850
850,851
850,852
850,853
851,852
853,854
855,856
857,858
857,859
857,860
857,861
857,862
858,859
859,860
859,861
860,861
860,862
861,862
861,863
862,863
866,867
866,868
867,868
869,870
871,872
872,873
872,874
873,874
873,875
874,875
874,876
875,876
879,880
879,881
880,881
880,882
881,882
885,886
886,887
886,888
887,888
887,889
888,889
888,890
889,890
893,894
893,895
894,895
894,896
895,896
899,900
900,901
900,902
901,902
901,903
902,903
902,904
903,904
907,908
907,909
908,909
908,910
909,910
913,914
914,915
914,916
915,916
915,917
916,917
919,920
920,921
922,923
922,924
923,924
924,925
924,926
925,926
925,927
926,927
926,928
927,928
931,932
931,933
932,933
934,935
936,937
937,938
937,939
938,939
938,940
939,940
942,943
944,945
944,946
945,946
946,947
946,948
947,948
947,949
948,949
952,953
952,954
953,954
954,955
954,956
954,957
954,958
954,959
955,956
957,958
957,959
958,959
961,962
964,965
964,966
964,967
965,966
965,967
966,967
968,969
972,973
974,975
975,976
975,977
976,977
976,978
977,978
977,979
978,979
982,983
982,984
983,984
983,985
984,985
988,989
988,990
989,990
989,991
990,991
990,992
991,992
991,993
992,993
996,997
998,999
999,1000
999,1001
1000,1001
1000,1002
1001,1002
1001,1003
1002,1003
1006,1007
1006,1008
1007,1008
1007,1009
1008,1009
1012,1013
1012,1014
1013,1014
1014,1015
1014,1016
1014,1017
1015,1016
1017,1018
1019,1020
1021,1022
1022,1023
1022,1024
1022,1025
1023,1024
1023,1025
1024,1025
1024,1026
1025,1026
1026,1027
1026,1028
1027,1028
1027,1029
1028,1029
1028,1030
1029,1030
1033,1034
1035,1036
1036,1037
1036,1038
1037,1038
1037,1039
1038,1039
1040,1041
1043,1044
1044,1045
1044,1046
1045,1046
1045,1047
1046,1047
1046,1048
1047,1048
1052,1053
1053,1054
1054,1055
1054,1056
1054,1057
1055,1056
1057,1058
1059,1060
1061,1062
1061,1063
1062,1063
1063,1064
1063,1065
1063,1066
1064,1065
1066,1067
1068,1069
1068,1070
1068,1071
1069,1070
1069,1071
1070,1071
1072,1073
1076,1077
1078,1079
1078,1080
1078,1081
1078,1082
1079,1080
1080,1081
1080,1082
1081,1082
1081,1083
1082,1083
1085,1086
1085,1087
1086,1087
1088,1089
1090,1091
1090,1092
1091,1092
1093,1094
1095,1096
1095,1097
1096,1097
1097,1098
1099,1100
1100,1101
1102,1103
1103,1104
1103,1105
1104,1105
1104,1106
1105,1106
1108,1109
1108,1110
1108,1111
1108,1112
1108,1113
1108,1114
1108,1115
1108,1116
1108,1117
1108,1118
1108,1119
1108,1120
1108,1121
1108,1122
1108,1123
1108,1124
1108,1125
1108,1126
1108,1127
1108,1128
1108,1129
1108,1130
1108,1131
1108,1132
1108,1133
1108,1134
1108,1135
1108,1136
1108,1137
1108,1138
1108,1139
1109,1110
1110,1111
1113,1114
1114,1115
1116,1117
1117,1118
1119,1120
1120,1121
1122,1123
1123,1124
1125,1126
1126,1127
1128,1129
1128,1130
1128,1131
1128,1132
1128,1133
1128,1134
1129,1130
1130,1131
1130,1132
1131,1132
1133,1134
1135,1136
1136,1137
1136,1138
1137,1138
1139,1140
1141,1142
1142,1143
1142,1144
1143,1144
1145,1146
1145,1147
1145,1148
1145,1149
1146,1147
1148,1149
1150,1151
1152,1153
1153,1154
1155,1156
1155,1157
1156,1157
1156,1158
1157,1158
1159,1160
1161,1162
1162,1163
1162,1164
1163,1164
1165,1166
1165,1167
1165,1168
1165,1169
1166,1167
1168,1169
1170,1171
1172,1173
1173,1174
1175,1176
1175,1177
1176,1177
1176,1178
1177,1178
1179,1180
1181,1182
1181,1183
1181,1184
1182,1183
1183,1184
1183,1185
1184,1185
1186,1187
1186,1188
1186,1189
1187,1188
1189,1190
1191,1192
1191,1193
1192,1193
1195,1196
1196,1197
1196,1198
1196,1199
1196,1200
1196,1201
1196,1202
1197,1198
1199,1200
1201,1202
1203,1204
1205,1206
1205,1207
1205,1208
1206,1207
1208,1209
1208,1210
1209,1210
1214,1215
1216,1217
1216,1218
1217,1218
1218,1219
1218,1220
1218,1221
1218,1222
1219,1220
1221,1222
1223,1224
1223,1225
1224,1225
1227,1228
1229,1230
1232,1233
1233,1234
1235,1236
1236,1237
1238,1239
1238,1240
1238,1241
1238,1242
1238,1243
1238,1244
1238,1245
1238,1246
1238,1247
1238,1248
1238,1249
1238,1250
1239,1240
1240,1241
1240,1242
1242,1243
1242,1244
1245,1246
1246,1247
1246,1248
1247,1248
1249,1250
1251,1252
1252,1253
1252,1254
1253,1254
1255,1256
1257,1258
1258,1259
1258,1260
1260,1261
1262,1263
1262,1264
1262,1265
1263,1264
1263,1265
1264,1265
1264,1266
1265,1266
1268,1269
1268,1270
1269,1270
1269,1271
1270,1271
1273,1274
1273,1275
1274,1275
1274,1276
1275,1276
1279,1280
1280,1281
1280,1282
1281,1282
1283,1284
1285,1286
1286,1287
1286,1288
1287,1288
1289,1290
1289,1291
1289,1292
1289,1293
1290,1291
1292,1293
1294,1295
1296,1297
1297,1298
1299,1300
1299,1301
1300,1301
1300,1302
1301,1302
1303,1304
1305,1306
1305,1307
1305,1308
1306,1307
1307,1308
1307,1309
1308,1309
1310,1311
1310,1312
1310,1313
1311,1312
1313,1314
1315,1316
1315,1317
1316,1317
1319,1320
1320,1321
1320,1322
1320,1323
1320,1324
1320,1325
1320,1326
1321,1322
1323,1324
1325,1326
1327,1328
1329,1330
1329,1331
1329,1332
1330,1331
1332,1333
1332,1334
1333,1334
1338,1339
1340,1341
1341,1342
1341,1343
1342,1343
1344,1345
1344,1346
1345,1346
1348,1349
1349,1350
1349,1351
1350,1351
1350,1352
1351,1352
1354,1355
1356,1357
1357,1358
1357,1359
1358,1359
1360,1361
1360,1362
1360,1363
1360,1364
1361,1362
1363,1364
1365,1366
1365,1367
1366,1367
1369,1370
1371,1372
1372,1373
1372,1374
1373,1374
1373,1375
1374,1375
1377,1378
1379,1380
1380,1381
1380,1382
1381,1382
1383,1384
1385,1386
1385,1387
1386,1387
1387,1388
1389,1390
1392,1393
1393,1394
1395,1396
1396,1397
1398,1399
1398,1400
1399,1400
1400,1401
1400,1402
1400,1403
1400,1404
1400,1405
1401,1402
1403,1404
1405,1406
1407,1408
1407,1409
1408,1409
1408,1410
1409,1410
1413,1414
1414,1415
1414,1416
1415,1416
1415,1417
1416,1417
1420,1421
1423,1424
1424,1425
1426,1427
1427,1428
1429,1430
1429,1431
1430,1431
1431,1432
1431,1433
1431,1434
1431,1435
1431,1436
1432,1433
1434,1435
1436,1437
1438,1439
1438,1440
1439,1440
1439,1441
1440,1441
1444,1445
1445,1446
1445,1447
1446,1447
1446,1448
1447,1448
1451,1452
1454,1455
1455,1456
1457,1458
1458,1459
1460,1461
1460,1462
1460,1463
1460,1464
1460,1465
1460,1466
1460,1467
1460,1468
1460,1469
1461,1462
1462,1463
1462,1464
1463,1464
1465,1466
1467,1468
1468,1469
1468,1470
1469,1470
1471,1472
1473,1474
1474,1475
1474,1476
1475,1476
1477,1478
1479,1480
1480,1481
1480,1482
1481,1482
1483,1484
1485,1486
1486,1487
1486,1488
1487,1488
1489,1490
1489,1491
1489,1492
1492,1493
1493,1494
1495,1496
1496,1497
1496,1498
1497,1498
1499,1500
1500,1501
1500,1502
1502,1503
1502,1504
1503,1504
1503,1505
1504,1505
1508,1509
1508,1510
1508,1511
1509,1510
1509,1511
1510,1511
1511,1512
1511,1513
1512,1513
1512,1514
1513,1514
1516,1517
1518,1519
1519,1520
1519,1521
1520,1521
1520,1522
1521,1522
1524,1525
1524,1526
1525,1526
1525,1527
1526,1527
1529,1530
1531,1532
1531,1533
1532,1533
1533,1534
1533,1535
1534,1535
1536,1537
1538,1539
1539,1540
1539,1541
1540,1541
1543,1544
1543,1545
1544,1545
1545,1546
1545,1547
1546,1547
1548,1549
1548,1550
1550,1551
1552,1553
1553,1554
1553,1555
1554,1555
1556,1557
1558,1559
1558,1560
1558,1561
1559,1560
1559,1561
1560,1561
1560,1562
1561,1562
1564,1565
1564,1566
1565,1566
1565,1567
1566,1567
1569,1570
1571,1572
1572,1573
1572,1574
1573,1574
1575,1576
1577,1578
1578,1579
1578,1580
1579,1580
1581,1582
1581,1583
1581,1584
1581,1585
1582,1583
1584,1585
1586,1587
1588,1589
1589,1590
1591,1592
1591,1593
1591,1594
1592,1593
1592,1594
1593,1594
1595,1596
1597,1598
1597,1599
1598,1599
1599,1600
1599,1601
1600,1601
1602,1603
1602,1604
1602,1605
1603,1604
1605,1606
1607,1608
1607,1609
1608,1609
1611,1612
1612,1613
1612,1614
1612,1615
1612,1616
1612,1617
1612,1618
1613,1614
1615,1616
1617,1618
1619,1620
1621,1622
1621,1623
1621,1624
1622,1623
1624,1625
1624,1626
1625,1626
1630,1631
1630,1632
1631,1632
1632,1633
1632,1634
1632,1635
1632,1636
1632,1637
1632,1638
1633,1634
1635,1636
1637,1638
1637,1639
1638,1639
1641,1642
1643,1644
1643,1645
1644,1645
1646,1647
1648,1649
1648,1650
1649,1650
1651,1652
1651,1653
1653,1654
1655,1656
1656,1657
1656,1658
1657,1658
1659,1660
1662,1663
1663,1664
1665,1666
1665,1667
1665,1668
1666,1667
1667,1668
1667,1669
1668,1669
1670,1671
1672,1673
1673,1674
1673,1675
1674,1675
1676,1677
1678,1679
1678,1680
1679,1680
1679,1681
1680,1681
1680,1682
1680,1683
1680,1684
1681,1682
1683,1684
1685,1686
1687,1688
1688,1689
1690,1691
1692,1693
1692,1694
1693,1694
1693,1695
1694,1695
1696,1697
1696,1698
1696,1699
1696,1700
1696,1701
1696,1702
1696,1703
1696,1704
1696,1705
1697,1698
1698,1699
1700,1701
1701,1702
1701,1703
1702,1703
1704,1705
1707,1708
1708,1709
1710,1711
1711,1712
1711,1713
1712,1713
1714,1715
1718,1719
1719,1720
1719,1721
1720,1721
1724,1725
1724,1726
1725,1726
1725,1727
1726,1727
1729,1730
1730,1731
1730,1732
1730,1733
1730,1734
1731,1732
1733,1734
1735,1736
1737,1738
1741,1742
1742,1743
1742,1744
1743,1744
1743,1745
1746,1747
1746,1748
1746,1749
1746,1750
1747,1748
1749,1750
1751,1752
1753,1754
1756,1757
1756,1758
1757,1758
1757,1759
1758,1759
1758,1760
1759,1760
1759,1761
1760,1761
1764,1765
1766,1767
1766,1768
1766,1769
1767,1768
1767,1769
1767,1770
1768,1769
1769,1770
1769,1771
1769,1772
1770,1771
1772,1773
1774,1775
1776,1777
1776,1778
1777,1778
1778,1779
1778,1780
1778,1781
1778,1782
1779,1780
1781,1782
1781,1783
1782,1783
1785,1786
1788,1789
1788,1790
1789,1790
1790,1791
1790,1792
1790,1793
1790,1794
1791,1792
1793,1794
1795,1796
1797,1798
1799,1800
1801,1802
1801,1803
1802,1803
1802,1804
1803,1804
1803,1805
1804,1805
1804,1806
1805,1806
1809,1810
1811,1812
1811,1813
1812,1813
1813,1814
1813,1815
1814,1815
1814,1816
1815,1816
1815,1817
1816,1817
1820,1821
1822,1823
1823,1824
1823,1825
1823,1826
1823,1827
1824,1825
1826,1827
1826,1828
1827,1828
1830,1831
1833,1834
1833,1835
1834,1835
1835,1836
1835,1837
1835,1838
1836,1837
1838,1839
1840,1841
1842,1843
1842,1844
1843,1844
1844,1845
1844,1846
1844,1847
1844,1848
1845,1846
1847,1848
1847,1849
1848,1849
1851,1852
1854,1855
1854,1856
1855,1856
1856,1857
1856,1858
1856,1859
1856,1860
1857,1858
1859,1860
1861,1862
1864,1865
1866,1867
1866,1868
1867,1868
1868,1869
1868,1870
1868,1871
1869,1870
1871,1872
1873,1874
1875,1876
1875,1877
1876,1877
1876,1878
1877,1878
1877,1879
1878,1879
1878,1880
1879,1880
1879,1881
1880,1881
1884,1885
1886,1887
1886,1888
1887,1888
1888,1889
1888,1890
1888,1891
1888,1892
1889,1890
1891,1892
1891,1893
1892,1893
1895,1896
1898,1899
1898,1900
1899,1900
1900,1901
1900,1902
1900,1903
1900,1904
1901,1902
1903,1904
1905,1906
1908,1909
1910,1911
1910,1912
1910,1913
1911,1912
1911,1913
1912,1913
1912,1914
1913,1914
1913,1915
1914,1915
1918,1919
1920,1921
1920,1922
1921,1922
1922,1923
1922,1924
1922,1925
1922,1926
1923,1924
1925,1926
1925,1927
1926,1927
1929,1930
1932,1933
1932,1934
1933,1934
1934,1935
1934,1936
1934,1937
1934,1938
1935,1936
1937,1938
1939,1940
1942,1943
1944,1945
1944,1946
1945,1946
1945,1947
1946,1947
1947,1948
1947,1949
1948,1949
1948,1950
1949,1950
1949,1951
1950,1951
1954,1955
1956,1957
1957,1958
1957,1959
1958,1959
1958,1960
1959,1960
1959,1961
1960,1961
1964,1965
1966,1967
1967,1968
1967,1969
1968,1969
1969,1970
1969,1971
1969,1972
1969,1973
1970,1971
1972,1973
1974,1975
1977,1978
1979,1980
1979,1981
1980,1981
1980,1982
1981,1982
1981,1983
1982,1983
1982,1984
1983,1984
1983,1985
1984,1985
1988,1989
1990,1991
1991,1992
1991,1993
1991,1994
1992,1993
1994,1995
1996,1997
1998,1999
1999,2000
1999,2001
1999,2002
2000,2001
2000,2002
2001,2002
2001,2003
2002,2003
2002,2004
2003,2004
2003,2005
2004,2005
2009,2010
2009,2011
2010,2011
2010,2012
2011,2012
2011,2013
2012,2013
2017,2018
2018,2019
2018,2020
2019,2020
2019,2021
2020,2021
2020,2022
2021,2022
2025,2026
2027,2028
2027,2029
2027,2030
2028,2029
2028,2030
2029,2030
2029,2031
2030,2031
2030,2032
2031,2032
2036,2037
2037,2038
2037,2039
2038,2039
2038,2040
2039,2040
2039,2041
2040,2041
2044,2045
2046,2047
2046,2048
2047,2048
2048,2049
2048,2050
2048,2051
2049,2050
2051,2052
2054,2055
2056,2057
2056,2058
2057,2058
2057,2059
2058,2059
2058,2060
2059,2060
2059,2061
2060,2061
2064,2065
2066,2067
2067,2068
2067,2069
2067,2070
2068,2069
2069,2070
2069,2071
2069,2072
2070,2071
2072,2073
2074,2075
2076,2077
2076,2078
2076,2079
2077,2078
2077,2079
2078,2079
2078,2080
2079,2080
2080,2081
2080,2082
2081,2082
2081,2083
2082,2083
2082,2084
2083,2084
2083,2085
2084,2085
2088,2089
2090,2091
2090,2092
2091,2092
2091,2093
2092,2093
2092,2094
2093,2094
2098,2099
2099,2100
2099,2101
2100,2101
2100,2102
2101,2102
2101,2103
2102,2103
2102,2104
2103,2104
2107,2108
2109,2110
2109,2111
2110,2111
2110,2112
2111,2112
2111,2113
2112,2113
2116,2117
2116,2118
2117,2118
2117,2119
2118,2119
2121,2122
2121,2123
2122,2123
2122,2124
2123,2124
2127,2128
2127,2129
2128,2129
2129,2130
2129,2131
2129,2132
2130,2131
2132,2133
2135,2136
2137,2138
2138,2139
2138,2140
2138,2141
2138,2142
2139,2140
2141,2142
2141,2143
2142,2143
2145,2146
2148,2149
2148,2150
2149,2150
2149,2151
2150,2151
2150,2152
2150,2153
2150,2154
2151,2152
2153,2154
2155,2156
2157,2158
2160,2161
2162,2163
2162,2164
2162,2165
2163,2164
2163,2165
2164,2165
2164,2166
2165,2166
2165,2167
2166,2167
2166,2168
2167,2168
2167,2169
2168,2169
2168,2170
2169,2170
2174,2175
2174,2176
2175,2176
2177,2178
2179,2180
2179,2181
2180,2181
2180,2182
2181,2182
2181,2183
2182,2183
2182,2184
2183,2184
2189,2190
2190,2191
2190,2192
2191,2192
2191,2193
2192,2193
2193,2194
2193,2195
2194,2195
2194,2196
2195,2196
2195,2197
2196,2197
2196,2198
2197,2198
2197,2199
2198,2199
2204,2205
2204,2206
2205,2206
2205,2207
2206,2207
2206,2208
2207,2208
2207,2209
2208,2209
2214,2215
2215,2216
2215,2217
2216,2217
2216,2218
2217,2218
2217,2219
2218,2219
2218,2220
2219,2220
2223,2224
2225,2226
2225,2227
2226,2227
2226,2228
2227,2228
2227,2229
2228,2229
2228,2230
2229,2230
2234,2235
2234,2236
2235,2236
2235,2237
2236,2237
2238,2239
2240,2241
2240,2242
2241,2242
2241,2243
2242,2243
2242,2244
2243,2244
2248,2249
2249,2250
2249,2251
2250,2251
2250,2252
2251,2252
2251,2253
2252,2253
2252,2254
2253,2254
2256,2257
2258,2259
2258,2260
2259,2260
2259,2261
2260,2261
2260,2262
2261,2262
2265,2266
2267,2268
2267,2269
2268,2269
2268,2270
2269,2270
2269,2271
2270,2271
2270,2272
2271,2272
2276,2277
2276,2278
2277,2278
2277,2279
2278,2279
2280,2281
2282,2283
2282,2284
2283,2284
2283,2285
2284,2285
2288,2289
2288,2290
2289,2290
2290,2291
2290,2292
2290,2293
2290,2294
2291,2292
2293,2294
2293,2295
2294,2295
2297,2298
2300,2301
2300,2302
2301,2302
2301,2303
2302,2303
2302,2304
2302,2305
2302,2306
2303,2304
2305,2306
2307,2308
2309,2310
2312,2313
2314,2315
2314,2316
2315,2316
2315,2317
2316,2317
2316,2318
2317,2318
2317,2319
2318,2319
2318,2320
2319,2320
2319,2321
2320,2321
2320,2322
2321,2322
2321,2323
2322,2323
2322,2324
2323,2324
2327,2328
2329,2330
2329,2331
2330,2331
2330,2332
2331,2332
2331,2333
2332,2333
2337,2338
2337,2339
2338,2339
2338,2340
2339,2340
2339,2341
2340,2341
2344,2345
2346,2347
2346,2348
2347,2348
2347,2349
2348,2349
2348,2350
2349,2350
2349,2351
2350,2351
2355,2356
2355,2357
2356,2357
2356,2358
2357,2358
2357,2359
2358,2359
2363,2364
2363,2365
2364,2365
2364,2366
2365,2366
2365,2367
2366,2367
2366,2368
2367,2368
2373,2374
2373,2375
2374,2375
2374,2376
2375,2376
2375,2377
2376,2377
2376,2378
2377,2378
2383,2384
2383,2385
2384,2385
2385,2386
2385,2387
2385,2388
2385,2389
2386,2387
2388,2389
2388,2390
2389,2390
2392,2393
2395,2396
2395,2397
2396,2397
2396,2398
2397,2398
2397,2399
2397,2400
2397,2401
2398,2399
2400,2401
2402,2403
2404,2405
2407,2408
2409,2410
2409,2411
2410,2411
2412,2413
2412,2414
2413,2414
2414,2415
2414,2416
2415,2416
2417,2418
2419,2420
2420,2421
2420,2422
2421,2422
2423,2424
2425,2426
2425,2427
2426,2427
2427,2428
2427,2429
2427,2430
2428,2429
2430,2431
2432,2433
2434,2435
2435,2436
2435,2437
2435,2438
2436,2437
2436,2438
2437,2438
2437,2439
2438,2439
2438,2440
2439,2440
2444,2445
2445,2446
2445,2447
2446,2447
2446,2448
2447,2448
2447,2449
2448,2449
2453,2454
2454,2455
2454,2456
2455,2456
2455,2457
2456,2457
2456,2458
2457,2458
2461,2462
2461,2463
2462,2463
2463,2464
2465,2466
2465,2467
2466,2467
2467,2468
2467,2469
2469,2470
2469,2471
2470,2471
2470,2472
2471,2472
2476,2477
2476,2478
2477,2478
2477,2479
2478,2479
2478,2480
2479,2480
2479,2481
2480,2481
2485,2486
2485,2487
2485,2488
2486,2487
2487,2488
2487,2489
2488,2489
2490,2491
2492,2493
2493,2494
2493,2495
2494,2495
2494,2496
2495,2496
2495,2497
2496,2497
2501,2502
2501,2503
2501,2504
2501,2505
2502,2503
2503,2504
2503,2505
2504,2505
2507,2508
2507,2509
2508,2509
2510,2511
2510,2512
2511,2512
2511,2513
2512,2513
2516,2517
2517,2518
2519,2520
2520,2521
2520,2522
2521,2522
2521,2523
2522,2523
2522,2524
2523,2524
2523,2525
2524,2525
2524,2526
2525,2526
2529,2530
2529,2531
2530,2531
2533,2534
2533,2535
2534,2535
2534,2536
2535,2536
2535,2537
2536,2537
2540,2541
2542,2543
2542,2544
2543,2544
2544,2545
2544,2546
2545,2546
2545,2547
2546,2547
2546,2548
2547,2548
2553,2554
2554,2555
2554,2556
2555,2556
2556,2557
2557,2558
2557,2559
2558,2559
2561,2562
2563,2564
2563,2565
2564,2565
2564,2566
2565,2566
2565,2567
2566,2567
2566,2568
2567,2568
2568,2569
2568,2570
2569,2570
2569,2571
2570,2571
2570,2572
2571,2572
2575,2576
2577,2578
2578,2579
2578,2580
2579,2580
2579,2581
2580,2581
2580,2582
2581,2582
2586,2587
2587,2588
2587,2589
2588,2589
2588,2590
2589,2590
2589,2591
2590,2591
2594,2595
2596,2597
2597,2598
2597,2599
2598,2599
2599,2600
2599,2601
2600,2601
2600,2602
2601,2602
2604,2605
2605,2606
2605,2607
2606,2607
2608,2609
2610,2611
2612,2613
2612,2614
2613,2614
2613,2615
2614,2615
2614,2616
2615,2616
2616,2617
2616,2618
2617,2618
2619,2620
2621,2622
2622,2623
2622,2624
2623,2624
2623,2625
2624,2625
2628,2629
2630,2631
2631,2632
2631,2633
2632,2633
2634,2635
2636,2637
2637,2638
2637,2639
2638,2639
2638,2640
2639,2640
2642,2643
2643,2644
2645,2646
2646,2647
2646,2648
2647,2648
2647,2649
2648,2649
2651,2652
2652,2653
2654,2655
2655,2656
2655,2657
2656,2657
2656,2658
2657,2658
2660,2661
2660,2662
2661,2662
2662,2663
2665,2666
2666,2667
2666,2668
2667,2668
2667,2669
2668,2669
2671,2672
2671,2673
2672,2673
2673,2674
2676,2677
2677,2678
2677,2679
2678,2679
2678,2680
2679,2680
2682,2683
2682,2684
2683,2684
2684,2685
2687,2688
2688,2689
2688,2690
2689,2690
2689,2691
2690,2691
2693,2694
2693,2695
2694,2695
2695,2696
2698,2699
2699,2700
2699,2701
2700,2701
2700,2702
2701,2702
2704,2705
2704,2706
2705,2706
2706,2707
2709,2710
2710,2711
2710,2712
2711,2712
2711,2713
2712,2713
2715,2716
2715,2717
2716,2717
2718,2719
2720,2721
2720,2722
2721,2722
2722,2723
2722,2724
2723,2724
2726,2727
2726,2728
2727,2728
2728,2729
2728,2730
2728,2731
2728,2732
2729,2730
2731,2732
2731,2733
2732,2733
2735,2736
2738,2739
2739,2740
2741,2742
2741,2743
2741,2744
2742,2743
2742,2744
2743,2744
2745,2746
2747,2748
2747,2749
2748,2749
2749,2750
2749,2751
2750,2751
2750,2752
2751,2752
2754,2755
2754,2756
2755,2756
2757,2758
2759,2760
2759,2761
2760,2761
2761,2762
2761,2763
2762,2763
2765,2766
2765,2767
2766,2767
2767,2768
2767,2769
2767,2770
2767,2771
2768,2769
2770,2771
2770,2772
2771,2772
2774,2775
2777,2778
2778,2779
2780,2781
2781,2782
2781,2783
2782,2783
2783,2784
2783,2785
2784,2785
2786,2787
2788,2789
2788,2790
2789,2790
2790,2791
2790,2792
2790,2793
2790,2794
2791,2792
2793,2794
2793,2795
2794,2795
2797,2798
2800,2801
2801,2802
2803,2804
2804,2805
2806,2807
2806,2808
2808,2809
2808,2810
2809,2810
2811,2812
2812,2813
2812,2814
2813,2814
2815,2816
2817,2818
2818,2819
-----nextToken-----
2,4,7,9,10,14,16,17,19,23,25,26,30,32,36,38,39,43,45,49,51,52,56,58,61,65,67,72,73,76,77,82,84,87,88,90,97,98,100,105,106,110,113,114,118,121,123,125,128,132,133,137,141,145,147,149,151,156,158,159,163,165,171,173,176,177,180,182,186,189,194,196,197,201,203,209,212,213,216,219,220,223,225,229,232,238,239,242,243,248,249,251,256,257,260,265,266,269,273,275,279,281,285,287,289,291,295,298,300,302,304,306,309,315,317,319,320,322,327,328,330,334,337,339,341,343,345,348,353,355,359,361,365,368,370,372,375,379,381,385,388,390,392,395,399,401,406,408,410,412,413,414,416,421,423,425,427,429,434,435,437,443,445,447,449,451,457,458,461,463,466,468,472,475,481,482,484,489,491,494,495,498,502,504,509,512,513,515,516,519,520,523,524,529,531,534,536,539,540,544,545,548,549,550,555,558,559,561,562,565,566,569,570,575,576,578,583,585,588,589,592,596,599,601,606,607,609,614,618,619,621,626,627,629,634,635,637,642,643,647,650,653,656,660,662,665,666,667,670,673,676,679,682,685,688,691,694,699,701,703,704,706,711,712,714,715,723,724,725,727,733,734,735,737,743,745,747,751,754,756,758,760,762,768,769,774,775,776,781,784,786,788,790,792,798,799,804,805,806,813,814,815,817,821,824,825,827,828,833,835,837,842,844,845,847,852,854,856,863,864,865,868,870,876,877,878,882,883,884,890,891,892,896,897,898,904,905,906,910,911,912,917,918,921,928,929,930,933,935,940,941,943,949,950,951,956,959,960,962,963,967,969,970,971,973,979,980,981,985,986,987,993,994,995,997,1003,1004,1005,1009,1010,1011,1016,1018,1020,1030,1031,1032,1034,1039,1041,1042,1048,1049,1050,1051,1056,1058,1060,1065,1067,1071,1073,1074,1075,1077,1083,1084,1087,1089,1092,1094,1098,1101,1106,1107,1111,1112,1115,1118,1121,1124,1127,1132,1134,1138,1140,1144,1147,1149,1151,1154,1158,1160,1164,1167,1169,1171,1174,1178,1180,1185,1188,1190,1193,1194,1198,1200,1202,1204,1207,1210,1211,1212,1213,1215,1220,1222,1225,1226,1228,1230,1231,1234,1237,1241,1243,1244,1248,1250,1254,1256,1259,1261,1266,1267,1271,1272,1276,1277,1278,1282,1284,1288,1291,1293,1295,1298,1302,1304,1309,1312,1314,1317,1318,1322,1324,1326,1328,1331,1334,1335,1336,1337,1339,1343,1346,1347,1352,1353,1355,1359,1362,1364,1367,1368,1370,1375,1376,1378,1382,1384,1388,1390,1391,1394,1397,1402,1404,1406,1410,1411,1412,1417,1418,1419,1421,1422,1425,1428,1433,1435,1437,1441,1442,1443,1448,1449,1450,1452,1453,1456,1459,1464,1466,1470,1472,1476,1478,1482,1484,1488,1490,1491,1494,1498,1501,1505,1506,1507,1514,1515,1517,1522,1523,1527,1528,1530,1535,1537,1541,1542,1547,1549,1551,1555,1557,1562,1563,1567,1568,1570,1574,1576,1580,1583,1585,1587,1590,1594,1596,1601,1604,1606,1609,1610,1614,1616,1618,1620,1623,1626,1627,1628,1629,1634,1636,1639,1640,1642,1645,1647,1650,1652,1654,1658,1660,1661,1664,1669,1671,1675,1677,1682,1684,1686,1689,1691,1695,1699,1703,1705,1706,1709,1713,1715,1716,1717,1721,1722,1723,1727,1728,1732,1734,1736,1738,1739,1740,1744,1745,1748,1750,1752,1754,1755,1761,1762,1763,1765,1771,1773,1775,1780,1783,1784,1786,1787,1792,1794,1796,1798,1800,1806,1807,1808,1810,1817,1818,1819,1821,1825,1828,1829,1831,1832,1837,1839,1841,1846,1849,1850,1852,1853,1858,1860,1862,1863,1865,1870,1872,1874,1881,1882,1883,1885,1890,1893,1894,1896,1897,1902,1904,1906,1907,1909,1915,1916,1917,1919,1924,1927,1928,1930,1931,1936,1938,1940,1941,1943,1951,1952,1953,1955,1961,1962,1963,1965,1971,1973,1975,1976,1978,1985,1986,1987,1989,1993,1995,1997,2005,2006,2007,2008,2013,2014,2015,2016,2022,2023,2024,2026,2032,2033,2034,2035,2041,2042,2043,2045,2050,2052,2053,2055,2061,2062,2063,2065,2071,2073,2075,2085,2086,2087,2089,2094,2095,2096,2097,2104,2105,2106,2108,2113,2114,2115,2119,2120,2124,2125,2126,2131,2133,2134,2136,2140,2143,2144,2146,2147,2152,2154,2156,2158,2159,2161,2170,2171,2172,2173,2176,2178,2184,2185,2186,2187,2188,2199,2200,2201,2202,2203,2209,2210,2211,2212,2213,2220,2221,2222,2224,2230,2231,2232,2233,2237,2239,2244,2245,2246,2247,2254,2255,2257,2262,2263,2264,2266,2272,2273,2274,2275,2279,2281,2285,2286,2287,2292,2295,2296,2298,2299,2304,2306,2308,2310,2311,2313,2324,2325,2326,2328,2333,2334,2335,2336,2341,2342,2343,2345,2351,2352,2353,2354,2359,2360,2361,2362,2368,2369,2370,2371,2372,2378,2379,2380,2381,2382,2387,2390,2391,2393,2394,2399,2401,2403,2405,2406,2408,2411,2416,2418,2422,2424,2429,2431,2433,2440,2441,2442,2443,2449,2450,2451,2452,2458,2459,2460,2464,2468,2472,2473,2474,2475,2481,2482,2483,2484,2489,2491,2497,2498,2499,2500,2505,2506,2509,2513,2514,2515,2518,2526,2527,2528,2531,2532,2537,2538,2539,2541,2548,2549,2550,2551,2552,2559,2560,2562,2572,2573,2574,2576,2582,2583,2584,2585,2591,2592,2593,2595,2602,2603,2607,2609,2611,2618,2620,2625,2626,2627,2629,2633,2635,2640,2641,2644,2649,2650,2653,2658,2659,2663,2664,2669,2670,2674,2675,2680,2681,2685,2686,2691,2692,2696,2697,2702,2703,2707,2708,2713,2714,2717,2719,2724,2725,2730,2733,2734,2736,2737,2740,2744,2746,2752,2753,2756,2758,2763,2764,2769,2772,2773,2775,2776,2779,2785,2787,2792,2795,2796,2798,2799,2802,2805,2807,2810,2814,2816,2819
-----computeFrom-----
69,70
69,71
108,109
108,110
116,117
116,118
169,170
169,171
174,175
174,176
178,179
178,180
207,208
207,209
210,211
210,212
214,215
214,216
217,218
217,219
221,222
221,223
235,236
235,237
245,246
245,247
253,254
253,255
262,263
262,264
293,294
293,295
324,325
324,326
332,333
332,334
363,364
363,365
377,378
377,379
383,384
383,385
397,398
397,399
431,432
431,433
455,456
455,457
459,460
459,461
464,465
464,466
478,479
478,480
500,501
500,502
572,573
572,574
597,598
597,599
603,604
603,605
612,613
612,614
623,624
623,625
631,632
631,633
708,709
708,710
717,718
717,719
719,720
719,721
729,730
729,731
749,750
749,751
764,765
764,766
766,767
766,768
771,772
771,773
779,780
779,781
794,795
794,796
796,797
796,798
801,802
801,803
809,810
809,811
859,860
859,861
872,873
872,874
886,887
886,888
900,901
900,902
914,915
914,916
924,925
924,926
937,938
937,939
975,976
975,977
989,990
989,991
999,1000
999,1001
1023,1024
1023,1025
1024,1025
1024,1026
1026,1027
1026,1028
1036,1037
1036,1038
1044,1045
1044,1046
1081,1082
1081,1083
1085,1086
1085,1087
1090,1091
1090,1092
1142,1143
1142,1144
1156,1157
1156,1158
1162,1163
1162,1164
1176,1177
1176,1178
1183,1184
1183,1185
1263,1264
1263,1265
1280,1281
1280,1282
1286,1287
1286,1288
1300,1301
1300,1302
1307,1308
1307,1309
1341,1342
1341,1343
1349,1350
1349,1351
1357,1358
1357,1359
1372,1373
1372,1374
1496,1497
1496,1498
1500,1501
1500,1502
1509,1510
1509,1511
1511,1512
1511,1513
1519,1520
1519,1521
1533,1534
1533,1535
1539,1540
1539,1541
1545,1546
1545,1547
1548,1549
1548,1550
1553,1554
1553,1555
1559,1560
1559,1561
1572,1573
1572,1574
1578,1579
1578,1580
1592,1593
1592,1594
1599,1600
1599,1601
1643,1644
1643,1645
1648,1649
1648,1650
1651,1652
1651,1653
1679,1680
1679,1681
1701,1702
1701,1703
1711,1712
1711,1713
1719,1720
1719,1721
1725,1726
1725,1727
1757,1758
1757,1759
1802,1803
1802,1804
1813,1814
1813,1815
1877,1878
1877,1879
1911,1912
1911,1913
1945,1946
1945,1947
1947,1948
1947,1949
1957,1958
1957,1959
1980,1981
1980,1982
1981,1982
1981,1983
2000,2001
2000,2002
2001,2002
2001,2003
2009,2010
2009,2011
2018,2019
2018,2020
2028,2029
2028,2030
2037,2038
2037,2039
2057,2058
2057,2059
2078,2079
2078,2080
2080,2081
2080,2082
2081,2082
2081,2083
2090,2091
2090,2092
2099,2100
2099,2101
2100,2101
2100,2102
2109,2110
2109,2111
2149,2150
2149,2151
2163,2164
2163,2165
2164,2165
2164,2166
2165,2166
2165,2167
2166,2167
2166,2168
2179,2180
2179,2181
2190,2191
2190,2192
2191,2192
2191,2193
2193,2194
2193,2195
2194,2195
2194,2196
2204,2205
2204,2206
2215,2216
2215,2217
2216,2217
2216,2218
2225,2226
2225,2227
2234,2235
2234,2236
2249,2250
2249,2251
2250,2251
2250,2252
2251,2252
2251,2253
2258,2259
2258,2260
2267,2268
2267,2269
2276,2277
2276,2278
2301,2302
2301,2303
2315,2316
2315,2317
2316,2317
2316,2318
2317,2318
2317,2319
2318,2319
2318,2320
2319,2320
2319,2321
2320,2321
2320,2322
2329,2330
2329,2331
2337,2338
2337,2339
2346,2347
2346,2348
2363,2364
2363,2365
2373,2374
2373,2375
2396,2397
2396,2398
2420,2421
2420,2422
2436,2437
2436,2438
2445,2446
2445,2447
2454,2455
2454,2456
2465,2466
2465,2467
2467,2468
2467,2469
2477,2478
2477,2479
2493,2494
2493,2495
2503,2504
2503,2505
2507,2508
2507,2509
2521,2522
2521,2523
2529,2530
2529,2531
2544,2545
2544,2546
2564,2565
2564,2566
2565,2566
2565,2567
2566,2567
2566,2568
2568,2569
2568,2570
2578,2579
2578,2580
2587,2588
2587,2589
2597,2598
2597,2599
2599,2600
2599,2601
2605,2606
2605,2607
2614,2615
2614,2616
2637,2638
2637,2639
2646,2647
2646,2648
2655,2656
2655,2657
2660,2661
2660,2662
2666,2667
2666,2668
2671,2672
2671,2673
2677,2678
2677,2679
2682,2683
2682,2684
2688,2689
2688,2690
2693,2694
2693,2695
2699,2700
2699,2701
2704,2705
2704,2706
2710,2711
2710,2712
2749,2750
2749,2751
-----guardedBy-----
243,249
242,248
379,385
399,410
482,589
481,588
484,578
502,599
504,601
607,712
606,711
609,714
733,824
734,814
735,815
775,805
774,804
993,1009
994,1010
1048,1058
1158,1164
1178,1202
1302,1326
1530,1537
1594,1618
1684,1734
1689,1695
1727,1738
1761,1973
1762,1962
1806,1828
1807,1818
1808,1819
1881,1904
1915,1938
1961,1973
1995,2052
1986,2042
1987,2043
2013,2022
2014,2023
2032,2041
2033,2042
2061,2401
2063,2343
2062,2379
2124,2133
2184,2306
2378,2401
2440,2449
2441,2450
2481,2548
2482,2549
2483,2515
2537,2548
2538,2549
2602,2635
2592,2626
-----guardedByNegation-----
627,666
626,665
1048,1073
1039,1071
1276,1293
1266,1295
1530,1557
1562,1587
1915,1973
1916,1962
1917,1963
2013,2052
2014,2042
2007,2034
2032,2052
2184,2401
2185,2379
2172,2335
2440,2472
2441,2473
2442,2474
-----lastLexicalUse-----
1048,1073
1530,1557
1915,1973
2013,2052
2014,2042
2032,2052
2184,2401
2440,2472
2441,2473
-----jump-----
1048,1073
1530,1557
1915,1973
2013,2052
2014,2042
2032,2052
2184,2401
2440,2472
2441,2473
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ProblemStatement;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;LabelStatement;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
intTIFFReadDirectory(TIFF* tif){	static const char module[] = "TIFFReadDirectory";	TIFFDirEntry* dir;	uint16 dircount;	TIFFDirEntry* dp;	uint16 di;	const TIFFField* fip;	uint32 fii=FAILED_FII;        toff_t nextdiroff;	tif->tif_diroff=tif->tif_nextdiroff;	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))		return 0;           /* last offset or bad offset (IFD looping) */	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */	tif->tif_curdir++;        nextdiroff = tif->tif_nextdiroff;	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);	if (!dircount)	{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}	TIFFReadDirectoryCheckOrder(tif,dir,dircount);        /*         * Mark duplicates of any tag to be ignored (bugzilla 1994)         * to avoid certain pathological problems.         */	{		TIFFDirEntry* ma;		uint16 mb;		for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}	}        	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */	/* free any old stuff and reinit */	TIFFFreeDirectory(tif);	TIFFDefaultDirectory(tif);	/*	 * Electronic Arts writes gray-scale TIFF files	 * without a PlanarConfiguration directory entry.	 * Thus we setup a default value here, even though	 * the TIFF spec says there is no default value.	 */	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);	/*	 * Setup default value and then make a pass over	 * the fields to check type and tag information,	 * and to extract info required to size data	 * structures.  A second pass is made afterwards	 * to read in everthing not taken in the first pass.	 * But we must process the Compression tag first	 * in order to merge in codec-private tag definitions (otherwise	 * we may get complaints about unknown tags).  However, the	 * Compression tag may be dependent on the SamplesPerPixel	 * tag value because older TIFF specs permited Compression	 * to be written as a SamplesPerPixel-count tag entry.	 * Thus if we don't first figure out the correct SamplesPerPixel	 * tag value then we may end up ignoring the Compression tag	 * value because it has an incorrect count value (if the	 * true value of SamplesPerPixel is not 1).	 */	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);	if (dp)	{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);	if (dp)	{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}	else	{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}	/*	 * First real pass over the directory.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}		}	}	/*	 * XXX: OJPEG hack.	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,	 * c) strip offsets/bytecounts tag are both present and	 * d) both contain exactly one value, then we consistently find	 * that the buggy implementation of the buggy compression scheme	 * matches contig planarconfig best. So we 'fix-up' the tag here	 */	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))	{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}	/*	 * Allocate directory structure and setup defaults.	 */	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))	{		MissingRequired(tif,"ImageLength");		goto bad;	}	/*	 * Setup appropriate structures (by strip or by tile)	 */	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	} else {		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}	if (!tif->tif_dir.td_nstrips) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}	/*	 * Second pass: extract other information.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yech). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}	/*	 * OJPEG hack:	 * - If a) compression is OJPEG, and b) photometric tag is missing,	 * then we consistently find that photometric should be YCbCr	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,	 * then we consistently find that the buggy implementation of the	 * buggy compression scheme matches photometric YCbCr instead.	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,	 * then we consistently find bitspersample should be 8.	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is RGB or YCbCr, then we consistently find	 * samplesperpixel should be 3	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently	 * find samplesperpixel should be 3	 */	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)	{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}	/*	 * Verify Palette image has a Colormap.	 */	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}	/*	 * OJPEG hack:	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG	 * TIFFs	 */	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)	{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}	if (dir)	{		_TIFFfree(dir);		dir=NULL;	}	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))	{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}	/*	 * XXX: We can optimize checking for the strip bounds using the sorted	 * bytecounts array. See also comments for TIFFAppendToStrip()	 * function in tif_write.c.	 */#if !defined(DEFER_STRILE_LOAD)        	if (tif->tif_dir.td_nstrips > 1) {		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}#endif /* !defined(DEFER_STRILE_LOAD) */        	/*	 * An opportunity for compression mode dependent tag fixup	 */	(*tif->tif_fixuptags)(tif);	/*	 * Some manufacturers make life difficult by writing	 * large amounts of uncompressed data as a single strip.	 * This is contrary to the recommendations of the spec.	 * The following makes an attempt at breaking such images	 * into strips closer to the recommended 8k bytes.  A	 * side effect, however, is that the RowsPerStrip tag	 * value may be changed.	 */	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))    {        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }        /*         * Clear the dirty directory flag.          */	tif->tif_flags &= ~TIFF_DIRTYDIRECT;	tif->tif_flags &= ~TIFF_DIRTYSTRIP;	/*	 * Reinitialize i/o since we are starting on a new directory.	 */	tif->tif_row = (uint32) -1;	tif->tif_curstrip = (uint32) -1;	tif->tif_col = (uint32) -1;	tif->tif_curtile = (uint32) -1;	tif->tif_tilesize = (tmsize_t) -1;	tif->tif_scanlinesize = TIFFScanlineSize(tif);	if (!tif->tif_scanlinesize) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}	if (isTiled(tif)) {		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	} else {		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}	return (1);bad:	if (dir)		_TIFFfree(dir);	return (0);}
int
TIFFReadDirectory(TIFF* tif)
TIFFReadDirectory
TIFF* tif
TIFF
TIFF
* tif
*
tif
{	static const char module[] = "TIFFReadDirectory";	TIFFDirEntry* dir;	uint16 dircount;	TIFFDirEntry* dp;	uint16 di;	const TIFFField* fip;	uint32 fii=FAILED_FII;        toff_t nextdiroff;	tif->tif_diroff=tif->tif_nextdiroff;	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))		return 0;           /* last offset or bad offset (IFD looping) */	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */	tif->tif_curdir++;        nextdiroff = tif->tif_nextdiroff;	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);	if (!dircount)	{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}	TIFFReadDirectoryCheckOrder(tif,dir,dircount);        /*         * Mark duplicates of any tag to be ignored (bugzilla 1994)         * to avoid certain pathological problems.         */	{		TIFFDirEntry* ma;		uint16 mb;		for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}	}        	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */	/* free any old stuff and reinit */	TIFFFreeDirectory(tif);	TIFFDefaultDirectory(tif);	/*	 * Electronic Arts writes gray-scale TIFF files	 * without a PlanarConfiguration directory entry.	 * Thus we setup a default value here, even though	 * the TIFF spec says there is no default value.	 */	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);	/*	 * Setup default value and then make a pass over	 * the fields to check type and tag information,	 * and to extract info required to size data	 * structures.  A second pass is made afterwards	 * to read in everthing not taken in the first pass.	 * But we must process the Compression tag first	 * in order to merge in codec-private tag definitions (otherwise	 * we may get complaints about unknown tags).  However, the	 * Compression tag may be dependent on the SamplesPerPixel	 * tag value because older TIFF specs permited Compression	 * to be written as a SamplesPerPixel-count tag entry.	 * Thus if we don't first figure out the correct SamplesPerPixel	 * tag value then we may end up ignoring the Compression tag	 * value because it has an incorrect count value (if the	 * true value of SamplesPerPixel is not 1).	 */	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);	if (dp)	{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);	if (dp)	{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}	else	{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}	/*	 * First real pass over the directory.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}		}	}	/*	 * XXX: OJPEG hack.	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,	 * c) strip offsets/bytecounts tag are both present and	 * d) both contain exactly one value, then we consistently find	 * that the buggy implementation of the buggy compression scheme	 * matches contig planarconfig best. So we 'fix-up' the tag here	 */	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))	{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}	/*	 * Allocate directory structure and setup defaults.	 */	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))	{		MissingRequired(tif,"ImageLength");		goto bad;	}	/*	 * Setup appropriate structures (by strip or by tile)	 */	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	} else {		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}	if (!tif->tif_dir.td_nstrips) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}	/*	 * Second pass: extract other information.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yech). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}	/*	 * OJPEG hack:	 * - If a) compression is OJPEG, and b) photometric tag is missing,	 * then we consistently find that photometric should be YCbCr	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,	 * then we consistently find that the buggy implementation of the	 * buggy compression scheme matches photometric YCbCr instead.	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,	 * then we consistently find bitspersample should be 8.	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is RGB or YCbCr, then we consistently find	 * samplesperpixel should be 3	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently	 * find samplesperpixel should be 3	 */	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)	{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}	/*	 * Verify Palette image has a Colormap.	 */	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}	/*	 * OJPEG hack:	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG	 * TIFFs	 */	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)	{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}	if (dir)	{		_TIFFfree(dir);		dir=NULL;	}	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))	{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}	/*	 * XXX: We can optimize checking for the strip bounds using the sorted	 * bytecounts array. See also comments for TIFFAppendToStrip()	 * function in tif_write.c.	 */#if !defined(DEFER_STRILE_LOAD)        	if (tif->tif_dir.td_nstrips > 1) {		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}#endif /* !defined(DEFER_STRILE_LOAD) */        	/*	 * An opportunity for compression mode dependent tag fixup	 */	(*tif->tif_fixuptags)(tif);	/*	 * Some manufacturers make life difficult by writing	 * large amounts of uncompressed data as a single strip.	 * This is contrary to the recommendations of the spec.	 * The following makes an attempt at breaking such images	 * into strips closer to the recommended 8k bytes.  A	 * side effect, however, is that the RowsPerStrip tag	 * value may be changed.	 */	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))    {        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }        /*         * Clear the dirty directory flag.          */	tif->tif_flags &= ~TIFF_DIRTYDIRECT;	tif->tif_flags &= ~TIFF_DIRTYSTRIP;	/*	 * Reinitialize i/o since we are starting on a new directory.	 */	tif->tif_row = (uint32) -1;	tif->tif_curstrip = (uint32) -1;	tif->tif_col = (uint32) -1;	tif->tif_curtile = (uint32) -1;	tif->tif_tilesize = (tmsize_t) -1;	tif->tif_scanlinesize = TIFFScanlineSize(tif);	if (!tif->tif_scanlinesize) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}	if (isTiled(tif)) {		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	} else {		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}	return (1);bad:	if (dir)		_TIFFfree(dir);	return (0);}
static const char module[] = "TIFFReadDirectory";
static const char module[] = "TIFFReadDirectory";
static const char
module[] = "TIFFReadDirectory"
module
[]
= "TIFFReadDirectory"
"TIFFReadDirectory"
TIFFDirEntry* dir;
TIFFDirEntry* dir;
TIFFDirEntry
TIFFDirEntry
* dir
*
dir
uint16 dircount;
uint16 dircount;
uint16
uint16
dircount
dircount
TIFFDirEntry* dp;
TIFFDirEntry* dp;
TIFFDirEntry
TIFFDirEntry
* dp
*
dp
uint16 di;
uint16 di;
uint16
uint16
di
di
const TIFFField* fip;
const TIFFField* fip;
const TIFFField
TIFFField
* fip
*
fip
uint32 fii=FAILED_FII;
uint32 fii=FAILED_FII;
uint32
uint32
fii=FAILED_FII
fii
=FAILED_FII
FAILED_FII
FAILED_FII
toff_t nextdiroff;
toff_t nextdiroff;
toff_t
toff_t
nextdiroff
nextdiroff
tif->tif_diroff=tif->tif_nextdiroff;
tif->tif_diroff=tif->tif_nextdiroff
tif->tif_diroff
tif
tif
tif_diroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))		return 0;
!TIFFCheckDirOffset(tif,tif->tif_nextdiroff)
TIFFCheckDirOffset(tif,tif->tif_nextdiroff)
TIFFCheckDirOffset
TIFFCheckDirOffset
tif
tif
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
return 0;
0
(*tif->tif_cleanup)(tif);
(*tif->tif_cleanup)(tif)
(*tif->tif_cleanup)
*tif->tif_cleanup
tif->tif_cleanup
tif
tif
tif_cleanup
tif
tif
tif->tif_curdir++;
tif->tif_curdir++
tif->tif_curdir
tif
tif
tif_curdir
nextdiroff = tif->tif_nextdiroff;
nextdiroff = tif->tif_nextdiroff
nextdiroff
nextdiroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff)
dircount
dircount
TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff)
TIFFFetchDirectory
TIFFFetchDirectory
tif
tif
nextdiroff
nextdiroff
&dir
dir
dir
&tif->tif_nextdiroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
if (!dircount)	{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}
!dircount
dircount
dircount
{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}
TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);
return 0;
0
TIFFReadDirectoryCheckOrder(tif,dir,dircount);
TIFFReadDirectoryCheckOrder(tif,dir,dircount)
TIFFReadDirectoryCheckOrder
TIFFReadDirectoryCheckOrder
tif
tif
dir
dir
dircount
dircount
{		TIFFDirEntry* ma;		uint16 mb;		for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}	}
TIFFDirEntry* ma;
TIFFDirEntry* ma;
TIFFDirEntry
TIFFDirEntry
* ma
*
ma
uint16 mb;
uint16 mb;
uint16
uint16
mb
mb
for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}
ma=dir, mb=0;
ma=dir, mb=0
ma=dir
ma
ma
dir
dir
mb=0
mb
mb
0
mb<dircount
mb
mb
dircount
dircount
ma++, mb++
ma++
ma
ma
mb++
mb
mb
{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}
TIFFDirEntry* na;
TIFFDirEntry* na;
TIFFDirEntry
TIFFDirEntry
* na
*
na
uint16 nb;
uint16 nb;
uint16
uint16
nb
nb
for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}
na=ma+1, nb=mb+1;
na=ma+1, nb=mb+1
na=ma+1
na
na
ma+1
ma
ma
1
nb=mb+1
nb
nb
mb+1
mb
mb
1
nb<dircount
nb
nb
dircount
dircount
na++, nb++
na++
na
na
nb++
nb
nb
{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}
if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;
ma->tdir_tag==na->tdir_tag
ma->tdir_tag
ma
ma
tdir_tag
na->tdir_tag
na
na
tdir_tag
na->tdir_tag=IGNORE;
na->tdir_tag=IGNORE
na->tdir_tag
na
na
tdir_tag
IGNORE
IGNORE
tif->tif_flags &= ~TIFF_BEENWRITING;
tif->tif_flags &= ~TIFF_BEENWRITING
tif->tif_flags
tif
tif
tif_flags
~TIFF_BEENWRITING
TIFF_BEENWRITING
TIFF_BEENWRITING
tif->tif_flags &= ~TIFF_BUF4WRITE;
tif->tif_flags &= ~TIFF_BUF4WRITE
tif->tif_flags
tif
tif
tif_flags
~TIFF_BUF4WRITE
TIFF_BUF4WRITE
TIFF_BUF4WRITE
TIFFFreeDirectory(tif);
TIFFFreeDirectory(tif)
TIFFFreeDirectory
TIFFFreeDirectory
tif
tif
TIFFDefaultDirectory(tif);
TIFFDefaultDirectory(tif)
TIFFDefaultDirectory
TIFFDefaultDirectory
tif
tif
TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_PLANARCONFIG
TIFFTAG_PLANARCONFIG
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
if (dp)	{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}
dp
dp
{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}
if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;
!TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag
TIFFFetchNormalTag
tif
tif
dp
dp
0
goto bad;
bad
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
if (dp)	{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}	else	{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}
dp
dp
{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}
uint16 value;
uint16 value;
uint16
uint16
value
value
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
err=TIFFReadDirEntryShort(tif,dp,&value);
err=TIFFReadDirEntryShort(tif,dp,&value)
err
err
TIFFReadDirEntryShort(tif,dp,&value)
TIFFReadDirEntryShort
TIFFReadDirEntryShort
tif
tif
dp
dp
&value
value
value
if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err==TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err=TIFFReadDirEntryPersampleShort(tif,dp,&value)
err
err
TIFFReadDirEntryPersampleShort(tif,dp,&value)
TIFFReadDirEntryPersampleShort
TIFFReadDirEntryPersampleShort
tif
tif
dp
dp
&value
value
value
if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}
TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);
TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
"Compression"
0
goto bad;
bad
if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;
!TIFFSetField(tif,TIFFTAG_COMPRESSION,value)
TIFFSetField(tif,TIFFTAG_COMPRESSION,value)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
value
value
goto bad;
bad
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}
if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;
!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE)
TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
COMPRESSION_NONE
COMPRESSION_NONE
goto bad;
bad
for (di=0, dp=dir; di<dircount; di++, dp++)	{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}		}	}
di=0, dp=dir;
di=0, dp=dir
di=0
di
di
0
dp=dir
dp
dp
dir
dir
di<dircount
di
di
dircount
dircount
di++, dp++
di++
di
di
dp++
dp
dp
{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}		}	}
if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}
dp->tdir_tag!=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii)
TIFFReadDirectoryFindFieldInfo
TIFFReadDirectoryFindFieldInfo
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
&fii
fii
fii
if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}
fii == FAILED_FII
fii
fii
FAILED_FII
FAILED_FII
{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}
TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Unknown field with tag %d (0x%x) encountered"
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag
dp
dp
tdir_tag
if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}
!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)
_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)
_TIFFMergeFields
_TIFFMergeFields
tif
tif
_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type)
_TIFFCreateAnonField
_TIFFCreateAnonField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
(TIFFDataType) dp->tdir_type
TIFFDataType
TIFFDataType
TIFFDataType

dp->tdir_type
dp
dp
tdir_type
1
{					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				}
TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Registering anonymous field with tag %d (0x%x) failed"
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii)
TIFFReadDirectoryFindFieldInfo
TIFFReadDirectoryFindFieldInfo
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
&fii
fii
fii
assert(fii != FAILED_FII);
assert(fii != FAILED_FII)
assert
assert
fii != FAILED_FII
fii
fii
FAILED_FII
FAILED_FII
if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}		}
dp->tdir_tag!=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}		}
fip=tif->tif_fields[fii];
fip=tif->tif_fields[fii]
fip
fip
tif->tif_fields[fii]
tif->tif_fields
tif
tif
tif_fields
fii
fii
if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}
fip->field_bit==FIELD_IGNORE
fip->field_bit
fip
fip
field_bit
FIELD_IGNORE
FIELD_IGNORE
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}			}
switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}
dp->tdir_tag
dp
dp
tdir_tag
{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;				}
case TIFFTAG_STRIPOFFSETS:
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
case TIFFTAG_STRIPBYTECOUNTS:
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
case TIFFTAG_TILEOFFSETS:
TIFFTAG_TILEOFFSETS
TIFFTAG_TILEOFFSETS
case TIFFTAG_TILEBYTECOUNTS:
TIFFTAG_TILEBYTECOUNTS
TIFFTAG_TILEBYTECOUNTS
TIFFSetFieldBit(tif,fip->field_bit);
TIFFSetFieldBit(tif,fip->field_bit)
TIFFSetFieldBit
TIFFSetFieldBit
tif
tif
fip->field_bit
fip
fip
field_bit
break;
case TIFFTAG_IMAGEWIDTH:
TIFFTAG_IMAGEWIDTH
TIFFTAG_IMAGEWIDTH
case TIFFTAG_IMAGELENGTH:
TIFFTAG_IMAGELENGTH
TIFFTAG_IMAGELENGTH
case TIFFTAG_IMAGEDEPTH:
TIFFTAG_IMAGEDEPTH
TIFFTAG_IMAGEDEPTH
case TIFFTAG_TILELENGTH:
TIFFTAG_TILELENGTH
TIFFTAG_TILELENGTH
case TIFFTAG_TILEWIDTH:
TIFFTAG_TILEWIDTH
TIFFTAG_TILEWIDTH
case TIFFTAG_TILEDEPTH:
TIFFTAG_TILEDEPTH
TIFFTAG_TILEDEPTH
case TIFFTAG_PLANARCONFIG:
TIFFTAG_PLANARCONFIG
TIFFTAG_PLANARCONFIG
case TIFFTAG_ROWSPERSTRIP:
TIFFTAG_ROWSPERSTRIP
TIFFTAG_ROWSPERSTRIP
case TIFFTAG_EXTRASAMPLES:
TIFFTAG_EXTRASAMPLES
TIFFTAG_EXTRASAMPLES
if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;
!TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag
TIFFFetchNormalTag
tif
tif
dp
dp
0
goto bad;
bad
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
break;
if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))	{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}
(tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE)
(tif->tif_dir.td_compression==COMPRESSION_OJPEG)
tif->tif_dir.td_compression==COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
(tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE)
tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_SEPARATE
PLANARCONFIG_SEPARATE
{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}
if (!_TIFFFillStriles(tif))            goto bad;
!_TIFFFillStriles(tif)
_TIFFFillStriles(tif)
_TIFFFillStriles
_TIFFFillStriles
tif
tif
goto bad;
bad
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}
(dp!=0)&&(dp->tdir_count==1)
(dp!=0)
dp!=0
dp
dp
0
(dp->tdir_count==1)
dp->tdir_count==1
dp->tdir_count
dp
dp
tdir_count
1
{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}
(dp!=0)&&(dp->tdir_count==1)
(dp!=0)
dp!=0
dp
dp
0
(dp->tdir_count==1)
dp->tdir_count==1
dp->tdir_count
dp
dp
tdir_count
1
{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}
tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");
TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky"
if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))	{		MissingRequired(tif,"ImageLength");		goto bad;	}
!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)
TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_IMAGEDIMENSIONS
FIELD_IMAGEDIMENSIONS
{		MissingRequired(tif,"ImageLength");		goto bad;	}
MissingRequired(tif,"ImageLength");
MissingRequired(tif,"ImageLength")
MissingRequired
MissingRequired
tif
tif
"ImageLength"
goto bad;
bad
if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	} else {		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}
!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)
TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_TILEDIMENSIONS
FIELD_TILEDIMENSIONS
{		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	}
tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);
tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif)
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
TIFFNumberOfStrips(tif)
TIFFNumberOfStrips
TIFFNumberOfStrips
tif
tif
tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth
tif->tif_dir.td_tilewidth
tif->tif_dir
tif
tif
tif_dir
td_tilewidth
tif->tif_dir.td_imagewidth
tif->tif_dir
tif
tif
tif_dir
td_imagewidth
tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip
tif->tif_dir.td_tilelength
tif->tif_dir
tif
tif
tif_dir
td_tilelength
tif->tif_dir.td_rowsperstrip
tif->tif_dir
tif
tif
tif_dir
td_rowsperstrip
tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth
tif->tif_dir.td_tiledepth
tif->tif_dir
tif
tif
tif_dir
td_tiledepth
tif->tif_dir.td_imagedepth
tif->tif_dir
tif
tif
tif_dir
td_imagedepth
tif->tif_flags &= ~TIFF_ISTILED;
tif->tif_flags &= ~TIFF_ISTILED
tif->tif_flags
tif
tif
tif_flags
~TIFF_ISTILED
TIFF_ISTILED
TIFF_ISTILED
{		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}
tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif)
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
TIFFNumberOfTiles(tif)
TIFFNumberOfTiles
TIFFNumberOfTiles
tif
tif
tif->tif_flags |= TIFF_ISTILED;
tif->tif_flags |= TIFF_ISTILED
tif->tif_flags
tif
tif
tif_flags
TIFF_ISTILED
TIFF_ISTILED
if (!tif->tif_dir.td_nstrips) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}
!tif->tif_dir.td_nstrips
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
{		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero number of %s"
isTiled(tif) ? "tiles" : "strips"
isTiled(tif)
isTiled
isTiled
tif
tif
"tiles"
"strips"
goto bad;
bad
tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips
tif->tif_dir.td_stripsperimage
tif->tif_dir
tif
tif
tif_dir
td_stripsperimage
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_SEPARATE
PLANARCONFIG_SEPARATE
tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel
tif->tif_dir.td_stripsperimage
tif->tif_dir
tif
tif
tif_dir
td_stripsperimage
tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}
!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)
TIFFFieldSet(tif, FIELD_STRIPOFFSETS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_STRIPOFFSETS
FIELD_STRIPOFFSETS
{		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}
if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}
(tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)
(tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0)
(tif->tif_dir.td_compression==COMPRESSION_OJPEG)
tif->tif_dir.td_compression==COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
(isTiled(tif)==0)
isTiled(tif)==0
isTiled(tif)
isTiled
isTiled
tif
tif
0
(tif->tif_dir.td_nstrips==1)
tif->tif_dir.td_nstrips==1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
{			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		}
TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS)
TIFFSetFieldBit
TIFFSetFieldBit
tif
tif
FIELD_STRIPOFFSETS
FIELD_STRIPOFFSETS
{			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}
MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");
MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets")
MissingRequired
MissingRequired
tif
tif
isTiled(tif) ? "TileOffsets" : "StripOffsets"
isTiled(tif)
isTiled
isTiled
tif
tif
"TileOffsets"
"StripOffsets"
goto bad;
bad
for (di=0, dp=dir; di<dircount; di++, dp++)	{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yech). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}
di=0, dp=dir;
di=0, dp=dir
di=0
di
di
0
dp=dir
dp
dp
dir
dir
di<dircount
di
di
dircount
dircount
di++, dp++
di++
di
di
dp++
dp
dp
{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yech). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}
switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yech). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}
dp->tdir_tag
dp
dp
tdir_tag
{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yech). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                          				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}
case IGNORE:
IGNORE
IGNORE
break;
case TIFFTAG_MINSAMPLEVALUE:
TIFFTAG_MINSAMPLEVALUE
TIFFTAG_MINSAMPLEVALUE
case TIFFTAG_MAXSAMPLEVALUE:
TIFFTAG_MAXSAMPLEVALUE
TIFFTAG_MAXSAMPLEVALUE
case TIFFTAG_BITSPERSAMPLE:
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
case TIFFTAG_DATATYPE:
TIFFTAG_DATATYPE
TIFFTAG_DATATYPE
case TIFFTAG_SAMPLEFORMAT:
TIFFTAG_SAMPLEFORMAT
TIFFTAG_SAMPLEFORMAT
{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;				}
uint16 value;
uint16 value;
uint16
uint16
value
value
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
err=TIFFReadDirEntryShort(tif,dp,&value);
err=TIFFReadDirEntryShort(tif,dp,&value)
err
err
TIFFReadDirEntryShort(tif,dp,&value)
TIFFReadDirEntryShort
TIFFReadDirEntryShort
tif
tif
dp
dp
&value
value
value
if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err==TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err=TIFFReadDirEntryPersampleShort(tif,dp,&value)
err
err
TIFFReadDirEntryPersampleShort(tif,dp,&value)
TIFFReadDirEntryPersampleShort
TIFFReadDirEntryPersampleShort
tif
tif
dp
dp
&value
value
value
if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
0
goto bad;
bad
if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;
!TIFFSetField(tif,dp->tdir_tag,value)
TIFFSetField(tif,dp->tdir_tag,value)
TIFFSetField
TIFFSetField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
value
value
goto bad;
bad
break;
case TIFFTAG_SMINSAMPLEVALUE:
TIFFTAG_SMINSAMPLEVALUE
TIFFTAG_SMINSAMPLEVALUE
case TIFFTAG_SMAXSAMPLEVALUE:
TIFFTAG_SMAXSAMPLEVALUE
TIFFTAG_SMAXSAMPLEVALUE
{					double *data;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}
double *data;
double *data;
double
*data
*
data
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
uint32 saved_flags;
uint32 saved_flags;
uint32
uint32
saved_flags
saved_flags
int m;
int m;
int
m
m
if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel
dp->tdir_count
dp
dp
tdir_count
(uint64)tif->tif_dir.td_samplesperpixel
uint64
uint64
uint64

tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
err = TIFFReadDirEntryErrCount;
err = TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
err = TIFFReadDirEntryDoubleArray(tif, dp, &data)
err
err
TIFFReadDirEntryDoubleArray(tif, dp, &data)
TIFFReadDirEntryDoubleArray
TIFFReadDirEntryDoubleArray
tif
tif
dp
dp
&data
data
data
if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
0
goto bad;
bad
saved_flags = tif->tif_flags;
saved_flags = tif->tif_flags
saved_flags
saved_flags
tif->tif_flags
tif
tif
tif_flags
tif->tif_flags |= TIFF_PERSAMPLE;
tif->tif_flags |= TIFF_PERSAMPLE
tif->tif_flags
tif
tif
tif_flags
TIFF_PERSAMPLE
TIFF_PERSAMPLE
m = TIFFSetField(tif,dp->tdir_tag,data);
m = TIFFSetField(tif,dp->tdir_tag,data)
m
m
TIFFSetField(tif,dp->tdir_tag,data)
TIFFSetField
TIFFSetField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
data
data
tif->tif_flags = saved_flags;
tif->tif_flags = saved_flags
tif->tif_flags
tif
tif
tif_flags
saved_flags
saved_flags
_TIFFfree(data);
_TIFFfree(data)
_TIFFfree
_TIFFfree
data
data
if (!m)						goto bad;
!m
m
m
goto bad;
bad
break;
case TIFFTAG_STRIPOFFSETS:
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
case TIFFTAG_TILEOFFSETS:
TIFFTAG_TILEOFFSETS
TIFFTAG_TILEOFFSETS
if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;
!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset)
TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset)
TIFFFetchStripThing
TIFFFetchStripThing
tif
tif
dp
dp
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
&tif->tif_dir.td_stripoffset
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
goto bad;
bad
break;
case TIFFTAG_STRIPBYTECOUNTS:
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
case TIFFTAG_TILEBYTECOUNTS:
TIFFTAG_TILEBYTECOUNTS
TIFFTAG_TILEBYTECOUNTS
if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;
!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount)
TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount)
TIFFFetchStripThing
TIFFFetchStripThing
tif
tif
dp
dp
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
&tif->tif_dir.td_stripbytecount
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
goto bad;
bad
break;
case TIFFTAG_COLORMAP:
TIFFTAG_COLORMAP
TIFFTAG_COLORMAP
case TIFFTAG_TRANSFERFUNCTION:
TIFFTAG_TRANSFERFUNCTION
TIFFTAG_TRANSFERFUNCTION
{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;					countpersample=(1L<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
uint32 countpersample;
uint32 countpersample;
uint32
uint32
countpersample
countpersample
uint32 countrequired;
uint32 countrequired;
uint32
uint32
countrequired
countrequired
uint32 incrementpersample;
uint32 incrementpersample;
uint32
uint32
incrementpersample
incrementpersample
uint16* value=NULL;
uint16* value=NULL;
uint16
uint16
* value=NULL
*
value
=NULL
NULL
NULL
countpersample=(1L<<tif->tif_dir.td_bitspersample);
countpersample=(1L<<tif->tif_dir.td_bitspersample)
countpersample
countpersample
(1L<<tif->tif_dir.td_bitspersample)
1L<<tif->tif_dir.td_bitspersample
1L
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}
(dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample)
(dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)
dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION
dp->tdir_tag
dp
dp
tdir_tag
TIFFTAG_TRANSFERFUNCTION
TIFFTAG_TRANSFERFUNCTION
(dp->tdir_count==(uint64)countpersample)
dp->tdir_count==(uint64)countpersample
dp->tdir_count
dp
dp
tdir_count
(uint64)countpersample
uint64
uint64
uint64

countpersample
countpersample
{						countrequired=countpersample;						incrementpersample=0;					}
countrequired=countpersample;
countrequired=countpersample
countrequired
countrequired
countpersample
countpersample
incrementpersample=0;
incrementpersample=0
incrementpersample
incrementpersample
0
{						countrequired=3*countpersample;						incrementpersample=countpersample;					}
countrequired=3*countpersample;
countrequired=3*countpersample
countrequired
countrequired
3*countpersample
3
countpersample
countpersample
incrementpersample=countpersample;
incrementpersample=countpersample
incrementpersample
incrementpersample
countpersample
countpersample
if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);
dp->tdir_count!=(uint64)countrequired
dp->tdir_count
dp
dp
tdir_count
(uint64)countrequired
uint64
uint64
uint64

countrequired
countrequired
err=TIFFReadDirEntryErrCount;
err=TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err=TIFFReadDirEntryShortArray(tif,dp,&value);
err=TIFFReadDirEntryShortArray(tif,dp,&value)
err
err
TIFFReadDirEntryShortArray(tif,dp,&value)
TIFFReadDirEntryShortArray
TIFFReadDirEntryShortArray
tif
tif
dp
dp
&value
value
value
if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
1
{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}
TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample)
TIFFSetField
TIFFSetField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
value
value
value+incrementpersample
value
value
incrementpersample
incrementpersample
value+2*incrementpersample
value
value
2*incrementpersample
2
incrementpersample
incrementpersample
_TIFFfree(value);
_TIFFfree(value)
_TIFFfree
_TIFFfree
value
value
break;
case TIFFTAG_OSUBFILETYPE:
TIFFTAG_OSUBFILETYPE
TIFFTAG_OSUBFILETYPE
{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}
uint16 valueo;
uint16 valueo;
uint16
uint16
valueo
valueo
uint32 value;
uint32 value;
uint32
uint32
value
value
if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}
TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk
TIFFReadDirEntryShort(tif,dp,&valueo)
TIFFReadDirEntryShort
TIFFReadDirEntryShort
tif
tif
dp
dp
&valueo
valueo
valueo
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}
switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}
valueo
valueo
{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}
case OFILETYPE_REDUCEDIMAGE:
OFILETYPE_REDUCEDIMAGE
OFILETYPE_REDUCEDIMAGE
value=FILETYPE_REDUCEDIMAGE;
value=FILETYPE_REDUCEDIMAGE
value
value
FILETYPE_REDUCEDIMAGE
FILETYPE_REDUCEDIMAGE
break;
case OFILETYPE_PAGE:
OFILETYPE_PAGE
OFILETYPE_PAGE
value=FILETYPE_PAGE;
value=FILETYPE_PAGE
value
value
FILETYPE_PAGE
FILETYPE_PAGE
break;
default:
value=0;
value=0
value
value
0
break;
if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
value!=0
value
value
0
TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SUBFILETYPE
TIFFTAG_SUBFILETYPE
value
value
break;
default:
(void) TIFFFetchNormalTag(tif, dp, TRUE);
(void) TIFFFetchNormalTag(tif, dp, TRUE)
void
void

TIFFFetchNormalTag(tif, dp, TRUE)
TIFFFetchNormalTag
TIFFFetchNormalTag
tif
tif
dp
dp
TRUE
TRUE
break;
if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)	{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}
tif->tif_dir.td_compression==COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}
if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}
!TIFFFieldSet(tif,FIELD_PHOTOMETRIC)
TIFFFieldSet(tif,FIELD_PHOTOMETRIC)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_PHOTOMETRIC
FIELD_PHOTOMETRIC
{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Photometric tag is missing, assuming data is YCbCr"
if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;
!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR)
TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_PHOTOMETRIC
TIFFTAG_PHOTOMETRIC
PHOTOMETRIC_YCBCR
PHOTOMETRIC_YCBCR
goto bad;
bad
if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}
tif->tif_dir.td_photometric==PHOTOMETRIC_RGB
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_RGB
PHOTOMETRIC_RGB
{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}
tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_YCBCR
PHOTOMETRIC_YCBCR
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB"
if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}
!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)
TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_BITSPERSAMPLE
FIELD_BITSPERSAMPLE
{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}
TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");
TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"BitsPerSample tag is missing, assuming 8 bits per sample"
if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;
!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8)
TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
8
goto bad;
bad
if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}
!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)
TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_SAMPLESPERPIXEL
FIELD_SAMPLESPERPIXEL
{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}
if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}
tif->tif_dir.td_photometric==PHOTOMETRIC_RGB
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_RGB
PHOTOMETRIC_RGB
{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3"
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;
!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
3
goto bad;
bad
if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}
tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_YCBCR
PHOTOMETRIC_YCBCR
{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3"
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;
!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
3
goto bad;
bad
if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}
(tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK)
(tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_MINISWHITE
PHOTOMETRIC_MINISWHITE
(tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK)
tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_MINISBLACK
PHOTOMETRIC_MINISBLACK
{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;
!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1)
TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
1
goto bad;
bad
if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}
tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)
tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_PALETTE
PHOTOMETRIC_PALETTE
!TIFFFieldSet(tif, FIELD_COLORMAP)
TIFFFieldSet(tif, FIELD_COLORMAP)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_COLORMAP
FIELD_COLORMAP
{		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}
if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}
tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3
tif->tif_dir.td_bitspersample>=8
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
8
tif->tif_dir.td_samplesperpixel==3
tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
3
tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
tif->tif_dir.td_photometric = PHOTOMETRIC_RGB
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_RGB
PHOTOMETRIC_RGB
if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}
tif->tif_dir.td_bitspersample>=8
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
8
tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_MINISBLACK
PHOTOMETRIC_MINISBLACK
{			MissingRequired(tif, "Colormap");			goto bad;		}
MissingRequired(tif, "Colormap");
MissingRequired(tif, "Colormap")
MissingRequired
MissingRequired
tif
tif
"Colormap"
goto bad;
bad
if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)	{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}
tif->tif_dir.td_compression!=COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}
if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)
TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_STRIPBYTECOUNTS
FIELD_STRIPBYTECOUNTS
{			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		}
if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}
(tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)
(tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1)
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
tif->tif_dir.td_nstrips > 1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
(tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)
tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel
tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_SEPARATE
PLANARCONFIG_SEPARATE
tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
(uint32)tif->tif_dir.td_samplesperpixel
uint32
uint32
uint32

tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
{			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}
MissingRequired(tif, "StripByteCounts");
MissingRequired(tif, "StripByteCounts")
MissingRequired
MissingRequired
tif
tif
"StripByteCounts"
goto bad;
bad
TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");
TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength"
if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;
EstimateStripByteCounts(tif, dir, dircount) < 0
EstimateStripByteCounts(tif, dir, dircount)
EstimateStripByteCounts
EstimateStripByteCounts
tif
tif
dir
dir
dircount
dircount
0
goto bad;
bad
if (tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD
tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0
tif->tif_dir.td_nstrips == 1                           && _TIFFFillStriles(tif)
tif->tif_dir.td_nstrips == 1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
_TIFFFillStriles(tif)
_TIFFFillStriles
_TIFFFillStriles
tif
tif
tif->tif_dir.td_stripoffset[0] != 0
tif->tif_dir.td_stripoffset[0]
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
0
0
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
{			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		}
TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");
TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength"
if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;
EstimateStripByteCounts(tif, dir, dircount) < 0
EstimateStripByteCounts(tif, dir, dircount)
EstimateStripByteCounts
EstimateStripByteCounts
tif
tif
dir
dir
dircount
dircount
0
goto bad;
bad
if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
tif->tif_dir.td_nstrips > 2
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
2
tif->tif_dir.td_compression == COMPRESSION_NONE
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_NONE
COMPRESSION_NONE
tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_stripbytecount[0]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
0
tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
1
tif->tif_dir.td_stripbytecount[0] != 0
tif->tif_dir.td_stripbytecount[0]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
0
0
tif->tif_dir.td_stripbytecount[1] != 0
tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
1
0
{			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");
TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength"
if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;
EstimateStripByteCounts(tif, dir, dircount) < 0
EstimateStripByteCounts(tif, dir, dircount)
EstimateStripByteCounts
EstimateStripByteCounts
tif
tif
dir
dir
dircount
dircount
0
goto bad;
bad
if (dir)	{		_TIFFfree(dir);		dir=NULL;	}
dir
dir
{		_TIFFfree(dir);		dir=NULL;	}
_TIFFfree(dir);
_TIFFfree(dir)
_TIFFfree
_TIFFfree
dir
dir
dir=NULL;
dir=NULL
dir
dir
NULL
NULL
if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))	{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}
!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE)
TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_MAXSAMPLEVALUE
FIELD_MAXSAMPLEVALUE
{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}
if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
tif->tif_dir.td_bitspersample>=16
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
16
tif->tif_dir.td_maxsamplevalue=0xFFFF;
tif->tif_dir.td_maxsamplevalue=0xFFFF
tif->tif_dir.td_maxsamplevalue
tif->tif_dir
tif
tif
tif_dir
td_maxsamplevalue
0xFFFF
tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1)
tif->tif_dir.td_maxsamplevalue
tif->tif_dir
tif
tif
tif_dir
td_maxsamplevalue
(uint16)((1L<<tif->tif_dir.td_bitspersample)-1)
(uint16)
uint16
uint16
(1L<<tif->tif_dir.td_bitspersample)-1
(1L<<tif->tif_dir.td_bitspersample)
1L<<tif->tif_dir.td_bitspersample
1L
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
1
if (tif->tif_dir.td_nstrips > 1) {		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}
tif->tif_dir.td_nstrips > 1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
{		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}
uint32 strip;
uint32 strip;
uint32
uint32
strip
strip
tif->tif_dir.td_stripbytecountsorted = 1;
tif->tif_dir.td_stripbytecountsorted = 1
tif->tif_dir.td_stripbytecountsorted
tif->tif_dir
tif
tif
tif_dir
td_stripbytecountsorted
1
for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}
strip = 1;
strip = 1
strip
strip
1
strip < tif->tif_dir.td_nstrips
strip
strip
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
strip++
strip
strip
{			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}
if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}
tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]
tif->tif_dir.td_stripoffset[strip - 1]
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
strip - 1
strip
strip
1
tif->tif_dir.td_stripoffset[strip]
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
strip
strip
{				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}
tif->tif_dir.td_stripbytecountsorted = 0;
tif->tif_dir.td_stripbytecountsorted = 0
tif->tif_dir.td_stripbytecountsorted
tif->tif_dir
tif
tif
tif_dir
td_stripbytecountsorted
0
break;
(*tif->tif_fixuptags)(tif);
(*tif->tif_fixuptags)(tif)
(*tif->tif_fixuptags)
*tif->tif_fixuptags
tif->tif_fixuptags
tif
tif
tif_fixuptags
tif
tif
if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))    {        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP)
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)
tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
(tif->tif_dir.td_nstrips==1)
tif->tif_dir.td_nstrips==1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
(tif->tif_dir.td_compression==COMPRESSION_NONE)
tif->tif_dir.td_compression==COMPRESSION_NONE
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_NONE
COMPRESSION_NONE
((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP)
(tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP
(tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))
tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)
tif->tif_flags
tif
tif
tif_flags
(TIFF_STRIPCHOP|TIFF_ISTILED)
TIFF_STRIPCHOP|TIFF_ISTILED
TIFF_STRIPCHOP
TIFF_STRIPCHOP
TIFF_ISTILED
TIFF_ISTILED
TIFF_STRIPCHOP
TIFF_STRIPCHOP
{        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }
if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;
!_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount
!_TIFFFillStriles(tif)
_TIFFFillStriles(tif)
_TIFFFillStriles
_TIFFFillStriles
tif
tif
!tif->tif_dir.td_stripbytecount
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
return 0;
0
ChopUpSingleUncompressedStrip(tif);
ChopUpSingleUncompressedStrip(tif)
ChopUpSingleUncompressedStrip
ChopUpSingleUncompressedStrip
tif
tif
tif->tif_flags &= ~TIFF_DIRTYDIRECT;
tif->tif_flags &= ~TIFF_DIRTYDIRECT
tif->tif_flags
tif
tif
tif_flags
~TIFF_DIRTYDIRECT
TIFF_DIRTYDIRECT
TIFF_DIRTYDIRECT
tif->tif_flags &= ~TIFF_DIRTYSTRIP;
tif->tif_flags &= ~TIFF_DIRTYSTRIP
tif->tif_flags
tif
tif
tif_flags
~TIFF_DIRTYSTRIP
TIFF_DIRTYSTRIP
TIFF_DIRTYSTRIP
tif->tif_row = (uint32) -1;
tif->tif_row = (uint32) -1
tif->tif_row
tif
tif
tif_row
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_curstrip = (uint32) -1;
tif->tif_curstrip = (uint32) -1
tif->tif_curstrip
tif
tif
tif_curstrip
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_col = (uint32) -1;
tif->tif_col = (uint32) -1
tif->tif_col
tif
tif
tif_col
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_curtile = (uint32) -1;
tif->tif_curtile = (uint32) -1
tif->tif_curtile
tif
tif
tif_curtile
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_tilesize = (tmsize_t) -1;
tif->tif_tilesize = (tmsize_t) -1
tif->tif_tilesize
tif
tif
tif_tilesize
(tmsize_t) -1
(tmsize_t)
tmsize_t
tmsize_t
1
tif->tif_scanlinesize = TIFFScanlineSize(tif);
tif->tif_scanlinesize = TIFFScanlineSize(tif)
tif->tif_scanlinesize
tif
tif
tif_scanlinesize
TIFFScanlineSize(tif)
TIFFScanlineSize
TIFFScanlineSize
tif
tif
if (!tif->tif_scanlinesize) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}
!tif->tif_scanlinesize
tif->tif_scanlinesize
tif
tif
tif_scanlinesize
{		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero scanline size"
return (0);
(0)
0
if (isTiled(tif)) {		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	} else {		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}
isTiled(tif)
isTiled
isTiled
tif
tif
{		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	}
tif->tif_tilesize = TIFFTileSize(tif);
tif->tif_tilesize = TIFFTileSize(tif)
tif->tif_tilesize
tif
tif
tif_tilesize
TIFFTileSize(tif)
TIFFTileSize
TIFFTileSize
tif
tif
if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}
!tif->tif_tilesize
tif->tif_tilesize
tif
tif
tif_tilesize
{			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}
TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");
TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero tile size"
return (0);
(0)
0
{		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}
if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}
!TIFFStripSize(tif)
TIFFStripSize(tif)
TIFFStripSize
TIFFStripSize
tif
tif
{			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}
TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");
TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero strip size"
return (0);
(0)
0
return (1);
(1)
1
bad:	if (dir)		_TIFFfree(dir);
bad
if (dir)		_TIFFfree(dir);
dir
dir
_TIFFfree(dir);
_TIFFfree(dir)
_TIFFfree
_TIFFfree
dir
dir
return (0);
(0)
0
-----joern-----
(0,7,0)
(5,8,0)
(5,10,0)
(9,10,0)
(1,4,0)
(2,8,0)
(7,3,0)
(6,7,0)
(5,8,1)
(8,2,1)
(7,0,1)
(0,6,1)
(10,9,1)
(5,10,1)
(2,7,1)
(7,3,1)
(9,7,1)
(5,8,2)
(5,10,2)
(10,7,2)
(7,3,2)
(2,7,2)
(9,7,2)
(8,7,2)
-----------------------------------
(0,TIFF_INT64_MAX)
(1,if (value > TIFF_INT64_MAX)
(2,TIFFReadDirEntryErrOk)
(3,uint64 value)
(4,)
(5,RET)
(6,value)
(7,value > TIFF_INT64_MAX)
(8,return(TIFFReadDirEntryErrOk)
(9,TIFFReadDirEntryErrRange)
(10,return(TIFFReadDirEntryErrRange)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
----------------dynamic----------------
=======testcase========
model_version:0x01000000
A-data-stat:0x000800000000000000000020000000000100000000000000a4810000e8030000e9030000ffffffff0000000000000000ffffffffffffffff0010000000000000ffffffffffffffffc7a1b56300000000ffffffffffffffff56a2b56300000000ffffffffffffffff56a2b56300000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
A-data:0x4d4d002b00080000000000000000000900ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
=========trace=========
int TIFFReadDirectory(TIFF* tif) {
static const char module[] = 'TIFFReadDirectory';
TIFFDirEntry* dir;
uint16 dircount;
TIFFDirEntry* dp;
uint16 di;
const TIFFField* fip;
uint32 fii=FAILED_FII;
toff_t nextdiroff;
tif->tif_diroff=tif->tif_nextdiroff;
(*tif->tif_cleanup)(tif);
tif->tif_curdir++;
nextdiroff = tif->tif_nextdiroff;
dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
if(!dircount)
TIFFErrorExt(tif->tif_clientdata,module, 		    'Failed to read directory at offset ' TIFF_UINT64_FORMAT,nextdiroff);
return 0;
=======================
