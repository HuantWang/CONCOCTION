-----label-----
1
-----code-----
int
TIFFReadDirectory(TIFF* tif)
{
	static const char module[] = "TIFFReadDirectory";
	TIFFDirEntry* dir;
	uint16 dircount;
	TIFFDirEntry* dp;
	uint16 di;
	const TIFFField* fip;
	uint32 fii=FAILED_FII;
        toff_t nextdiroff;
    int bitspersample_read = FALSE;
        int color_channels;

	tif->tif_diroff=tif->tif_nextdiroff;
	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
		return 0;           /* last offset or bad offset (IFD looping) */
	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
	tif->tif_curdir++;
        nextdiroff = tif->tif_nextdiroff;
	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
	if (!dircount)
	{
		TIFFErrorExt(tif->tif_clientdata,module,
		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);
		return 0;
	}
	TIFFReadDirectoryCheckOrder(tif,dir,dircount);

        /*
         * Mark duplicates of any tag to be ignored (bugzilla 1994)
         * to avoid certain pathological problems.
         */
	{
		TIFFDirEntry* ma;
		uint16 mb;
		for (ma=dir, mb=0; mb<dircount; ma++, mb++)
		{
			TIFFDirEntry* na;
			uint16 nb;
			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)
			{
				if (ma->tdir_tag==na->tdir_tag)
					na->tdir_tag=IGNORE;
			}
		}
	}
        
	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */
	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */
	/* free any old stuff and reinit */
	TIFFFreeDirectory(tif);
	TIFFDefaultDirectory(tif);
	/*
	 * Electronic Arts writes gray-scale TIFF files
	 * without a PlanarConfiguration directory entry.
	 * Thus we setup a default value here, even though
	 * the TIFF spec says there is no default value.
	 */
	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
	/*
	 * Setup default value and then make a pass over
	 * the fields to check type and tag information,
	 * and to extract info required to size data
	 * structures.  A second pass is made afterwards
	 * to read in everything not taken in the first pass.
	 * But we must process the Compression tag first
	 * in order to merge in codec-private tag definitions (otherwise
	 * we may get complaints about unknown tags).  However, the
	 * Compression tag may be dependent on the SamplesPerPixel
	 * tag value because older TIFF specs permitted Compression
	 * to be written as a SamplesPerPixel-count tag entry.
	 * Thus if we don't first figure out the correct SamplesPerPixel
	 * tag value then we may end up ignoring the Compression tag
	 * value because it has an incorrect count value (if the
	 * true value of SamplesPerPixel is not 1).
	 */
	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
	if (dp)
	{
		if (!TIFFFetchNormalTag(tif,dp,0))
			goto bad;
		dp->tdir_tag=IGNORE;
	}
	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
	if (dp)
	{
		/*
		 * The 5.0 spec says the Compression tag has one value, while
		 * earlier specs say it has one value per sample.  Because of
		 * this, we accept the tag if one value is supplied with either
		 * count.
		 */
		uint16 value;
		enum TIFFReadDirEntryErr err;
		err=TIFFReadDirEntryShort(tif,dp,&value);
		if (err==TIFFReadDirEntryErrCount)
			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
		if (err!=TIFFReadDirEntryErrOk)
		{
			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);
			goto bad;
		}
		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))
			goto bad;
		dp->tdir_tag=IGNORE;
	}
	else
	{
		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))
			goto bad;
	}
	/*
	 * First real pass over the directory.
	 */
	for (di=0, dp=dir; di<dircount; di++, dp++)
	{
		if (dp->tdir_tag!=IGNORE)
		{
			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
			if (fii == FAILED_FII)
			{
				TIFFWarningExt(tif->tif_clientdata, module,
				    "Unknown field with tag %d (0x%x) encountered",
				    dp->tdir_tag,dp->tdir_tag);
                                /* the following knowingly leaks the 
                                   anonymous field structure */
				if (!_TIFFMergeFields(tif,
					_TIFFCreateAnonField(tif,
						dp->tdir_tag,
						(TIFFDataType) dp->tdir_type),
					1)) {
					TIFFWarningExt(tif->tif_clientdata,
					    module,
					    "Registering anonymous field with tag %d (0x%x) failed",
					    dp->tdir_tag,
					    dp->tdir_tag);
					dp->tdir_tag=IGNORE;
				} else {
					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
					assert(fii != FAILED_FII);
				}
			}
		}
		if (dp->tdir_tag!=IGNORE)
		{
			fip=tif->tif_fields[fii];
			if (fip->field_bit==FIELD_IGNORE)
				dp->tdir_tag=IGNORE;
			else
			{
				switch (dp->tdir_tag)
				{
					case TIFFTAG_STRIPOFFSETS:
					case TIFFTAG_STRIPBYTECOUNTS:
					case TIFFTAG_TILEOFFSETS:
					case TIFFTAG_TILEBYTECOUNTS:
						TIFFSetFieldBit(tif,fip->field_bit);
						break;
					case TIFFTAG_IMAGEWIDTH:
					case TIFFTAG_IMAGELENGTH:
					case TIFFTAG_IMAGEDEPTH:
					case TIFFTAG_TILELENGTH:
					case TIFFTAG_TILEWIDTH:
					case TIFFTAG_TILEDEPTH:
					case TIFFTAG_PLANARCONFIG:
					case TIFFTAG_ROWSPERSTRIP:
					case TIFFTAG_EXTRASAMPLES:
						if (!TIFFFetchNormalTag(tif,dp,0))
							goto bad;
						dp->tdir_tag=IGNORE;
						break;
                                        default:
                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )
                                                dp->tdir_tag=IGNORE;
                                            break;
				}
			}
		}
	}
	/*
	 * XXX: OJPEG hack.
	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,
	 * c) strip offsets/bytecounts tag are both present and
	 * d) both contain exactly one value, then we consistently find
	 * that the buggy implementation of the buggy compression scheme
	 * matches contig planarconfig best. So we 'fix-up' the tag here
	 */
	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&
	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))
	{
        if (!_TIFFFillStriles(tif))
            goto bad;
		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
		if ((dp!=0)&&(dp->tdir_count==1))
		{
			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,
			    TIFFTAG_STRIPBYTECOUNTS);
			if ((dp!=0)&&(dp->tdir_count==1))
			{
				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
				TIFFWarningExt(tif->tif_clientdata,module,
				    "Planarconfig tag value assumed incorrect, "
				    "assuming data is contig instead of chunky");
			}
		}
	}
	/*
	 * Allocate directory structure and setup defaults.
	 */
	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))
	{
		MissingRequired(tif,"ImageLength");
		goto bad;
	}
	/*
	 * Setup appropriate structures (by strip or by tile)
	 */
	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  
		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
		tif->tif_flags &= ~TIFF_ISTILED;
	} else {
		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
		tif->tif_flags |= TIFF_ISTILED;
	}
	if (!tif->tif_dir.td_nstrips) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    "Cannot handle zero number of %s",
		    isTiled(tif) ? "tiles" : "strips");
		goto bad;
	}
	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)
		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
#ifdef OJPEG_SUPPORT
		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&
		    (isTiled(tif)==0) &&
		    (tif->tif_dir.td_nstrips==1)) {
			/*
			 * XXX: OJPEG hack.
			 * If a) compression is OJPEG, b) it's not a tiled TIFF,
			 * and c) the number of strips is 1,
			 * then we tolerate the absence of stripoffsets tag,
			 * because, presumably, all required data is in the
			 * JpegInterchangeFormat stream.
			 */
			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
		} else
#endif
        {
			MissingRequired(tif,
				isTiled(tif) ? "TileOffsets" : "StripOffsets");
			goto bad;
		}
	}
	/*
	 * Second pass: extract other information.
	 */
	for (di=0, dp=dir; di<dircount; di++, dp++)
	{
		switch (dp->tdir_tag)
		{
			case IGNORE:
				break;
			case TIFFTAG_MINSAMPLEVALUE:
			case TIFFTAG_MAXSAMPLEVALUE:
			case TIFFTAG_BITSPERSAMPLE:
			case TIFFTAG_DATATYPE:
			case TIFFTAG_SAMPLEFORMAT:
				/*
				 * The MinSampleValue, MaxSampleValue, BitsPerSample
				 * DataType and SampleFormat tags are supposed to be
				 * written as one value/sample, but some vendors
				 * incorrectly write one value only -- so we accept
				 * that as well (yuck). Other vendors write correct
				 * value for NumberOfSamples, but incorrect one for
				 * BitsPerSample and friends, and we will read this
				 * too.
				 */
				{
					uint16 value;
					enum TIFFReadDirEntryErr err;
					err=TIFFReadDirEntryShort(tif,dp,&value);
					if (err==TIFFReadDirEntryErrCount)
						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
					if (err!=TIFFReadDirEntryErrOk)
					{
						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
						goto bad;
					}
					if (!TIFFSetField(tif,dp->tdir_tag,value))
						goto bad;
                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )
                        bitspersample_read = TRUE;
				}
				break;
			case TIFFTAG_SMINSAMPLEVALUE:
			case TIFFTAG_SMAXSAMPLEVALUE:
				{

					double *data = NULL;
					enum TIFFReadDirEntryErr err;
					uint32 saved_flags;
					int m;
					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)
						err = TIFFReadDirEntryErrCount;
					else
						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
					if (err!=TIFFReadDirEntryErrOk)
					{
						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
						goto bad;
					}
					saved_flags = tif->tif_flags;
					tif->tif_flags |= TIFF_PERSAMPLE;
					m = TIFFSetField(tif,dp->tdir_tag,data);
					tif->tif_flags = saved_flags;
					_TIFFfree(data);
					if (!m)
						goto bad;
				}
				break;
			case TIFFTAG_STRIPOFFSETS:
			case TIFFTAG_TILEOFFSETS:
#if defined(DEFER_STRILE_LOAD)
                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),
                                             dp, sizeof(TIFFDirEntry) );
#else                          
                                if( tif->tif_dir.td_stripoffset != NULL )
                                {
                                    TIFFErrorExt(tif->tif_clientdata, module,
                                        "tif->tif_dir.td_stripoffset is "
                                        "already allocated. Likely duplicated "
                                        "StripOffsets/TileOffsets tag");
                                    goto bad;
                                }
				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  
					goto bad;
#endif                                
				break;
			case TIFFTAG_STRIPBYTECOUNTS:
			case TIFFTAG_TILEBYTECOUNTS:
#if defined(DEFER_STRILE_LOAD)
                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),
                                             dp, sizeof(TIFFDirEntry) );
#else                          
                                if( tif->tif_dir.td_stripbytecount != NULL )
                                {
                                    TIFFErrorExt(tif->tif_clientdata, module,
                                        "tif->tif_dir.td_stripbytecount is "
                                        "already allocated. Likely duplicated "
                                        "StripByteCounts/TileByteCounts tag");
                                    goto bad;
                                }
                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  
					goto bad;
#endif                                
				break;
			case TIFFTAG_COLORMAP:
			case TIFFTAG_TRANSFERFUNCTION:
				{
					enum TIFFReadDirEntryErr err;
					uint32 countpersample;
					uint32 countrequired;
					uint32 incrementpersample;
					uint16* value=NULL;
                    /* It would be dangerous to instantiate those tag values */
                    /* since if td_bitspersample has not yet been read (due to */
                    /* unordered tags), it could be read afterwards with a */
                    /* values greater than the default one (1), which may cause */
                    /* crashes in user code */
                    if( !bitspersample_read )
                    {
                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);
                        TIFFWarningExt(tif->tif_clientdata,module,
                                       "Ignoring %s since BitsPerSample tag not found",
                                       fip ? fip->field_name : "unknown tagname");
                        continue;
                    }
					/* ColorMap or TransferFunction for high bit */
					/* depths do not make much sense and could be */
					/* used as a denial of service vector */
					if (tif->tif_dir.td_bitspersample > 24)
					{
					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);
					    TIFFWarningExt(tif->tif_clientdata,module,
						"Ignoring %s because BitsPerSample=%d>24",
						fip ? fip->field_name : "unknown tagname",
						tif->tif_dir.td_bitspersample);
					    continue;
					}
					countpersample=(1U<<tif->tif_dir.td_bitspersample);
					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))
					{
						countrequired=countpersample;
						incrementpersample=0;
					}
					else
					{
						countrequired=3*countpersample;
						incrementpersample=countpersample;
					}
					if (dp->tdir_count!=(uint64)countrequired)
						err=TIFFReadDirEntryErrCount;
					else
						err=TIFFReadDirEntryShortArray(tif,dp,&value);
					if (err!=TIFFReadDirEntryErrOk)
                    {
						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);
                    }
					else
					{
						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
						_TIFFfree(value);
					}
				}
				break;
/* BEGIN REV 4.0 COMPATIBILITY */
			case TIFFTAG_OSUBFILETYPE:
				{
					uint16 valueo;
					uint32 value;
					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)
					{
						switch (valueo)
						{
							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;
							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;
							default: value=0; break;
						}
						if (value!=0)
							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
					}
				}
				break;
/* END REV 4.0 COMPATIBILITY */
			default:
				(void) TIFFFetchNormalTag(tif, dp, TRUE);
				break;
		}
	}
	/*
	 * OJPEG hack:
	 * - If a) compression is OJPEG, and b) photometric tag is missing,
	 * then we consistently find that photometric should be YCbCr
	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,
	 * then we consistently find that the buggy implementation of the
	 * buggy compression scheme matches photometric YCbCr instead.
	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,
	 * then we consistently find bitspersample should be 8.
	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
	 * and c) photometric is RGB or YCbCr, then we consistently find
	 * samplesperpixel should be 3
	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently
	 * find samplesperpixel should be 3
	 */
	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)
	{
		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))
		{
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Photometric tag is missing, assuming data is YCbCr");
			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))
				goto bad;
		}
		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
		{
			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Photometric tag value assumed incorrect, "
			    "assuming data is YCbCr instead of RGB");
		}
		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
		{
			TIFFWarningExt(tif->tif_clientdata,module,
			    "BitsPerSample tag is missing, assuming 8 bits per sample");
			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))
				goto bad;
		}
		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
		{
			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
			{
				TIFFWarningExt(tif->tif_clientdata,module,
				    "SamplesPerPixel tag is missing, "
				    "assuming correct SamplesPerPixel value is 3");
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
					goto bad;
			}
			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)
			{
				TIFFWarningExt(tif->tif_clientdata,module,
				    "SamplesPerPixel tag is missing, "
				    "applying correct SamplesPerPixel value of 3");
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
					goto bad;
			}
			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))
			{
				/*
				 * SamplesPerPixel tag is missing, but is not required
				 * by spec.  Assume correct SamplesPerPixel value of 1.
				 */
				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))
					goto bad;
			}
		}
	}

	/*
	 * Make sure all non-color channels are extrasamples.
	 * If it's not the case, define them as such.
	 */
        color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);
        if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {
                uint16 old_extrasamples;
                uint16 *new_sampleinfo;

                TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "
                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "
                    "Defining non-color channels as ExtraSamples.");

                old_extrasamples = tif->tif_dir.td_extrasamples;
                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);

                // sampleinfo should contain information relative to these new extra samples
                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));
                if (!new_sampleinfo) {
                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "
                                "temporary new sampleinfo array (%d 16 bit elements)",
                                tif->tif_dir.td_extrasamples);
                    goto bad;
                }

                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));
                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
                _TIFFfree(new_sampleinfo);
        }

	/*
	 * Verify Palette image has a Colormap.
	 */
	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&
	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {
		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)
			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
		else if (tif->tif_dir.td_bitspersample>=8)
			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
		else {
			MissingRequired(tif, "Colormap");
			goto bad;
		}
	}
	/*
	 * OJPEG hack:
	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG
	 * TIFFs
	 */
	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)
	{
		/*
		 * Attempt to deal with a missing StripByteCounts tag.
		 */
		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
			/*
			 * Some manufacturers violate the spec by not giving
			 * the size of the strips.  In this case, assume there
			 * is one uncompressed strip of data.
			 */
			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
			    tif->tif_dir.td_nstrips > 1) ||
			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&
			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {
			    MissingRequired(tif, "StripByteCounts");
			    goto bad;
			}
			TIFFWarningExt(tif->tif_clientdata, module,
				"TIFF directory is missing required "
				"\"StripByteCounts\" field, calculating from imagelength");
			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;
		/*
		 * Assume we have wrong StripByteCount value (in case
		 * of single strip) in following cases:
		 *   - it is equal to zero along with StripOffset;
		 *   - it is larger than file itself (in case of uncompressed
		 *     image);
		 *   - it is smaller than the size of the bytes per row
		 *     multiplied on the number of rows.  The last case should
		 *     not be checked in the case of writing new image,
		 *     because we may do not know the exact strip size
		 *     until the whole image will be written and directory
		 *     dumped out.
		 */
		#define	BYTECOUNTLOOKSBAD \
		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \
		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \
		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \
		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \
		      (tif->tif_mode == O_RDONLY && \
		       tif->tif_dir.td_compression == COMPRESSION_NONE && \
		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )

		} else if (tif->tif_dir.td_nstrips == 1
                           && !(tif->tif_flags&TIFF_ISTILED)
                           && _TIFFFillStriles(tif)
			   && tif->tif_dir.td_stripoffset[0] != 0
			   && BYTECOUNTLOOKSBAD) {
			/*
			 * XXX: Plexus (and others) sometimes give a value of
			 * zero for a tag when they don't know what the
			 * correct value is!  Try and handle the simple case
			 * of estimating the size of a one strip image.
			 */
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");
			if(EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;

#if !defined(DEFER_STRILE_LOAD)
		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
			   && tif->tif_dir.td_nstrips > 2
			   && tif->tif_dir.td_compression == COMPRESSION_NONE
			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
			   && tif->tif_dir.td_stripbytecount[0] != 0
			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {
			/*
			 * XXX: Some vendors fill StripByteCount array with
			 * absolutely wrong values (it can be equal to
			 * StripOffset array, for example). Catch this case
			 * here.
                         *
                         * We avoid this check if deferring strile loading
                         * as it would always force us to load the strip/tile
                         * information.
			 */
			TIFFWarningExt(tif->tif_clientdata, module,
			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");
			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
			    goto bad;
#endif /* !defined(DEFER_STRILE_LOAD) */                        
		}
	}
	if (dir)
	{
		_TIFFfree(dir);
		dir=NULL;
	}
	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
	{
		if (tif->tif_dir.td_bitspersample>=16)
			tif->tif_dir.td_maxsamplevalue=0xFFFF;
		else
			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
	}
	/*
	 * XXX: We can optimize checking for the strip bounds using the sorted
	 * bytecounts array. See also comments for TIFFAppendToStrip()
	 * function in tif_write.c.
	 */
#if !defined(DEFER_STRILE_LOAD)        
	if (tif->tif_dir.td_nstrips > 1) {
		uint32 strip;

		tif->tif_dir.td_stripbytecountsorted = 1;
		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
			if (tif->tif_dir.td_stripoffset[strip - 1] >
			    tif->tif_dir.td_stripoffset[strip]) {
				tif->tif_dir.td_stripbytecountsorted = 0;
				break;
			}
		}
	}
#endif /* !defined(DEFER_STRILE_LOAD) */
        
	/*
	 * An opportunity for compression mode dependent tag fixup
	 */
	(*tif->tif_fixuptags)(tif);

	/*
	 * Some manufacturers make life difficult by writing
	 * large amounts of uncompressed data as a single strip.
	 * This is contrary to the recommendations of the spec.
	 * The following makes an attempt at breaking such images
	 * into strips closer to the recommended 8k bytes.  A
	 * side effect, however, is that the RowsPerStrip tag
	 * value may be changed.
	 */
	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&
	    (tif->tif_dir.td_nstrips==1)&&
	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  
	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))
    {
        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )
            return 0;
		ChopUpSingleUncompressedStrip(tif);
    }

        /*
         * Clear the dirty directory flag. 
         */
	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
	tif->tif_flags &= ~TIFF_DIRTYSTRIP;

	/*
	 * Reinitialize i/o since we are starting on a new directory.
	 */
	tif->tif_row = (uint32) -1;
	tif->tif_curstrip = (uint32) -1;
	tif->tif_col = (uint32) -1;
	tif->tif_curtile = (uint32) -1;
	tif->tif_tilesize = (tmsize_t) -1;

	tif->tif_scanlinesize = TIFFScanlineSize(tif);
	if (!tif->tif_scanlinesize) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    "Cannot handle zero scanline size");
		return (0);
	}

	if (isTiled(tif)) {
		tif->tif_tilesize = TIFFTileSize(tif);
		if (!tif->tif_tilesize) {
			TIFFErrorExt(tif->tif_clientdata, module,
			     "Cannot handle zero tile size");
			return (0);
		}
	} else {
		if (!TIFFStripSize(tif)) {
			TIFFErrorExt(tif->tif_clientdata, module,
			    "Cannot handle zero strip size");
			return (0);
		}
	}
	return (1);
bad:
	if (dir)
		_TIFFfree(dir);
	return (0);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
11,30
11,31
11,32
11,33
11,34
11,35
11,36
11,37
11,38
11,39
11,40
11,41
11,42
11,43
11,44
11,45
11,46
11,47
11,48
11,49
11,50
11,51
11,52
11,53
11,54
11,55
11,56
11,57
11,58
11,59
11,60
11,61
11,62
11,63
11,64
11,65
11,66
11,67
11,68
11,69
11,70
11,71
12,13
13,14
13,15
15,16
15,17
15,18
18,19
20,21
21,22
21,23
22,23
24,25
24,26
27,28
28,29
28,30
29,30
31,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
55,56
57,58
57,59
59,60
60,61
62,63
63,64
63,65
64,65
66,67
68,69
69,70
69,71
71,72
71,73
73,74
74,75
76,77
77,78
77,79
79,80
81,82
82,83
82,84
83,84
83,85
84,85
87,88
87,89
88,89
91,92
91,93
92,93
93,94
93,95
93,96
94,95
96,97
98,99
98,100
99,100
102,103
104,105
105,106
105,107
106,107
107,108
108,109
108,110
109,110
112,113
114,115
115,116
116,117
116,118
117,118
120,121
121,122
121,123
122,123
124,125
124,126
125,126
128,129
129,130
129,131
130,131
132,133
132,134
132,135
132,136
132,137
133,134
135,136
137,138
139,140
140,141
142,143
143,144
143,145
144,145
147,148
147,149
148,149
149,150
151,152
151,153
152,153
153,154
155,156
156,157
156,158
156,159
156,160
157,158
159,160
161,162
163,164
165,166
165,167
165,168
166,167
167,168
167,169
168,169
170,171
170,172
173,174
174,175
174,176
175,176
177,178
179,180
179,181
179,182
179,183
180,181
181,182
181,183
182,183
182,184
183,184
185,186
187,188
187,189
188,189
191,192
191,193
192,193
194,195
196,197
196,198
197,198
198,199
200,201
201,202
203,204
203,205
203,206
204,205
205,206
205,207
206,207
208,209
208,210
211,212
212,213
212,214
213,214
215,216
217,218
217,219
217,220
217,221
218,219
219,220
219,221
220,221
220,222
221,222
223,224
223,225
224,225
227,228
227,229
228,229
230,231
230,232
231,232
234,235
234,236
235,236
237,238
239,240
239,241
240,241
241,242
243,244
244,245
246,247
247,248
247,249
248,249
248,250
249,250
249,251
250,251
253,254
253,255
254,255
257,258
258,259
258,260
259,260
259,261
260,261
263,264
265,266
266,267
266,268
267,268
267,269
268,269
271,272
272,273
274,275
275,276
275,277
276,277
276,278
277,278
280,281
281,282
283,284
284,285
284,286
285,286
287,288
289,290
290,291
290,292
291,292
293,294
295,296
296,297
296,298
296,299
296,300
297,298
299,300
301,302
303,304
305,306
306,307
306,308
307,308
309,310
309,311
309,312
309,313
309,314
310,311
312,313
314,315
316,317
318,319
320,321
320,322
321,322
323,324
323,325
324,325
324,326
325,326
326,327
326,328
326,329
326,330
327,328
329,330
331,332
334,335
336,337
337,338
337,339
338,339
338,340
339,340
342,343
344,345
345,346
345,347
346,347
348,349
348,350
348,351
348,352
348,353
349,350
351,352
353,354
355,356
357,358
359,360
359,361
359,362
360,361
362,363
362,364
362,365
362,366
362,367
362,368
362,369
363,364
364,365
364,366
365,366
367,368
369,370
370,371
370,372
371,372
373,374
375,376
376,377
376,378
377,378
379,380
379,381
379,382
379,383
380,381
382,383
384,385
386,387
387,388
389,390
389,391
390,391
390,392
391,392
393,394
395,396
396,397
396,398
397,398
399,400
399,401
399,402
399,403
400,401
402,403
404,405
406,407
407,408
409,410
409,411
410,411
410,412
411,412
413,414
415,416
415,417
416,417
417,418
417,419
417,420
417,421
417,422
417,423
418,419
420,421
422,423
424,425
428,429
430,431
430,432
431,432
432,433
432,434
432,435
432,436
433,434
435,436
437,438
439,440
441,442
443,444
444,445
444,446
445,446
445,447
446,447
449,450
451,452
452,453
452,454
453,454
454,455
454,456
454,457
454,458
455,456
457,458
459,460
461,462
463,464
465,466
465,467
465,468
465,469
466,467
467,468
467,469
468,469
468,470
469,470
472,473
472,474
473,474
475,476
477,478
477,479
478,479
480,481
482,483
482,484
483,484
484,485
486,487
487,488
489,490
489,491
490,491
490,492
491,492
491,493
492,493
492,494
493,494
496,497
498,499
498,500
499,500
500,501
500,502
500,503
500,504
501,502
503,504
505,506
505,507
506,507
509,510
510,511
512,513
512,514
513,514
513,515
514,515
516,517
518,519
518,520
519,520
520,521
520,522
520,523
520,524
520,525
520,526
521,522
523,524
523,525
524,525
527,528
530,531
530,532
531,532
534,535
534,536
535,536
538,539
538,540
538,541
539,540
540,541
540,542
540,543
540,544
541,542
543,544
545,546
545,547
545,548
545,549
546,547
548,549
550,551
550,552
551,552
554,555
554,556
555,556
555,557
556,557
559,560
559,561
560,561
564,565
564,566
565,566
566,567
566,568
566,569
566,570
566,571
566,572
567,568
569,570
569,571
570,571
573,574
576,577
576,578
577,578
580,581
580,582
581,582
584,585
585,586
585,587
586,587
586,588
587,588
590,591
592,593
592,594
593,594
594,595
594,596
594,597
594,598
595,596
597,598
599,600
599,601
600,601
603,604
604,605
606,607
607,608
607,609
608,609
610,611
610,612
611,612
613,614
615,616
615,617
616,617
616,618
617,618
617,619
618,619
621,622
623,624
623,625
624,625
625,626
625,627
626,627
628,629
628,630
629,630
629,631
630,631
633,634
635,636
635,637
635,638
636,637
636,638
637,638
637,639
638,639
641,642
643,644
644,645
644,646
645,646
645,647
646,647
649,650
651,652
652,653
652,654
653,654
653,655
654,655
657,658
657,659
657,660
657,661
657,662
657,663
657,664
657,665
657,666
657,667
657,668
657,669
657,670
657,671
657,672
657,673
657,674
657,675
657,676
657,677
657,678
658,659
659,660
661,662
662,663
664,665
665,666
667,668
668,669
670,671
671,672
671,673
671,674
672,673
674,675
676,677
676,678
677,678
681,682
682,683
684,685
685,686
687,688
688,689
690,691
691,692
693,694
694,695
696,697
697,698
699,700
700,701
702,703
703,704
705,706
706,707
708,709
708,710
709,710
710,711
710,712
710,713
710,714
711,712
713,714
715,716
718,719
720,721
721,722
721,723
722,723
722,724
723,724
726,727
730,731
730,732
731,732
732,733
732,734
732,735
733,734
735,736
737,738
737,739
738,739
741,742
742,743
742,744
743,744
743,745
744,745
747,748
750,751
750,752
751,752
751,753
752,753
753,754
753,755
754,755
754,756
755,756
755,757
756,757
760,761
762,763
763,764
763,765
764,765
764,766
765,766
765,767
766,767
770,771
772,773
772,774
772,775
773,774
773,775
774,775
775,776
775,777
776,777
778,779
780,781
782,783
783,784
783,785
784,785
786,787
786,788
786,789
786,790
786,791
787,788
789,790
791,792
793,794
795,796
797,798
797,799
798,799
798,800
799,800
800,801
800,802
801,802
804,805
805,806
805,807
806,807
806,808
807,808
811,812
811,813
812,813
813,814
813,815
814,815
816,817
816,818
816,819
816,820
816,821
817,818
819,820
821,822
823,824
825,826
827,828
827,829
828,829
828,830
829,830
830,831
830,832
831,832
834,835
835,836
835,837
836,837
836,838
837,838
841,842
841,843
842,843
843,844
843,845
844,845
844,846
845,846
845,847
846,847
850,851
852,853
853,854
853,855
853,856
853,857
854,855
856,857
856,858
857,858
860,861
863,864
863,865
864,865
865,866
865,867
865,868
866,867
868,869
870,871
872,873
872,874
873,874
874,875
874,876
874,877
875,876
877,878
880,881
882,883
882,884
882,885
883,884
884,885
884,886
884,887
885,886
887,888
889,890
891,892
891,893
891,894
891,895
891,896
892,893
893,894
893,895
894,895
894,896
895,896
895,897
896,897
900,901
900,902
901,902
903,904
905,906
906,907
906,908
907,908
907,909
908,909
908,910
909,910
913,914
913,915
914,915
914,916
915,916
919,920
920,921
920,922
921,922
921,923
922,923
922,924
923,924
927,928
927,929
928,929
928,930
929,930
933,934
934,935
934,936
935,936
935,937
936,937
936,938
937,938
941,942
941,943
942,943
942,944
943,944
947,948
948,949
948,950
949,950
949,951
950,951
953,954
954,955
956,957
956,958
957,958
958,959
958,960
959,960
959,961
960,961
960,962
961,962
965,966
965,967
966,967
968,969
970,971
971,972
971,973
972,973
972,974
973,974
976,977
978,979
978,980
979,980
980,981
980,982
981,982
981,983
982,983
986,987
986,988
987,988
988,989
988,990
988,991
988,992
988,993
989,990
991,992
991,993
992,993
995,996
998,999
998,1000
998,1001
999,1000
999,1001
1000,1001
1002,1003
1006,1007
1008,1009
1009,1010
1009,1011
1010,1011
1010,1012
1011,1012
1011,1013
1012,1013
1016,1017
1016,1018
1017,1018
1017,1019
1018,1019
1022,1023
1022,1024
1023,1024
1023,1025
1024,1025
1024,1026
1025,1026
1025,1027
1026,1027
1030,1031
1032,1033
1033,1034
1033,1035
1034,1035
1034,1036
1035,1036
1035,1037
1036,1037
1040,1041
1040,1042
1041,1042
1041,1043
1042,1043
1046,1047
1046,1048
1047,1048
1048,1049
1048,1050
1048,1051
1049,1050
1051,1052
1053,1054
1055,1056
1056,1057
1056,1058
1057,1058
1058,1059
1058,1060
1058,1061
1059,1060
1061,1062
1063,1064
1063,1065
1063,1066
1064,1065
1064,1066
1065,1066
1067,1068
1071,1072
1073,1074
1073,1075
1073,1076
1073,1077
1074,1075
1075,1076
1075,1077
1076,1077
1076,1078
1077,1078
1080,1081
1080,1082
1081,1082
1083,1084
1085,1086
1085,1087
1086,1087
1088,1089
1090,1091
1090,1092
1091,1092
1092,1093
1094,1095
1095,1096
1097,1098
1098,1099
1098,1100
1099,1100
1099,1101
1100,1101
1103,1104
1103,1105
1103,1106
1103,1107
1103,1108
1103,1109
1103,1110
1103,1111
1103,1112
1103,1113
1103,1114
1103,1115
1103,1116
1103,1117
1103,1118
1103,1119
1103,1120
1103,1121
1103,1122
1103,1123
1103,1124
1103,1125
1103,1126
1103,1127
1103,1128
1103,1129
1103,1130
1103,1131
1103,1132
1103,1133
1103,1134
1103,1135
1103,1136
1104,1105
1105,1106
1108,1109
1109,1110
1111,1112
1112,1113
1114,1115
1115,1116
1117,1118
1118,1119
1120,1121
1121,1122
1123,1124
1123,1125
1123,1126
1123,1127
1123,1128
1123,1129
1123,1130
1124,1125
1125,1126
1125,1127
1126,1127
1128,1129
1130,1131
1131,1132
1131,1133
1132,1133
1134,1135
1136,1137
1137,1138
1137,1139
1138,1139
1140,1141
1140,1142
1140,1143
1140,1144
1141,1142
1143,1144
1145,1146
1147,1148
1148,1149
1150,1151
1150,1152
1151,1152
1151,1153
1152,1153
1154,1155
1156,1157
1157,1158
1157,1159
1158,1159
1160,1161
1160,1162
1160,1163
1160,1164
1161,1162
1163,1164
1165,1166
1167,1168
1168,1169
1170,1171
1170,1172
1171,1172
1171,1173
1172,1173
1174,1175
1176,1177
1176,1178
1176,1179
1177,1178
1178,1179
1178,1180
1179,1180
1181,1182
1181,1183
1181,1184
1182,1183
1184,1185
1186,1187
1186,1188
1187,1188
1190,1191
1191,1192
1191,1193
1191,1194
1191,1195
1191,1196
1191,1197
1192,1193
1194,1195
1196,1197
1198,1199
1200,1201
1200,1202
1200,1203
1201,1202
1203,1204
1203,1205
1204,1205
1209,1210
1211,1212
1211,1213
1212,1213
1213,1214
1213,1215
1213,1216
1213,1217
1214,1215
1216,1217
1218,1219
1218,1220
1219,1220
1222,1223
1224,1225
1226,1227
1226,1228
1227,1228
1227,1229
1228,1229
1228,1230
1229,1230
1232,1233
1234,1235
1235,1236
1235,1237
1236,1237
1238,1239
1241,1242
1242,1243
1244,1245
1245,1246
1247,1248
1247,1249
1247,1250
1247,1251
1247,1252
1247,1253
1247,1254
1247,1255
1247,1256
1247,1257
1247,1258
1247,1259
1248,1249
1249,1250
1249,1251
1251,1252
1251,1253
1251,1254
1254,1255
1255,1256
1257,1258
1258,1259
1258,1260
1259,1260
1261,1262
1263,1264
1264,1265
1264,1266
1265,1266
1267,1268
1269,1270
1270,1271
1270,1272
1272,1273
1274,1275
1274,1276
1274,1277
1275,1276
1275,1277
1276,1277
1276,1278
1277,1278
1280,1281
1280,1282
1281,1282
1281,1283
1282,1283
1285,1286
1285,1287
1286,1287
1286,1288
1287,1288
1291,1292
1292,1293
1292,1294
1293,1294
1295,1296
1297,1298
1298,1299
1298,1300
1299,1300
1301,1302
1301,1303
1301,1304
1301,1305
1302,1303
1304,1305
1306,1307
1308,1309
1309,1310
1311,1312
1311,1313
1312,1313
1312,1314
1313,1314
1315,1316
1317,1318
1317,1319
1317,1320
1318,1319
1319,1320
1319,1321
1320,1321
1322,1323
1322,1324
1322,1325
1323,1324
1325,1326
1327,1328
1327,1329
1328,1329
1331,1332
1332,1333
1332,1334
1332,1335
1332,1336
1332,1337
1332,1338
1333,1334
1335,1336
1337,1338
1339,1340
1341,1342
1341,1343
1341,1344
1342,1343
1344,1345
1344,1346
1345,1346
1350,1351
1352,1353
1353,1354
1353,1355
1354,1355
1356,1357
1356,1358
1357,1358
1360,1361
1361,1362
1361,1363
1362,1363
1362,1364
1363,1364
1366,1367
1368,1369
1369,1370
1369,1371
1370,1371
1372,1373
1372,1374
1372,1375
1372,1376
1373,1374
1375,1376
1377,1378
1377,1379
1378,1379
1381,1382
1383,1384
1384,1385
1384,1386
1385,1386
1385,1387
1386,1387
1389,1390
1391,1392
1392,1393
1392,1394
1393,1394
1395,1396
1397,1398
1397,1399
1398,1399
1399,1400
1401,1402
1404,1405
1405,1406
1407,1408
1408,1409
1410,1411
1410,1412
1411,1412
1411,1413
1412,1413
1412,1414
1413,1414
1413,1415
1414,1415
1418,1419
1420,1421
1420,1422
1421,1422
1422,1423
1422,1424
1422,1425
1422,1426
1423,1424
1425,1426
1425,1427
1426,1427
1429,1430
1432,1433
1434,1435
1434,1436
1435,1436
1436,1437
1436,1438
1436,1439
1436,1440
1436,1441
1437,1438
1439,1440
1441,1442
1443,1444
1443,1445
1444,1445
1444,1446
1445,1446
1449,1450
1450,1451
1450,1452
1451,1452
1451,1453
1452,1453
1456,1457
1459,1460
1460,1461
1462,1463
1463,1464
1465,1466
1465,1467
1466,1467
1466,1468
1467,1468
1467,1469
1468,1469
1468,1470
1469,1470
1473,1474
1475,1476
1475,1477
1476,1477
1477,1478
1477,1479
1477,1480
1477,1481
1478,1479
1480,1481
1480,1482
1481,1482
1484,1485
1487,1488
1489,1490
1489,1491
1490,1491
1491,1492
1491,1493
1491,1494
1491,1495
1491,1496
1492,1493
1494,1495
1496,1497
1498,1499
1498,1500
1499,1500
1499,1501
1500,1501
1504,1505
1505,1506
1505,1507
1506,1507
1506,1508
1507,1508
1511,1512
1514,1515
1515,1516
1517,1518
1518,1519
1520,1521
1520,1522
1520,1523
1520,1524
1520,1525
1520,1526
1520,1527
1520,1528
1520,1529
1520,1530
1520,1531
1521,1522
1522,1523
1522,1524
1523,1524
1525,1526
1527,1528
1528,1529
1528,1530
1529,1530
1531,1532
1533,1534
1534,1535
1534,1536
1535,1536
1537,1538
1539,1540
1540,1541
1540,1542
1541,1542
1543,1544
1545,1546
1546,1547
1546,1548
1547,1548
1549,1550
1549,1551
1549,1552
1552,1553
1553,1554
1555,1556
1555,1557
1556,1557
1557,1558
1559,1560
1559,1561
1559,1562
1560,1561
1561,1562
1561,1563
1562,1563
1564,1565
1564,1566
1564,1567
1565,1566
1567,1568
1569,1570
1569,1571
1570,1571
1573,1574
1574,1575
1574,1576
1574,1577
1574,1578
1574,1579
1575,1576
1577,1578
1577,1579
1578,1579
1581,1582
1584,1585
1584,1586
1584,1587
1585,1586
1587,1588
1587,1589
1588,1589
1593,1594
1593,1595
1594,1595
1594,1596
1595,1596
1595,1597
1596,1597
1596,1598
1597,1598
1602,1603
1602,1604
1602,1605
1603,1604
1604,1605
1604,1606
1605,1606
1607,1608
1607,1609
1607,1610
1608,1609
1610,1611
1612,1613
1612,1614
1613,1614
1616,1617
1617,1618
1617,1619
1617,1620
1617,1621
1617,1622
1617,1623
1618,1619
1620,1621
1620,1622
1621,1622
1624,1625
1627,1628
1627,1629
1627,1630
1628,1629
1630,1631
1630,1632
1631,1632
1635,1636
1635,1637
1636,1637
1636,1638
1637,1638
1642,1643
1643,1644
1643,1645
1644,1645
1646,1647
1647,1648
1647,1649
1649,1650
1649,1651
1650,1651
1650,1652
1651,1652
1655,1656
1655,1657
1655,1658
1656,1657
1656,1658
1657,1658
1658,1659
1658,1660
1659,1660
1659,1661
1660,1661
1663,1664
1665,1666
1666,1667
1666,1668
1667,1668
1667,1669
1668,1669
1671,1672
1671,1673
1672,1673
1672,1674
1673,1674
1676,1677
1678,1679
1678,1680
1679,1680
1680,1681
1680,1682
1681,1682
1683,1684
1685,1686
1686,1687
1686,1688
1687,1688
1690,1691
1690,1692
1691,1692
1692,1693
1692,1694
1693,1694
1695,1696
1695,1697
1697,1698
1699,1700
1700,1701
1700,1702
1701,1702
1703,1704
1705,1706
1705,1707
1705,1708
1706,1707
1706,1708
1707,1708
1707,1709
1708,1709
1711,1712
1711,1713
1712,1713
1712,1714
1713,1714
1716,1717
1718,1719
1719,1720
1719,1721
1720,1721
1722,1723
1724,1725
1725,1726
1725,1727
1726,1727
1728,1729
1728,1730
1728,1731
1728,1732
1729,1730
1731,1732
1733,1734
1735,1736
1736,1737
1738,1739
1738,1740
1738,1741
1739,1740
1739,1741
1740,1741
1742,1743
1744,1745
1744,1746
1745,1746
1746,1747
1746,1748
1747,1748
1749,1750
1749,1751
1749,1752
1750,1751
1752,1753
1754,1755
1754,1756
1755,1756
1758,1759
1759,1760
1759,1761
1759,1762
1759,1763
1759,1764
1759,1765
1760,1761
1762,1763
1764,1765
1766,1767
1768,1769
1768,1770
1768,1771
1769,1770
1771,1772
1771,1773
1772,1773
1777,1778
1777,1779
1778,1779
1779,1780
1779,1781
1779,1782
1779,1783
1779,1784
1779,1785
1780,1781
1782,1783
1784,1785
1784,1786
1785,1786
1788,1789
1790,1791
1790,1792
1791,1792
1793,1794
1795,1796
1795,1797
1796,1797
1798,1799
1798,1800
1800,1801
1802,1803
1803,1804
1803,1805
1804,1805
1806,1807
1809,1810
1810,1811
1812,1813
1812,1814
1812,1815
1813,1814
1814,1815
1814,1816
1815,1816
1817,1818
1819,1820
1820,1821
1820,1822
1821,1822
1823,1824
1825,1826
1825,1827
1826,1827
1826,1828
1827,1828
1827,1829
1827,1830
1827,1831
1828,1829
1830,1831
1832,1833
1834,1835
1835,1836
1837,1838
1839,1840
1839,1841
1840,1841
1840,1842
1841,1842
1843,1844
1843,1845
1843,1846
1843,1847
1843,1848
1843,1849
1843,1850
1843,1851
1843,1852
1844,1845
1845,1846
1847,1848
1848,1849
1848,1850
1849,1850
1851,1852
1854,1855
1855,1856
1857,1858
1858,1859
1858,1860
1859,1860
1861,1862
1865,1866
1866,1867
1866,1868
1867,1868
1871,1872
1871,1873
1872,1873
1872,1874
1873,1874
1876,1877
1877,1878
1877,1879
1877,1880
1877,1881
1878,1879
1880,1881
1882,1883
1884,1885
1888,1889
1889,1890
1889,1891
1890,1891
1890,1892
1893,1894
1893,1895
1893,1896
1893,1897
1894,1895
1896,1897
1898,1899
1900,1901
1903,1904
1903,1905
1904,1905
1904,1906
1905,1906
1905,1907
1906,1907
1906,1908
1907,1908
1911,1912
1913,1914
1913,1915
1913,1916
1914,1915
1914,1916
1914,1917
1915,1916
1916,1917
1916,1918
1916,1919
1917,1918
1919,1920
1921,1922
1923,1924
1923,1925
1924,1925
1925,1926
1925,1927
1925,1928
1925,1929
1926,1927
1928,1929
1928,1930
1929,1930
1932,1933
1935,1936
1935,1937
1936,1937
1937,1938
1937,1939
1937,1940
1937,1941
1938,1939
1940,1941
1942,1943
1944,1945
1946,1947
1948,1949
1948,1950
1949,1950
1949,1951
1950,1951
1950,1952
1951,1952
1951,1953
1952,1953
1956,1957
1958,1959
1958,1960
1959,1960
1960,1961
1960,1962
1961,1962
1961,1963
1962,1963
1962,1964
1963,1964
1967,1968
1969,1970
1970,1971
1970,1972
1970,1973
1970,1974
1971,1972
1973,1974
1973,1975
1974,1975
1977,1978
1980,1981
1980,1982
1981,1982
1982,1983
1982,1984
1982,1985
1983,1984
1985,1986
1987,1988
1989,1990
1989,1991
1990,1991
1991,1992
1991,1993
1991,1994
1991,1995
1992,1993
1994,1995
1994,1996
1995,1996
1998,1999
2001,2002
2001,2003
2002,2003
2003,2004
2003,2005
2003,2006
2003,2007
2004,2005
2006,2007
2008,2009
2011,2012
2013,2014
2013,2015
2014,2015
2015,2016
2015,2017
2015,2018
2016,2017
2018,2019
2020,2021
2022,2023
2022,2024
2023,2024
2023,2025
2024,2025
2024,2026
2025,2026
2025,2027
2026,2027
2026,2028
2027,2028
2031,2032
2033,2034
2033,2035
2034,2035
2035,2036
2035,2037
2035,2038
2035,2039
2036,2037
2038,2039
2038,2040
2039,2040
2042,2043
2045,2046
2045,2047
2046,2047
2047,2048
2047,2049
2047,2050
2047,2051
2048,2049
2050,2051
2052,2053
2055,2056
2057,2058
2057,2059
2057,2060
2058,2059
2058,2060
2059,2060
2059,2061
2060,2061
2060,2062
2061,2062
2065,2066
2067,2068
2067,2069
2068,2069
2069,2070
2069,2071
2069,2072
2069,2073
2070,2071
2072,2073
2072,2074
2073,2074
2076,2077
2079,2080
2079,2081
2080,2081
2081,2082
2081,2083
2081,2084
2081,2085
2082,2083
2084,2085
2086,2087
2089,2090
2091,2092
2091,2093
2092,2093
2092,2094
2093,2094
2094,2095
2094,2096
2095,2096
2095,2097
2096,2097
2096,2098
2097,2098
2101,2102
2103,2104
2104,2105
2104,2106
2105,2106
2105,2107
2106,2107
2106,2108
2107,2108
2111,2112
2113,2114
2114,2115
2114,2116
2115,2116
2116,2117
2116,2118
2116,2119
2116,2120
2117,2118
2119,2120
2121,2122
2124,2125
2126,2127
2127,2128
2127,2129
2128,2129
2130,2131
2130,2132
2131,2132
2133,2134
2133,2135
2134,2135
2134,2136
2135,2136
2139,2140
2139,2141
2140,2141
2140,2142
2141,2142
2143,2144
2143,2145
2144,2145
2144,2146
2145,2146
2145,2147
2146,2147
2146,2148
2147,2148
2151,2152
2151,2153
2152,2153
2152,2154
2153,2154
2157,2158
2159,2160
2159,2161
2159,2162
2159,2163
2159,2164
2159,2165
2159,2166
2159,2167
2159,2168
2159,2169
2160,2161
2161,2162
2161,2163
2162,2163
2164,2165
2166,2167
2167,2168
2167,2169
2168,2169
2170,2171
2170,2172
2173,2174
2174,2175
2174,2176
2174,2177
2174,2178
2175,2176
2177,2178
2177,2179
2178,2179
2181,2182
2184,2185
2185,2186
2185,2187
2186,2187
2188,2189
2188,2190
2189,2190
2189,2191
2190,2191
2194,2195
2195,2196
2195,2197
2196,2197
2196,2198
2197,2198
2197,2199
2198,2199
2202,2203
2202,2204
2203,2204
2204,2205
2206,2207
2206,2208
2207,2208
2207,2209
2208,2209
2208,2210
2209,2210
2213,2214
2215,2216
2216,2217
2216,2218
2217,2218
2219,2220
2219,2221
2220,2221
2220,2222
2221,2222
2223,2224
2225,2226
2225,2227
2225,2228
2226,2227
2228,2229
2228,2230
2229,2230
2229,2231
2230,2231
2234,2235
2235,2236
2235,2237
2236,2237
2239,2240
2239,2241
2240,2241
2241,2242
2243,2244
2243,2245
2244,2245
2245,2246
2245,2247
2245,2248
2245,2249
2245,2250
2246,2247
2248,2249
2248,2250
2249,2250
2252,2253
2255,2256
2255,2257
2256,2257
2256,2258
2257,2258
2261,2262
2263,2264
2264,2265
2264,2266
2264,2267
2264,2268
2265,2266
2267,2268
2269,2270
2269,2271
2270,2271
2270,2272
2271,2272
2275,2276
2275,2277
2276,2277
2278,2279
2279,2280
2279,2281
2280,2281
2283,2284
2284,2285
2284,2286
2284,2287
2284,2288
2285,2286
2287,2288
2288,2289
2288,2290
2289,2290
2289,2291
2290,2291
2294,2295
2296,2297
2296,2298
2297,2298
2297,2299
2298,2299
2302,2303
2303,2304
2303,2305
2304,2305
2306,2307
2308,2309
2308,2310
2309,2310
2309,2311
2310,2311
2310,2312
2311,2312
2311,2313
2312,2313
2312,2314
2313,2314
2317,2318
2319,2320
2320,2321
2320,2322
2320,2323
2321,2322
2323,2324
2325,2326
2327,2328
2328,2329
2328,2330
2328,2331
2329,2330
2329,2331
2330,2331
2330,2332
2331,2332
2331,2333
2332,2333
2332,2334
2333,2334
2338,2339
2338,2340
2339,2340
2339,2341
2340,2341
2340,2342
2341,2342
2346,2347
2347,2348
2347,2349
2348,2349
2348,2350
2349,2350
2349,2351
2350,2351
2354,2355
2356,2357
2356,2358
2356,2359
2357,2358
2357,2359
2358,2359
2358,2360
2359,2360
2359,2361
2360,2361
2365,2366
2366,2367
2366,2368
2367,2368
2367,2369
2368,2369
2368,2370
2369,2370
2373,2374
2375,2376
2375,2377
2376,2377
2377,2378
2377,2379
2377,2380
2378,2379
2380,2381
2383,2384
2385,2386
2385,2387
2386,2387
2386,2388
2387,2388
2387,2389
2388,2389
2388,2390
2389,2390
2393,2394
2395,2396
2396,2397
2396,2398
2396,2399
2397,2398
2398,2399
2398,2400
2398,2401
2399,2400
2401,2402
2403,2404
2405,2406
2405,2407
2405,2408
2406,2407
2406,2408
2407,2408
2407,2409
2408,2409
2409,2410
2409,2411
2410,2411
2410,2412
2411,2412
2411,2413
2412,2413
2412,2414
2413,2414
2417,2418
2419,2420
2419,2421
2420,2421
2420,2422
2421,2422
2421,2423
2422,2423
2427,2428
2428,2429
2428,2430
2429,2430
2429,2431
2430,2431
2430,2432
2431,2432
2431,2433
2432,2433
2436,2437
2438,2439
2438,2440
2439,2440
2439,2441
2440,2441
2440,2442
2441,2442
2445,2446
2445,2447
2446,2447
2446,2448
2447,2448
2450,2451
2450,2452
2451,2452
2451,2453
2452,2453
2456,2457
2456,2458
2457,2458
2458,2459
2458,2460
2458,2461
2459,2460
2461,2462
2464,2465
2466,2467
2467,2468
2467,2469
2467,2470
2467,2471
2468,2469
2470,2471
2470,2472
2471,2472
2474,2475
2477,2478
2477,2479
2478,2479
2478,2480
2479,2480
2479,2481
2479,2482
2479,2483
2480,2481
2482,2483
2484,2485
2486,2487
2489,2490
2491,2492
2491,2493
2491,2494
2492,2493
2492,2494
2493,2494
2493,2495
2494,2495
2494,2496
2495,2496
2495,2497
2496,2497
2496,2498
2497,2498
2497,2499
2498,2499
2498,2500
2499,2500
2504,2505
2505,2506
2506,2507
2506,2508
2507,2508
2507,2509
2508,2509
2511,2512
2513,2514
2513,2515
2514,2515
2516,2517
2518,2519
2518,2520
2519,2520
2519,2521
2520,2521
2520,2522
2521,2522
2521,2523
2522,2523
2528,2529
2529,2530
2529,2531
2530,2531
2530,2532
2531,2532
2532,2533
2532,2534
2533,2534
2533,2535
2534,2535
2534,2536
2535,2536
2535,2537
2536,2537
2536,2538
2537,2538
2543,2544
2543,2545
2544,2545
2544,2546
2545,2546
2545,2547
2546,2547
2546,2548
2547,2548
2553,2554
2554,2555
2554,2556
2555,2556
2555,2557
2556,2557
2556,2558
2557,2558
2557,2559
2558,2559
2562,2563
2564,2565
2565,2566
2565,2567
2566,2567
2566,2568
2567,2568
2567,2569
2568,2569
2568,2570
2569,2570
2569,2571
2570,2571
2575,2576
2575,2577
2576,2577
2578,2579
2580,2581
2580,2582
2581,2582
2581,2583
2582,2583
2582,2584
2583,2584
2583,2585
2584,2585
2589,2590
2589,2591
2590,2591
2590,2592
2591,2592
2593,2594
2595,2596
2595,2597
2596,2597
2596,2598
2597,2598
2597,2599
2598,2599
2603,2604
2604,2605
2604,2606
2605,2606
2605,2607
2606,2607
2606,2608
2607,2608
2607,2609
2608,2609
2611,2612
2613,2614
2613,2615
2614,2615
2614,2616
2615,2616
2615,2617
2616,2617
2620,2621
2622,2623
2622,2624
2623,2624
2623,2625
2624,2625
2624,2626
2625,2626
2625,2627
2626,2627
2631,2632
2631,2633
2632,2633
2632,2634
2633,2634
2635,2636
2637,2638
2637,2639
2638,2639
2638,2640
2639,2640
2643,2644
2643,2645
2644,2645
2645,2646
2645,2647
2645,2648
2645,2649
2646,2647
2648,2649
2648,2650
2649,2650
2652,2653
2655,2656
2655,2657
2656,2657
2656,2658
2657,2658
2657,2659
2657,2660
2657,2661
2658,2659
2660,2661
2662,2663
2664,2665
2667,2668
2669,2670
2669,2671
2670,2671
2670,2672
2671,2672
2671,2673
2672,2673
2672,2674
2673,2674
2673,2675
2674,2675
2674,2676
2675,2676
2675,2677
2676,2677
2676,2678
2677,2678
2677,2679
2678,2679
2682,2683
2684,2685
2684,2686
2685,2686
2685,2687
2686,2687
2686,2688
2687,2688
2692,2693
2692,2694
2693,2694
2693,2695
2694,2695
2694,2696
2695,2696
2699,2700
2701,2702
2701,2703
2702,2703
2702,2704
2703,2704
2703,2705
2704,2705
2704,2706
2705,2706
2710,2711
2710,2712
2711,2712
2711,2713
2712,2713
2712,2714
2713,2714
2718,2719
2718,2720
2719,2720
2719,2721
2720,2721
2720,2722
2721,2722
2721,2723
2722,2723
2728,2729
2728,2730
2729,2730
2729,2731
2730,2731
2730,2732
2731,2732
2731,2733
2732,2733
2738,2739
2738,2740
2739,2740
2740,2741
2740,2742
2740,2743
2740,2744
2741,2742
2743,2744
2743,2745
2744,2745
2747,2748
2750,2751
2750,2752
2751,2752
2751,2753
2752,2753
2752,2754
2752,2755
2752,2756
2753,2754
2755,2756
2757,2758
2759,2760
2762,2763
2764,2765
2764,2766
2765,2766
2767,2768
2767,2769
2768,2769
2769,2770
2769,2771
2770,2771
2772,2773
2774,2775
2775,2776
2775,2777
2776,2777
2778,2779
2780,2781
2780,2782
2781,2782
2782,2783
2782,2784
2782,2785
2783,2784
2785,2786
2787,2788
2789,2790
2790,2791
2790,2792
2790,2793
2791,2792
2791,2793
2792,2793
2792,2794
2793,2794
2793,2795
2794,2795
2799,2800
2800,2801
2800,2802
2801,2802
2801,2803
2802,2803
2802,2804
2803,2804
2808,2809
2809,2810
2809,2811
2810,2811
2810,2812
2811,2812
2811,2813
2812,2813
2816,2817
2816,2818
2817,2818
2818,2819
2820,2821
2820,2822
2821,2822
2822,2823
2822,2824
2824,2825
2824,2826
2825,2826
2825,2827
2826,2827
2831,2832
2831,2833
2832,2833
2832,2834
2833,2834
2833,2835
2834,2835
2834,2836
2835,2836
2840,2841
2840,2842
2840,2843
2841,2842
2842,2843
2842,2844
2843,2844
2845,2846
2847,2848
2848,2849
2848,2850
2849,2850
2849,2851
2850,2851
2850,2852
2851,2852
2856,2857
2856,2858
2856,2859
2856,2860
2857,2858
2858,2859
2858,2860
2859,2860
2862,2863
2862,2864
2863,2864
2865,2866
2865,2867
2866,2867
2866,2868
2867,2868
2871,2872
2872,2873
2874,2875
2875,2876
2875,2877
2876,2877
2876,2878
2877,2878
2877,2879
2878,2879
2878,2880
2879,2880
2879,2881
2880,2881
2884,2885
2884,2886
2885,2886
2888,2889
2888,2890
2889,2890
2889,2891
2890,2891
2890,2892
2891,2892
2895,2896
2897,2898
2897,2899
2898,2899
2899,2900
2899,2901
2900,2901
2900,2902
2901,2902
2901,2903
2902,2903
2908,2909
2909,2910
2909,2911
2910,2911
2911,2912
2912,2913
2912,2914
2913,2914
2916,2917
2918,2919
2918,2920
2919,2920
2919,2921
2920,2921
2920,2922
2921,2922
2921,2923
2922,2923
2923,2924
2923,2925
2924,2925
2924,2926
2925,2926
2925,2927
2926,2927
2930,2931
2932,2933
2933,2934
2933,2935
2934,2935
2934,2936
2935,2936
2935,2937
2936,2937
2941,2942
2942,2943
2942,2944
2943,2944
2943,2945
2944,2945
2944,2946
2945,2946
2949,2950
2951,2952
2952,2953
2952,2954
2953,2954
2954,2955
2954,2956
2955,2956
2955,2957
2956,2957
2959,2960
2960,2961
2960,2962
2961,2962
2963,2964
2965,2966
2967,2968
2967,2969
2968,2969
2968,2970
2969,2970
2969,2971
2970,2971
2971,2972
2971,2973
2972,2973
2974,2975
2976,2977
2977,2978
2977,2979
2978,2979
2978,2980
2979,2980
2983,2984
2985,2986
2986,2987
2986,2988
2987,2988
2989,2990
2991,2992
2992,2993
2992,2994
2993,2994
2993,2995
2994,2995
2997,2998
2998,2999
3000,3001
3001,3002
3001,3003
3002,3003
3002,3004
3003,3004
3006,3007
3007,3008
3009,3010
3010,3011
3010,3012
3011,3012
3011,3013
3012,3013
3015,3016
3015,3017
3016,3017
3017,3018
3020,3021
3021,3022
3021,3023
3022,3023
3022,3024
3023,3024
3026,3027
3026,3028
3027,3028
3028,3029
3031,3032
3032,3033
3032,3034
3033,3034
3033,3035
3034,3035
3037,3038
3037,3039
3038,3039
3039,3040
3042,3043
3043,3044
3043,3045
3044,3045
3044,3046
3045,3046
3048,3049
3048,3050
3049,3050
3050,3051
3053,3054
3054,3055
3054,3056
3055,3056
3055,3057
3056,3057
3059,3060
3059,3061
3060,3061
3061,3062
3064,3065
3065,3066
3065,3067
3066,3067
3066,3068
3067,3068
3070,3071
3070,3072
3071,3072
3073,3074
3075,3076
3075,3077
3076,3077
3077,3078
3077,3079
3078,3079
3081,3082
3081,3083
3082,3083
3083,3084
3083,3085
3083,3086
3083,3087
3084,3085
3086,3087
3086,3088
3087,3088
3090,3091
3093,3094
3094,3095
3096,3097
3096,3098
3096,3099
3097,3098
3097,3099
3098,3099
3100,3101
3102,3103
3102,3104
3103,3104
3104,3105
3104,3106
3105,3106
3105,3107
3106,3107
3109,3110
3109,3111
3110,3111
3112,3113
3114,3115
3114,3116
3115,3116
3116,3117
3116,3118
3117,3118
3120,3121
3120,3122
3121,3122
3122,3123
3122,3124
3122,3125
3122,3126
3123,3124
3125,3126
3125,3127
3126,3127
3129,3130
3132,3133
3133,3134
3135,3136
3136,3137
3136,3138
3137,3138
3138,3139
3138,3140
3139,3140
3141,3142
3143,3144
3143,3145
3144,3145
3145,3146
3145,3147
3145,3148
3145,3149
3146,3147
3148,3149
3148,3150
3149,3150
3152,3153
3155,3156
3156,3157
3158,3159
3159,3160
3161,3162
3161,3163
3163,3164
3163,3165
3164,3165
3166,3167
3167,3168
3167,3169
3168,3169
3170,3171
3172,3173
3173,3174
-----nextToken-----
2,4,7,9,10,14,16,17,19,23,25,26,30,32,36,38,39,43,45,49,51,52,56,58,61,65,67,70,72,75,78,80,85,86,89,90,95,97,100,101,103,110,111,113,118,119,123,126,127,131,134,136,138,141,145,146,150,154,158,160,162,164,169,171,172,176,178,184,186,189,190,193,195,199,202,207,209,210,214,216,222,225,226,229,232,233,236,238,242,245,251,252,255,256,261,262,264,269,270,273,278,279,282,286,288,292,294,298,300,302,304,308,311,313,315,317,319,322,328,330,332,333,335,340,341,343,347,350,352,354,356,358,361,366,368,372,374,378,381,383,385,388,392,394,398,401,403,405,408,412,414,419,421,423,425,426,427,429,434,436,438,440,442,447,448,450,456,458,460,462,464,470,471,474,476,479,481,485,488,494,495,497,502,504,507,508,511,515,517,522,525,526,528,529,532,533,536,537,542,544,547,549,552,553,557,558,561,562,563,568,571,572,574,575,578,579,582,583,588,589,591,596,598,601,602,605,609,612,614,619,620,622,627,631,632,634,639,640,642,647,648,650,655,656,660,663,666,669,673,675,678,679,680,683,686,689,692,695,698,701,704,707,712,714,716,717,719,724,725,727,728,729,734,736,739,740,745,746,748,749,757,758,759,761,767,768,769,771,777,779,781,785,788,790,792,794,796,802,803,808,809,810,815,818,820,822,824,826,832,833,838,839,840,847,848,849,851,855,858,859,861,862,867,869,871,876,878,879,881,886,888,890,897,898,899,902,904,910,911,912,916,917,918,924,925,926,930,931,932,938,939,940,944,945,946,951,952,955,962,963,964,967,969,974,975,977,983,984,985,990,993,994,996,997,1001,1003,1004,1005,1007,1013,1014,1015,1019,1020,1021,1027,1028,1029,1031,1037,1038,1039,1043,1044,1045,1050,1052,1054,1060,1062,1066,1068,1069,1070,1072,1078,1079,1082,1084,1087,1089,1093,1096,1101,1102,1106,1107,1110,1113,1116,1119,1122,1127,1129,1133,1135,1139,1142,1144,1146,1149,1153,1155,1159,1162,1164,1166,1169,1173,1175,1180,1183,1185,1188,1189,1193,1195,1197,1199,1202,1205,1206,1207,1208,1210,1215,1217,1220,1221,1223,1225,1230,1231,1233,1237,1239,1240,1243,1246,1250,1252,1253,1256,1260,1262,1266,1268,1271,1273,1278,1279,1283,1284,1288,1289,1290,1294,1296,1300,1303,1305,1307,1310,1314,1316,1321,1324,1326,1329,1330,1334,1336,1338,1340,1343,1346,1347,1348,1349,1351,1355,1358,1359,1364,1365,1367,1371,1374,1376,1379,1380,1382,1387,1388,1390,1394,1396,1400,1402,1403,1406,1409,1415,1416,1417,1419,1424,1427,1428,1430,1431,1433,1438,1440,1442,1446,1447,1448,1453,1454,1455,1457,1458,1461,1464,1470,1471,1472,1474,1479,1482,1483,1485,1486,1488,1493,1495,1497,1501,1502,1503,1508,1509,1510,1512,1513,1516,1519,1524,1526,1530,1532,1536,1538,1542,1544,1548,1550,1551,1554,1558,1563,1566,1568,1571,1572,1576,1579,1580,1582,1583,1586,1589,1590,1591,1592,1598,1599,1600,1601,1606,1609,1611,1614,1615,1619,1622,1623,1625,1626,1629,1632,1633,1634,1638,1639,1640,1641,1645,1648,1652,1653,1654,1661,1662,1664,1669,1670,1674,1675,1677,1682,1684,1688,1689,1694,1696,1698,1702,1704,1709,1710,1714,1715,1717,1721,1723,1727,1730,1732,1734,1737,1741,1743,1748,1751,1753,1756,1757,1761,1763,1765,1767,1770,1773,1774,1775,1776,1781,1783,1786,1787,1789,1792,1794,1797,1799,1801,1805,1807,1808,1811,1816,1818,1822,1824,1829,1831,1833,1836,1838,1842,1846,1850,1852,1853,1856,1860,1862,1863,1864,1868,1869,1870,1874,1875,1879,1881,1883,1885,1886,1887,1891,1892,1895,1897,1899,1901,1902,1908,1909,1910,1912,1918,1920,1922,1927,1930,1931,1933,1934,1939,1941,1943,1945,1947,1953,1954,1955,1957,1964,1965,1966,1968,1972,1975,1976,1978,1979,1984,1986,1988,1993,1996,1997,1999,2000,2005,2007,2009,2010,2012,2017,2019,2021,2028,2029,2030,2032,2037,2040,2041,2043,2044,2049,2051,2053,2054,2056,2062,2063,2064,2066,2071,2074,2075,2077,2078,2083,2085,2087,2088,2090,2098,2099,2100,2102,2108,2109,2110,2112,2118,2120,2122,2123,2125,2129,2132,2136,2137,2138,2142,2148,2149,2150,2154,2155,2156,2158,2163,2165,2169,2171,2172,2176,2179,2180,2182,2183,2187,2191,2192,2193,2199,2200,2201,2205,2210,2211,2212,2214,2218,2222,2224,2227,2231,2232,2233,2237,2238,2242,2247,2250,2251,2253,2254,2258,2259,2260,2262,2266,2268,2272,2273,2274,2277,2281,2282,2286,2291,2292,2293,2295,2299,2300,2301,2305,2307,2314,2315,2316,2318,2322,2324,2326,2334,2335,2336,2337,2342,2343,2344,2345,2351,2352,2353,2355,2361,2362,2363,2364,2370,2371,2372,2374,2379,2381,2382,2384,2390,2391,2392,2394,2400,2402,2404,2414,2415,2416,2418,2423,2424,2425,2426,2433,2434,2435,2437,2442,2443,2444,2448,2449,2453,2454,2455,2460,2462,2463,2465,2469,2472,2473,2475,2476,2481,2483,2485,2487,2488,2490,2500,2501,2502,2503,2509,2510,2512,2515,2517,2523,2524,2525,2526,2527,2538,2539,2540,2541,2542,2548,2549,2550,2551,2552,2559,2560,2561,2563,2571,2572,2573,2574,2577,2579,2585,2586,2587,2588,2592,2594,2599,2600,2601,2602,2609,2610,2612,2617,2618,2619,2621,2627,2628,2629,2630,2634,2636,2640,2641,2642,2647,2650,2651,2653,2654,2659,2661,2663,2665,2666,2668,2679,2680,2681,2683,2688,2689,2690,2691,2696,2697,2698,2700,2706,2707,2708,2709,2714,2715,2716,2717,2723,2724,2725,2726,2727,2733,2734,2735,2736,2737,2742,2745,2746,2748,2749,2754,2756,2758,2760,2761,2763,2766,2771,2773,2777,2779,2784,2786,2788,2795,2796,2797,2798,2804,2805,2806,2807,2813,2814,2815,2819,2823,2827,2828,2829,2830,2836,2837,2838,2839,2844,2846,2852,2853,2854,2855,2860,2861,2864,2868,2869,2870,2873,2881,2882,2883,2886,2887,2892,2893,2894,2896,2903,2904,2905,2906,2907,2914,2915,2917,2927,2928,2929,2931,2937,2938,2939,2940,2946,2947,2948,2950,2957,2958,2962,2964,2966,2973,2975,2980,2981,2982,2984,2988,2990,2995,2996,2999,3004,3005,3008,3013,3014,3018,3019,3024,3025,3029,3030,3035,3036,3040,3041,3046,3047,3051,3052,3057,3058,3062,3063,3068,3069,3072,3074,3079,3080,3085,3088,3089,3091,3092,3095,3099,3101,3107,3108,3111,3113,3118,3119,3124,3127,3128,3130,3131,3134,3140,3142,3147,3150,3151,3153,3154,3157,3160,3162,3165,3169,3171,3174
-----computeFrom-----
82,83
82,84
121,122
121,123
129,130
129,131
182,183
182,184
187,188
187,189
191,192
191,193
220,221
220,222
223,224
223,225
227,228
227,229
230,231
230,232
234,235
234,236
248,249
248,250
258,259
258,260
266,267
266,268
275,276
275,277
306,307
306,308
337,338
337,339
345,346
345,347
376,377
376,378
390,391
390,392
396,397
396,398
410,411
410,412
444,445
444,446
468,469
468,470
472,473
472,474
477,478
477,479
491,492
491,493
513,514
513,515
585,586
585,587
610,611
610,612
616,617
616,618
625,626
625,627
636,637
636,638
644,645
644,646
721,722
721,723
742,743
742,744
751,752
751,753
753,754
753,755
763,764
763,765
783,784
783,785
798,799
798,800
800,801
800,802
805,806
805,807
813,814
813,815
828,829
828,830
830,831
830,832
835,836
835,837
843,844
843,845
893,894
893,895
906,907
906,908
920,921
920,922
934,935
934,936
948,949
948,950
958,959
958,960
971,972
971,973
1009,1010
1009,1011
1023,1024
1023,1025
1033,1034
1033,1035
1076,1077
1076,1078
1080,1081
1080,1082
1085,1086
1085,1087
1137,1138
1137,1139
1151,1152
1151,1153
1157,1158
1157,1159
1171,1172
1171,1173
1178,1179
1178,1180
1227,1228
1227,1229
1235,1236
1235,1237
1275,1276
1275,1277
1292,1293
1292,1294
1298,1299
1298,1300
1312,1313
1312,1314
1319,1320
1319,1321
1353,1354
1353,1355
1361,1362
1361,1363
1369,1370
1369,1371
1384,1385
1384,1386
1411,1412
1411,1413
1466,1467
1466,1468
1561,1562
1561,1563
1594,1595
1594,1596
1604,1605
1604,1606
1643,1644
1643,1645
1647,1648
1647,1649
1656,1657
1656,1658
1658,1659
1658,1660
1666,1667
1666,1668
1680,1681
1680,1682
1686,1687
1686,1688
1692,1693
1692,1694
1695,1696
1695,1697
1700,1701
1700,1702
1706,1707
1706,1708
1719,1720
1719,1721
1725,1726
1725,1727
1739,1740
1739,1741
1746,1747
1746,1748
1790,1791
1790,1792
1795,1796
1795,1797
1798,1799
1798,1800
1826,1827
1826,1828
1848,1849
1848,1850
1858,1859
1858,1860
1866,1867
1866,1868
1872,1873
1872,1874
1904,1905
1904,1906
1949,1950
1949,1951
1960,1961
1960,1962
2024,2025
2024,2026
2058,2059
2058,2060
2092,2093
2092,2094
2094,2095
2094,2096
2104,2105
2104,2106
2127,2128
2127,2129
2140,2141
2140,2142
2143,2144
2143,2145
2144,2145
2144,2146
2185,2186
2185,2187
2195,2196
2195,2197
2206,2207
2206,2208
2216,2217
2216,2218
2275,2276
2275,2277
2309,2310
2309,2311
2310,2311
2310,2312
2329,2330
2329,2331
2330,2331
2330,2332
2338,2339
2338,2340
2347,2348
2347,2349
2357,2358
2357,2359
2366,2367
2366,2368
2386,2387
2386,2388
2407,2408
2407,2409
2409,2410
2409,2411
2410,2411
2410,2412
2419,2420
2419,2421
2428,2429
2428,2430
2429,2430
2429,2431
2438,2439
2438,2440
2478,2479
2478,2480
2492,2493
2492,2494
2493,2494
2493,2495
2494,2495
2494,2496
2495,2496
2495,2497
2496,2497
2496,2498
2506,2507
2506,2508
2518,2519
2518,2520
2529,2530
2529,2531
2530,2531
2530,2532
2532,2533
2532,2534
2533,2534
2533,2535
2543,2544
2543,2545
2554,2555
2554,2556
2555,2556
2555,2557
2565,2566
2565,2567
2566,2567
2566,2568
2580,2581
2580,2582
2589,2590
2589,2591
2604,2605
2604,2606
2605,2606
2605,2607
2606,2607
2606,2608
2613,2614
2613,2615
2622,2623
2622,2624
2631,2632
2631,2633
2656,2657
2656,2658
2670,2671
2670,2672
2671,2672
2671,2673
2672,2673
2672,2674
2673,2674
2673,2675
2674,2675
2674,2676
2675,2676
2675,2677
2684,2685
2684,2686
2692,2693
2692,2694
2701,2702
2701,2703
2718,2719
2718,2720
2728,2729
2728,2730
2751,2752
2751,2753
2775,2776
2775,2777
2791,2792
2791,2793
2800,2801
2800,2802
2809,2810
2809,2811
2820,2821
2820,2822
2822,2823
2822,2824
2832,2833
2832,2834
2848,2849
2848,2850
2858,2859
2858,2860
2862,2863
2862,2864
2876,2877
2876,2878
2884,2885
2884,2886
2899,2900
2899,2901
2919,2920
2919,2921
2920,2921
2920,2922
2921,2922
2921,2923
2923,2924
2923,2925
2933,2934
2933,2935
2942,2943
2942,2944
2952,2953
2952,2954
2954,2955
2954,2956
2960,2961
2960,2962
2969,2970
2969,2971
2992,2993
2992,2994
3001,3002
3001,3003
3010,3011
3010,3012
3015,3016
3015,3017
3021,3022
3021,3023
3026,3027
3026,3028
3032,3033
3032,3034
3037,3038
3037,3039
3043,3044
3043,3045
3048,3049
3048,3050
3054,3055
3054,3056
3059,3060
3059,3061
3065,3066
3065,3067
3104,3105
3104,3106
-----guardedBy-----
256,262
255,261
392,398
412,423
495,602
494,601
497,591
515,612
517,614
620,746
619,745
622,748
767,858
768,848
769,849
809,839
808,838
1027,1043
1028,1044
1153,1159
1173,1197
1314,1338
1415,1427
1470,1482
1598,1638
1599,1639
1600,1640
1677,1684
1741,1765
1831,1881
1836,1842
1874,1885
1908,2120
1909,2109
1953,1975
1954,1965
1955,1966
2028,2051
2062,2085
2108,2120
2154,2299
2158,2214
2150,2212
2155,2300
2156,2301
2324,2381
2315,2371
2316,2372
2342,2351
2343,2352
2361,2370
2362,2371
2390,2756
2392,2698
2391,2734
2453,2462
2523,2661
2733,2756
2795,2804
2796,2805
2836,2903
2837,2904
2838,2870
2892,2903
2893,2904
2957,2990
2947,2981
-----guardedByNegation-----
640,679
639,678
1288,1305
1278,1307
1677,1704
1709,1734
2062,2120
2063,2109
2064,2110
2342,2381
2343,2371
2336,2363
2361,2381
2523,2756
2524,2734
2502,2690
2795,2827
2796,2828
2797,2829
-----lastLexicalUse-----
1677,1704
2062,2120
2342,2381
2343,2371
2361,2381
2523,2756
2795,2827
2796,2828
-----jump-----
1677,1704
2062,2120
2342,2381
2343,2371
2361,2381
2523,2756
2795,2827
2796,2828
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ProblemStatement;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;DefaultStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ConditionalExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;ForStatement;ExpressionStatement;ExpressionList;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionList;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ContinueStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ConditionalExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;GotoStatement;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ArraySubscriptExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;ReturnStatement;UnaryExpression;LiteralExpression;LabelStatement;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;
-----ast_node-----
intTIFFReadDirectory(TIFF* tif){	static const char module[] = "TIFFReadDirectory";	TIFFDirEntry* dir;	uint16 dircount;	TIFFDirEntry* dp;	uint16 di;	const TIFFField* fip;	uint32 fii=FAILED_FII;        toff_t nextdiroff;    int bitspersample_read = FALSE;        int color_channels;	tif->tif_diroff=tif->tif_nextdiroff;	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))		return 0;           /* last offset or bad offset (IFD looping) */	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */	tif->tif_curdir++;        nextdiroff = tif->tif_nextdiroff;	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);	if (!dircount)	{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}	TIFFReadDirectoryCheckOrder(tif,dir,dircount);        /*         * Mark duplicates of any tag to be ignored (bugzilla 1994)         * to avoid certain pathological problems.         */	{		TIFFDirEntry* ma;		uint16 mb;		for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}	}        	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */	/* free any old stuff and reinit */	TIFFFreeDirectory(tif);	TIFFDefaultDirectory(tif);	/*	 * Electronic Arts writes gray-scale TIFF files	 * without a PlanarConfiguration directory entry.	 * Thus we setup a default value here, even though	 * the TIFF spec says there is no default value.	 */	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);	/*	 * Setup default value and then make a pass over	 * the fields to check type and tag information,	 * and to extract info required to size data	 * structures.  A second pass is made afterwards	 * to read in everything not taken in the first pass.	 * But we must process the Compression tag first	 * in order to merge in codec-private tag definitions (otherwise	 * we may get complaints about unknown tags).  However, the	 * Compression tag may be dependent on the SamplesPerPixel	 * tag value because older TIFF specs permitted Compression	 * to be written as a SamplesPerPixel-count tag entry.	 * Thus if we don't first figure out the correct SamplesPerPixel	 * tag value then we may end up ignoring the Compression tag	 * value because it has an incorrect count value (if the	 * true value of SamplesPerPixel is not 1).	 */	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);	if (dp)	{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);	if (dp)	{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}	else	{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}	/*	 * First real pass over the directory.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}		}	}	/*	 * XXX: OJPEG hack.	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,	 * c) strip offsets/bytecounts tag are both present and	 * d) both contain exactly one value, then we consistently find	 * that the buggy implementation of the buggy compression scheme	 * matches contig planarconfig best. So we 'fix-up' the tag here	 */	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))	{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}	/*	 * Allocate directory structure and setup defaults.	 */	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))	{		MissingRequired(tif,"ImageLength");		goto bad;	}	/*	 * Setup appropriate structures (by strip or by tile)	 */	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	} else {		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}	if (!tif->tif_dir.td_nstrips) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {#ifdef OJPEG_SUPPORT		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else#endif        {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}	/*	 * Second pass: extract other information.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yuck). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}	/*	 * OJPEG hack:	 * - If a) compression is OJPEG, and b) photometric tag is missing,	 * then we consistently find that photometric should be YCbCr	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,	 * then we consistently find that the buggy implementation of the	 * buggy compression scheme matches photometric YCbCr instead.	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,	 * then we consistently find bitspersample should be 8.	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is RGB or YCbCr, then we consistently find	 * samplesperpixel should be 3	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently	 * find samplesperpixel should be 3	 */	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)	{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}	/*	 * Make sure all non-color channels are extrasamples.	 * If it's not the case, define them as such.	 */        color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);        if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {                uint16 old_extrasamples;                uint16 *new_sampleinfo;                TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples.");                old_extrasamples = tif->tif_dir.td_extrasamples;                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);                // sampleinfo should contain information relative to these new extra samples                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));                if (!new_sampleinfo) {                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);                    goto bad;                }                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);                _TIFFfree(new_sampleinfo);        }	/*	 * Verify Palette image has a Colormap.	 */	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}	/*	 * OJPEG hack:	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG	 * TIFFs	 */	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)	{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}	if (dir)	{		_TIFFfree(dir);		dir=NULL;	}	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))	{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}	/*	 * XXX: We can optimize checking for the strip bounds using the sorted	 * bytecounts array. See also comments for TIFFAppendToStrip()	 * function in tif_write.c.	 */#if !defined(DEFER_STRILE_LOAD)        	if (tif->tif_dir.td_nstrips > 1) {		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}#endif /* !defined(DEFER_STRILE_LOAD) */        	/*	 * An opportunity for compression mode dependent tag fixup	 */	(*tif->tif_fixuptags)(tif);	/*	 * Some manufacturers make life difficult by writing	 * large amounts of uncompressed data as a single strip.	 * This is contrary to the recommendations of the spec.	 * The following makes an attempt at breaking such images	 * into strips closer to the recommended 8k bytes.  A	 * side effect, however, is that the RowsPerStrip tag	 * value may be changed.	 */	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))    {        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }        /*         * Clear the dirty directory flag.          */	tif->tif_flags &= ~TIFF_DIRTYDIRECT;	tif->tif_flags &= ~TIFF_DIRTYSTRIP;	/*	 * Reinitialize i/o since we are starting on a new directory.	 */	tif->tif_row = (uint32) -1;	tif->tif_curstrip = (uint32) -1;	tif->tif_col = (uint32) -1;	tif->tif_curtile = (uint32) -1;	tif->tif_tilesize = (tmsize_t) -1;	tif->tif_scanlinesize = TIFFScanlineSize(tif);	if (!tif->tif_scanlinesize) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}	if (isTiled(tif)) {		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	} else {		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}	return (1);bad:	if (dir)		_TIFFfree(dir);	return (0);}
int
TIFFReadDirectory(TIFF* tif)
TIFFReadDirectory
TIFF* tif
TIFF
TIFF
* tif
*
tif
{	static const char module[] = "TIFFReadDirectory";	TIFFDirEntry* dir;	uint16 dircount;	TIFFDirEntry* dp;	uint16 di;	const TIFFField* fip;	uint32 fii=FAILED_FII;        toff_t nextdiroff;    int bitspersample_read = FALSE;        int color_channels;	tif->tif_diroff=tif->tif_nextdiroff;	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))		return 0;           /* last offset or bad offset (IFD looping) */	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */	tif->tif_curdir++;        nextdiroff = tif->tif_nextdiroff;	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);	if (!dircount)	{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}	TIFFReadDirectoryCheckOrder(tif,dir,dircount);        /*         * Mark duplicates of any tag to be ignored (bugzilla 1994)         * to avoid certain pathological problems.         */	{		TIFFDirEntry* ma;		uint16 mb;		for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}	}        	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */	/* free any old stuff and reinit */	TIFFFreeDirectory(tif);	TIFFDefaultDirectory(tif);	/*	 * Electronic Arts writes gray-scale TIFF files	 * without a PlanarConfiguration directory entry.	 * Thus we setup a default value here, even though	 * the TIFF spec says there is no default value.	 */	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);	/*	 * Setup default value and then make a pass over	 * the fields to check type and tag information,	 * and to extract info required to size data	 * structures.  A second pass is made afterwards	 * to read in everything not taken in the first pass.	 * But we must process the Compression tag first	 * in order to merge in codec-private tag definitions (otherwise	 * we may get complaints about unknown tags).  However, the	 * Compression tag may be dependent on the SamplesPerPixel	 * tag value because older TIFF specs permitted Compression	 * to be written as a SamplesPerPixel-count tag entry.	 * Thus if we don't first figure out the correct SamplesPerPixel	 * tag value then we may end up ignoring the Compression tag	 * value because it has an incorrect count value (if the	 * true value of SamplesPerPixel is not 1).	 */	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);	if (dp)	{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);	if (dp)	{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}	else	{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}	/*	 * First real pass over the directory.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}		}	}	/*	 * XXX: OJPEG hack.	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,	 * c) strip offsets/bytecounts tag are both present and	 * d) both contain exactly one value, then we consistently find	 * that the buggy implementation of the buggy compression scheme	 * matches contig planarconfig best. So we 'fix-up' the tag here	 */	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))	{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}	/*	 * Allocate directory structure and setup defaults.	 */	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))	{		MissingRequired(tif,"ImageLength");		goto bad;	}	/*	 * Setup appropriate structures (by strip or by tile)	 */	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	} else {		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}	if (!tif->tif_dir.td_nstrips) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {#ifdef OJPEG_SUPPORT		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else#endif        {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}	/*	 * Second pass: extract other information.	 */	for (di=0, dp=dir; di<dircount; di++, dp++)	{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yuck). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}	/*	 * OJPEG hack:	 * - If a) compression is OJPEG, and b) photometric tag is missing,	 * then we consistently find that photometric should be YCbCr	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,	 * then we consistently find that the buggy implementation of the	 * buggy compression scheme matches photometric YCbCr instead.	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,	 * then we consistently find bitspersample should be 8.	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is RGB or YCbCr, then we consistently find	 * samplesperpixel should be 3	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently	 * find samplesperpixel should be 3	 */	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)	{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}	/*	 * Make sure all non-color channels are extrasamples.	 * If it's not the case, define them as such.	 */        color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);        if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {                uint16 old_extrasamples;                uint16 *new_sampleinfo;                TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples.");                old_extrasamples = tif->tif_dir.td_extrasamples;                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);                // sampleinfo should contain information relative to these new extra samples                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));                if (!new_sampleinfo) {                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);                    goto bad;                }                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);                _TIFFfree(new_sampleinfo);        }	/*	 * Verify Palette image has a Colormap.	 */	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}	/*	 * OJPEG hack:	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG	 * TIFFs	 */	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)	{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}	if (dir)	{		_TIFFfree(dir);		dir=NULL;	}	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))	{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}	/*	 * XXX: We can optimize checking for the strip bounds using the sorted	 * bytecounts array. See also comments for TIFFAppendToStrip()	 * function in tif_write.c.	 */#if !defined(DEFER_STRILE_LOAD)        	if (tif->tif_dir.td_nstrips > 1) {		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}#endif /* !defined(DEFER_STRILE_LOAD) */        	/*	 * An opportunity for compression mode dependent tag fixup	 */	(*tif->tif_fixuptags)(tif);	/*	 * Some manufacturers make life difficult by writing	 * large amounts of uncompressed data as a single strip.	 * This is contrary to the recommendations of the spec.	 * The following makes an attempt at breaking such images	 * into strips closer to the recommended 8k bytes.  A	 * side effect, however, is that the RowsPerStrip tag	 * value may be changed.	 */	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))    {        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }        /*         * Clear the dirty directory flag.          */	tif->tif_flags &= ~TIFF_DIRTYDIRECT;	tif->tif_flags &= ~TIFF_DIRTYSTRIP;	/*	 * Reinitialize i/o since we are starting on a new directory.	 */	tif->tif_row = (uint32) -1;	tif->tif_curstrip = (uint32) -1;	tif->tif_col = (uint32) -1;	tif->tif_curtile = (uint32) -1;	tif->tif_tilesize = (tmsize_t) -1;	tif->tif_scanlinesize = TIFFScanlineSize(tif);	if (!tif->tif_scanlinesize) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}	if (isTiled(tif)) {		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	} else {		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}	return (1);bad:	if (dir)		_TIFFfree(dir);	return (0);}
static const char module[] = "TIFFReadDirectory";
static const char module[] = "TIFFReadDirectory";
static const char
module[] = "TIFFReadDirectory"
module
[]
= "TIFFReadDirectory"
"TIFFReadDirectory"
TIFFDirEntry* dir;
TIFFDirEntry* dir;
TIFFDirEntry
TIFFDirEntry
* dir
*
dir
uint16 dircount;
uint16 dircount;
uint16
uint16
dircount
dircount
TIFFDirEntry* dp;
TIFFDirEntry* dp;
TIFFDirEntry
TIFFDirEntry
* dp
*
dp
uint16 di;
uint16 di;
uint16
uint16
di
di
const TIFFField* fip;
const TIFFField* fip;
const TIFFField
TIFFField
* fip
*
fip
uint32 fii=FAILED_FII;
uint32 fii=FAILED_FII;
uint32
uint32
fii=FAILED_FII
fii
=FAILED_FII
FAILED_FII
FAILED_FII
toff_t nextdiroff;
toff_t nextdiroff;
toff_t
toff_t
nextdiroff
nextdiroff
int bitspersample_read = FALSE;
int bitspersample_read = FALSE;
int
bitspersample_read = FALSE
bitspersample_read
= FALSE
FALSE
FALSE
int color_channels;
int color_channels;
int
color_channels
color_channels
tif->tif_diroff=tif->tif_nextdiroff;
tif->tif_diroff=tif->tif_nextdiroff
tif->tif_diroff
tif
tif
tif_diroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))		return 0;
!TIFFCheckDirOffset(tif,tif->tif_nextdiroff)
TIFFCheckDirOffset(tif,tif->tif_nextdiroff)
TIFFCheckDirOffset
TIFFCheckDirOffset
tif
tif
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
return 0;
0
(*tif->tif_cleanup)(tif);
(*tif->tif_cleanup)(tif)
(*tif->tif_cleanup)
*tif->tif_cleanup
tif->tif_cleanup
tif
tif
tif_cleanup
tif
tif
tif->tif_curdir++;
tif->tif_curdir++
tif->tif_curdir
tif
tif
tif_curdir
nextdiroff = tif->tif_nextdiroff;
nextdiroff = tif->tif_nextdiroff
nextdiroff
nextdiroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff)
dircount
dircount
TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff)
TIFFFetchDirectory
TIFFFetchDirectory
tif
tif
nextdiroff
nextdiroff
&dir
dir
dir
&tif->tif_nextdiroff
tif->tif_nextdiroff
tif
tif
tif_nextdiroff
if (!dircount)	{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}
!dircount
dircount
dircount
{		TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);		return 0;	}
TIFFErrorExt(tif->tif_clientdata,module,		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);
return 0;
0
TIFFReadDirectoryCheckOrder(tif,dir,dircount);
TIFFReadDirectoryCheckOrder(tif,dir,dircount)
TIFFReadDirectoryCheckOrder
TIFFReadDirectoryCheckOrder
tif
tif
dir
dir
dircount
dircount
{		TIFFDirEntry* ma;		uint16 mb;		for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}	}
TIFFDirEntry* ma;
TIFFDirEntry* ma;
TIFFDirEntry
TIFFDirEntry
* ma
*
ma
uint16 mb;
uint16 mb;
uint16
uint16
mb
mb
for (ma=dir, mb=0; mb<dircount; ma++, mb++)		{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}
ma=dir, mb=0;
ma=dir, mb=0
ma=dir
ma
ma
dir
dir
mb=0
mb
mb
0
mb<dircount
mb
mb
dircount
dircount
ma++, mb++
ma++
ma
ma
mb++
mb
mb
{			TIFFDirEntry* na;			uint16 nb;			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}		}
TIFFDirEntry* na;
TIFFDirEntry* na;
TIFFDirEntry
TIFFDirEntry
* na
*
na
uint16 nb;
uint16 nb;
uint16
uint16
nb
nb
for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)			{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}
na=ma+1, nb=mb+1;
na=ma+1, nb=mb+1
na=ma+1
na
na
ma+1
ma
ma
1
nb=mb+1
nb
nb
mb+1
mb
mb
1
nb<dircount
nb
nb
dircount
dircount
na++, nb++
na++
na
na
nb++
nb
nb
{				if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;			}
if (ma->tdir_tag==na->tdir_tag)					na->tdir_tag=IGNORE;
ma->tdir_tag==na->tdir_tag
ma->tdir_tag
ma
ma
tdir_tag
na->tdir_tag
na
na
tdir_tag
na->tdir_tag=IGNORE;
na->tdir_tag=IGNORE
na->tdir_tag
na
na
tdir_tag
IGNORE
IGNORE
tif->tif_flags &= ~TIFF_BEENWRITING;
tif->tif_flags &= ~TIFF_BEENWRITING
tif->tif_flags
tif
tif
tif_flags
~TIFF_BEENWRITING
TIFF_BEENWRITING
TIFF_BEENWRITING
tif->tif_flags &= ~TIFF_BUF4WRITE;
tif->tif_flags &= ~TIFF_BUF4WRITE
tif->tif_flags
tif
tif
tif_flags
~TIFF_BUF4WRITE
TIFF_BUF4WRITE
TIFF_BUF4WRITE
TIFFFreeDirectory(tif);
TIFFFreeDirectory(tif)
TIFFFreeDirectory
TIFFFreeDirectory
tif
tif
TIFFDefaultDirectory(tif);
TIFFDefaultDirectory(tif)
TIFFDefaultDirectory
TIFFDefaultDirectory
tif
tif
TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_PLANARCONFIG
TIFFTAG_PLANARCONFIG
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
if (dp)	{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}
dp
dp
{		if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;		dp->tdir_tag=IGNORE;	}
if (!TIFFFetchNormalTag(tif,dp,0))			goto bad;
!TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag
TIFFFetchNormalTag
tif
tif
dp
dp
0
goto bad;
bad
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
if (dp)	{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}	else	{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}
dp
dp
{		/*		 * The 5.0 spec says the Compression tag has one value, while		 * earlier specs say it has one value per sample.  Because of		 * this, we accept the tag if one value is supplied with either		 * count.		 */		uint16 value;		enum TIFFReadDirEntryErr err;		err=TIFFReadDirEntryShort(tif,dp,&value);		if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);		if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;		dp->tdir_tag=IGNORE;	}
uint16 value;
uint16 value;
uint16
uint16
value
value
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
err=TIFFReadDirEntryShort(tif,dp,&value);
err=TIFFReadDirEntryShort(tif,dp,&value)
err
err
TIFFReadDirEntryShort(tif,dp,&value)
TIFFReadDirEntryShort
TIFFReadDirEntryShort
tif
tif
dp
dp
&value
value
value
if (err==TIFFReadDirEntryErrCount)			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err==TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err=TIFFReadDirEntryPersampleShort(tif,dp,&value)
err
err
TIFFReadDirEntryPersampleShort(tif,dp,&value)
TIFFReadDirEntryPersampleShort
TIFFReadDirEntryPersampleShort
tif
tif
dp
dp
&value
value
value
if (err!=TIFFReadDirEntryErrOk)		{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);			goto bad;		}
TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);
TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
"Compression"
0
goto bad;
bad
if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))			goto bad;
!TIFFSetField(tif,TIFFTAG_COMPRESSION,value)
TIFFSetField(tif,TIFFTAG_COMPRESSION,value)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
value
value
goto bad;
bad
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;	}
if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))			goto bad;
!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE)
TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_COMPRESSION
TIFFTAG_COMPRESSION
COMPRESSION_NONE
COMPRESSION_NONE
goto bad;
bad
for (di=0, dp=dir; di<dircount; di++, dp++)	{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}		}	}
di=0, dp=dir;
di=0, dp=dir
di=0
di
di
0
dp=dir
dp
dp
dir
dir
di<dircount
di
di
dircount
dircount
di++, dp++
di++
di
di
dp++
dp
dp
{		if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}		if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}		}	}
if (dp->tdir_tag!=IGNORE)		{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}
dp->tdir_tag!=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);			if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}		}
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii)
TIFFReadDirectoryFindFieldInfo
TIFFReadDirectoryFindFieldInfo
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
&fii
fii
fii
if (fii == FAILED_FII)			{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}
fii == FAILED_FII
fii
fii
FAILED_FII
FAILED_FII
{				TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);                                /* the following knowingly leaks the                                    anonymous field structure */				if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}			}
TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata, module,				    "Unknown field with tag %d (0x%x) encountered",				    dp->tdir_tag,dp->tdir_tag)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Unknown field with tag %d (0x%x) encountered"
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag
dp
dp
tdir_tag
if (!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)) {					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				} else {					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}
!_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)
_TIFFMergeFields(tif,					_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type),					1)
_TIFFMergeFields
_TIFFMergeFields
tif
tif
_TIFFCreateAnonField(tif,						dp->tdir_tag,						(TIFFDataType) dp->tdir_type)
_TIFFCreateAnonField
_TIFFCreateAnonField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
(TIFFDataType) dp->tdir_type
TIFFDataType
TIFFDataType
TIFFDataType

dp->tdir_type
dp
dp
tdir_type
1
{					TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);					dp->tdir_tag=IGNORE;				}
TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag);
TIFFWarningExt(tif->tif_clientdata,					    module,					    "Registering anonymous field with tag %d (0x%x) failed",					    dp->tdir_tag,					    dp->tdir_tag)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Registering anonymous field with tag %d (0x%x) failed"
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);					assert(fii != FAILED_FII);				}
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii)
TIFFReadDirectoryFindFieldInfo
TIFFReadDirectoryFindFieldInfo
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
&fii
fii
fii
assert(fii != FAILED_FII);
assert(fii != FAILED_FII)
assert
assert
fii != FAILED_FII
fii
fii
FAILED_FII
FAILED_FII
if (dp->tdir_tag!=IGNORE)		{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}		}
dp->tdir_tag!=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{			fip=tif->tif_fields[fii];			if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}		}
fip=tif->tif_fields[fii];
fip=tif->tif_fields[fii]
fip
fip
tif->tif_fields[fii]
tif->tif_fields
tif
tif
tif_fields
fii
fii
if (fip->field_bit==FIELD_IGNORE)				dp->tdir_tag=IGNORE;			else			{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}
fip->field_bit==FIELD_IGNORE
fip->field_bit
fip
fip
field_bit
FIELD_IGNORE
FIELD_IGNORE
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
{				switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}			}
switch (dp->tdir_tag)				{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}
dp->tdir_tag
dp
dp
tdir_tag
{					case TIFFTAG_STRIPOFFSETS:					case TIFFTAG_STRIPBYTECOUNTS:					case TIFFTAG_TILEOFFSETS:					case TIFFTAG_TILEBYTECOUNTS:						TIFFSetFieldBit(tif,fip->field_bit);						break;					case TIFFTAG_IMAGEWIDTH:					case TIFFTAG_IMAGELENGTH:					case TIFFTAG_IMAGEDEPTH:					case TIFFTAG_TILELENGTH:					case TIFFTAG_TILEWIDTH:					case TIFFTAG_TILEDEPTH:					case TIFFTAG_PLANARCONFIG:					case TIFFTAG_ROWSPERSTRIP:					case TIFFTAG_EXTRASAMPLES:						if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;						dp->tdir_tag=IGNORE;						break;                                        default:                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;                                            break;				}
case TIFFTAG_STRIPOFFSETS:
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
case TIFFTAG_STRIPBYTECOUNTS:
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
case TIFFTAG_TILEOFFSETS:
TIFFTAG_TILEOFFSETS
TIFFTAG_TILEOFFSETS
case TIFFTAG_TILEBYTECOUNTS:
TIFFTAG_TILEBYTECOUNTS
TIFFTAG_TILEBYTECOUNTS
TIFFSetFieldBit(tif,fip->field_bit);
TIFFSetFieldBit(tif,fip->field_bit)
TIFFSetFieldBit
TIFFSetFieldBit
tif
tif
fip->field_bit
fip
fip
field_bit
break;
case TIFFTAG_IMAGEWIDTH:
TIFFTAG_IMAGEWIDTH
TIFFTAG_IMAGEWIDTH
case TIFFTAG_IMAGELENGTH:
TIFFTAG_IMAGELENGTH
TIFFTAG_IMAGELENGTH
case TIFFTAG_IMAGEDEPTH:
TIFFTAG_IMAGEDEPTH
TIFFTAG_IMAGEDEPTH
case TIFFTAG_TILELENGTH:
TIFFTAG_TILELENGTH
TIFFTAG_TILELENGTH
case TIFFTAG_TILEWIDTH:
TIFFTAG_TILEWIDTH
TIFFTAG_TILEWIDTH
case TIFFTAG_TILEDEPTH:
TIFFTAG_TILEDEPTH
TIFFTAG_TILEDEPTH
case TIFFTAG_PLANARCONFIG:
TIFFTAG_PLANARCONFIG
TIFFTAG_PLANARCONFIG
case TIFFTAG_ROWSPERSTRIP:
TIFFTAG_ROWSPERSTRIP
TIFFTAG_ROWSPERSTRIP
case TIFFTAG_EXTRASAMPLES:
TIFFTAG_EXTRASAMPLES
TIFFTAG_EXTRASAMPLES
if (!TIFFFetchNormalTag(tif,dp,0))							goto bad;
!TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag(tif,dp,0)
TIFFFetchNormalTag
TIFFFetchNormalTag
tif
tif
dp
dp
0
goto bad;
bad
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
break;
default:
if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )                                                dp->tdir_tag=IGNORE;
!_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag)
_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag)
_TIFFCheckFieldIsValidForCodec
_TIFFCheckFieldIsValidForCodec
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
dp->tdir_tag=IGNORE;
dp->tdir_tag=IGNORE
dp->tdir_tag
dp
dp
tdir_tag
IGNORE
IGNORE
break;
if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))	{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}
(tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE)
(tif->tif_dir.td_compression==COMPRESSION_OJPEG)
tif->tif_dir.td_compression==COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
(tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE)
tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_SEPARATE
PLANARCONFIG_SEPARATE
{        if (!_TIFFFillStriles(tif))            goto bad;		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);		if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}	}
if (!_TIFFFillStriles(tif))            goto bad;
!_TIFFFillStriles(tif)
_TIFFFillStriles(tif)
_TIFFFillStriles
_TIFFFillStriles
tif
tif
goto bad;
bad
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
if ((dp!=0)&&(dp->tdir_count==1))		{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}
(dp!=0)&&(dp->tdir_count==1)
(dp!=0)
dp!=0
dp
dp
0
(dp->tdir_count==1)
dp->tdir_count==1
dp->tdir_count
dp
dp
tdir_count
1
{			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);			if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}		}
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS);
dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS)
dp
dp
TIFFReadDirectoryFindEntry(tif,dir,dircount,			    TIFFTAG_STRIPBYTECOUNTS)
TIFFReadDirectoryFindEntry
TIFFReadDirectoryFindEntry
tif
tif
dir
dir
dircount
dircount
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
if ((dp!=0)&&(dp->tdir_count==1))			{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}
(dp!=0)&&(dp->tdir_count==1)
(dp!=0)
dp!=0
dp
dp
0
(dp->tdir_count==1)
dp->tdir_count==1
dp->tdir_count
dp
dp
tdir_count
1
{				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;				TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");			}
tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky");
TIFFWarningExt(tif->tif_clientdata,module,				    "Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Planarconfig tag value assumed incorrect, "				    "assuming data is contig instead of chunky"
if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))	{		MissingRequired(tif,"ImageLength");		goto bad;	}
!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)
TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_IMAGEDIMENSIONS
FIELD_IMAGEDIMENSIONS
{		MissingRequired(tif,"ImageLength");		goto bad;	}
MissingRequired(tif,"ImageLength");
MissingRequired(tif,"ImageLength")
MissingRequired
MissingRequired
tif
tif
"ImageLength"
goto bad;
bad
if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	} else {		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}
!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)
TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_TILEDIMENSIONS
FIELD_TILEDIMENSIONS
{		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;		tif->tif_flags &= ~TIFF_ISTILED;	}
tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);
tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif)
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
TIFFNumberOfStrips(tif)
TIFFNumberOfStrips
TIFFNumberOfStrips
tif
tif
tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth
tif->tif_dir.td_tilewidth
tif->tif_dir
tif
tif
tif_dir
td_tilewidth
tif->tif_dir.td_imagewidth
tif->tif_dir
tif
tif
tif_dir
td_imagewidth
tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip
tif->tif_dir.td_tilelength
tif->tif_dir
tif
tif
tif_dir
td_tilelength
tif->tif_dir.td_rowsperstrip
tif->tif_dir
tif
tif
tif_dir
td_rowsperstrip
tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth
tif->tif_dir.td_tiledepth
tif->tif_dir
tif
tif
tif_dir
td_tiledepth
tif->tif_dir.td_imagedepth
tif->tif_dir
tif
tif
tif_dir
td_imagedepth
tif->tif_flags &= ~TIFF_ISTILED;
tif->tif_flags &= ~TIFF_ISTILED
tif->tif_flags
tif
tif
tif_flags
~TIFF_ISTILED
TIFF_ISTILED
TIFF_ISTILED
{		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);		tif->tif_flags |= TIFF_ISTILED;	}
tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif)
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
TIFFNumberOfTiles(tif)
TIFFNumberOfTiles
TIFFNumberOfTiles
tif
tif
tif->tif_flags |= TIFF_ISTILED;
tif->tif_flags |= TIFF_ISTILED
tif->tif_flags
tif
tif
tif_flags
TIFF_ISTILED
TIFF_ISTILED
if (!tif->tif_dir.td_nstrips) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}
!tif->tif_dir.td_nstrips
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
{		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");		goto bad;	}
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips");
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero number of %s",		    isTiled(tif) ? "tiles" : "strips")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero number of %s"
isTiled(tif) ? "tiles" : "strips"
isTiled(tif)
isTiled
isTiled
tif
tif
"tiles"
"strips"
goto bad;
bad
tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips
tif->tif_dir.td_stripsperimage
tif->tif_dir
tif
tif
tif_dir
td_stripsperimage
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_SEPARATE
PLANARCONFIG_SEPARATE
tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel
tif->tif_dir.td_stripsperimage
tif->tif_dir
tif
tif
tif_dir
td_stripsperimage
tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {#ifdef OJPEG_SUPPORT		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else#endif        {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}
!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)
TIFFFieldSet(tif, FIELD_STRIPOFFSETS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_STRIPOFFSETS
FIELD_STRIPOFFSETS
{#ifdef OJPEG_SUPPORT		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&		    (isTiled(tif)==0) &&		    (tif->tif_dir.td_nstrips==1)) {			/*			 * XXX: OJPEG hack.			 * If a) compression is OJPEG, b) it's not a tiled TIFF,			 * and c) the number of strips is 1,			 * then we tolerate the absence of stripoffsets tag,			 * because, presumably, all required data is in the			 * JpegInterchangeFormat stream.			 */			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);		} else#endif        {			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}	}
{			MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");			goto bad;		}
MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets");
MissingRequired(tif,				isTiled(tif) ? "TileOffsets" : "StripOffsets")
MissingRequired
MissingRequired
tif
tif
isTiled(tif) ? "TileOffsets" : "StripOffsets"
isTiled(tif)
isTiled
isTiled
tif
tif
"TileOffsets"
"StripOffsets"
goto bad;
bad
for (di=0, dp=dir; di<dircount; di++, dp++)	{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yuck). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}
di=0, dp=dir;
di=0, dp=dir
di=0
di
di
0
dp=dir
dp
dp
dir
dir
di<dircount
di
di
dircount
dircount
di++, dp++
di++
di
di
dp++
dp
dp
{		switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yuck). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}	}
switch (dp->tdir_tag)		{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yuck). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}
dp->tdir_tag
dp
dp
tdir_tag
{			case IGNORE:				break;			case TIFFTAG_MINSAMPLEVALUE:			case TIFFTAG_MAXSAMPLEVALUE:			case TIFFTAG_BITSPERSAMPLE:			case TIFFTAG_DATATYPE:			case TIFFTAG_SAMPLEFORMAT:				/*				 * The MinSampleValue, MaxSampleValue, BitsPerSample				 * DataType and SampleFormat tags are supposed to be				 * written as one value/sample, but some vendors				 * incorrectly write one value only -- so we accept				 * that as well (yuck). Other vendors write correct				 * value for NumberOfSamples, but incorrect one for				 * BitsPerSample and friends, and we will read this				 * too.				 */				{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}				break;			case TIFFTAG_SMINSAMPLEVALUE:			case TIFFTAG_SMAXSAMPLEVALUE:				{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}				break;			case TIFFTAG_STRIPOFFSETS:			case TIFFTAG_TILEOFFSETS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;#endif                                				break;			case TIFFTAG_STRIPBYTECOUNTS:			case TIFFTAG_TILEBYTECOUNTS:#if defined(DEFER_STRILE_LOAD)                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),                                             dp, sizeof(TIFFDirEntry) );#else                                                          if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;#endif                                				break;			case TIFFTAG_COLORMAP:			case TIFFTAG_TRANSFERFUNCTION:				{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}				break;/* BEGIN REV 4.0 COMPATIBILITY */			case TIFFTAG_OSUBFILETYPE:				{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}				break;/* END REV 4.0 COMPATIBILITY */			default:				(void) TIFFFetchNormalTag(tif, dp, TRUE);				break;		}
case IGNORE:
IGNORE
IGNORE
break;
case TIFFTAG_MINSAMPLEVALUE:
TIFFTAG_MINSAMPLEVALUE
TIFFTAG_MINSAMPLEVALUE
case TIFFTAG_MAXSAMPLEVALUE:
TIFFTAG_MAXSAMPLEVALUE
TIFFTAG_MAXSAMPLEVALUE
case TIFFTAG_BITSPERSAMPLE:
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
case TIFFTAG_DATATYPE:
TIFFTAG_DATATYPE
TIFFTAG_DATATYPE
case TIFFTAG_SAMPLEFORMAT:
TIFFTAG_SAMPLEFORMAT
TIFFTAG_SAMPLEFORMAT
{					uint16 value;					enum TIFFReadDirEntryErr err;					err=TIFFReadDirEntryShort(tif,dp,&value);					if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;				}
uint16 value;
uint16 value;
uint16
uint16
value
value
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
err=TIFFReadDirEntryShort(tif,dp,&value);
err=TIFFReadDirEntryShort(tif,dp,&value)
err
err
TIFFReadDirEntryShort(tif,dp,&value)
TIFFReadDirEntryShort
TIFFReadDirEntryShort
tif
tif
dp
dp
&value
value
value
if (err==TIFFReadDirEntryErrCount)						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err==TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
err=TIFFReadDirEntryPersampleShort(tif,dp,&value)
err
err
TIFFReadDirEntryPersampleShort(tif,dp,&value)
TIFFReadDirEntryPersampleShort
TIFFReadDirEntryPersampleShort
tif
tif
dp
dp
&value
value
value
if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
0
goto bad;
bad
if (!TIFFSetField(tif,dp->tdir_tag,value))						goto bad;
!TIFFSetField(tif,dp->tdir_tag,value)
TIFFSetField(tif,dp->tdir_tag,value)
TIFFSetField
TIFFSetField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
value
value
goto bad;
bad
if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )                        bitspersample_read = TRUE;
dp->tdir_tag == TIFFTAG_BITSPERSAMPLE
dp->tdir_tag
dp
dp
tdir_tag
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
bitspersample_read = TRUE;
bitspersample_read = TRUE
bitspersample_read
bitspersample_read
TRUE
TRUE
break;
case TIFFTAG_SMINSAMPLEVALUE:
TIFFTAG_SMINSAMPLEVALUE
TIFFTAG_SMINSAMPLEVALUE
case TIFFTAG_SMAXSAMPLEVALUE:
TIFFTAG_SMAXSAMPLEVALUE
TIFFTAG_SMAXSAMPLEVALUE
{					double *data = NULL;					enum TIFFReadDirEntryErr err;					uint32 saved_flags;					int m;					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);					if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}					saved_flags = tif->tif_flags;					tif->tif_flags |= TIFF_PERSAMPLE;					m = TIFFSetField(tif,dp->tdir_tag,data);					tif->tif_flags = saved_flags;					_TIFFfree(data);					if (!m)						goto bad;				}
double *data = NULL;
double *data = NULL;
double
*data = NULL
*
data
= NULL
NULL
NULL
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
uint32 saved_flags;
uint32 saved_flags;
uint32
uint32
saved_flags
saved_flags
int m;
int m;
int
m
m
if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)						err = TIFFReadDirEntryErrCount;					else						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel
dp->tdir_count
dp
dp
tdir_count
(uint64)tif->tif_dir.td_samplesperpixel
uint64
uint64
uint64

tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
err = TIFFReadDirEntryErrCount;
err = TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
err = TIFFReadDirEntryDoubleArray(tif, dp, &data)
err
err
TIFFReadDirEntryDoubleArray(tif, dp, &data)
TIFFReadDirEntryDoubleArray
TIFFReadDirEntryDoubleArray
tif
tif
dp
dp
&data
data
data
if (err!=TIFFReadDirEntryErrOk)					{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);						goto bad;					}
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
0
goto bad;
bad
saved_flags = tif->tif_flags;
saved_flags = tif->tif_flags
saved_flags
saved_flags
tif->tif_flags
tif
tif
tif_flags
tif->tif_flags |= TIFF_PERSAMPLE;
tif->tif_flags |= TIFF_PERSAMPLE
tif->tif_flags
tif
tif
tif_flags
TIFF_PERSAMPLE
TIFF_PERSAMPLE
m = TIFFSetField(tif,dp->tdir_tag,data);
m = TIFFSetField(tif,dp->tdir_tag,data)
m
m
TIFFSetField(tif,dp->tdir_tag,data)
TIFFSetField
TIFFSetField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
data
data
tif->tif_flags = saved_flags;
tif->tif_flags = saved_flags
tif->tif_flags
tif
tif
tif_flags
saved_flags
saved_flags
_TIFFfree(data);
_TIFFfree(data)
_TIFFfree
_TIFFfree
data
data
if (!m)						goto bad;
!m
m
m
goto bad;
bad
break;
case TIFFTAG_STRIPOFFSETS:
TIFFTAG_STRIPOFFSETS
TIFFTAG_STRIPOFFSETS
case TIFFTAG_TILEOFFSETS:
TIFFTAG_TILEOFFSETS
TIFFTAG_TILEOFFSETS
if( tif->tif_dir.td_stripoffset != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }
tif->tif_dir.td_stripoffset != NULL
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
NULL
NULL
{                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");                                    goto bad;                                }
TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag");
TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"tif->tif_dir.td_stripoffset is "                                        "already allocated. Likely duplicated "                                        "StripOffsets/TileOffsets tag"
goto bad;
bad
if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  					goto bad;
!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset)
TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset)
TIFFFetchStripThing
TIFFFetchStripThing
tif
tif
dp
dp
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
&tif->tif_dir.td_stripoffset
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
goto bad;
bad
break;
case TIFFTAG_STRIPBYTECOUNTS:
TIFFTAG_STRIPBYTECOUNTS
TIFFTAG_STRIPBYTECOUNTS
case TIFFTAG_TILEBYTECOUNTS:
TIFFTAG_TILEBYTECOUNTS
TIFFTAG_TILEBYTECOUNTS
if( tif->tif_dir.td_stripbytecount != NULL )                                {                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }
tif->tif_dir.td_stripbytecount != NULL
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
NULL
NULL
{                                    TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");                                    goto bad;                                }
TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag");
TIFFErrorExt(tif->tif_clientdata, module,                                        "tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"tif->tif_dir.td_stripbytecount is "                                        "already allocated. Likely duplicated "                                        "StripByteCounts/TileByteCounts tag"
goto bad;
bad
if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  					goto bad;
!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount)
TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount)
TIFFFetchStripThing
TIFFFetchStripThing
tif
tif
dp
dp
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
&tif->tif_dir.td_stripbytecount
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
goto bad;
bad
break;
case TIFFTAG_COLORMAP:
TIFFTAG_COLORMAP
TIFFTAG_COLORMAP
case TIFFTAG_TRANSFERFUNCTION:
TIFFTAG_TRANSFERFUNCTION
TIFFTAG_TRANSFERFUNCTION
{					enum TIFFReadDirEntryErr err;					uint32 countpersample;					uint32 countrequired;					uint32 incrementpersample;					uint16* value=NULL;                    /* It would be dangerous to instantiate those tag values */                    /* since if td_bitspersample has not yet been read (due to */                    /* unordered tags), it could be read afterwards with a */                    /* values greater than the default one (1), which may cause */                    /* crashes in user code */                    if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }					/* ColorMap or TransferFunction for high bit */					/* depths do not make much sense and could be */					/* used as a denial of service vector */					if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}					countpersample=(1U<<tif->tif_dir.td_bitspersample);					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}					if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);					if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}				}
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr err;
enum TIFFReadDirEntryErr
TIFFReadDirEntryErr
err
err
uint32 countpersample;
uint32 countpersample;
uint32
uint32
countpersample
countpersample
uint32 countrequired;
uint32 countrequired;
uint32
uint32
countrequired
countrequired
uint32 incrementpersample;
uint32 incrementpersample;
uint32
uint32
incrementpersample
incrementpersample
uint16* value=NULL;
uint16* value=NULL;
uint16
uint16
* value=NULL
*
value
=NULL
NULL
NULL
if( !bitspersample_read )                    {                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }
!bitspersample_read
bitspersample_read
bitspersample_read
{                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);                        TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");                        continue;                    }
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname");
TIFFWarningExt(tif->tif_clientdata,module,                                       "Ignoring %s since BitsPerSample tag not found",                                       fip ? fip->field_name : "unknown tagname")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Ignoring %s since BitsPerSample tag not found"
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
continue;
if (tif->tif_dir.td_bitspersample > 24)					{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}
tif->tif_dir.td_bitspersample > 24
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
24
{					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);					    TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);					    continue;					}
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample);
TIFFWarningExt(tif->tif_clientdata,module,						"Ignoring %s because BitsPerSample=%d>24",						fip ? fip->field_name : "unknown tagname",						tif->tif_dir.td_bitspersample)
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Ignoring %s because BitsPerSample=%d>24"
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
continue;
countpersample=(1U<<tif->tif_dir.td_bitspersample);
countpersample=(1U<<tif->tif_dir.td_bitspersample)
countpersample
countpersample
(1U<<tif->tif_dir.td_bitspersample)
1U<<tif->tif_dir.td_bitspersample
1U
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))					{						countrequired=countpersample;						incrementpersample=0;					}					else					{						countrequired=3*countpersample;						incrementpersample=countpersample;					}
(dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample)
(dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)
dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION
dp->tdir_tag
dp
dp
tdir_tag
TIFFTAG_TRANSFERFUNCTION
TIFFTAG_TRANSFERFUNCTION
(dp->tdir_count==(uint64)countpersample)
dp->tdir_count==(uint64)countpersample
dp->tdir_count
dp
dp
tdir_count
(uint64)countpersample
uint64
uint64
uint64

countpersample
countpersample
{						countrequired=countpersample;						incrementpersample=0;					}
countrequired=countpersample;
countrequired=countpersample
countrequired
countrequired
countpersample
countpersample
incrementpersample=0;
incrementpersample=0
incrementpersample
incrementpersample
0
{						countrequired=3*countpersample;						incrementpersample=countpersample;					}
countrequired=3*countpersample;
countrequired=3*countpersample
countrequired
countrequired
3*countpersample
3
countpersample
countpersample
incrementpersample=countpersample;
incrementpersample=countpersample
incrementpersample
incrementpersample
countpersample
countpersample
if (dp->tdir_count!=(uint64)countrequired)						err=TIFFReadDirEntryErrCount;					else						err=TIFFReadDirEntryShortArray(tif,dp,&value);
dp->tdir_count!=(uint64)countrequired
dp->tdir_count
dp
dp
tdir_count
(uint64)countrequired
uint64
uint64
uint64

countrequired
countrequired
err=TIFFReadDirEntryErrCount;
err=TIFFReadDirEntryErrCount
err
err
TIFFReadDirEntryErrCount
TIFFReadDirEntryErrCount
err=TIFFReadDirEntryShortArray(tif,dp,&value);
err=TIFFReadDirEntryShortArray(tif,dp,&value)
err
err
TIFFReadDirEntryShortArray(tif,dp,&value)
TIFFReadDirEntryShortArray
TIFFReadDirEntryShortArray
tif
tif
dp
dp
&value
value
value
if (err!=TIFFReadDirEntryErrOk)                    {						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }					else					{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}
err!=TIFFReadDirEntryErrOk
err
err
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						fip = TIFFFieldWithTag(tif,dp->tdir_tag);						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);                    }
fip = TIFFFieldWithTag(tif,dp->tdir_tag);
fip = TIFFFieldWithTag(tif,dp->tdir_tag)
fip
fip
TIFFFieldWithTag(tif,dp->tdir_tag)
TIFFFieldWithTag
TIFFFieldWithTag
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);
TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1)
TIFFReadDirEntryOutputErr
TIFFReadDirEntryOutputErr
tif
tif
err
err
module
module
fip ? fip->field_name : "unknown tagname"
fip
fip
fip->field_name
fip
fip
field_name
"unknown tagname"
1
{						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);						_TIFFfree(value);					}
TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample)
TIFFSetField
TIFFSetField
tif
tif
dp->tdir_tag
dp
dp
tdir_tag
value
value
value+incrementpersample
value
value
incrementpersample
incrementpersample
value+2*incrementpersample
value
value
2*incrementpersample
2
incrementpersample
incrementpersample
_TIFFfree(value);
_TIFFfree(value)
_TIFFfree
_TIFFfree
value
value
break;
case TIFFTAG_OSUBFILETYPE:
TIFFTAG_OSUBFILETYPE
TIFFTAG_OSUBFILETYPE
{					uint16 valueo;					uint32 value;					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}				}
uint16 valueo;
uint16 valueo;
uint16
uint16
valueo
valueo
uint32 value;
uint32 value;
uint32
uint32
value
value
if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)					{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}
TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk
TIFFReadDirEntryShort(tif,dp,&valueo)
TIFFReadDirEntryShort
TIFFReadDirEntryShort
tif
tif
dp
dp
&valueo
valueo
valueo
TIFFReadDirEntryErrOk
TIFFReadDirEntryErrOk
{						switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}						if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);					}
switch (valueo)						{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}
valueo
valueo
{							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;							default: value=0; break;						}
case OFILETYPE_REDUCEDIMAGE:
OFILETYPE_REDUCEDIMAGE
OFILETYPE_REDUCEDIMAGE
value=FILETYPE_REDUCEDIMAGE;
value=FILETYPE_REDUCEDIMAGE
value
value
FILETYPE_REDUCEDIMAGE
FILETYPE_REDUCEDIMAGE
break;
case OFILETYPE_PAGE:
OFILETYPE_PAGE
OFILETYPE_PAGE
value=FILETYPE_PAGE;
value=FILETYPE_PAGE
value
value
FILETYPE_PAGE
FILETYPE_PAGE
break;
default:
value=0;
value=0
value
value
0
break;
if (value!=0)							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
value!=0
value
value
0
TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SUBFILETYPE
TIFFTAG_SUBFILETYPE
value
value
break;
default:
(void) TIFFFetchNormalTag(tif, dp, TRUE);
(void) TIFFFetchNormalTag(tif, dp, TRUE)
void
void

TIFFFetchNormalTag(tif, dp, TRUE)
TIFFFetchNormalTag
TIFFFetchNormalTag
tif
tif
dp
dp
TRUE
TRUE
break;
if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)	{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}
tif->tif_dir.td_compression==COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
{		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}	}
if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))		{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}
!TIFFFieldSet(tif,FIELD_PHOTOMETRIC)
TIFFFieldSet(tif,FIELD_PHOTOMETRIC)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_PHOTOMETRIC
FIELD_PHOTOMETRIC
{			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;		}
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr");
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag is missing, assuming data is YCbCr")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Photometric tag is missing, assuming data is YCbCr"
if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))				goto bad;
!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR)
TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_PHOTOMETRIC
TIFFTAG_PHOTOMETRIC
PHOTOMETRIC_YCBCR
PHOTOMETRIC_YCBCR
goto bad;
bad
if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)		{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}
tif->tif_dir.td_photometric==PHOTOMETRIC_RGB
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_RGB
PHOTOMETRIC_RGB
{			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;			TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");		}
tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_YCBCR
PHOTOMETRIC_YCBCR
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB");
TIFFWarningExt(tif->tif_clientdata, module,			    "Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Photometric tag value assumed incorrect, "			    "assuming data is YCbCr instead of RGB"
if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))		{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}
!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)
TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_BITSPERSAMPLE
FIELD_BITSPERSAMPLE
{			TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;		}
TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample");
TIFFWarningExt(tif->tif_clientdata,module,			    "BitsPerSample tag is missing, assuming 8 bits per sample")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"BitsPerSample tag is missing, assuming 8 bits per sample"
if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))				goto bad;
!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8)
TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_BITSPERSAMPLE
TIFFTAG_BITSPERSAMPLE
8
goto bad;
bad
if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))		{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}
!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)
TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_SAMPLESPERPIXEL
FIELD_SAMPLESPERPIXEL
{			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}		}
if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}
tif->tif_dir.td_photometric==PHOTOMETRIC_RGB
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_RGB
PHOTOMETRIC_RGB
{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3");
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"SamplesPerPixel tag is missing, "				    "assuming correct SamplesPerPixel value is 3"
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;
!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
3
goto bad;
bad
if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)			{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}
tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_YCBCR
PHOTOMETRIC_YCBCR
{				TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;			}
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3");
TIFFWarningExt(tif->tif_clientdata,module,				    "SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"SamplesPerPixel tag is missing, "				    "applying correct SamplesPerPixel value of 3"
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))					goto bad;
!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
3
goto bad;
bad
if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))			{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}
(tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK)
(tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_MINISWHITE
PHOTOMETRIC_MINISWHITE
(tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK)
tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_MINISBLACK
PHOTOMETRIC_MINISBLACK
{				/*				 * SamplesPerPixel tag is missing, but is not required				 * by spec.  Assume correct SamplesPerPixel value of 1.				 */				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;			}
if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))					goto bad;
!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1)
TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1)
TIFFSetField
TIFFSetField
tif
tif
TIFFTAG_SAMPLESPERPIXEL
TIFFTAG_SAMPLESPERPIXEL
1
goto bad;
bad
color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);
color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric)
color_channels
color_channels
_TIFFGetMaxColorChannels(tif->tif_dir.td_photometric)
_TIFFGetMaxColorChannels
_TIFFGetMaxColorChannels
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {                uint16 old_extrasamples;                uint16 *new_sampleinfo;                TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples.");                old_extrasamples = tif->tif_dir.td_extrasamples;                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);                // sampleinfo should contain information relative to these new extra samples                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));                if (!new_sampleinfo) {                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);                    goto bad;                }                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);                _TIFFfree(new_sampleinfo);        }
color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels
color_channels
color_channels
tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels
tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples
tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
tif->tif_dir.td_extrasamples
tif->tif_dir
tif
tif
tif_dir
td_extrasamples
color_channels
color_channels
{                uint16 old_extrasamples;                uint16 *new_sampleinfo;                TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples.");                old_extrasamples = tif->tif_dir.td_extrasamples;                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);                // sampleinfo should contain information relative to these new extra samples                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));                if (!new_sampleinfo) {                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);                    goto bad;                }                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);                _TIFFfree(new_sampleinfo);        }
uint16 old_extrasamples;
uint16 old_extrasamples;
uint16
uint16
old_extrasamples
old_extrasamples
uint16 *new_sampleinfo;
uint16 *new_sampleinfo;
uint16
uint16
*new_sampleinfo
*
new_sampleinfo
TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples.");
TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples.")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Sum of Photometric type-related "                    "color channels and ExtraSamples doesn't match SamplesPerPixel. "                    "Defining non-color channels as ExtraSamples."
old_extrasamples = tif->tif_dir.td_extrasamples;
old_extrasamples = tif->tif_dir.td_extrasamples
old_extrasamples
old_extrasamples
tif->tif_dir.td_extrasamples
tif->tif_dir
tif
tif
tif_dir
td_extrasamples
tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);
tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels)
tif->tif_dir.td_extrasamples
tif->tif_dir
tif
tif
tif_dir
td_extrasamples
(uint16) (tif->tif_dir.td_samplesperpixel - color_channels)
(uint16)
uint16
uint16
tif->tif_dir.td_samplesperpixel - color_channels
tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
color_channels
color_channels
new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));
new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16))
new_sampleinfo
new_sampleinfo
(uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16))
uint16*
uint16
uint16
*
*
_TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16))
_TIFFcalloc
_TIFFcalloc
tif->tif_dir.td_extrasamples
tif->tif_dir
tif
tif
tif_dir
td_extrasamples
sizeof(uint16)
uint16
uint16
uint16

if (!new_sampleinfo) {                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);                    goto bad;                }
!new_sampleinfo
new_sampleinfo
new_sampleinfo
{                    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);                    goto bad;                }
TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples);
TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)",                                tif->tif_dir.td_extrasamples)
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Failed to allocate memory for "                                "temporary new sampleinfo array (%d 16 bit elements)"
tif->tif_dir.td_extrasamples
tif->tif_dir
tif
tif
tif_dir
td_extrasamples
goto bad;
bad
memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));
memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16))
memcpy
memcpy
new_sampleinfo
new_sampleinfo
tif->tif_dir.td_sampleinfo
tif->tif_dir
tif
tif
tif_dir
td_sampleinfo
old_extrasamples * sizeof(uint16)
old_extrasamples
old_extrasamples
sizeof(uint16)
uint16
uint16
uint16

_TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
_TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples)
_TIFFsetShortArray
_TIFFsetShortArray
&tif->tif_dir.td_sampleinfo
tif->tif_dir.td_sampleinfo
tif->tif_dir
tif
tif
tif_dir
td_sampleinfo
new_sampleinfo
new_sampleinfo
tif->tif_dir.td_extrasamples
tif->tif_dir
tif
tif
tif_dir
td_extrasamples
_TIFFfree(new_sampleinfo);
_TIFFfree(new_sampleinfo)
_TIFFfree
_TIFFfree
new_sampleinfo
new_sampleinfo
if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}
tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&	    !TIFFFieldSet(tif, FIELD_COLORMAP)
tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_PALETTE
PHOTOMETRIC_PALETTE
!TIFFFieldSet(tif, FIELD_COLORMAP)
TIFFFieldSet(tif, FIELD_COLORMAP)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_COLORMAP
FIELD_COLORMAP
{		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}	}
if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;		else if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}
tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3
tif->tif_dir.td_bitspersample>=8
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
8
tif->tif_dir.td_samplesperpixel==3
tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
3
tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
tif->tif_dir.td_photometric = PHOTOMETRIC_RGB
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_RGB
PHOTOMETRIC_RGB
if (tif->tif_dir.td_bitspersample>=8)			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;		else {			MissingRequired(tif, "Colormap");			goto bad;		}
tif->tif_dir.td_bitspersample>=8
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
8
tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK
tif->tif_dir.td_photometric
tif->tif_dir
tif
tif
tif_dir
td_photometric
PHOTOMETRIC_MINISBLACK
PHOTOMETRIC_MINISBLACK
{			MissingRequired(tif, "Colormap");			goto bad;		}
MissingRequired(tif, "Colormap");
MissingRequired(tif, "Colormap")
MissingRequired
MissingRequired
tif
tif
"Colormap"
goto bad;
bad
if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)	{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}
tif->tif_dir.td_compression!=COMPRESSION_OJPEG
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_OJPEG
COMPRESSION_OJPEG
{		/*		 * Attempt to deal with a missing StripByteCounts tag.		 */		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}	}
if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		} else if (tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)
TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_STRIPBYTECOUNTS
FIELD_STRIPBYTECOUNTS
{			/*			 * Some manufacturers violate the spec by not giving			 * the size of the strips.  In this case, assume there			 * is one uncompressed strip of data.			 */			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}			TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;		/*		 * Assume we have wrong StripByteCount value (in case		 * of single strip) in following cases:		 *   - it is equal to zero along with StripOffset;		 *   - it is larger than file itself (in case of uncompressed		 *     image);		 *   - it is smaller than the size of the bytes per row		 *     multiplied on the number of rows.  The last case should		 *     not be checked in the case of writing new image,		 *     because we may do not know the exact strip size		 *     until the whole image will be written and directory		 *     dumped out.		 */		#define	BYTECOUNTLOOKSBAD \		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \		       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \		        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \		      (tif->tif_mode == O_RDONLY && \		       tif->tif_dir.td_compression == COMPRESSION_NONE && \		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )		}
if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}
(tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1) ||			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)
(tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1)
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&			    tif->tif_dir.td_nstrips > 1
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
tif->tif_dir.td_nstrips > 1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
(tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)
tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel
tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_SEPARATE
PLANARCONFIG_SEPARATE
tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
(uint32)tif->tif_dir.td_samplesperpixel
uint32
uint32
uint32

tif->tif_dir.td_samplesperpixel
tif->tif_dir
tif
tif
tif_dir
td_samplesperpixel
{			    MissingRequired(tif, "StripByteCounts");			    goto bad;			}
MissingRequired(tif, "StripByteCounts");
MissingRequired(tif, "StripByteCounts")
MissingRequired
MissingRequired
tif
tif
"StripByteCounts"
goto bad;
bad
TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength");
TIFFWarningExt(tif->tif_clientdata, module,				"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"TIFF directory is missing required "				"\"StripByteCounts\" field, calculating from imagelength"
if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;
EstimateStripByteCounts(tif, dir, dircount) < 0
EstimateStripByteCounts(tif, dir, dircount)
EstimateStripByteCounts
EstimateStripByteCounts
tif
tif
dir
dir
dircount
dircount
0
goto bad;
bad
if (tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD) {			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0			   && BYTECOUNTLOOKSBAD
tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)			   && tif->tif_dir.td_stripoffset[0] != 0
tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)                           && _TIFFFillStriles(tif)
tif->tif_dir.td_nstrips == 1                           && !(tif->tif_flags&TIFF_ISTILED)
tif->tif_dir.td_nstrips == 1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
!(tif->tif_flags&TIFF_ISTILED)
(tif->tif_flags&TIFF_ISTILED)
tif->tif_flags&TIFF_ISTILED
tif->tif_flags
tif
tif
tif_flags
TIFF_ISTILED
TIFF_ISTILED
_TIFFFillStriles(tif)
_TIFFFillStriles
_TIFFFillStriles
tif
tif
tif->tif_dir.td_stripoffset[0] != 0
tif->tif_dir.td_stripoffset[0]
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
0
0
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
BYTECOUNTLOOKSBAD
{			/*			 * XXX: Plexus (and others) sometimes give a value of			 * zero for a tag when they don't know what the			 * correct value is!  Try and handle the simple case			 * of estimating the size of a one strip image.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");			if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#if !defined(DEFER_STRILE_LOAD)		}
TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");
TIFFWarningExt(tif->tif_clientdata, module,			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength"
if(EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;
EstimateStripByteCounts(tif, dir, dircount) < 0
EstimateStripByteCounts(tif, dir, dircount)
EstimateStripByteCounts
EstimateStripByteCounts
tif
tif
dir
dir
dircount
dircount
0
goto bad;
bad
if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0			   && tif->tif_dir.td_stripbytecount[1] != 0
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]			   && tif->tif_dir.td_stripbytecount[0] != 0
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2			   && tif->tif_dir.td_compression == COMPRESSION_NONE
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG			   && tif->tif_dir.td_nstrips > 2
tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
tif->tif_dir.td_nstrips > 2
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
2
tif->tif_dir.td_compression == COMPRESSION_NONE
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_NONE
COMPRESSION_NONE
tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_stripbytecount[0]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
0
tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
1
tif->tif_dir.td_stripbytecount[0] != 0
tif->tif_dir.td_stripbytecount[0]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
0
0
tif->tif_dir.td_stripbytecount[1] != 0
tif->tif_dir.td_stripbytecount[1]
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
1
0
{			/*			 * XXX: Some vendors fill StripByteCount array with			 * absolutely wrong values (it can be equal to			 * StripOffset array, for example). Catch this case			 * here.                         *                         * We avoid this check if deferring strile loading                         * as it would always force us to load the strip/tile                         * information.			 */			TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");			if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;#endif /* !defined(DEFER_STRILE_LOAD) */                        		}
TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");
TIFFWarningExt(tif->tif_clientdata, module,			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength")
TIFFWarningExt
TIFFWarningExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength"
if (EstimateStripByteCounts(tif, dir, dircount) < 0)			    goto bad;
EstimateStripByteCounts(tif, dir, dircount) < 0
EstimateStripByteCounts(tif, dir, dircount)
EstimateStripByteCounts
EstimateStripByteCounts
tif
tif
dir
dir
dircount
dircount
0
goto bad;
bad
if (dir)	{		_TIFFfree(dir);		dir=NULL;	}
dir
dir
{		_TIFFfree(dir);		dir=NULL;	}
_TIFFfree(dir);
_TIFFfree(dir)
_TIFFfree
_TIFFfree
dir
dir
dir=NULL;
dir=NULL
dir
dir
NULL
NULL
if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))	{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}
!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE)
TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE)
TIFFFieldSet
TIFFFieldSet
tif
tif
FIELD_MAXSAMPLEVALUE
FIELD_MAXSAMPLEVALUE
{		if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);	}
if (tif->tif_dir.td_bitspersample>=16)			tif->tif_dir.td_maxsamplevalue=0xFFFF;		else			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
tif->tif_dir.td_bitspersample>=16
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
16
tif->tif_dir.td_maxsamplevalue=0xFFFF;
tif->tif_dir.td_maxsamplevalue=0xFFFF
tif->tif_dir.td_maxsamplevalue
tif->tif_dir
tif
tif
tif_dir
td_maxsamplevalue
0xFFFF
tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1)
tif->tif_dir.td_maxsamplevalue
tif->tif_dir
tif
tif
tif_dir
td_maxsamplevalue
(uint16)((1L<<tif->tif_dir.td_bitspersample)-1)
(uint16)
uint16
uint16
(1L<<tif->tif_dir.td_bitspersample)-1
(1L<<tif->tif_dir.td_bitspersample)
1L<<tif->tif_dir.td_bitspersample
1L
tif->tif_dir.td_bitspersample
tif->tif_dir
tif
tif
tif_dir
td_bitspersample
1
if (tif->tif_dir.td_nstrips > 1) {		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}
tif->tif_dir.td_nstrips > 1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
{		uint32 strip;		tif->tif_dir.td_stripbytecountsorted = 1;		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}	}
uint32 strip;
uint32 strip;
uint32
uint32
strip
strip
tif->tif_dir.td_stripbytecountsorted = 1;
tif->tif_dir.td_stripbytecountsorted = 1
tif->tif_dir.td_stripbytecountsorted
tif->tif_dir
tif
tif
tif_dir
td_stripbytecountsorted
1
for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}
strip = 1;
strip = 1
strip
strip
1
strip < tif->tif_dir.td_nstrips
strip
strip
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
strip++
strip
strip
{			if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}		}
if (tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]) {				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}
tif->tif_dir.td_stripoffset[strip - 1] >			    tif->tif_dir.td_stripoffset[strip]
tif->tif_dir.td_stripoffset[strip - 1]
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
strip - 1
strip
strip
1
tif->tif_dir.td_stripoffset[strip]
tif->tif_dir.td_stripoffset
tif->tif_dir
tif
tif
tif_dir
td_stripoffset
strip
strip
{				tif->tif_dir.td_stripbytecountsorted = 0;				break;			}
tif->tif_dir.td_stripbytecountsorted = 0;
tif->tif_dir.td_stripbytecountsorted = 0
tif->tif_dir.td_stripbytecountsorted
tif->tif_dir
tif
tif
tif_dir
td_stripbytecountsorted
0
break;
(*tif->tif_fixuptags)(tif);
(*tif->tif_fixuptags)(tif)
(*tif->tif_fixuptags)
*tif->tif_fixuptags
tif->tif_fixuptags
tif
tif
tif_fixuptags
tif
tif
if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))    {        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP)
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)&&	    (tif->tif_dir.td_compression==COMPRESSION_NONE)
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&	    (tif->tif_dir.td_nstrips==1)
(tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)
tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG
tif->tif_dir.td_planarconfig
tif->tif_dir
tif
tif
tif_dir
td_planarconfig
PLANARCONFIG_CONTIG
PLANARCONFIG_CONTIG
(tif->tif_dir.td_nstrips==1)
tif->tif_dir.td_nstrips==1
tif->tif_dir.td_nstrips
tif->tif_dir
tif
tif
tif_dir
td_nstrips
1
(tif->tif_dir.td_compression==COMPRESSION_NONE)
tif->tif_dir.td_compression==COMPRESSION_NONE
tif->tif_dir.td_compression
tif->tif_dir
tif
tif
tif_dir
td_compression
COMPRESSION_NONE
COMPRESSION_NONE
((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP)
(tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP
(tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))
tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)
tif->tif_flags
tif
tif
tif_flags
(TIFF_STRIPCHOP|TIFF_ISTILED)
TIFF_STRIPCHOP|TIFF_ISTILED
TIFF_STRIPCHOP
TIFF_STRIPCHOP
TIFF_ISTILED
TIFF_ISTILED
TIFF_STRIPCHOP
TIFF_STRIPCHOP
{        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;		ChopUpSingleUncompressedStrip(tif);    }
if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )            return 0;
!_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount
!_TIFFFillStriles(tif)
_TIFFFillStriles(tif)
_TIFFFillStriles
_TIFFFillStriles
tif
tif
!tif->tif_dir.td_stripbytecount
tif->tif_dir.td_stripbytecount
tif->tif_dir
tif
tif
tif_dir
td_stripbytecount
return 0;
0
ChopUpSingleUncompressedStrip(tif);
ChopUpSingleUncompressedStrip(tif)
ChopUpSingleUncompressedStrip
ChopUpSingleUncompressedStrip
tif
tif
tif->tif_flags &= ~TIFF_DIRTYDIRECT;
tif->tif_flags &= ~TIFF_DIRTYDIRECT
tif->tif_flags
tif
tif
tif_flags
~TIFF_DIRTYDIRECT
TIFF_DIRTYDIRECT
TIFF_DIRTYDIRECT
tif->tif_flags &= ~TIFF_DIRTYSTRIP;
tif->tif_flags &= ~TIFF_DIRTYSTRIP
tif->tif_flags
tif
tif
tif_flags
~TIFF_DIRTYSTRIP
TIFF_DIRTYSTRIP
TIFF_DIRTYSTRIP
tif->tif_row = (uint32) -1;
tif->tif_row = (uint32) -1
tif->tif_row
tif
tif
tif_row
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_curstrip = (uint32) -1;
tif->tif_curstrip = (uint32) -1
tif->tif_curstrip
tif
tif
tif_curstrip
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_col = (uint32) -1;
tif->tif_col = (uint32) -1
tif->tif_col
tif
tif
tif_col
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_curtile = (uint32) -1;
tif->tif_curtile = (uint32) -1
tif->tif_curtile
tif
tif
tif_curtile
(uint32) -1
(uint32)
uint32
uint32
1
tif->tif_tilesize = (tmsize_t) -1;
tif->tif_tilesize = (tmsize_t) -1
tif->tif_tilesize
tif
tif
tif_tilesize
(tmsize_t) -1
(tmsize_t)
tmsize_t
tmsize_t
1
tif->tif_scanlinesize = TIFFScanlineSize(tif);
tif->tif_scanlinesize = TIFFScanlineSize(tif)
tif->tif_scanlinesize
tif
tif
tif_scanlinesize
TIFFScanlineSize(tif)
TIFFScanlineSize
TIFFScanlineSize
tif
tif
if (!tif->tif_scanlinesize) {		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}
!tif->tif_scanlinesize
tif->tif_scanlinesize
tif
tif
tif_scanlinesize
{		TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");		return (0);	}
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size");
TIFFErrorExt(tif->tif_clientdata, module,		    "Cannot handle zero scanline size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero scanline size"
return (0);
(0)
0
if (isTiled(tif)) {		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	} else {		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}
isTiled(tif)
isTiled
isTiled
tif
tif
{		tif->tif_tilesize = TIFFTileSize(tif);		if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}	}
tif->tif_tilesize = TIFFTileSize(tif);
tif->tif_tilesize = TIFFTileSize(tif)
tif->tif_tilesize
tif
tif
tif_tilesize
TIFFTileSize(tif)
TIFFTileSize
TIFFTileSize
tif
tif
if (!tif->tif_tilesize) {			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}
!tif->tif_tilesize
tif->tif_tilesize
tif
tif
tif_tilesize
{			TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");			return (0);		}
TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size");
TIFFErrorExt(tif->tif_clientdata, module,			     "Cannot handle zero tile size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero tile size"
return (0);
(0)
0
{		if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}	}
if (!TIFFStripSize(tif)) {			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}
!TIFFStripSize(tif)
TIFFStripSize(tif)
TIFFStripSize
TIFFStripSize
tif
tif
{			TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");			return (0);		}
TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size");
TIFFErrorExt(tif->tif_clientdata, module,			    "Cannot handle zero strip size")
TIFFErrorExt
TIFFErrorExt
tif->tif_clientdata
tif
tif
tif_clientdata
module
module
"Cannot handle zero strip size"
return (0);
(0)
0
return (1);
(1)
1
bad:	if (dir)		_TIFFfree(dir);
bad
if (dir)		_TIFFfree(dir);
dir
dir
_TIFFfree(dir);
_TIFFfree(dir)
_TIFFfree
_TIFFfree
dir
dir
return (0);
(0)
0
-----joern-----
(3,10,0)
(7,8,0)
(2,0,0)
(1,8,0)
(4,10,0)
(6,9,0)
(4,0,0)
(8,5,0)
(0,2,1)
(1,7,1)
(8,1,1)
(8,5,1)
(4,10,1)
(4,0,1)
(3,8,1)
(2,8,1)
(10,3,1)
(4,10,2)
(3,8,2)
(10,8,2)
(2,8,2)
(4,0,2)
(0,8,2)
(8,5,2)
-----------------------------------
(0,return(TIFFReadDirEntryErrRange)
(1,TIFF_INT64_MAX)
(2,TIFFReadDirEntryErrRange)
(3,TIFFReadDirEntryErrOk)
(4,RET)
(5,uint64 value)
(6,if (value > TIFF_INT64_MAX)
(7,value)
(8,value > TIFF_INT64_MAX)
(9,)
(10,return(TIFFReadDirEntryErrOk)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
----------------dynamic----------------
=======testcase========
model_version:0x01000000
A-data-stat:0x000800000000000001000000000000000100000000000000a4810000e8030000e9030000ffffffff0000000000000000ffffffffffffffff0010000000000000ffffffffffffffff85f6b26300000000ffffffffffffffff94f6b26300000000ffffffffffffffff94f6b26300000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
A-data:0x45502b00080000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
=========trace=========
int TIFFReadDirectory(TIFF* tif) {
static const char module[] = 'TIFFReadDirectory';
TIFFDirEntry* dir;
uint16 dircount;
TIFFDirEntry* dp;
uint16 di;
const TIFFField* fip;
uint32 fii=FAILED_FII;
toff_t nextdiroff;
int bitspersample_read = FALSE;
int color_channels;
tif->tif_diroff=tif->tif_nextdiroff;
if(!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
return 0;
=======================
