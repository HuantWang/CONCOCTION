static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,   int cnt) { 	jas_icccurv_t *curv = &attrval->data.curv; 	unsigned int i;  	curv->numents = 0; 	curv->ents = 0;  	if (jas_iccgetuint32(in, &curv->numents)) 		goto error; 	if (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t)))) 		goto error; 	for (i = 0; i < curv->numents; ++i) { 		if (jas_iccgetuint16(in, &curv->ents[i])) 			goto error; 	}  	if (JAS_CAST(int, 4 + 2 * curv->numents) != cnt) 		goto error; 	return 0;  error: 	jas_icccurv_destroy(attrval); 	return -1; }
static int jas_cmpxformseq_resize(jas_cmpxformseq_t *pxformseq, int n) { 	jas_cmpxform_t **p; 	assert(n >= pxformseq->numpxforms); 	p = (!pxformseq->pxforms) ? jas_malloc(n * sizeof(jas_cmpxform_t *)) : 	  jas_realloc(pxformseq->pxforms, n * sizeof(jas_cmpxform_t *)); 	if (!p) { 		return -1; 	} 	pxformseq->pxforms = p; 	pxformseq->maxpxforms = n; 	return 0; }
static jpc_enc_cp_t *cp_create(char *optstr, jas_image_t *image) { 	jpc_enc_cp_t *cp; 	jas_tvparser_t *tvp; 	int ret; 	int numilyrrates; 	double *ilyrrates; 	int i; 	int tagid; 	jpc_enc_tcp_t *tcp; 	jpc_enc_tccp_t *tccp; 	jpc_enc_ccp_t *ccp; 	int cmptno; 	uint_fast16_t rlvlno; 	uint_fast16_t prcwidthexpn; 	uint_fast16_t prcheightexpn; 	bool enablemct; 	uint_fast32_t jp2overhead; 	uint_fast16_t lyrno; 	uint_fast32_t hsteplcm; 	uint_fast32_t vsteplcm; 	bool mctvalid;  	tvp = 0; 	cp = 0; 	ilyrrates = 0; 	numilyrrates = 0;  	if (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) { 		goto error; 	}  	prcwidthexpn = 15; 	prcheightexpn = 15; 	enablemct = true; 	jp2overhead = 0;  	cp->ccps = 0; 	cp->debug = 0; 	cp->imgareatlx = UINT_FAST32_MAX; 	cp->imgareatly = UINT_FAST32_MAX; 	cp->refgrdwidth = 0; 	cp->refgrdheight = 0; 	cp->tilegrdoffx = UINT_FAST32_MAX; 	cp->tilegrdoffy = UINT_FAST32_MAX; 	cp->tilewidth = 0; 	cp->tileheight = 0; 	cp->numcmpts = jas_image_numcmpts(image);  	hsteplcm = 1; 	vsteplcm = 1; 	for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) { 		if (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <= 		  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) + 		  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) { 			jas_eprintf("unsupported image type\n"); 			goto error; 		} 		/* Note: We ought to be calculating the LCMs here.  Fix some day. */ 		hsteplcm *= jas_image_cmpthstep(image, cmptno); 		vsteplcm *= jas_image_cmptvstep(image, cmptno); 	}  	if (!(cp->ccps = jas_malloc(cp->numcmpts * sizeof(jpc_enc_ccp_t)))) { 		goto error; 	} 	for (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno, 	  ++ccp) { 		ccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno); 		ccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno); 		/* XXX - this isn't quite correct for more general image */ 		ccp->sampgrdsubstepx = 0; 		ccp->sampgrdsubstepx = 0; 		ccp->prec = jas_image_cmptprec(image, cmptno); 		ccp->sgnd = jas_image_cmptsgnd(image, cmptno); 		ccp->numstepsizes = 0; 		memset(ccp->stepsizes, 0, sizeof(ccp->stepsizes)); 	}  	cp->rawsize = jas_image_rawsize(image); 	cp->totalsize = UINT_FAST32_MAX;  	tcp = &cp->tcp; 	tcp->csty = 0; 	tcp->intmode = true; 	tcp->prg = JPC_COD_LRCPPRG; 	tcp->numlyrs = 1; 	tcp->ilyrrates = 0;  	tccp = &cp->tccp; 	tccp->csty = 0; 	tccp->maxrlvls = 6; 	tccp->cblkwidthexpn = 6; 	tccp->cblkheightexpn = 6; 	tccp->cblksty = 0; 	tccp->numgbits = 2;  	if (!(tvp = jas_tvparser_create(optstr ? optstr : ""))) { 		goto error; 	}  	while (!(ret = jas_tvparser_next(tvp))) { 		switch (jas_taginfo_nonull(jas_taginfos_lookup(encopts, 		  jas_tvparser_gettag(tvp)))->id) { 		case OPT_DEBUG: 			cp->debug = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_IMGAREAOFFX: 			cp->imgareatlx = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_IMGAREAOFFY: 			cp->imgareatly = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEGRDOFFX: 			cp->tilegrdoffx = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEGRDOFFY: 			cp->tilegrdoffy = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEWIDTH: 			cp->tilewidth = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_TILEHEIGHT: 			cp->tileheight = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_PRCWIDTH: 			prcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_PRCHEIGHT: 			prcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_CBLKWIDTH: 			tccp->cblkwidthexpn = 			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_CBLKHEIGHT: 			tccp->cblkheightexpn = 			  jpc_floorlog2(atoi(jas_tvparser_getval(tvp))); 			break; 		case OPT_MODE: 			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab, 			  jas_tvparser_getval(tvp)))->id) < 0) { 				jas_eprintf("ignoring invalid mode %s\n", 				  jas_tvparser_getval(tvp)); 			} else { 				tcp->intmode = (tagid == MODE_INT); 			} 			break; 		case OPT_PRG: 			if ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab, 			  jas_tvparser_getval(tvp)))->id) < 0) { 				jas_eprintf("ignoring invalid progression order %s\n", 				  jas_tvparser_getval(tvp)); 			} else { 				tcp->prg = tagid; 			} 			break; 		case OPT_NOMCT: 			enablemct = false; 			break; 		case OPT_MAXRLVLS: 			tccp->maxrlvls = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_SOP: 			cp->tcp.csty |= JPC_COD_SOP; 			break; 		case OPT_EPH: 			cp->tcp.csty |= JPC_COD_EPH; 			break; 		case OPT_LAZY: 			tccp->cblksty |= JPC_COX_LAZY; 			break; 		case OPT_TERMALL: 			tccp->cblksty |= JPC_COX_TERMALL; 			break; 		case OPT_SEGSYM: 			tccp->cblksty |= JPC_COX_SEGSYM; 			break; 		case OPT_VCAUSAL: 			tccp->cblksty |= JPC_COX_VSC; 			break; 		case OPT_RESET: 			tccp->cblksty |= JPC_COX_RESET; 			break; 		case OPT_PTERM: 			tccp->cblksty |= JPC_COX_PTERM; 			break; 		case OPT_NUMGBITS: 			cp->tccp.numgbits = atoi(jas_tvparser_getval(tvp)); 			break; 		case OPT_RATE: 			if (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize, 			  &cp->totalsize)) { 				jas_eprintf("ignoring bad rate specifier %s\n", 				  jas_tvparser_getval(tvp)); 			} 			break; 		case OPT_ILYRRATES: 			if (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates, 			  &ilyrrates)) { 				jas_eprintf("warning: invalid intermediate layer rates specifier ignored (%s)\n", 				  jas_tvparser_getval(tvp)); 			} 			break;  		case OPT_JP2OVERHEAD: 			jp2overhead = atoi(jas_tvparser_getval(tvp)); 			break; 		default: 			jas_eprintf("warning: ignoring invalid option %s\n", 			 jas_tvparser_gettag(tvp)); 			break; 		} 	}  	jas_tvparser_destroy(tvp); 	tvp = 0;  	if (cp->totalsize != UINT_FAST32_MAX) { 		cp->totalsize = (cp->totalsize > jp2overhead) ? 		  (cp->totalsize - jp2overhead) : 0; 	}  	if (cp->imgareatlx == UINT_FAST32_MAX) { 		cp->imgareatlx = 0; 	} else { 		if (hsteplcm != 1) { 			jas_eprintf("warning: overriding imgareatlx value\n"); 		} 		cp->imgareatlx *= hsteplcm; 	} 	if (cp->imgareatly == UINT_FAST32_MAX) { 		cp->imgareatly = 0; 	} else { 		if (vsteplcm != 1) { 			jas_eprintf("warning: overriding imgareatly value\n"); 		} 		cp->imgareatly *= vsteplcm; 	} 	cp->refgrdwidth = cp->imgareatlx + jas_image_width(image); 	cp->refgrdheight = cp->imgareatly + jas_image_height(image); 	if (cp->tilegrdoffx == UINT_FAST32_MAX) { 		cp->tilegrdoffx = cp->imgareatlx; 	} 	if (cp->tilegrdoffy == UINT_FAST32_MAX) { 		cp->tilegrdoffy = cp->imgareatly; 	} 	if (!cp->tilewidth) { 		cp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx; 	} 	if (!cp->tileheight) { 		cp->tileheight = cp->refgrdheight - cp->tilegrdoffy; 	}  	if (cp->numcmpts == 3) { 		mctvalid = true; 		for (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) { 			if (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) || 			  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) || 			  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) || 			  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) { 				mctvalid = false; 			} 		} 	} else { 		mctvalid = false; 	} 	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) { 		jas_eprintf("warning: color space apparently not RGB\n"); 	} 	if (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) { 		tcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT); 	} else { 		tcp->mctid = JPC_MCT_NONE; 	} 	tccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);  	for (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) { 		tccp->prcwidthexpns[rlvlno] = prcwidthexpn; 		tccp->prcheightexpns[rlvlno] = prcheightexpn; 	} 	if (prcwidthexpn != 15 || prcheightexpn != 15) { 		tccp->csty |= JPC_COX_PRT; 	}  	/* Ensure that the tile width and height is valid. */ 	if (!cp->tilewidth) { 		jas_eprintf("invalid tile width %lu\n", (unsigned long) 		  cp->tilewidth); 		goto error; 	} 	if (!cp->tileheight) { 		jas_eprintf("invalid tile height %lu\n", (unsigned long) 		  cp->tileheight); 		goto error; 	}  	/* Ensure that the tile grid offset is valid. */ 	if (cp->tilegrdoffx > cp->imgareatlx || 	  cp->tilegrdoffy > cp->imgareatly || 	  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx || 	  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) { 		jas_eprintf("invalid tile grid offset (%lu, %lu)\n", 		  (unsigned long) cp->tilegrdoffx, (unsigned long) 		  cp->tilegrdoffy); 		goto error; 	}  	cp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx, 	  cp->tilewidth); 	cp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy, 	  cp->tileheight); 	cp->numtiles = cp->numhtiles * cp->numvtiles;  	if (ilyrrates && numilyrrates > 0) { 		tcp->numlyrs = numilyrrates + 1; 		if (!(tcp->ilyrrates = jas_malloc((tcp->numlyrs - 1) * 		  sizeof(jpc_fix_t)))) { 			goto error; 		} 		for (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) { 			tcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]); 		} 	}  	/* Ensure that the integer mode is used in the case of lossless 	  coding. */ 	if (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) { 		jas_eprintf("cannot use real mode for lossless coding\n"); 		goto error; 	}  	/* Ensure that the precinct width is valid. */ 	if (prcwidthexpn > 15) { 		jas_eprintf("invalid precinct width\n"); 		goto error; 	}  	/* Ensure that the precinct height is valid. */ 	if (prcheightexpn > 15) { 		jas_eprintf("invalid precinct height\n"); 		goto error; 	}  	/* Ensure that the code block width is valid. */ 	if (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) { 		jas_eprintf("invalid code block width %d\n", 		  JPC_POW2(cp->tccp.cblkwidthexpn)); 		goto error; 	}  	/* Ensure that the code block height is valid. */ 	if (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) { 		jas_eprintf("invalid code block height %d\n", 		  JPC_POW2(cp->tccp.cblkheightexpn)); 		goto error; 	}  	/* Ensure that the code block size is not too large. */ 	if (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) { 		jas_eprintf("code block size too large\n"); 		goto error; 	}  	/* Ensure that the number of layers is valid. */ 	if (cp->tcp.numlyrs > 16384) { 		jas_eprintf("too many layers\n"); 		goto error; 	}  	/* There must be at least one resolution level. */ 	if (cp->tccp.maxrlvls < 1) { 		jas_eprintf("must be at least one resolution level\n"); 		goto error; 	}  	/* Ensure that the number of guard bits is valid. */ 	if (cp->tccp.numgbits > 8) { 		jas_eprintf("invalid number of guard bits\n"); 		goto error; 	}  	/* Ensure that the rate is within the legal range. */ 	if (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) { 		jas_eprintf("warning: specified rate is unreasonably large (%lu > %lu)\n", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize); 	}  	/* Ensure that the intermediate layer rates are valid. */ 	if (tcp->numlyrs > 1) { 		/* The intermediate layers rates must increase monotonically. */ 		for (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) { 			if (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) { 				jas_eprintf("intermediate layer rates must increase monotonically\n"); 				goto error; 			} 		} 		/* The intermediate layer rates must be less than the overall rate. */ 		if (cp->totalsize != UINT_FAST32_MAX) { 			for (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) { 				if (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize) 				  / cp->rawsize) { 					jas_eprintf("warning: intermediate layer rates must be less than overall rate\n"); 					goto error; 				} 			} 		} 	}  	if (ilyrrates) { 		jas_free(ilyrrates); 	}  	return cp;  error:  	if (ilyrrates) { 		jas_free(ilyrrates); 	} 	if (tvp) { 		jas_tvparser_destroy(tvp); 	} 	if (cp) { 		jpc_enc_cp_destroy(cp); 	} 	return 0; }
static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,   int bufsize) { 	/* If this function is being called, the buffer should not have been 	  initialized yet. */ 	assert(!stream->bufbase_);  	if (bufmode != JAS_STREAM_UNBUF) { 		/* The full- or line-buffered mode is being employed. */ 		if (!buf) { 			/* The caller has not specified a buffer to employ, so allocate 			  one. */ 			if ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE + 			  JAS_STREAM_MAXPUTBACK))) { 				stream->bufmode_ |= JAS_STREAM_FREEBUF; 				stream->bufsize_ = JAS_STREAM_BUFSIZE; 			} else { 				/* The buffer allocation has failed.  Resort to unbuffered 				  operation. */ 				stream->bufbase_ = stream->tinybuf_; 				stream->bufsize_ = 1; 			} 		} else { 			/* The caller has specified a buffer to employ. */ 			/* The buffer must be large enough to accommodate maximum 			  putback. */ 			assert(bufsize > JAS_STREAM_MAXPUTBACK); 			stream->bufbase_ = JAS_CAST(uchar *, buf); 			stream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK; 		} 	} else { 		/* The unbuffered mode is being employed. */ 		/* A buffer should not have been supplied by the caller. */ 		assert(!buf); 		/* Use a trivial one-character buffer. */ 		stream->bufbase_ = stream->tinybuf_; 		stream->bufsize_ = 1; 	} 	stream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK]; 	stream->ptr_ = stream->bufstart_; 	stream->cnt_ = 0; 	stream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK; }
static void jas_icccurv_destroy(jas_iccattrval_t *attrval) { 	jas_icccurv_t *curv = &attrval->data.curv; 	if (curv->ents) 		jas_free(curv->ents); }
static int jas_iccgettime(jas_stream_t *in, jas_icctime_t *time) { 	if (jas_iccgetuint16(in, &time->year) || 	  jas_iccgetuint16(in, &time->month) || 	  jas_iccgetuint16(in, &time->day) || 	  jas_iccgetuint16(in, &time->hour) || 	  jas_iccgetuint16(in, &time->min) || 	  jas_iccgetuint16(in, &time->sec)) { 		return -1; 	} 	return 0; }
static int file_close(jas_stream_obj_t *obj) { 	jas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj); 	int ret; 	ret = close(fileobj->fd); 	if (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) { 		unlink(fileobj->pathname); 	} 	jas_free(fileobj); 	return ret; }
int jas_stream_gobble(jas_stream_t *stream, int n) { 	int m; 	m = n; 	for (m = n; m > 0; --m) { 		if (jas_stream_getc(stream) == EOF) { 			return n - m; 		} 	} 	return n; }
void *jas_malloc(size_t size) { #if defined(MEMALLOC_ALIGN2) 	void *ptr; abort(); 	if (posix_memalign(&ptr, MEMALLOC_ALIGNMENT, size)) { 		return 0; 	} 	return ptr; #endif 	return malloc(size); }
int jas_stream_rewind(jas_stream_t *stream) { 	return jas_stream_seek(stream, 0, SEEK_SET); }
static jas_iccattrvalinfo_t *jas_iccattrvalinfo_lookup(jas_iccsig_t type) { 	jas_iccattrvalinfo_t *info; 	info = jas_iccattrvalinfos; 	for (info = jas_iccattrvalinfos; info->type; ++info) { 		if (info->type == type) { 			return info; 		} 	} 	return 0; }
int pnm_fmt(uint_fast16_t magic) { 	int fmt; 	switch (magic) { 	case PNM_MAGIC_TXTPBM: 	case PNM_MAGIC_TXTPGM: 	case PNM_MAGIC_TXTPPM: 		fmt = PNM_FMT_TXT; 		break; 	case PNM_MAGIC_BINPBM: 	case PNM_MAGIC_BINPGM: 	case PNM_MAGIC_BINPPM: 		fmt = PNM_FMT_BIN; 		break; 	default: 		/* This should not happen. */ 		abort(); 		break; 	} 	return fmt; }
int jpc_bitstream_close(jpc_bitstream_t *bitstream) { 	int ret = 0;  	/* Align to the next byte boundary while considering the effects of 	  bit stuffing. */ 	if (jpc_bitstream_align(bitstream)) { 		ret = -1; 	}  	/* If necessary, close the underlying (character) stream. */ 	if (!(bitstream->flags_ & JPC_BITSTREAM_NOCLOSE) && bitstream->stream_) { 		if (jas_stream_close(bitstream->stream_)) { 			ret = -1; 		} 		bitstream->stream_ = 0; 	}  	jas_free(bitstream); 	return ret; }
jas_iccattrval_t *jas_iccattrval_clone(jas_iccattrval_t *attrval) { 	++attrval->refcnt; 	return attrval; }
static void jas_iccattrtab_destroy(jas_iccattrtab_t *tab) { 	if (tab->attrs) { 		while (tab->numattrs > 0) { 			jas_iccattrtab_delete(tab, 0); 		} 		jas_free(tab->attrs); 	} 	jas_free(tab); }
int jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt, char *optstr) { 	jas_image_fmtinfo_t *fmtinfo; 	if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) { 		return -1; 	} 	return (fmtinfo->ops.encode) ? (*fmtinfo->ops.encode)(image, out, 	  optstr) : (-1); }
int jpc_putuint16(jas_stream_t *out, uint_fast16_t val) { 	if (jas_stream_putc(out, (val >> 8) & 0xff) == EOF || 	  jas_stream_putc(out, val & 0xff) == EOF) { 		return -1; 	} 	return 0; }
void jas_free(void *ptr) { 	free(ptr); }
void jas_tmr_start(jas_tmr_t *tmr) { }
int jas_tvparser_next(jas_tvparser_t *tvp) { 	char *p; 	char *tag; 	char *val;  	/* Skip any leading whitespace. */ 	p = tvp->pos; 	while (*p != '\0' && isspace(*p)) { 		++p; 	}  	/* Has the end of the input data been reached? */ 	if (*p == '\0') { 		/* No more tags are present. */ 		tvp->pos = p; 		return 1; 	}  	/* Does the tag name begin with a valid character? */ 	if (!JAS_TVP_ISTAG(*p)) { 		return -1; 	}  	/* Remember where the tag name begins. */ 	tag = p;  	/* Find the end of the tag name. */ 	while (*p != '\0' && JAS_TVP_ISTAG(*p)) { 		++p; 	}  	/* Has the end of the input data been reached? */ 	if (*p == '\0') { 		/* The value field is empty. */ 		tvp->tag = tag; 		tvp->val = ""; 		tvp->pos = p; 		return 0; 	}  	/* Is a value field not present? */ 	if (*p != '=') { 		if (*p != '\0' && !isspace(*p)) { 			return -1; 		} 		*p++ = '\0'; 		tvp->tag = tag; 		tvp->val = ""; 		tvp->pos = p; 		return 0; 	}  	*p++ = '\0';  	val = p; 	while (*p != '\0' && !isspace(*p)) { 		++p; 	}  	if (*p != '\0') { 		*p++ = '\0'; 	}  	tvp->pos = p; 	tvp->tag = tag; 	tvp->val = val;  	return 0; }
static int jas_icctagtabent_cmp(const void *src, const void *dst) { 	jas_icctagtabent_t *srctagtabent = JAS_CAST(jas_icctagtabent_t *, src); 	jas_icctagtabent_t *dsttagtabent = JAS_CAST(jas_icctagtabent_t *, dst); 	if (srctagtabent->off > dsttagtabent->off) { 		return 1; 	} else if (srctagtabent->off < dsttagtabent->off) { 		return -1; 	} 	return 0; }
jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile) { 	jpc_pi_t *pi; 	int compno; 	jpc_picomp_t *picomp; 	jpc_pirlvl_t *pirlvl; 	jpc_enc_tcmpt_t *tcomp; 	int rlvlno; 	jpc_enc_rlvl_t *rlvl; 	int prcno; 	int *prclyrno;  	if (!(pi = jpc_pi_create0())) { 		return 0; 	} 	pi->pktno = -1; 	pi->numcomps = cp->numcmpts; 	if (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) { 		jpc_pi_destroy(pi); 		return 0; 	} 	for (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno, 	  ++picomp) { 		picomp->pirlvls = 0; 	}  	for (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps; 	  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) { 		picomp->numrlvls = tcomp->numrlvls; 		if (!(picomp->pirlvls = jas_malloc(picomp->numrlvls * 		  sizeof(jpc_pirlvl_t)))) { 			jpc_pi_destroy(pi); 			return 0; 		} 		for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno < 		  picomp->numrlvls; ++rlvlno, ++pirlvl) { 			pirlvl->prclyrnos = 0; 		} 		for (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls; 		  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) { /* XXX sizeof(long) should be sizeof different type */ 			pirlvl->numprcs = rlvl->numprcs; 			if (rlvl->numprcs) { 				if (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs * 				  sizeof(long)))) { 					jpc_pi_destroy(pi); 					return 0; 				} 			} else { 				pirlvl->prclyrnos = 0; 			} 		} 	}  	pi->maxrlvls = 0; 	for (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps; 	  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) { 		picomp->hsamp = cp->ccps[compno].sampgrdstepx; 		picomp->vsamp = cp->ccps[compno].sampgrdstepy; 		for (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls; 		  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) { 			pirlvl->prcwidthexpn = rlvl->prcwidthexpn; 			pirlvl->prcheightexpn = rlvl->prcheightexpn; 			for (prcno = 0, prclyrno = pirlvl->prclyrnos; 			  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) { 				*prclyrno = 0; 			} 			pirlvl->numhprcs = rlvl->numhprcs; 		} 		if (pi->maxrlvls < tcomp->numrlvls) { 			pi->maxrlvls = tcomp->numrlvls; 		} 	}  	pi->numlyrs = tile->numlyrs; 	pi->xstart = tile->tlx; 	pi->ystart = tile->tly; 	pi->xend = tile->brx; 	pi->yend = tile->bry;  	pi->picomp = 0; 	pi->pirlvl = 0; 	pi->x = 0; 	pi->y = 0; 	pi->compno = 0; 	pi->rlvlno = 0; 	pi->prcno = 0; 	pi->lyrno = 0; 	pi->xstep = 0; 	pi->ystep = 0;  	pi->pchgno = -1;  	pi->defaultpchg.prgord = tile->prg; 	pi->defaultpchg.compnostart = 0; 	pi->defaultpchg.compnoend = pi->numcomps; 	pi->defaultpchg.rlvlnostart = 0; 	pi->defaultpchg.rlvlnoend = pi->maxrlvls; 	pi->defaultpchg.lyrnoend = pi->numlyrs; 	pi->pchg = 0;  	pi->valid = 0;  	return pi; }
static int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out) { 	jpc_qcxcp_t *compparms = &ms->parms.qcd.compparms; 	return jpc_qcx_putcompparms(compparms, cstate, out); }
int jas_stream_flushbuf(jas_stream_t *stream, int c) { 	int len; 	int n;  	/* The stream should not be in an error or EOF state. */ 	if ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) { 		return EOF; 	}  	/* The stream must be open for writing. */ 	if ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) { 		return EOF; 	}  	/* The buffer should not currently be in use for reading. */ 	assert(!(stream->bufmode_ & JAS_STREAM_RDBUF));  	/* Note: Do not use the quantity stream->cnt to determine the number 	of characters in the buffer!  Depending on how this function was 	called, the stream->cnt value may be "off-by-one". */ 	len = stream->ptr_ - stream->bufstart_; 	if (len > 0) { 		n = (*stream->ops_->write_)(stream->obj_, (char *) 		  stream->bufstart_, len); 		if (n != len) { 			stream->flags_ |= JAS_STREAM_ERR; 			return EOF; 		} 	} 	stream->cnt_ = stream->bufsize_; 	stream->ptr_ = stream->bufstart_;  	stream->bufmode_ |= JAS_STREAM_WRBUF;  	if (c != EOF) { 		assert(stream->cnt_ > 0); 		return jas_stream_putc2(stream, c); 	}  	return 0; }
static int pnm_getsintstr(jas_stream_t *in, int_fast32_t *val) { 	int c; 	int s; 	int_fast32_t v;  	/* Discard any leading whitespace. */ 	do { 		if ((c = pnm_getc(in)) == EOF) { 			return -1; 		} 	} while (isspace(c));  	/* Get the number, allowing for a negative sign. */ 	s = 1; 	if (c == '-') { 		s = -1; 		if ((c = pnm_getc(in)) == EOF) { 			return -1; 		} 	} else if (c == '+') { 		if ((c = pnm_getc(in)) == EOF) { 			return -1; 		} 	} 	v = 0; 	while (isdigit(c)) { 		v = 10 * v + c - '0'; 		if ((c = pnm_getc(in)) < 0) { 			return -1; 		} 	}  	/* The number must be followed by whitespace. */ 	if (!isspace(c)) { 		return -1; 	}  	if (val) { 		*val = (s >= 0) ? v : (-v); 	}  	return 0; }
void jas_tmr_stop(jas_tmr_t *tmr) { }
static void jpc_mqenc_setbits(jpc_mqenc_t *mqenc) { 	uint_fast32_t tmp = mqenc->creg + mqenc->areg; 	mqenc->creg |= 0xffff; 	if (mqenc->creg >= tmp) { 		mqenc->creg -= 0x8000; 	} }
static void jas_icctxt_destroy(jas_iccattrval_t *attrval) { 	jas_icctxt_t *txt = &attrval->data.txt; 	if (txt->string) 		jas_free(txt->string); }
static jas_iccprof_t *jas_iccprof_create() { 	jas_iccprof_t *prof; 	prof = 0; 	if (!(prof = jas_malloc(sizeof(jas_iccprof_t)))) { 		goto error; 	} 	if (!(prof->attrtab = jas_iccattrtab_create())) 		goto error; 	memset(&prof->hdr, 0, sizeof(jas_icchdr_t)); 	prof->tagtab.numents = 0; 	prof->tagtab.ents = 0; 	return prof; error: 	if (prof) 		jas_iccprof_destroy(prof); 	return 0; }
static void jpc_picomp_destroy(jpc_picomp_t *picomp) { 	int rlvlno; 	jpc_pirlvl_t *pirlvl; 	if (picomp->pirlvls) { 		for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno < 		  picomp->numrlvls; ++rlvlno, ++pirlvl) { 			pirlvl_destroy(pirlvl); 		} 		jas_free(picomp->pirlvls); 	} }
jpc_cstate_t *jpc_cstate_create() { 	jpc_cstate_t *cstate; 	if (!(cstate = jas_malloc(sizeof(jpc_cstate_t)))) { 		return 0; 	} 	cstate->numcomps = 0; 	return cstate; }
void jpc_initmqctxs() { 	jpc_initctxs(jpc_mqctxs); }
char *jas_tvparser_gettag(jas_tvparser_t *tvp) { 	return tvp->tag; }
static int jpc_pi_nextlrcp(register jpc_pi_t *pi) { 	jpc_pchg_t *pchg; 	int *prclyrno;  	pchg = pi->pchg; 	if (!pi->prgvolfirst) { 		prclyrno = &pi->pirlvl->prclyrnos[pi->prcno]; 		goto skip; 	} else { 		pi->prgvolfirst = false; 	}  	for (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno < 	  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) { 		for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls && 		  pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) { 			for (pi->compno = pchg->compnostart, pi->picomp = 			  &pi->picomps[pi->compno]; pi->compno < pi->numcomps 			  && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, 			  ++pi->picomp) { 				if (pi->rlvlno >= pi->picomp->numrlvls) { 					continue; 				} 				pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno]; 				for (pi->prcno = 0, prclyrno = 				  pi->pirlvl->prclyrnos; pi->prcno < 				  pi->pirlvl->numprcs; ++pi->prcno, 				  ++prclyrno) { 					if (pi->lyrno >= *prclyrno) { 						*prclyrno = pi->lyrno; 						++(*prclyrno); 						return 0; 					} skip: 					; 				} 			} 		} 	} 	return 1; }
void jas_iccprof_destroy(jas_iccprof_t *prof) { 	if (prof->attrtab) 		jas_iccattrtab_destroy(prof->attrtab); 	if (prof->tagtab.ents) 		jas_free(prof->tagtab.ents); 	jas_free(prof); }
void jpc_tagtree_setvalue(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf,   int value) { 	jpc_tagtreenode_t *node;  	/* Avoid compiler warnings about unused parameters. */ 	tree = 0;  	assert(value >= 0);  	node = leaf; 	while (node && node->value_ > value) { 		node->value_ = value; 		node = node->parent_; 	} }
int jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,   int width, int height, int stride, int numlvls) { 	if (width > 0 && height > 0) { 		if ((*tsfb->qmfb->analyze)(a, xstart, ystart, width, height, stride)) 			return -1; 		if (numlvls > 0) { 			if (jpc_tsfb_analyze2(tsfb, a, JPC_CEILDIVPOW2(xstart, 			  1), JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2( 			  xstart + width, 1) - JPC_CEILDIVPOW2(xstart, 1), 			  JPC_CEILDIVPOW2(ystart + height, 1) - 			  JPC_CEILDIVPOW2(ystart, 1), stride, numlvls - 1)) { 				return -1; 			} 		} 	} 	return 0; }
int jpc_mqenc_flush(jpc_mqenc_t *mqenc, int termmode) { 	int_fast16_t k;  	switch (termmode) { 	case JPC_MQENC_PTERM: 		k = 11 - mqenc->ctreg + 1; 		while (k > 0) { 			mqenc->creg <<= mqenc->ctreg; 			mqenc->ctreg = 0; 			jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, 			  mqenc); 			k -= mqenc->ctreg; 		} 		if (mqenc->outbuf != 0xff) { 			jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc); 		} 		break; 	case JPC_MQENC_DEFTERM: 		jpc_mqenc_setbits(mqenc); 		mqenc->creg <<= mqenc->ctreg; 		jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc); 		mqenc->creg <<= mqenc->ctreg; 		jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc); 		if (mqenc->outbuf != 0xff) { 			jpc_mqenc_byteout(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc); 		} 		break; 	default: 		abort(); 		break; 	} 	return 0; }
static int jas_iccxyz_input(jas_iccattrval_t *attrval, jas_stream_t *in,   int len) { 	if (len != 4 * 3) abort(); 	return jas_iccgetxyz(in, &attrval->data.xyz); }
int jpc_floorlog2(int x) { 	int y;  	/* The argument must be positive. */ 	assert(x > 0);  	y = 0; 	while (x > 1) { 		x >>= 1; 		++y; 	} 	return y; }
int jpc_getscctxno(int f) { 	int hc; 	int vc; 	int n;  	/* Avoid compiler warning. */ 	n = 0;  	hc = JAS_MIN(((f & (JPC_ESIG | JPC_ESGN)) == JPC_ESIG) + ((f & (JPC_WSIG | JPC_WSGN)) == JPC_WSIG), 	  1) - JAS_MIN(((f & (JPC_ESIG | JPC_ESGN)) == (JPC_ESIG | JPC_ESGN)) + 	  ((f & (JPC_WSIG | JPC_WSGN)) == (JPC_WSIG | JPC_WSGN)), 1); 	vc = JAS_MIN(((f & (JPC_NSIG | JPC_NSGN)) == JPC_NSIG) + ((f & (JPC_SSIG | JPC_SSGN)) == JPC_SSIG), 	  1) - JAS_MIN(((f & (JPC_NSIG | JPC_NSGN)) == (JPC_NSIG | JPC_NSGN)) + 	  ((f & (JPC_SSIG | JPC_SSGN)) == (JPC_SSIG | JPC_SSGN)), 1); 	assert(hc >= -1 && hc <= 1 && vc >= -1 && vc <= 1); 	if (hc < 0) { 		hc = -hc; 		vc = -vc; 	} 	if (!hc) { 		if (vc == -1) { 			n = 1; 		} else if (!vc) { 			n = 0; 		} else { 			n = 1; 		} 	} else if (hc == 1) { 		if (vc == -1) { 			n = 2; 		} else if (!vc) { 			n = 3; 		} else { 			n = 4; 		} 	} 	assert(n < JPC_NUMSCCTXS); 	return JPC_SCCTXNO + n; }
static int file_read(jas_stream_obj_t *obj, char *buf, int cnt) { 	jas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj); 	return read(fileobj->fd, buf, cnt); }
static int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out) { 	jp2_ftyp_t *ftyp = &box->data.ftyp; 	unsigned int i; 	if (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) { 		return -1; 	} 	for (i = 0; i < ftyp->numcompatcodes; ++i) { 		if (jp2_putuint32(out, ftyp->compatcodes[i])) { 			return -1; 		} 	} 	return 0; }
static jpc_enc_cblk_t *cblk_create(jpc_enc_cblk_t *cblk, jpc_enc_cp_t *cp, jpc_enc_prc_t *prc) { 	jpc_enc_band_t *band; 	uint_fast32_t cblktlx; 	uint_fast32_t cblktly; 	uint_fast32_t cblkbrx; 	uint_fast32_t cblkbry; 	jpc_enc_rlvl_t *rlvl; 	uint_fast32_t cblkxind; 	uint_fast32_t cblkyind; 	uint_fast32_t cblkno; 	uint_fast32_t tlcblktlx; 	uint_fast32_t tlcblktly;  	cblkno = cblk - prc->cblks; 	cblkxind = cblkno % prc->numhcblks; 	cblkyind = cblkno / prc->numhcblks; 	rlvl = prc->band->rlvl; 	cblk->prc = prc;  	cblk->numpasses = 0; 	cblk->passes = 0; 	cblk->numencpasses = 0; 	cblk->numimsbs = 0; 	cblk->numlenbits = 0; 	cblk->stream = 0; 	cblk->mqenc = 0; 	cblk->flags = 0; 	cblk->numbps = 0; 	cblk->curpass = 0; 	cblk->data = 0; 	cblk->savedcurpass = 0; 	cblk->savednumlenbits = 0; 	cblk->savednumencpasses = 0;  	band = prc->band; 	tlcblktlx = JPC_FLOORTOMULTPOW2(prc->tlx, rlvl->cblkwidthexpn); 	tlcblktly = JPC_FLOORTOMULTPOW2(prc->tly, rlvl->cblkheightexpn); 	cblktlx = JAS_MAX(tlcblktlx + (cblkxind << rlvl->cblkwidthexpn), prc->tlx); 	cblktly = JAS_MAX(tlcblktly + (cblkyind << rlvl->cblkheightexpn), prc->tly); 	cblkbrx = JAS_MIN(tlcblktlx + ((cblkxind + 1) << rlvl->cblkwidthexpn), 	  prc->brx); 	cblkbry = JAS_MIN(tlcblktly + ((cblkyind + 1) << rlvl->cblkheightexpn), 	  prc->bry);  	assert(cblktlx < cblkbrx && cblktly < cblkbry); 	if (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) { 		goto error; 	} 	jas_seq2d_bindsub(cblk->data, band->data, cblktlx, cblktly, cblkbrx, cblkbry);  	return cblk;  error: 	cblk_destroy(cblk); 	return 0; }
static void rlvl_destroy(jpc_enc_rlvl_t *rlvl) { 	jpc_enc_band_t *band; 	uint_fast16_t bandno;  	if (rlvl->bands) { 		for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; 		  ++bandno, ++band) { 			band_destroy(band); 		} 		jas_free(rlvl->bands); 	} }
static jas_stream_t *jas_stream_create() { 	jas_stream_t *stream;  	if (!(stream = jas_malloc(sizeof(jas_stream_t)))) { 		return 0; 	} 	stream->openmode_ = 0; 	stream->bufmode_ = 0; 	stream->flags_ = 0; 	stream->bufbase_ = 0; 	stream->bufstart_ = 0; 	stream->bufsize_ = 0; 	stream->ptr_ = 0; 	stream->cnt_ = 0; 	stream->ops_ = 0; 	stream->obj_ = 0; 	stream->rwcnt_ = 0; 	stream->rwlimit_ = -1;  	return stream; }
static void pirlvl_destroy(jpc_pirlvl_t *rlvl) { 	if (rlvl->prclyrnos) { 		jas_free(rlvl->prclyrnos); 	} }
void calcrdslopes(jpc_enc_cblk_t *cblk) { 	jpc_enc_pass_t *endpasses; 	jpc_enc_pass_t *pass0; 	jpc_enc_pass_t *pass1; 	jpc_enc_pass_t *pass2; 	jpc_flt_t slope0; 	jpc_flt_t slope; 	jpc_flt_t dd; 	long dr;  	endpasses = &cblk->passes[cblk->numpasses]; 	pass2 = cblk->passes; 	slope0 = 0; 	while (pass2 != endpasses) { 		pass0 = 0; 		for (pass1 = cblk->passes; pass1 != endpasses; ++pass1) { 			dd = pass1->cumwmsedec; 			dr = pass1->end; 			if (pass0) { 				dd -= pass0->cumwmsedec; 				dr -= pass0->end; 			} 			if (dd <= 0) { 				pass1->rdslope = JPC_BADRDSLOPE; 				if (pass1 >= pass2) { 					pass2 = &pass1[1]; 				} 				continue; 			} 			if (pass1 < pass2 && pass1->rdslope <= 0) { 				continue; 			} 			if (!dr) { 				assert(pass0); 				pass0->rdslope = 0; 				break; 			} 			slope = dd / dr; 			if (pass0 && slope >= slope0) { 				pass0->rdslope = 0; 				break; 			} 			pass1->rdslope = slope; 			if (pass1 >= pass2) { 				pass2 = &pass1[1]; 			} 			pass0 = pass1; 			slope0 = slope; 		} 	}  #if 0 	for (pass0 = cblk->passes; pass0 != endpasses; ++pass0) { if (pass0->rdslope > 0.0) { 		jas_eprintf("pass %02d nmsedec=%lf dec=%lf end=%d %lf\n", pass0 - cblk->passes, 		  fixtodbl(pass0->nmsedec), pass0->wmsedec, pass0->end, pass0->rdslope); } 	} #endif }
static jpc_enc_prc_t *prc_create(jpc_enc_prc_t *prc, jpc_enc_cp_t *cp, jpc_enc_band_t *band) { 	uint_fast32_t prcno; 	uint_fast32_t prcxind; 	uint_fast32_t prcyind; 	uint_fast32_t cbgtlx; 	uint_fast32_t cbgtly; 	uint_fast32_t tlprctlx; 	uint_fast32_t tlprctly; 	uint_fast32_t tlcbgtlx; 	uint_fast32_t tlcbgtly; 	uint_fast16_t rlvlno; 	jpc_enc_rlvl_t *rlvl; 	uint_fast32_t tlcblktlx; 	uint_fast32_t tlcblktly; 	uint_fast32_t brcblkbrx; 	uint_fast32_t brcblkbry; 	uint_fast32_t cblkno; 	jpc_enc_cblk_t *cblk; 	jpc_enc_tcmpt_t *tcmpt;  	prc->cblks = 0; 	prc->incltree = 0; 	prc->savincltree = 0; 	prc->nlibtree = 0; 	prc->savnlibtree = 0;  	rlvl = band->rlvl; 	tcmpt = rlvl->tcmpt; rlvlno = rlvl - tcmpt->rlvls; 	prcno = prc - band->prcs; 	prcxind = prcno % rlvl->numhprcs; 	prcyind = prcno / rlvl->numhprcs; 	prc->band = band;  tlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn); tlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn); if (!rlvlno) { 	tlcbgtlx = tlprctlx; 	tlcbgtly = tlprctly; } else { 	tlcbgtlx = JPC_CEILDIVPOW2(tlprctlx, 1); 	tlcbgtly = JPC_CEILDIVPOW2(tlprctly, 1); }  	/* Compute the coordinates of the top-left and bottom-right 	  corners of the precinct. */ 	cbgtlx = tlcbgtlx + (prcxind << rlvl->cbgwidthexpn); 	cbgtly = tlcbgtly + (prcyind << rlvl->cbgheightexpn); 	prc->tlx = JAS_MAX(jas_seq2d_xstart(band->data), cbgtlx); 	prc->tly = JAS_MAX(jas_seq2d_ystart(band->data), cbgtly); 	prc->brx = JAS_MIN(jas_seq2d_xend(band->data), cbgtlx + 	  (1 << rlvl->cbgwidthexpn)); 	prc->bry = JAS_MIN(jas_seq2d_yend(band->data), cbgtly + 	  (1 << rlvl->cbgheightexpn));  	if (prc->tlx < prc->brx && prc->tly < prc->bry) { 		/* The precinct contains at least one code block. */  		tlcblktlx = JPC_FLOORTOMULTPOW2(prc->tlx, rlvl->cblkwidthexpn); 		tlcblktly = JPC_FLOORTOMULTPOW2(prc->tly, rlvl->cblkheightexpn); 		brcblkbrx = JPC_CEILTOMULTPOW2(prc->brx, rlvl->cblkwidthexpn); 		brcblkbry = JPC_CEILTOMULTPOW2(prc->bry, rlvl->cblkheightexpn); 		prc->numhcblks = JPC_FLOORDIVPOW2(brcblkbrx - tlcblktlx, 		  rlvl->cblkwidthexpn); 		prc->numvcblks = JPC_FLOORDIVPOW2(brcblkbry - tlcblktly, 		  rlvl->cblkheightexpn); 		prc->numcblks = prc->numhcblks * prc->numvcblks;  		if (!(prc->incltree = jpc_tagtree_create(prc->numhcblks, 		  prc->numvcblks))) { 			goto error; 		} 		if (!(prc->nlibtree = jpc_tagtree_create(prc->numhcblks, 		  prc->numvcblks))) { 			goto error; 		} 		if (!(prc->savincltree = jpc_tagtree_create(prc->numhcblks, 		  prc->numvcblks))) { 			goto error; 		} 		if (!(prc->savnlibtree = jpc_tagtree_create(prc->numhcblks, 		  prc->numvcblks))) { 			goto error; 		}  		if (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_enc_cblk_t)))) { 			goto error; 		} 		for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks; 		  ++cblkno, ++cblk) { 			cblk->passes = 0; 			cblk->stream = 0; 			cblk->mqenc = 0; 			cblk->data = 0; 			cblk->flags = 0; 			cblk->prc = prc; 		} 		for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks; 		  ++cblkno, ++cblk) { 			if (!cblk_create(cblk, cp, prc)) { 				goto error; 			} 		} 	} else { 		/* The precinct does not contain any code blocks. */ 		prc->tlx = prc->brx; 		prc->tly = prc->bry; 		prc->numcblks = 0; 		prc->numhcblks = 0; 		prc->numvcblks = 0; 		prc->cblks = 0; 		prc->incltree = 0; 		prc->nlibtree = 0; 		prc->savincltree = 0; 		prc->savnlibtree = 0; 	}  	return prc;  error: 	prc_destroy(prc); 	return 0; }
static void jas_cmpxform_destroy(jas_cmpxform_t *pxform) { 	if (--pxform->refcnt <= 0) { 		(*pxform->ops->destroy)(pxform); 		jas_free(pxform); 	} }
jas_iccattrval_t *jas_iccprof_getattr(jas_iccprof_t *prof,   jas_iccattrname_t name) { 	int i; 	jas_iccattrval_t *attrval; 	if ((i = jas_iccattrtab_lookup(prof->attrtab, name)) < 0) 		goto error; 	if (!(attrval = jas_iccattrval_clone(prof->attrtab->attrs[i].val))) 		goto error; 	return attrval; error: 	return 0; }
int jpc_getmagctxno(int f) { 	int n;  	if (!(f & JPC_REFINE)) { 		n = (f & (JPC_OTHSIGMSK)) ? 1 : 0; 	} else { 		n = 2; 	}  	assert(n < JPC_NUMMAGCTXS); 	return JPC_MAGCTXNO + n; }
int jas_stream_fillbuf(jas_stream_t *stream, int getflag) { 	int c;  	/* The stream must not be in an error or EOF state. */ 	if ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) { 		return EOF; 	}  	/* The stream must be open for reading. */ 	if ((stream->openmode_ & JAS_STREAM_READ) == 0) { 		return EOF; 	}  	/* Make a half-hearted attempt to confirm that the buffer is not 	currently being used for writing.  This check is not intended 	to be foolproof! */ 	assert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);  	assert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);  	/* Mark the buffer as being used for reading. */ 	stream->bufmode_ |= JAS_STREAM_RDBUF;  	/* Read new data into the buffer. */ 	stream->ptr_ = stream->bufstart_; 	if ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_, 	  (char *) stream->bufstart_, stream->bufsize_)) <= 0) { 		if (stream->cnt_ < 0) { 			stream->flags_ |= JAS_STREAM_ERR; 		} else { 			stream->flags_ |= JAS_STREAM_EOF; 		} 		stream->cnt_ = 0; 		return EOF; 	}  	assert(stream->cnt_ > 0); 	/* Get or peek at the first character in the buffer. */ 	c = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);  	return c; }
void jpc_cstate_destroy(jpc_cstate_t *cstate) { 	jas_free(cstate); }
void jpc_mqenc_destroy(jpc_mqenc_t *mqenc) { 	if (mqenc->ctxs) { 		jas_free(mqenc->ctxs); 	} 	jas_free(mqenc); }
void jas_image_destroy(jas_image_t *image) { 	int i;  	if (image->cmpts_) { 		for (i = 0; i < image->numcmpts_; ++i) { 			jas_image_cmpt_destroy(image->cmpts_[i]); 			image->cmpts_[i] = 0; 		} 		jas_free(image->cmpts_); 	} 	if (image->cmprof_) 		jas_cmprof_destroy(image->cmprof_); 	jas_free(image); }
void cmdopts_destroy(cmdopts_t *cmdopts) { 	free(cmdopts); }
void jpc_initctxs(jpc_mqctx_t *ctxs) { 	jpc_mqctx_t *ctx; 	int i;  	ctx = ctxs; 	for (i = 0; i < JPC_NUMCTXS; ++i) { 		ctx->mps = 0; 		switch (i) { 		case JPC_UCTXNO: 			ctx->ind = 46; 			break; 		case JPC_ZCCTXNO: 			ctx->ind = 4; 			break; 		case JPC_AGGCTXNO: 			ctx->ind = 3; 			break; 		default: 			ctx->ind = 0; 			break; 		} 		++ctx; 	} }
jpc_ms_t *jpc_ms_create(int type) { 	jpc_ms_t *ms; 	jpc_mstabent_t *mstabent;  	if (!(ms = jas_malloc(sizeof(jpc_ms_t)))) { 		return 0; 	} 	ms->id = type; 	ms->len = 0; 	mstabent = jpc_mstab_lookup(ms->id); 	ms->ops = &mstabent->ops; 	memset(&ms->parms, 0, sizeof(jpc_msparms_t)); 	return ms; }
static int pnm_getdata(jas_stream_t *in, pnm_hdr_t *hdr, jas_image_t *image) { 	int ret; #if 0 	int numcmpts; #endif 	int cmptno; 	int fmt; 	jas_matrix_t *data[3]; 	int x; 	int y; 	int_fast64_t v; 	int depth; 	int type; 	int c; 	int n;  	ret = -1;  #if 0 	numcmpts = jas_image_numcmpts(image); #endif 	fmt = pnm_fmt(hdr->magic); 	type = pnm_type(hdr->magic); 	depth = pnm_maxvaltodepth(hdr->maxval);  	data[0] = 0; 	data[1] = 0; 	data[2] = 0; 	for (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) { 		if (!(data[cmptno] = jas_matrix_create(1, hdr->width))) { 			goto done; 		} 	}  	for (y = 0; y < hdr->height; ++y) { 		if (type == PNM_TYPE_PBM) { 			if (fmt == PNM_FMT_BIN) { 				for (x = 0; x < hdr->width;) { 					if ((c = jas_stream_getc(in)) == EOF) { 						goto done; 					} 					n = 8; 					while (n > 0 && x < hdr->width) { 						jas_matrix_set(data[0], 0, x, 1 - ((c >> 7) & 1)); 						c <<= 1; 						--n; 						++x; 					} 				} 			} else { 				for (x = 0; x < hdr->width; ++x) { 					int uv; 					if (pnm_getbitstr(in, &uv)) { 						goto done; 					} 					jas_matrix_set(data[0], 0, x, 1 - uv); 				} 			} 		} else { 			for (x = 0; x < hdr->width; ++x) { 				for (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) { 					if (fmt == PNM_FMT_BIN) { 						/* The sample data is in binary format. */ 						if (hdr->sgnd) { 							/* The sample data is signed. */ 							int_fast32_t sv; 							if (pnm_getsint(in, depth, &sv)) { 								if (!pnm_allowtrunc) { 									goto done; 								} 								sv = 0; 							} 							v = sv; 						} else { 							/* The sample data is unsigned. */ 							uint_fast32_t uv; 							if (pnm_getuint(in, depth, &uv)) { 								if (!pnm_allowtrunc) { 									goto done; 								} 								uv = 0; 							} 							v = uv; 						} 					} else { 						/* The sample data is in text format. */ 						if (hdr->sgnd) { 							/* The sample data is signed. */ 							int_fast32_t sv; 							if (pnm_getsintstr(in, &sv)) { 								if (!pnm_allowtrunc) { 									goto done; 								} 								sv = 0; 							} 							v = sv; 						} else { 							/* The sample data is unsigned. */ 							uint_fast32_t uv; 							if (pnm_getuintstr(in, &uv)) { 								if (!pnm_allowtrunc) { 									goto done; 								} 								uv = 0; 							} 							v = uv; 						} 					} 					jas_matrix_set(data[cmptno], 0, x, v); 				} 			} 		} 		for (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) { 			if (jas_image_writecmpt(image, cmptno, 0, y, hdr->width, 1, 			  data[cmptno])) { 				goto done; 			} 		} 	}  	ret = 0;  done:  	for (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) { 		if (data[cmptno]) { 			jas_matrix_destroy(data[cmptno]); 		} 	}  	return ret; }
int jp2_box_put(jp2_box_t *box, jas_stream_t *out) { 	jas_stream_t *tmpstream; 	bool extlen; 	bool dataflag;  	tmpstream = 0;  	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));  	if (dataflag) { 		tmpstream = jas_stream_memopen(0, 0); 		if (box->ops->putdata) { 			if ((*box->ops->putdata)(box, tmpstream)) { 				goto error; 			} 		} 		box->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false); 		jas_stream_rewind(tmpstream); 	} 	extlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0; 	if (jp2_putuint32(out, extlen ? 1 : box->len)) { 		goto error; 	} 	if (jp2_putuint32(out, box->type)) { 		goto error; 	} 	if (extlen) { 		if (jp2_putuint64(out, box->len)) { 			goto error; 		} 	}  	if (dataflag) { 		if (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) { 			goto error; 		} 		jas_stream_close(tmpstream); 	}  	return 0; 	abort();  error:  	if (tmpstream) { 		jas_stream_close(tmpstream); 	} 	return -1; }
int jpc_putdata(jas_stream_t *out, jas_stream_t *in, long len) { 	return jas_stream_copy(out, in, len); }
static jpc_enc_band_t *band_create(jpc_enc_band_t *band, jpc_enc_cp_t *cp,   jpc_enc_rlvl_t *rlvl, jpc_tsfb_band_t *bandinfos) { 	uint_fast16_t bandno; 	uint_fast16_t gblbandno; 	uint_fast16_t rlvlno; 	jpc_tsfb_band_t *bandinfo; 	jpc_enc_tcmpt_t *tcmpt; 	uint_fast32_t prcno; 	jpc_enc_prc_t *prc;  	tcmpt = rlvl->tcmpt; 	band->data = 0; 	band->prcs = 0; 	band->rlvl = rlvl;  	/* Deduce the resolution level and band number. */ 	rlvlno = rlvl - rlvl->tcmpt->rlvls; 	bandno = band - rlvl->bands; 	gblbandno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) + bandno + 1);  	bandinfo = &bandinfos[gblbandno];  if (bandinfo->xstart != bandinfo->xend && bandinfo->ystart != bandinfo->yend) { 	if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) { 		goto error; 	} 	jas_seq2d_bindsub(band->data, tcmpt->data, bandinfo->locxstart, 	  bandinfo->locystart, bandinfo->locxend, bandinfo->locyend); 	jas_seq2d_setshift(band->data, bandinfo->xstart, bandinfo->ystart); } 	band->orient = bandinfo->orient; 	band->analgain = JPC_NOMINALGAIN(cp->tccp.qmfbid, tcmpt->numrlvls, rlvlno, 	  band->orient); 	band->numbps = 0; 	band->absstepsize = 0; 	band->stepsize = 0; 	band->synweight = bandinfo->synenergywt;  if (band->data) { 	if (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_enc_prc_t)))) { 		goto error; 	} 	for (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno, 	  ++prc) { 		prc->cblks = 0; 		prc->incltree = 0; 		prc->nlibtree = 0; 		prc->savincltree = 0; 		prc->savnlibtree = 0; 		prc->band = band; 	} 	for (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno, 	  ++prc) { 		if (!prc_create(prc, cp, band)) { 			goto error; 		} 	} }  	return band;  error: 	band_destroy(band); 	return 0; }
jas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id) { 	int i; 	jas_image_fmtinfo_t *fmtinfo;  	for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) { 		if (fmtinfo->id == id) { 			return fmtinfo; 		} 	} 	return 0; }
void jpc_tsfb_destroy(jpc_tsfb_t *tsfb) { 	free(tsfb); }
static jpc_bitstream_t *jpc_bitstream_alloc() { 	jpc_bitstream_t *bitstream;  	/* Allocate memory for the new bit stream object. */ 	if (!(bitstream = jas_malloc(sizeof(jpc_bitstream_t)))) { 		return 0; 	} 	/* Initialize all of the data members. */ 	bitstream->stream_ = 0; 	bitstream->cnt_ = 0; 	bitstream->flags_ = 0; 	bitstream->openmode_ = 0;  	return bitstream; }
int jas_setdbglevel(int dbglevel) { 	int olddbglevel;  	/* Save the old debug level. */ 	olddbglevel = jas_dbglevel;  	/* Change the debug level. */ 	jas_dbglevel = dbglevel;  	/* Return the old debug level. */ 	return olddbglevel; }
int jpc_tagtree_encode(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf,   int threshold, jpc_bitstream_t *out) { 	jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1]; 	jpc_tagtreenode_t **stkptr; 	jpc_tagtreenode_t *node; 	int low;  	/* Avoid compiler warnings about unused parameters. */ 	tree = 0;  	assert(leaf); 	assert(threshold >= 0);  	/* Traverse to the root of the tree, recording the path taken. */ 	stkptr = stk; 	node = leaf; 	while (node->parent_) { 		*stkptr++ = node; 		node = node->parent_; 	}  	low = 0; 	for (;;) { 		if (low > node->low_) { 			/* Deferred propagation of the lower bound downward in 			  the tree. */ 			node->low_ = low; 		} else { 			low = node->low_; 		}  		while (low < threshold) { 			if (low >= node->value_) { 				if (!node->known_) { 					if (jpc_bitstream_putbit(out, 1) == EOF) { 						return -1; 					} 					node->known_ = 1; 				} 				break; 			} 			if (jpc_bitstream_putbit(out, 0) == EOF) { 				return -1; 			} 			++low; 		} 		node->low_ = low; 		if (stkptr == stk) { 			break; 		} 		node = *--stkptr;  	} 	return (leaf->low_ < threshold) ? 1 : 0;  }
static jas_cmpxform_t *jas_cmpxform_create0() { 	jas_cmpxform_t *pxform; 	if (!(pxform = jas_malloc(sizeof(jas_cmpxform_t)))) 		return 0; 	memset(pxform, 0, sizeof(jas_cmpxform_t)); 	pxform->refcnt = 0; 	pxform->ops = 0; 	return pxform; }
static int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out) { 	jpc_sot_t *sot = &ms->parms.sot;  	/* Eliminate compiler warning about unused variables. */ 	cstate = 0;  	if (jpc_putuint16(out, sot->tileno) || 	  jpc_putuint32(out, sot->len) || 	  jpc_putuint8(out, sot->partno) || 	  jpc_putuint8(out, sot->numparts)) { 		return -1; 	} 	return 0; }
cmdopts_t *cmdopts_parse(int argc, char **argv) {  	typedef enum { 		CMDOPT_HELP = 0, 		CMDOPT_VERBOSE, 		CMDOPT_INFILE, 		CMDOPT_INFMT, 		CMDOPT_INOPT, 		CMDOPT_OUTFILE, 		CMDOPT_OUTFMT, 		CMDOPT_OUTOPT, 		CMDOPT_VERSION, 		CMDOPT_DEBUG, 		CMDOPT_CMPTNO, 		CMDOPT_SRGB 	} cmdoptid_t;  	static jas_opt_t cmdoptions[] = { 		{CMDOPT_HELP, "help", 0}, 		{CMDOPT_VERBOSE, "verbose", 0}, 		{CMDOPT_INFILE, "input", JAS_OPT_HASARG}, 		{CMDOPT_INFILE, "f", JAS_OPT_HASARG}, 		{CMDOPT_INFMT, "input-format", JAS_OPT_HASARG}, 		{CMDOPT_INFMT, "t", JAS_OPT_HASARG}, 		{CMDOPT_INOPT, "input-option", JAS_OPT_HASARG}, 		{CMDOPT_INOPT, "o", JAS_OPT_HASARG}, 		{CMDOPT_OUTFILE, "output", JAS_OPT_HASARG}, 		{CMDOPT_OUTFILE, "F", JAS_OPT_HASARG}, 		{CMDOPT_OUTFMT, "output-format", JAS_OPT_HASARG}, 		{CMDOPT_OUTFMT, "T", JAS_OPT_HASARG}, 		{CMDOPT_OUTOPT, "output-option", JAS_OPT_HASARG}, 		{CMDOPT_OUTOPT, "O", JAS_OPT_HASARG}, 		{CMDOPT_VERSION, "version", 0}, 		{CMDOPT_DEBUG, "debug-level", JAS_OPT_HASARG}, 		{CMDOPT_CMPTNO, "cmptno", JAS_OPT_HASARG}, 		{CMDOPT_SRGB, "force-srgb", 0}, 		{CMDOPT_SRGB, "S", 0}, 		{-1, 0, 0} 	};  	cmdopts_t *cmdopts; 	int c;  	if (!(cmdopts = malloc(sizeof(cmdopts_t)))) { 		fprintf(stderr, "error: insufficient memory\n"); 		exit(EXIT_FAILURE); 	}  	cmdopts->infile = 0; 	cmdopts->infmt = -1; 	cmdopts->inopts = 0; 	cmdopts->inoptsbuf[0] = '\0'; 	cmdopts->outfile = 0; 	cmdopts->outfmt = -1; 	cmdopts->outopts = 0; 	cmdopts->outoptsbuf[0] = '\0'; 	cmdopts->verbose = 0; 	cmdopts->version = 0; 	cmdopts->cmptno = -1; 	cmdopts->debug = 0; 	cmdopts->srgb = 0;  	while ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) { 		switch (c) { 		case CMDOPT_HELP: 			cmdusage(); 			break; 		case CMDOPT_VERBOSE: 			cmdopts->verbose = 1; 			break; 		case CMDOPT_VERSION: 			cmdopts->version = 1; 			break; 		case CMDOPT_DEBUG: 			cmdopts->debug = atoi(jas_optarg); 			break; 		case CMDOPT_INFILE: 			cmdopts->infile = jas_optarg; 			break; 		case CMDOPT_INFMT: 			if ((cmdopts->infmt = jas_image_strtofmt(jas_optarg)) < 0) { 				fprintf(stderr, "warning: ignoring invalid input format %s\n", 				  jas_optarg); 				cmdopts->infmt = -1; 			} 			break; 		case CMDOPT_INOPT: 			addopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg); 			cmdopts->inopts = cmdopts->inoptsbuf; 			break; 		case CMDOPT_OUTFILE: 			cmdopts->outfile = jas_optarg; 			break; 		case CMDOPT_OUTFMT: 			if ((cmdopts->outfmt = jas_image_strtofmt(jas_optarg)) < 0) { 				fprintf(stderr, "error: invalid output format %s\n", jas_optarg); 				badusage(); 			} 			break; 		case CMDOPT_OUTOPT: 			addopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg); 			cmdopts->outopts = cmdopts->outoptsbuf; 			break; 		case CMDOPT_CMPTNO: 			cmdopts->cmptno = atoi(jas_optarg); 			break; 		case CMDOPT_SRGB: 			cmdopts->srgb = 1; 			break; 		default: 			badusage(); 			break; 		} 	}  	while (jas_optind < argc) { 		fprintf(stderr, 		  "warning: ignoring bogus command line argument %s\n", 		  argv[jas_optind]); 		++jas_optind; 	}  	if (cmdopts->version) { 		goto done; 	}  	if (cmdopts->outfmt < 0 && cmdopts->outfile) { 		if ((cmdopts->outfmt = jas_image_fmtfromname(cmdopts->outfile)) < 0) { 			fprintf(stderr, 			  "error: cannot guess image format from output file name\n"); 		} 	}  	if (cmdopts->outfmt < 0) { 		fprintf(stderr, "error: no output format specified\n"); 		badusage(); 	}  done: 	return cmdopts; }
int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt) { 	int n; 	const char *bufptr;  	bufptr = buf;  	n = 0; 	while (n < cnt) { 		if (jas_stream_putc(stream, *bufptr) == EOF) { 			return n; 		} 		++bufptr; 		++n; 	}  	return n; }
int jpc_getzcctxno(int f, int orient) { 	int h; 	int v; 	int d; 	int n; 	int t; 	int hv;  	/* Avoid compiler warning. */ 	n = 0;  	h = ((f & JPC_WSIG) != 0) + ((f & JPC_ESIG) != 0); 	v = ((f & JPC_NSIG) != 0) + ((f & JPC_SSIG) != 0); 	d = ((f & JPC_NWSIG) != 0) + ((f & JPC_NESIG) != 0) + ((f & JPC_SESIG) != 0) + ((f & JPC_SWSIG) != 0); 	switch (orient) { 	case JPC_TSFB_HL: 		t = h; 		h = v; 		v = t; 	case JPC_TSFB_LL: 	case JPC_TSFB_LH: 		if (!h) { 			if (!v) { 				if (!d) { 					n = 0; 				} else if (d == 1) { 					n = 1; 				} else { 					n = 2; 				} 			} else if (v == 1) { 				n = 3; 			} else { 				n = 4; 			} 		} else if (h == 1) { 			if (!v) { 				if (!d) { 					n = 5; 				} else { 					n = 6; 				} 			} else { 				n = 7; 			} 		} else { 			n = 8; 		} 		break; 	case JPC_TSFB_HH: 		hv = h + v; 		if (!d) { 			if (!hv) { 				n = 0; 			} else if (hv == 1) { 				n = 1; 			} else { 				n = 2; 			} 		} else if (d == 1) { 			if (!hv) { 				n = 3; 			} else if (hv == 1) { 				n = 4; 			} else { 				n = 5; 			} 		} else if (d == 2) { 			if (!hv) { 				n = 6; 			} else { 				n = 7; 			} 		} else { 			n = 8; 		} 		break; 	} 	assert(n < JPC_NUMZCCTXS); 	return JPC_ZCCTXNO + n; }
jas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr) { 	jas_image_fmtinfo_t *fmtinfo; 	jas_image_t *image;  	image = 0;  	/* If possible, try to determine the format of the input data. */ 	if (fmt < 0) { 		if ((fmt = jas_image_getfmt(in)) < 0) 			goto error; 	}  	/* Is it possible to decode an image represented in this format? */ 	if (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) 		goto error; 	if (!fmtinfo->ops.decode) 		goto error;  	/* Decode the image. */ 	if (!(image = (*fmtinfo->ops.decode)(in, optstr))) 		goto error;  	/* Create a color profile if needed. */ 	if (!jas_clrspc_isunknown(image->clrspc_) && 	  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) { 		if (!(image->cmprof_ = 		  jas_cmprof_createfromclrspc(jas_image_clrspc(image)))) 			goto error; 	}  	return image; error: 	if (image) 		jas_image_destroy(image); 	return 0; }
jpc_tsfb_t *jpc_cod_gettsfb(int qmfbid, int numlvls) { 	jpc_tsfb_t *tsfb;  	if (!(tsfb = malloc(sizeof(jpc_tsfb_t)))) 		return 0;  	if (numlvls > 0) { 		switch (qmfbid) { 		case JPC_COX_INS: 			tsfb->qmfb = &jpc_ns_qmfb2d; 			break; 		default: 		case JPC_COX_RFT: 			tsfb->qmfb = &jpc_ft_qmfb2d; 			break; 		} 	} else { 		tsfb->qmfb = 0; 	} 	tsfb->numlvls = numlvls; 	return tsfb; }
jp2_box_t *jp2_box_create(int type) { 	jp2_box_t *box; 	jp2_boxinfo_t *boxinfo;  	if (!(box = jas_malloc(sizeof(jp2_box_t)))) { 		return 0; 	} 	memset(box, 0, sizeof(jp2_box_t)); 	box->type = type; 	box->len = 0; 	if (!(boxinfo = jp2_boxinfolookup(type))) { 		return 0; 	} 	box->info = boxinfo; 	box->ops = &boxinfo->ops; 	return box; }
void jpc_qmfb_split_row(jpc_fix_t *a, int numcols, int parity) {  	int bufsize = JPC_CEILDIVPOW2(numcols, 1); #if !defined(HAVE_VLA) 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE]; #else 	jpc_fix_t splitbuf[bufsize]; #endif 	jpc_fix_t *buf = splitbuf; 	register jpc_fix_t *srcptr; 	register jpc_fix_t *dstptr; 	register int n; 	register int m; 	int hstartcol;  #if !defined(HAVE_VLA) 	/* Get a buffer. */ 	if (bufsize > QMFB_SPLITBUFSIZE) { 		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) { 			/* We have no choice but to commit suicide in this case. */ 			abort(); 		} 	} #endif  	if (numcols >= 2) { 		hstartcol = (numcols + 1 - parity) >> 1; 		m = (parity) ? hstartcol : (numcols - hstartcol); 		/* Save the samples destined for the highpass channel. */ 		n = m; 		dstptr = buf; 		srcptr = &a[1 - parity]; 		while (n-- > 0) { 			*dstptr = *srcptr; 			++dstptr; 			srcptr += 2; 		} 		/* Copy the appropriate samples into the lowpass channel. */ 		dstptr = &a[1 - parity]; 		srcptr = &a[2 - parity]; 		n = numcols - m - (!parity); 		while (n-- > 0) { 			*dstptr = *srcptr; 			++dstptr; 			srcptr += 2; 		} 		/* Copy the saved samples into the highpass channel. */ 		dstptr = &a[hstartcol]; 		srcptr = buf; 		n = m; 		while (n-- > 0) { 			*dstptr = *srcptr; 			++dstptr; 			++srcptr; 		} 	}  #if !defined(HAVE_VLA) 	/* If the split buffer was allocated on the heap, free this memory. */ 	if (buf != splitbuf) { 		jas_free(buf); 	} #endif  }
static void jas_icctxtdesc_destroy(jas_iccattrval_t *attrval) { 	jas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc; 	if (txtdesc->ascdata) 		jas_free(txtdesc->ascdata); 	if (txtdesc->ucdata) 		jas_free(txtdesc->ucdata); }
int pnm_maxvaltodepth(uint_fast32_t maxval) { 	int n;  	n = 0; 	while (maxval > 0) { 		maxval >>= 1; 		++n; 	} 	return n; }
static void band_destroy(jpc_enc_band_t *band) { 	jpc_enc_prc_t *prc; 	jpc_enc_rlvl_t *rlvl; 	uint_fast32_t prcno;  	if (band->prcs) { 		rlvl = band->rlvl; 		for (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; 		  ++prcno, ++prc) { 			prc_destroy(prc); 		} 		jas_free(band->prcs); 	} 	if (band->data) { 		jas_seq2d_destroy(band->data); 	} }
static jas_opt_t *jas_optlookup(jas_opt_t *opts, char *name) { 	jas_opt_t *opt;  	for (opt = opts; opt->id >= 0 && opt->name; ++opt) { 		if (!strcmp(opt->name, name)) { 			return opt; 		} 	} 	return 0; }
static int jas_cmpxformseq_delete(jas_cmpxformseq_t *pxformseq, int i) { 	assert(i >= 0 && i < pxformseq->numpxforms); 	if (i != pxformseq->numpxforms - 1) 		abort(); 	jas_cmpxform_destroy(pxformseq->pxforms[i]); 	pxformseq->pxforms[i] = 0; 	--pxformseq->numpxforms; 	return 0; }
void jas_tvparser_destroy(jas_tvparser_t *tvp) { 	if (tvp->buf) { 		jas_free(tvp->buf); 	} 	jas_free(tvp); }
static jas_iccattrtab_t *jas_iccattrtab_create() { 	jas_iccattrtab_t *tab; 	tab = 0; 	if (!(tab = jas_malloc(sizeof(jas_iccattrtab_t)))) 		goto error; 	tab->maxattrs = 0; 	tab->numattrs = 0; 	tab->attrs = 0; 	if (jas_iccattrtab_resize(tab, 32)) 		goto error; 	return tab; error: 	if (tab) 		jas_iccattrtab_destroy(tab); 	return 0; }
void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,   int stride, int parity) {  	int bufsize = JPC_CEILDIVPOW2(numrows, 1); #if !defined(HAVE_VLA) 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE]; #else 	jpc_fix_t splitbuf[bufsize * numcols]; #endif 	jpc_fix_t *buf = splitbuf; 	jpc_fix_t *srcptr; 	jpc_fix_t *dstptr; 	register jpc_fix_t *srcptr2; 	register jpc_fix_t *dstptr2; 	register int n; 	register int i; 	int m; 	int hstartcol;  #if !defined(HAVE_VLA) 	/* Get a buffer. */ 	if (bufsize > QMFB_SPLITBUFSIZE) { 		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) { 			/* We have no choice but to commit suicide in this case. */ 			abort(); 		} 	} #endif  	if (numrows >= 2) { 		hstartcol = (numrows + 1 - parity) >> 1; 		m = (parity) ? hstartcol : (numrows - hstartcol); 		/* Save the samples destined for the highpass channel. */ 		n = m; 		dstptr = buf; 		srcptr = &a[(1 - parity) * stride]; 		while (n-- > 0) { 			dstptr2 = dstptr; 			srcptr2 = srcptr; 			for (i = 0; i < numcols; ++i) { 				*dstptr2 = *srcptr2; 				++dstptr2; 				++srcptr2; 			} 			dstptr += numcols; 			srcptr += stride << 1; 		} 		/* Copy the appropriate samples into the lowpass channel. */ 		dstptr = &a[(1 - parity) * stride]; 		srcptr = &a[(2 - parity) * stride]; 		n = numrows - m - (!parity); 		while (n-- > 0) { 			dstptr2 = dstptr; 			srcptr2 = srcptr; 			for (i = 0; i < numcols; ++i) { 				*dstptr2 = *srcptr2; 				++dstptr2; 				++srcptr2; 			} 			dstptr += stride; 			srcptr += stride << 1; 		} 		/* Copy the saved samples into the highpass channel. */ 		dstptr = &a[hstartcol * stride]; 		srcptr = buf; 		n = m; 		while (n-- > 0) { 			dstptr2 = dstptr; 			srcptr2 = srcptr; 			for (i = 0; i < numcols; ++i) { 				*dstptr2 = *srcptr2; 				++dstptr2; 				++srcptr2; 			} 			dstptr += stride; 			srcptr += numcols; 		} 	}  #if !defined(HAVE_VLA) 	/* If the split buffer was allocated on the heap, free this memory. */ 	if (buf != splitbuf) { 		jas_free(buf); 	} #endif  }
int jas_stream_close(jas_stream_t *stream) { 	/* Flush buffer if necessary. */ 	jas_stream_flush(stream);  	/* Close the underlying stream object. */ 	(*stream->ops_->close_)(stream->obj_);  	jas_stream_destroy(stream);  	return 0; }
void jpc_ms_destroy(jpc_ms_t *ms) { 	if (ms->ops && ms->ops->destroyparms) { 		(*ms->ops->destroyparms)(ms); 	} 	jas_free(ms); }
static void jas_image_setbbox(jas_image_t *image) { 	jas_image_cmpt_t *cmpt; 	int cmptno; 	int_fast32_t x; 	int_fast32_t y;  	if (image->numcmpts_ > 0) { 		/* Determine the bounding box for all of the components on the 		  reference grid (i.e., the image area) */ 		cmpt = image->cmpts_[0]; 		image->tlx_ = cmpt->tlx_; 		image->tly_ = cmpt->tly_; 		image->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1; 		image->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1; 		for (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) { 			cmpt = image->cmpts_[cmptno]; 			if (image->tlx_ > cmpt->tlx_) { 				image->tlx_ = cmpt->tlx_; 			} 			if (image->tly_ > cmpt->tly_) { 				image->tly_ = cmpt->tly_; 			} 			x = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1; 			if (image->brx_ < x) { 				image->brx_ = x; 			} 			y = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1; 			if (image->bry_ < y) { 				image->bry_ = y; 			} 		} 	} else { 		image->tlx_ = 0; 		image->tly_ = 0; 		image->brx_ = 0; 		image->bry_ = 0; 	} }
void jpc_mqenc_init(jpc_mqenc_t *mqenc) { 	mqenc->areg = 0x8000; 	mqenc->outbuf = -1; 	mqenc->creg = 0; 	mqenc->ctreg = 12; 	mqenc->lastbyte = -1; 	mqenc->err = 0; }
static void prc_destroy(jpc_enc_prc_t *prc) { 	jpc_enc_cblk_t *cblk; 	uint_fast32_t cblkno;  	if (prc->cblks) { 		for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks; 		  ++cblkno, ++cblk) { 			cblk_destroy(cblk); 		} 		jas_free(prc->cblks); 	} 	if (prc->incltree) { 		jpc_tagtree_destroy(prc->incltree); 	} 	if (prc->nlibtree) { 		jpc_tagtree_destroy(prc->nlibtree); 	} 	if (prc->savincltree) { 		jpc_tagtree_destroy(prc->savincltree); 	} 	if (prc->savnlibtree) { 		jpc_tagtree_destroy(prc->savnlibtree); 	} }
int jas_iccprof_setattr(jas_iccprof_t *prof, jas_iccattrname_t name,   jas_iccattrval_t *val) { 	int i; 	if ((i = jas_iccattrtab_lookup(prof->attrtab, name)) >= 0) { 		if (val) { 			if (jas_iccattrtab_replace(prof->attrtab, i, name, val)) 				goto error; 		} else { 			jas_iccattrtab_delete(prof->attrtab, i); 		} 	} else { 		if (val) { 			if (jas_iccattrtab_add(prof->attrtab, -1, name, val)) 				goto error; 		} else { 			/* NOP */ 		} 	} 	return 0; error: 	return -1; }
jas_image_t *jas_image_create0() { 	jas_image_t *image;  	if (!(image = jas_malloc(sizeof(jas_image_t)))) { 		return 0; 	}  	image->tlx_ = 0; 	image->tly_ = 0; 	image->brx_ = 0; 	image->bry_ = 0; 	image->clrspc_ = JAS_CLRSPC_UNKNOWN; 	image->numcmpts_ = 0; 	image->maxcmpts_ = 0; 	image->cmpts_ = 0; 	image->inmem_ = true; 	image->cmprof_ = 0;  	return image; }
jas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name) { 	int i; 	jas_image_fmtinfo_t *fmtinfo;  	for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) { 		if (!strcmp(fmtinfo->name, name)) { 			return fmtinfo; 		} 	} 	return 0; }
void jpc_enc_tile_destroy(jpc_enc_tile_t *tile) { 	jpc_enc_tcmpt_t *tcmpt; 	uint_fast16_t cmptno;  	if (tile->tcmpts) { 		for (cmptno = 0, tcmpt = tile->tcmpts; cmptno < 		  tile->numtcmpts; ++cmptno, ++tcmpt) { 			tcmpt_destroy(tcmpt); 		} 		jas_free(tile->tcmpts); 	} 	if (tile->lyrsizes) { 		jas_free(tile->lyrsizes); 	} 	if (tile->pi) { 		jpc_pi_destroy(tile->pi); 	} 	jas_free(tile); }
void jpc_tagtree_reset(jpc_tagtree_t *tree) { 	int n; 	jpc_tagtreenode_t *node;  	n = tree->numnodes_; 	node = tree->nodes_;  	while (--n >= 0) { 		node->value_ = INT_MAX; 		node->low_ = 0; 		node->known_ = 0; 		++node; 	} }
static int clrspctojp2(jas_clrspc_t clrspc) { 	switch (clrspc) { 	case JAS_CLRSPC_SRGB: 		return JP2_COLR_SRGB; 	case JAS_CLRSPC_SYCBCR: 		return JP2_COLR_SYCC; 	case JAS_CLRSPC_SGRAY: 		return JP2_COLR_SGRAY; 	default: 		abort(); 		break; 	} }
static jpc_mstabent_t *jpc_mstab_lookup(int id) { 	jpc_mstabent_t *mstabent; 	for (mstabent = jpc_mstab;; ++mstabent) { 		if (mstabent->id == id || mstabent->id < 0) { 			return mstabent; 		} 	} 	assert(0); 	return 0; }
static int jpc_putcommacode(jpc_bitstream_t *out, int n) { 	assert(n >= 0);  	while (--n >= 0) { 		if (jpc_bitstream_putbit(out, 1) == EOF) { 			return -1; 		} 	} 	if (jpc_bitstream_putbit(out, 0) == EOF) { 		return -1; 	} 	return 0; }
jas_matrix_t *jas_matrix_create(int numrows, int numcols) { 	jas_matrix_t *matrix; 	int i;  	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) { 		return 0; 	} 	matrix->flags_ = 0; 	matrix->numrows_ = numrows; 	matrix->numcols_ = numcols; 	matrix->rows_ = 0; 	matrix->maxrows_ = numrows; 	matrix->data_ = 0; 	matrix->datasize_ = numrows * numcols;  	if (matrix->maxrows_ > 0) { 		if (!(matrix->rows_ = jas_malloc(matrix->maxrows_ * 		  sizeof(jas_seqent_t *)))) { 			jas_matrix_destroy(matrix); 			return 0; 		} 	}  	if (matrix->datasize_ > 0) { 		if (!(matrix->data_ = jas_malloc(matrix->datasize_ * 		  sizeof(jas_seqent_t)))) { 			jas_matrix_destroy(matrix); 			return 0; 		} 	}  	for (i = 0; i < numrows; ++i) { 		matrix->rows_[i] = &matrix->data_[i * matrix->numcols_]; 	}  	for (i = 0; i < matrix->datasize_; ++i) { 		matrix->data_[i] = 0; 	}  	matrix->xstart_ = 0; 	matrix->ystart_ = 0; 	matrix->xend_ = matrix->numcols_; 	matrix->yend_ = matrix->numrows_;  	return matrix; }
jas_taginfo_t *jas_taginfo_nonull(jas_taginfo_t *taginfo) { 	static jas_taginfo_t invalidtaginfo = { 		-1, 0 	}; 	 	return taginfo ? taginfo : &invalidtaginfo; }
static int jpc_encclnpass(jpc_mqenc_t *mqenc, int bitpos, int orient, int vcausalflag, int segsymflag, jas_matrix_t *flags,   jas_matrix_t *data, int term, long *nmsedec) { 	int i; 	int j; 	int k; 	int vscanlen; 	int v; 	int runlen; 	jpc_fix_t *fp; 	int width; 	int height; 	jpc_fix_t *dp; 	int one; 	int frowstep; 	int drowstep; 	int fstripestep; 	int dstripestep; 	jpc_fix_t *fstripestart; 	jpc_fix_t *dstripestart; 	jpc_fix_t *fvscanstart; 	jpc_fix_t *dvscanstart;  	*nmsedec = 0; 	width = jas_matrix_numcols(data); 	height = jas_matrix_numrows(data); 	frowstep = jas_matrix_rowstep(flags); 	drowstep = jas_matrix_rowstep(data); 	fstripestep = frowstep << 2; 	dstripestep = drowstep << 2;  	one = 1 << (bitpos + JPC_NUMEXTRABITS);  	fstripestart = jas_matrix_getref(flags, 1, 1); 	dstripestart = jas_matrix_getref(data, 0, 0); 	for (i = height; i > 0; i -= 4, fstripestart += fstripestep, 	  dstripestart += dstripestep) { 		fvscanstart = fstripestart; 		dvscanstart = dstripestart; 		vscanlen = JAS_MIN(i, 4); 		for (j = width; j > 0; --j, ++fvscanstart, ++dvscanstart) {  			fp = fvscanstart; 			if (vscanlen >= 4 && !((*fp) & (JPC_SIG | JPC_VISIT | 			  JPC_OTHSIGMSK)) && (fp += frowstep, !((*fp) & (JPC_SIG | 			  JPC_VISIT | JPC_OTHSIGMSK))) && (fp += frowstep, !((*fp) & 			  (JPC_SIG | JPC_VISIT | JPC_OTHSIGMSK))) && (fp += frowstep, 			  !((*fp) & (JPC_SIG | JPC_VISIT | JPC_OTHSIGMSK)))) { 				dp = dvscanstart; 				for (k = 0; k < vscanlen; ++k) { 					v = (abs(*dp) & one) ? 1 : 0; 					if (v) { 						break; 					} 					dp += drowstep; 				} 				runlen = k; 				if (runlen >= 4) { 					jpc_mqenc_setcurctx(mqenc, JPC_AGGCTXNO); 					jpc_mqenc_putbit(mqenc, 0); 					continue; 				} 				jpc_mqenc_setcurctx(mqenc, JPC_AGGCTXNO); 				jpc_mqenc_putbit(mqenc, 1); 				jpc_mqenc_setcurctx(mqenc, JPC_UCTXNO); 				jpc_mqenc_putbit(mqenc, runlen >> 1); 				jpc_mqenc_putbit(mqenc, runlen & 1); 				fp = fvscanstart + frowstep * runlen; 				dp = dvscanstart + drowstep * runlen; 				k = vscanlen - runlen; 				switch (runlen) { 				case 0: 					goto clnpass_partial0; 					break; 				case 1: 					goto clnpass_partial1; 					break; 				case 2: 					goto clnpass_partial2; 					break; 				case 3: 					goto clnpass_partial3; 					break; 				} 			} else { 				runlen = 0; 				fp = fvscanstart; 				dp = dvscanstart; 				k = vscanlen; 				goto clnpass_full0; 			} 			clnpass_step(fp, frowstep, dp, bitpos, one, 			  orient, nmsedec, mqenc, clnpass_full0:, clnpass_partial0:, vcausalflag); 			if (--k <= 0) { 				continue; 			} 			fp += frowstep; 			dp += drowstep; 			clnpass_step(fp, frowstep, dp, bitpos, one, 				orient, nmsedec, mqenc, ;, clnpass_partial1:, 0); 			if (--k <= 0) { 				continue; 			} 			fp += frowstep; 			dp += drowstep; 			clnpass_step(fp, frowstep, dp, bitpos, one, 				orient, nmsedec, mqenc, ;, clnpass_partial2:, 0); 			if (--k <= 0) { 				continue; 			} 			fp += frowstep; 			dp += drowstep; 			clnpass_step(fp, frowstep, dp, bitpos, one, 				orient, nmsedec, mqenc, ;, clnpass_partial3:, 0); 		} 	}  	if (segsymflag) { 		jpc_mqenc_setcurctx(mqenc, JPC_UCTXNO); 		jpc_mqenc_putbit(mqenc, 1); 		jpc_mqenc_putbit(mqenc, 0); 		jpc_mqenc_putbit(mqenc, 1); 		jpc_mqenc_putbit(mqenc, 0); 	}  	if (term) { 		jpc_mqenc_flush(mqenc, term - 1); 	}  	return jpc_mqenc_error(mqenc) ? (-1) : 0; }
static int jas_cmshapmatlut_set(jas_cmshapmatlut_t *lut, jas_icccurv_t *curv) { 	jas_cmreal_t gamma; 	int i; 	gamma = 0; 	jas_cmshapmatlut_cleanup(lut); 	if (curv->numents == 0) { 		lut->size = 2; 		if (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t)))) 			goto error; 		lut->data[0] = 0.0; 		lut->data[1] = 1.0; 	} else if (curv->numents == 1) { 		lut->size = 256; 		if (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t)))) 			goto error; 		gamma = curv->ents[0] / 256.0; 		for (i = 0; i < lut->size; ++i) { 			lut->data[i] = gammafn(i / (double) (lut->size - 1), gamma); 		} 	} else { 		lut->size = curv->numents; 		if (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t)))) 			goto error; 		for (i = 0; i < lut->size; ++i) { 			lut->data[i] = curv->ents[i] / 65535.0; 		} 	} 	return 0; error: 	return -1; }
static void jas_cmshapmatlut_init(jas_cmshapmatlut_t *lut) { 	lut->data = 0; 	lut->size = 0; }
jas_iccattrval_t *jas_iccattrval_create(jas_iccuint32_t type) { 	jas_iccattrval_t *attrval; 	jas_iccattrvalinfo_t *info;  	if (!(info = jas_iccattrvalinfo_lookup(type))) 		goto error; 	if (!(attrval = jas_iccattrval_create0())) 		goto error; 	attrval->ops = &info->ops; 	attrval->type = type; 	++attrval->refcnt; 	memset(&attrval->data, 0, sizeof(attrval->data)); 	return attrval; error: 	return 0; }
static void jpc_com_destroyparms(jpc_ms_t *ms) { 	jpc_com_t *com = &ms->parms.com; 	if (com->data) { 		jas_free(com->data); 	} }
char *jas_strdup(const char *s) { 	int n; 	char *p; 	n = strlen(s) + 1; 	if (!(p = jas_malloc(n * sizeof(char)))) { 		return 0; 	} 	strcpy(p, s); 	return p; }
int jpc_firstone(int x) { 	int n;  	/* The argument must be nonnegative. */ 	assert(x >= 0);  	n = -1; 	while (x > 0) { 		x >>= 1; 		++n; 	} 	return n; }
static int jas_iccattrtab_lookup(jas_iccattrtab_t *attrtab,   jas_iccuint32_t name) { 	int i; 	jas_iccattr_t *attr; 	for (i = 0; i < attrtab->numattrs; ++i) { 		attr = &attrtab->attrs[i]; 		if (attr->name == name) 			return i; 	} 	return -1; }
jas_image_t *pnm_decode(jas_stream_t *in, char *opts) { 	pnm_hdr_t hdr; 	jas_image_t *image; 	jas_image_cmptparm_t cmptparms[3]; 	jas_image_cmptparm_t *cmptparm; 	int i;  	if (opts) { 		jas_eprintf("warning: ignoring options\n"); 	}  	/* Read the file header. */ 	if (pnm_gethdr(in, &hdr)) { 		return 0; 	}  	/* Create an image of the correct size. */ 	for (i = 0, cmptparm = cmptparms; i < hdr.numcmpts; ++i, ++cmptparm) { 		cmptparm->tlx = 0; 		cmptparm->tly = 0; 		cmptparm->hstep = 1; 		cmptparm->vstep = 1; 		cmptparm->width = hdr.width; 		cmptparm->height = hdr.height; 		cmptparm->prec = pnm_maxvaltodepth(hdr.maxval); 		cmptparm->sgnd = hdr.sgnd; 	} 	if (!(image = jas_image_create(hdr.numcmpts, cmptparms, JAS_CLRSPC_UNKNOWN))) { 		return 0; 	}  	if (hdr.numcmpts == 3) { 		jas_image_setclrspc(image, JAS_CLRSPC_SRGB); 		jas_image_setcmpttype(image, 0, 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R)); 		jas_image_setcmpttype(image, 1, 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G)); 		jas_image_setcmpttype(image, 2, 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B)); 	} else { 		jas_image_setclrspc(image, JAS_CLRSPC_SGRAY); 		jas_image_setcmpttype(image, 0, 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y)); 	}  	/* Read image data from stream into image. */ 	if (pnm_getdata(in, &hdr, image)) { 		jas_image_destroy(image); 		return 0; 	}  	return image; }
static jas_cmpxform_t *jas_cmpxform_createshapmat() { 	int i; 	int j; 	jas_cmpxform_t *pxform; 	jas_cmshapmat_t *shapmat; 	if (!(pxform = jas_cmpxform_create0())) 		return 0; 	pxform->ops = &shapmat_ops; 	shapmat = &pxform->data.shapmat; 	shapmat->mono = 0; 	shapmat->order = 0; 	shapmat->useluts = 0; 	shapmat->usemat = 0; 	for (i = 0; i < 3; ++i) 		jas_cmshapmatlut_init(&shapmat->luts[i]); 	for (i = 0; i < 3; ++i) { 		for (j = 0; j < 4; ++j) 			shapmat->mat[i][j] = 0.0; 	} 	++pxform->refcnt; 	return pxform; }
int jpc_encode(jas_image_t *image, jas_stream_t *out, char *optstr) { 	jpc_enc_t *enc; 	jpc_enc_cp_t *cp;  	enc = 0; 	cp = 0;  	jpc_initluts();  	if (!(cp = cp_create(optstr, image))) { 		jas_eprintf("invalid JP encoder options\n"); 		goto error; 	}  	if (!(enc = jpc_enc_create(cp, out, image))) { 		goto error; 	} 	cp = 0;  	/* Encode the main header. */ 	if (jpc_enc_encodemainhdr(enc)) { 		goto error; 	}  	/* Encode the main body.  This constitutes most of the encoding work. */ 	if (jpc_enc_encodemainbody(enc)) { 		goto error; 	}  	/* Write EOC marker segment. */ 	if (!(enc->mrk = jpc_ms_create(JPC_MS_EOC))) { 		goto error; 	} 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) { 		jas_eprintf("cannot write EOI marker\n"); 		goto error; 	} 	jpc_ms_destroy(enc->mrk); 	enc->mrk = 0;  	if (jas_stream_flush(enc->out)) { 		goto error; 	}  	jpc_enc_destroy(enc);  	return 0;  error: 	if (cp) { 		jpc_enc_cp_destroy(cp); 	} 	if (enc) { 		jpc_enc_destroy(enc); 	} 	return -1; }
int jas_getdbglevel() { 	return jas_dbglevel; }
static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val) { 	ulonglong tmp; 	if (jas_iccgetuint(in, 4, &tmp)) 		return -1; 	*val = tmp; 	return 0; }
int jas_eprintf(const char *fmt, ...) { 	int ret; 	va_list ap;  	va_start(ap, fmt); 	ret = vfprintf(stderr, fmt, ap); 	va_end(ap); 	return ret; }
int jas_clrspc_numchans(int clrspc) { 	switch (jas_clrspc_fam(clrspc)) { 	case JAS_CLRSPC_FAM_XYZ: 	case JAS_CLRSPC_FAM_LAB: 	case JAS_CLRSPC_FAM_RGB: 	case JAS_CLRSPC_FAM_YCBCR: 		return 3; 		break; 	case JAS_CLRSPC_FAM_GRAY: 		return 1; 		break; 	default: 		abort(); 		break; 	} }
static int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out) { 	jp2_ihdr_t *ihdr = &box->data.ihdr; 	if (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) || 	  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) || 	  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) || 	  jp2_putuint8(out, ihdr->ipr)) { 		return -1; 	} 	return 0; }
int jas_image_strtofmt(char *name) { 	jas_image_fmtinfo_t *fmtinfo; 	if (!(fmtinfo = jas_image_lookupfmtbyname(name))) { 		return -1; 	} 	return fmtinfo->id; }
void jpc_ft_fwdlift_colres(jpc_fix_t *a, int numrows, int numcols, int stride,   int parity) {  	jpc_fix_t *lptr; 	jpc_fix_t *hptr; 	register jpc_fix_t *lptr2; 	register jpc_fix_t *hptr2; 	register int n; 	register int i; 	int llen;  	llen = (numrows + 1 - parity) >> 1;  	if (numrows > 1) {  		/* Apply the first lifting step. */ 		lptr = &a[0]; 		hptr = &a[llen * stride]; 		if (parity) { 			lptr2 = lptr; 			hptr2 = hptr; 			for (i = 0; i < numcols; ++i) { 				hptr2[0] -= lptr2[0]; 				++hptr2; 				++lptr2; 			} 			hptr += stride; 		} 		n = numrows - llen - parity - (parity == (numrows & 1)); 		while (n-- > 0) { 			lptr2 = lptr; 			hptr2 = hptr; 			for (i = 0; i < numcols; ++i) { 				hptr2[0] -= (lptr2[0] + lptr2[stride]) >> 1; 				++lptr2; 				++hptr2; 			} 			hptr += stride; 			lptr += stride; 		} 		if (parity == (numrows & 1)) { 			lptr2 = lptr; 			hptr2 = hptr; 			for (i = 0; i < numcols; ++i) { 				hptr2[0] -= lptr2[0]; 				++lptr2; 				++hptr2; 			} 		}  		/* Apply the second lifting step. */ 		lptr = &a[0]; 		hptr = &a[llen * stride]; 		if (!parity) { 			lptr2 = lptr; 			hptr2 = hptr; 			for (i = 0; i < numcols; ++i) { 				lptr2[0] += (hptr2[0] + 1) >> 1; 				++lptr2; 				++hptr2; 			} 			lptr += stride; 		} 		n = llen - (!parity) - (parity != (numrows & 1)); 		while (n-- > 0) { 			lptr2 = lptr; 			hptr2 = hptr; 			for (i = 0; i < numcols; ++i) { 				lptr2[0] += (hptr2[0] + hptr2[stride] + 2) >> 2; 				++lptr2; 				++hptr2; 			} 			lptr += stride; 			hptr += stride; 		} 		if (parity != (numrows & 1)) { 			lptr2 = lptr; 			hptr2 = hptr; 			for (i = 0; i < numcols; ++i) { 				lptr2[0] += (hptr2[0] + 1) >> 1; 				++lptr2; 				++hptr2; 			} 		}  	} else {  		if (parity) { 			lptr2 = &a[0]; 			for (i = 0; i < numcols; ++i) { 				lptr2[0] <<= 1; 				++lptr2; 			} 		}  	}  }
jas_iccprof_t *jas_iccprof_createfromclrspc(int clrspc) { 	jas_iccprof_t *prof; 	switch (clrspc) { 	case JAS_CLRSPC_SRGB: 		prof = jas_iccprof_createfrombuf(jas_iccprofdata_srgb, 		  jas_iccprofdata_srgblen); 		break; 	case JAS_CLRSPC_SGRAY: 		prof = jas_iccprof_createfrombuf(jas_iccprofdata_sgray, 		  jas_iccprofdata_sgraylen); 		break; 	default: 		prof = 0; 		break; 	} 	return prof; }
void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,   int r1, int c1) { 	int i;  	if (mat0->data_) { 		if (!(mat0->flags_ & JAS_MATRIX_REF)) { 			jas_free(mat0->data_); 		} 		mat0->data_ = 0; 		mat0->datasize_ = 0; 	} 	if (mat0->rows_) { 		jas_free(mat0->rows_); 		mat0->rows_ = 0; 	} 	mat0->flags_ |= JAS_MATRIX_REF; 	mat0->numrows_ = r1 - r0 + 1; 	mat0->numcols_ = c1 - c0 + 1; 	mat0->maxrows_ = mat0->numrows_; 	mat0->rows_ = jas_malloc(mat0->maxrows_ * sizeof(jas_seqent_t *)); 	for (i = 0; i < mat0->numrows_; ++i) { 		mat0->rows_[i] = mat1->rows_[r0 + i] + c0; 	}  	mat0->xstart_ = mat1->xstart_ + c0; 	mat0->ystart_ = mat1->ystart_ + r0; 	mat0->xend_ = mat0->xstart_ + mat0->numcols_; 	mat0->yend_ = mat0->ystart_ + mat0->numrows_; }
static int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out) { 	jp2_colr_t *colr = &box->data.colr; 	if (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) || 	  jp2_putuint8(out, colr->approx)) { 		return -1; 	} 	switch (colr->method) { 	case JP2_COLR_ENUM: 		if (jp2_putuint32(out, colr->csid)) { 			return -1; 		} 		break; 	case JP2_COLR_ICC: 		if (jas_stream_write(out, colr->iccp, 		  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen)) 			return -1; 		break; 	} 	return 0; }
static int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out) { 	jpc_com_t *com = &ms->parms.com;  	/* Eliminate compiler warning about unused variables. */ 	cstate = 0;  	if (jpc_putuint16(out, com->regid)) { 		return -1; 	} 	if (jas_stream_write(out, com->data, com->len) != JAS_CAST(int, com->len)) { 		return -1; 	} 	return 0; }
int jas_image_addfmt(int id, char *name, char *ext, char *desc,   jas_image_fmtops_t *ops) { 	jas_image_fmtinfo_t *fmtinfo; 	assert(id >= 0 && name && ext && ops); 	if (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) { 		return -1; 	} 	fmtinfo = &jas_image_fmtinfos[jas_image_numfmts]; 	fmtinfo->id = id; 	if (!(fmtinfo->name = jas_strdup(name))) { 		return -1; 	} 	if (!(fmtinfo->ext = jas_strdup(ext))) { 		jas_free(fmtinfo->name); 		return -1; 	} 	if (!(fmtinfo->desc = jas_strdup(desc))) { 		jas_free(fmtinfo->name); 		jas_free(fmtinfo->ext); 		return -1; 	} 	fmtinfo->ops = *ops; 	++jas_image_numfmts; 	return 0; }
static jas_cmprof_t *jas_cmprof_create() { 	int i; 	jas_cmprof_t *prof; 	if (!(prof = jas_malloc(sizeof(jas_cmprof_t)))) 		return 0; 	memset(prof, 0, sizeof(jas_cmprof_t)); 	prof->iccprof = 0; 	for (i = 0; i < JAS_CMPROF_NUMPXFORMSEQS; ++i) 		prof->pxformseqs[i] = 0; 	return prof; }
jpc_enc_t *jpc_enc_create(jpc_enc_cp_t *cp, jas_stream_t *out, jas_image_t *image) { 	jpc_enc_t *enc;  	enc = 0;  	if (!(enc = jas_malloc(sizeof(jpc_enc_t)))) { 		goto error; 	}  	enc->image = image; 	enc->out = out; 	enc->cp = cp; 	enc->cstate = 0; 	enc->tmpstream = 0; 	enc->mrk = 0; 	enc->curtile = 0;  	if (!(enc->cstate = jpc_cstate_create())) { 		goto error; 	} 	enc->len = 0; 	enc->mainbodysize = 0;  	return enc;  error:  	if (enc) { 		jpc_enc_destroy(enc); 	} 	return 0; }
jpc_enc_tile_t *jpc_enc_tile_create(jpc_enc_cp_t *cp, jas_image_t *image, int tileno) { 	jpc_enc_tile_t *tile; 	uint_fast32_t htileno; 	uint_fast32_t vtileno; 	uint_fast16_t lyrno; 	uint_fast16_t cmptno; 	jpc_enc_tcmpt_t *tcmpt;  	if (!(tile = jas_malloc(sizeof(jpc_enc_tile_t)))) { 		goto error; 	}  	/* Initialize a few members used in error recovery. */ 	tile->tcmpts = 0; 	tile->lyrsizes = 0; 	tile->numtcmpts = cp->numcmpts; 	tile->pi = 0;  	tile->tileno = tileno; 	htileno = tileno % cp->numhtiles; 	vtileno = tileno / cp->numhtiles;  	/* Calculate the coordinates of the top-left and bottom-right 	  corners of the tile. */ 	tile->tlx = JAS_MAX(cp->tilegrdoffx + htileno * cp->tilewidth, 	  cp->imgareatlx); 	tile->tly = JAS_MAX(cp->tilegrdoffy + vtileno * cp->tileheight, 	  cp->imgareatly); 	tile->brx = JAS_MIN(cp->tilegrdoffx + (htileno + 1) * cp->tilewidth, 	  cp->refgrdwidth); 	tile->bry = JAS_MIN(cp->tilegrdoffy + (vtileno + 1) * cp->tileheight, 	  cp->refgrdheight);  	/* Initialize some tile coding parameters. */ 	tile->intmode = cp->tcp.intmode; 	tile->csty = cp->tcp.csty; 	tile->prg = cp->tcp.prg; 	tile->mctid = cp->tcp.mctid;  	tile->numlyrs = cp->tcp.numlyrs; 	if (!(tile->lyrsizes = jas_malloc(tile->numlyrs * 	  sizeof(uint_fast32_t)))) { 		goto error; 	} 	for (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) { 		tile->lyrsizes[lyrno] = 0; 	}  	/* Allocate an array for the per-tile-component information. */ 	if (!(tile->tcmpts = jas_malloc(cp->numcmpts * sizeof(jpc_enc_tcmpt_t)))) { 		goto error; 	} 	/* Initialize a few members critical for error recovery. */ 	for (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts; 	  ++cmptno, ++tcmpt) { 		tcmpt->rlvls = 0; 		tcmpt->tsfb = 0; 		tcmpt->data = 0; 	} 	/* Initialize the per-tile-component information. */ 	for (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts; 	  ++cmptno, ++tcmpt) { 		if (!tcmpt_create(tcmpt, cp, image, tile)) { 			goto error; 		} 	}  	/* Initialize the synthesis weights for the MCT. */ 	switch (tile->mctid) { 	case JPC_MCT_RCT: 		tile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0)); 		tile->tcmpts[1].synweight = jpc_dbltofix(sqrt(0.6875)); 		tile->tcmpts[2].synweight = jpc_dbltofix(sqrt(0.6875)); 		break; 	case JPC_MCT_ICT: 		tile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0000)); 		tile->tcmpts[1].synweight = jpc_dbltofix(sqrt(3.2584)); 		tile->tcmpts[2].synweight = jpc_dbltofix(sqrt(2.4755)); 		break; 	default: 	case JPC_MCT_NONE: 		for (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts; 		  ++cmptno, ++tcmpt) { 			tcmpt->synweight = JPC_FIX_ONE; 		} 		break; 	}  	if (!(tile->pi = jpc_enc_pi_create(cp, tile))) { 		goto error; 	}  	return tile;  error:  	if (tile) { 		jpc_enc_tile_destroy(tile); 	} 	return 0; }
void jpc_enc_destroy(jpc_enc_t *enc) { 	/* The image object (i.e., enc->image) and output stream object 	(i.e., enc->out) are created outside of the encoder. 	Therefore, they must not be destroyed here. */  	if (enc->curtile) { 		jpc_enc_tile_destroy(enc->curtile); 	} 	if (enc->cp) { 		jpc_enc_cp_destroy(enc->cp); 	} 	if (enc->cstate) { 		jpc_cstate_destroy(enc->cstate); 	} 	if (enc->tmpstream) { 		jas_stream_close(enc->tmpstream); 	}  	jas_free(enc); }
static int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out) { 	jp2_jp_t *jp = &box->data.jp; 	if (jp2_putuint32(out, jp->magic)) { 		return -1; 	} 	return 0; }
static long mem_seek(jas_stream_obj_t *obj, long offset, int origin) { 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; 	long newpos;  	switch (origin) { 	case SEEK_SET: 		newpos = offset; 		break; 	case SEEK_END: 		newpos = m->len_ - offset; 		break; 	case SEEK_CUR: 		newpos = m->pos_ + offset; 		break; 	default: 		abort(); 		break; 	} 	if (newpos < 0) { 		return -1; 	} 	m->pos_ = newpos;  	return m->pos_; }
static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt) { 	jpc_enc_rlvl_t *rlvl; 	uint_fast16_t rlvlno;  	if (tcmpt->rlvls) { 		for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls; 		  ++rlvlno, ++rlvl) { 			rlvl_destroy(rlvl); 		} 		jas_free(tcmpt->rlvls); 	}  	if (tcmpt->data) { 		jas_seq2d_destroy(tcmpt->data); 	} 	if (tcmpt->tsfb) { 		jpc_tsfb_destroy(tcmpt->tsfb); 	} }
void jpc_pchglist_destroy(jpc_pchglist_t *pchglist) { 	int pchgno; 	if (pchglist->pchgs) { 		for (pchgno = 0; pchgno < pchglist->numpchgs; ++pchgno) { 			jpc_pchg_destroy(pchglist->pchgs[pchgno]); 		} 		jas_free(pchglist->pchgs); 	} 	jas_free(pchglist); }
static int jas_iccattrtab_add(jas_iccattrtab_t *attrtab, int i,   jas_iccuint32_t name, jas_iccattrval_t *val) { 	int n; 	jas_iccattr_t *attr; 	jas_iccattrval_t *tmpattrval; 	tmpattrval = 0; 	if (i < 0) { 		i = attrtab->numattrs; 	} 	assert(i >= 0 && i <= attrtab->numattrs); 	if (attrtab->numattrs >= attrtab->maxattrs) { 		if (jas_iccattrtab_resize(attrtab, attrtab->numattrs + 32)) { 			goto error; 		} 	} 	if (!(tmpattrval = jas_iccattrval_clone(val))) 		goto error; 	n = attrtab->numattrs - i; 	if (n > 0) 		memmove(&attrtab->attrs[i + 1], &attrtab->attrs[i], 		  n * sizeof(jas_iccattr_t)); 	attr = &attrtab->attrs[i]; 	attr->name = name; 	attr->val = tmpattrval; 	++attrtab->numattrs; 	return 0; error: 	if (tmpattrval) 		jas_iccattrval_destroy(tmpattrval); 	return -1; }
static int pnm_getc(jas_stream_t *in) { 	int c; 	for (;;) { 		if ((c = jas_stream_getc(in)) == EOF) { 			return -1; 		} 		if (c != '#') { 			return c; 		} 		do { 			if ((c = jas_stream_getc(in)) == EOF) { 				return -1; 			} 		} while (c != '\n' && c != '\r'); 	} }
void jas_matrix_destroy(jas_matrix_t *matrix) { 	if (matrix->data_) { 		assert(!(matrix->flags_ & JAS_MATRIX_REF)); 		jas_free(matrix->data_); 		matrix->data_ = 0; 	} 	if (matrix->rows_) { 		jas_free(matrix->rows_); 		matrix->rows_ = 0; 	} 	jas_free(matrix); }
jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend) { 	jas_matrix_t *matrix; 	assert(xstart <= xend && ystart <= yend); 	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) { 		return 0; 	} 	matrix->xstart_ = xstart; 	matrix->ystart_ = ystart; 	matrix->xend_ = xend; 	matrix->yend_ = yend; 	return matrix; }
jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,   int clrspc) { 	jas_image_t *image; 	uint_fast32_t rawsize; 	uint_fast32_t inmem; 	int cmptno; 	jas_image_cmptparm_t *cmptparm;  	if (!(image = jas_image_create0())) { 		return 0; 	}  	image->clrspc_ = clrspc; 	image->maxcmpts_ = numcmpts; 	image->inmem_ = true;  	/* Allocate memory for the per-component information. */ 	if (!(image->cmpts_ = jas_malloc(image->maxcmpts_ * 	  sizeof(jas_image_cmpt_t *)))) { 		jas_image_destroy(image); 		return 0; 	} 	/* Initialize in case of failure. */ 	for (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) { 		image->cmpts_[cmptno] = 0; 	}  	/* Compute the approximate raw size of the image. */ 	rawsize = 0; 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno, 	  ++cmptparm) { 		rawsize += cmptparm->width * cmptparm->height * 		  (cmptparm->prec + 7) / 8; 	} 	/* Decide whether to buffer the image data in memory, based on the 	  raw size of the image. */ 	inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);  	/* Create the individual image components. */ 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno, 	  ++cmptparm) { 		if (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx, 		  cmptparm->tly, cmptparm->hstep, cmptparm->vstep, 		  cmptparm->width, cmptparm->height, cmptparm->prec, 		  cmptparm->sgnd, inmem))) { 			jas_image_destroy(image); 			return 0; 		} 		++image->numcmpts_; 	}  	/* Determine the bounding box for all of the components on the 	  reference grid (i.e., the image area) */ 	jas_image_setbbox(image);  	return image; }
static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt) { 	int n; 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; 	n = m->len_ - m->pos_; 	cnt = JAS_MIN(n, cnt); 	memcpy(buf, &m->buf_[m->pos_], cnt); 	m->pos_ += cnt; 	return cnt; }
static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt) { 	int n; 	int ret; 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; 	long newbufsize; 	long newpos;  	newpos = m->pos_ + cnt; 	if (newpos > m->bufsize_ && m->growable_) { 		newbufsize = m->bufsize_; 		while (newbufsize < newpos) { 			newbufsize <<= 1; 			assert(newbufsize >= 0); 		} 		if (mem_resize(m, newbufsize)) { 			return -1; 		} 	} 	if (m->pos_ > m->len_) { 		/* The current position is beyond the end of the file, so 		  pad the file to the current position with zeros. */ 		n = JAS_MIN(m->pos_, m->bufsize_) - m->len_; 		if (n > 0) { 			memset(&m->buf_[m->len_], 0, n); 			m->len_ += n; 		} 		if (m->pos_ != m->len_) { 			/* The buffer is not big enough. */ 			return 0; 		} 	} 	n = m->bufsize_ - m->pos_; 	ret = JAS_MIN(n, cnt); 	if (ret > 0) { 		memcpy(&m->buf_[m->pos_], buf, ret); 		m->pos_ += ret; 	} 	if (m->pos_ > m->len_) { 		m->len_ = m->pos_; 	} assert(ret == cnt); 	return ret; }
static int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,   jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms) { 	int i; 	assert(compparms->numdlvls <= 32);  	/* Eliminate compiler warning about unused variables. */ 	ms = 0; 	cstate = 0;  	if (jpc_putuint8(out, compparms->numdlvls) || 	  jpc_putuint8(out, compparms->cblkwidthval) || 	  jpc_putuint8(out, compparms->cblkheightval) || 	  jpc_putuint8(out, compparms->cblksty) || 	  jpc_putuint8(out, compparms->qmfbid)) { 		return -1; 	} 	if (prtflag) { 		for (i = 0; i < compparms->numrlvls; ++i) { 			if (jpc_putuint8(out, 			  ((compparms->rlvls[i].parheightval & 0xf) << 4) | 			  (compparms->rlvls[i].parwidthval & 0xf))) { 				return -1; 			} 		} 	} 	return 0; }
static jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,   uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t   height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem) { 	jas_image_cmpt_t *cmpt; 	long size;  	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) { 		return 0; 	}  	cmpt->type_ = JAS_IMAGE_CT_UNKNOWN; 	cmpt->tlx_ = tlx; 	cmpt->tly_ = tly; 	cmpt->hstep_ = hstep; 	cmpt->vstep_ = vstep; 	cmpt->width_ = width; 	cmpt->height_ = height; 	cmpt->prec_ = depth; 	cmpt->sgnd_ = sgnd; 	cmpt->stream_ = 0; 	cmpt->cps_ = (depth + 7) / 8;  	size = cmpt->width_ * cmpt->height_ * cmpt->cps_; 	cmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : jas_stream_tmpfile(); 	if (!cmpt->stream_) { 		jas_image_cmpt_destroy(cmpt); 		return 0; 	}  	/* Zero the component data.  This isn't necessary, but it is 	convenient for debugging purposes. */ 	if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 || 	  jas_stream_putc(cmpt->stream_, 0) == EOF || 	  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) { 		jas_image_cmpt_destroy(cmpt); 		return 0; 	}  	return cmpt; }
static void jas_iccprof_sorttagtab(jas_icctagtab_t *tagtab) { 	qsort(tagtab->ents, tagtab->numents, sizeof(jas_icctagtabent_t), 	  jas_icctagtabent_cmp); }
int jas_getopt(int argc, char **argv, jas_opt_t *opts) { 	char *cp; 	int id; 	int hasarg; 	jas_opt_t *opt; 	char *s;  	if (!jas_optind) { 		jas_optind = JAS_MIN(1, argc); 	} 	while (jas_optind < argc) { 		s = cp = argv[jas_optind]; 		if (*cp == '-') { 			/* We are processing an option. */ 			++jas_optind; 			if (*++cp == '-') { 				/* We are processing a long option. */ 				++cp; 				if (*cp == '\0') { 					/* This is the end of the options. */ 					return JAS_GETOPT_EOF; 				} 				if (!(opt = jas_optlookup(opts, cp))) { 					if (jas_opterr) { 						jas_eprintf("unknown long option %s\n", s); 					} 					return JAS_GETOPT_ERR; 				} 				hasarg = (opt->flags & JAS_OPT_HASARG) != 0; 				id = opt->id; 			} else { 				/* We are processing a short option. */ 				if (strlen(cp) != 1 || 				  !(opt = jas_optlookup(opts, cp))) { 					if (jas_opterr) { 						jas_eprintf("unknown short option %s\n", s); 					} 					return JAS_GETOPT_ERR; 				} 				hasarg = (opt->flags & JAS_OPT_HASARG) != 0; 				id = opt->id; 			} 			if (hasarg) { 				/* The option has an argument. */ 				if (jas_optind >= argc) { 					if (jas_opterr) { 						jas_eprintf("missing argument for option %s\n", s); 					} 					return JAS_GETOPT_ERR; 				} 				jas_optarg = argv[jas_optind]; 				++jas_optind; 			} else { 				/* The option does not have an argument. */ 				jas_optarg = 0; 			} 			return id; 		} else { 			/* We are not processing an option. */ 			return JAS_GETOPT_EOF; 		} 	} 	return JAS_GETOPT_EOF; }
static void cblk_destroy(jpc_enc_cblk_t *cblk) { 	uint_fast16_t passno; 	jpc_enc_pass_t *pass; 	if (cblk->passes) { 		for (passno = 0, pass = cblk->passes; passno < cblk->numpasses; 		  ++passno, ++pass) { 			pass_destroy(pass); 		} 		jas_free(cblk->passes); 	} 	if (cblk->stream) { 		jas_stream_close(cblk->stream); 	} 	if (cblk->mqenc) { 		jpc_mqenc_destroy(cblk->mqenc); 	} 	if (cblk->data) { 		jas_seq2d_destroy(cblk->data); 	} 	if (cblk->flags) { 		jas_seq2d_destroy(cblk->flags); 	} }
int pnm_type(uint_fast16_t magic) { 	int type; 	switch (magic) { 	case PNM_MAGIC_TXTPPM: 	case PNM_MAGIC_BINPPM: 		type = PNM_TYPE_PPM; 		break; 	case PNM_MAGIC_TXTPGM: 	case PNM_MAGIC_BINPGM: 		type = PNM_TYPE_PGM; 		break; 	case PNM_MAGIC_TXTPBM: 	case PNM_MAGIC_BINPBM: 		type = PNM_TYPE_PBM; 		break; 	default: 		/* This should not happen. */ 		abort(); 		break; 	} 	return type; }
double jas_tmr_get(jas_tmr_t *tmr) { 	return 0.0; }
static jpc_enc_tcmpt_t *tcmpt_create(jpc_enc_tcmpt_t *tcmpt, jpc_enc_cp_t *cp,   jas_image_t *image, jpc_enc_tile_t *tile) { 	uint_fast16_t cmptno; 	uint_fast16_t rlvlno; 	jpc_enc_rlvl_t *rlvl; 	uint_fast32_t tlx; 	uint_fast32_t tly; 	uint_fast32_t brx; 	uint_fast32_t bry; 	uint_fast32_t cmpttlx; 	uint_fast32_t cmpttly; 	jpc_enc_ccp_t *ccp; 	jpc_tsfb_band_t bandinfos[JPC_MAXBANDS];  	tcmpt->tile = tile; 	tcmpt->tsfb = 0; 	tcmpt->data = 0; 	tcmpt->rlvls = 0;  	/* Deduce the component number. */ 	cmptno = tcmpt - tile->tcmpts;  	ccp = &cp->ccps[cmptno];  	/* Compute the coordinates of the top-left and bottom-right 	  corners of this tile-component. */ 	tlx = JPC_CEILDIV(tile->tlx, ccp->sampgrdstepx); 	tly = JPC_CEILDIV(tile->tly, ccp->sampgrdstepy); 	brx = JPC_CEILDIV(tile->brx, ccp->sampgrdstepx); 	bry = JPC_CEILDIV(tile->bry, ccp->sampgrdstepy);  	/* Create a sequence to hold the tile-component sample data. */ 	if (!(tcmpt->data = jas_seq2d_create(tlx, tly, brx, bry))) { 		goto error; 	}  	/* Get the image data associated with this tile-component. */ 	cmpttlx = JPC_CEILDIV(cp->imgareatlx, ccp->sampgrdstepx); 	cmpttly = JPC_CEILDIV(cp->imgareatly, ccp->sampgrdstepy); 	if (jas_image_readcmpt(image, cmptno, tlx - cmpttlx, tly - cmpttly, 	  brx - tlx, bry - tly, tcmpt->data)) { 		goto error; 	}  	tcmpt->synweight = 0; 	tcmpt->qmfbid = cp->tccp.qmfbid; 	tcmpt->numrlvls = cp->tccp.maxrlvls; 	tcmpt->numbands = 3 * tcmpt->numrlvls - 2; 	if (!(tcmpt->tsfb = jpc_cod_gettsfb(tcmpt->qmfbid, tcmpt->numrlvls - 1))) { 		goto error; 	}  	for (rlvlno = 0; rlvlno < tcmpt->numrlvls; ++rlvlno) { 		tcmpt->prcwidthexpns[rlvlno] = cp->tccp.prcwidthexpns[rlvlno]; 		tcmpt->prcheightexpns[rlvlno] = cp->tccp.prcheightexpns[rlvlno]; 	} 	tcmpt->cblkwidthexpn = cp->tccp.cblkwidthexpn; 	tcmpt->cblkheightexpn = cp->tccp.cblkheightexpn; 	tcmpt->cblksty = cp->tccp.cblksty; 	tcmpt->csty = cp->tccp.csty;  	tcmpt->numstepsizes = tcmpt->numbands; 	assert(tcmpt->numstepsizes <= JPC_MAXBANDS); 	memset(tcmpt->stepsizes, 0, sizeof(tcmpt->numstepsizes * 	  sizeof(uint_fast16_t)));  	/* Retrieve information about the various bands. */ 	jpc_tsfb_getbands(tcmpt->tsfb, jas_seq2d_xstart(tcmpt->data), 	  jas_seq2d_ystart(tcmpt->data), jas_seq2d_xend(tcmpt->data), 	  jas_seq2d_yend(tcmpt->data), bandinfos);  	if (!(tcmpt->rlvls = jas_malloc(tcmpt->numrlvls * sizeof(jpc_enc_rlvl_t)))) { 		goto error; 	} 	for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls; 	  ++rlvlno, ++rlvl) { 		rlvl->bands = 0; 		rlvl->tcmpt = tcmpt; 	} 	for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls; 	  ++rlvlno, ++rlvl) { 		if (!rlvl_create(rlvl, cp, tcmpt, bandinfos)) { 			goto error; 		} 	}  	return tcmpt;  error:  	tcmpt_destroy(tcmpt); 	return 0;  }
static void jpc_cox_destroycompparms(jpc_coxcp_t *compparms) { 	/* Eliminate compiler warning about unused variables. */ 	compparms = 0; }
static jpc_enc_rlvl_t *rlvl_create(jpc_enc_rlvl_t *rlvl, jpc_enc_cp_t *cp,   jpc_enc_tcmpt_t *tcmpt, jpc_tsfb_band_t *bandinfos) { 	uint_fast16_t rlvlno; 	uint_fast32_t tlprctlx; 	uint_fast32_t tlprctly; 	uint_fast32_t brprcbrx; 	uint_fast32_t brprcbry; 	uint_fast16_t bandno; 	jpc_enc_band_t *band;  	/* Deduce the resolution level. */ 	rlvlno = rlvl - tcmpt->rlvls;  	/* Initialize members required for error recovery. */ 	rlvl->bands = 0; 	rlvl->tcmpt = tcmpt;  	/* Compute the coordinates of the top-left and bottom-right 	  corners of the tile-component at this resolution. */ 	rlvl->tlx = JPC_CEILDIVPOW2(jas_seq2d_xstart(tcmpt->data), tcmpt->numrlvls - 	  1 - rlvlno); 	rlvl->tly = JPC_CEILDIVPOW2(jas_seq2d_ystart(tcmpt->data), tcmpt->numrlvls - 	  1 - rlvlno); 	rlvl->brx = JPC_CEILDIVPOW2(jas_seq2d_xend(tcmpt->data), tcmpt->numrlvls - 	  1 - rlvlno); 	rlvl->bry = JPC_CEILDIVPOW2(jas_seq2d_yend(tcmpt->data), tcmpt->numrlvls - 	  1 - rlvlno);  	if (rlvl->tlx >= rlvl->brx || rlvl->tly >= rlvl->bry) { 		rlvl->numhprcs = 0; 		rlvl->numvprcs = 0; 		rlvl->numprcs = 0; 		return rlvl; 	}  	rlvl->numbands = (!rlvlno) ? 1 : 3; 	rlvl->prcwidthexpn = cp->tccp.prcwidthexpns[rlvlno]; 	rlvl->prcheightexpn = cp->tccp.prcheightexpns[rlvlno]; 	if (!rlvlno) { 		rlvl->cbgwidthexpn = rlvl->prcwidthexpn; 		rlvl->cbgheightexpn = rlvl->prcheightexpn; 	} else { 		rlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1; 		rlvl->cbgheightexpn = rlvl->prcheightexpn - 1; 	} 	rlvl->cblkwidthexpn = JAS_MIN(cp->tccp.cblkwidthexpn, rlvl->cbgwidthexpn); 	rlvl->cblkheightexpn = JAS_MIN(cp->tccp.cblkheightexpn, rlvl->cbgheightexpn);  	/* Compute the number of precincts. */ 	tlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn); 	tlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn); 	brprcbrx = JPC_CEILTOMULTPOW2(rlvl->brx, rlvl->prcwidthexpn); 	brprcbry = JPC_CEILTOMULTPOW2(rlvl->bry, rlvl->prcheightexpn); 	rlvl->numhprcs = JPC_FLOORDIVPOW2(brprcbrx - tlprctlx, rlvl->prcwidthexpn); 	rlvl->numvprcs = JPC_FLOORDIVPOW2(brprcbry - tlprctly, rlvl->prcheightexpn); 	rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;  	if (!(rlvl->bands = jas_malloc(rlvl->numbands * sizeof(jpc_enc_band_t)))) { 		goto error; 	} 	for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; 	  ++bandno, ++band) { 		band->prcs = 0; 		band->data = 0; 		band->rlvl = rlvl; 	} 	for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; 	  ++bandno, ++band) { 		if (!band_create(band, cp, rlvl, bandinfos)) { 			goto error; 		} 	}  	return rlvl; error:  	rlvl_destroy(rlvl); 	return 0; }
void jpc_tagtree_destroy(jpc_tagtree_t *tree) { 	if (tree->nodes_) { 		jas_free(tree->nodes_); 	} 	jas_free(tree); }
int jpc_pi_init(jpc_pi_t *pi) { 	int compno; 	int rlvlno; 	int prcno; 	jpc_picomp_t *picomp; 	jpc_pirlvl_t *pirlvl; 	int *prclyrno;  	pi->prgvolfirst = 0; 	pi->valid = 0; 	pi->pktno = -1; 	pi->pchgno = -1; 	pi->pchg = 0;  	for (compno = 0, picomp = pi->picomps; compno < pi->numcomps; 	  ++compno, ++picomp) { 		for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno < 		  picomp->numrlvls; ++rlvlno, ++pirlvl) { 			for (prcno = 0, prclyrno = pirlvl->prclyrnos; 			  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) { 				*prclyrno = 0; 			} 		} 	} 	return 0; }
void jas_image_clearfmts() { 	int i; 	jas_image_fmtinfo_t *fmtinfo; 	for (i = 0; i < jas_image_numfmts; ++i) { 		fmtinfo = &jas_image_fmtinfos[i]; 		if (fmtinfo->name) { 			jas_free(fmtinfo->name); 			fmtinfo->name = 0; 		} 		if (fmtinfo->ext) { 			jas_free(fmtinfo->ext); 			fmtinfo->ext = 0; 		} 		if (fmtinfo->desc) { 			jas_free(fmtinfo->desc); 			fmtinfo->desc = 0; 		} 	} 	jas_image_numfmts = 0; }
static int jas_cmpxformseq_insertpxform(jas_cmpxformseq_t *pxformseq,   int i, jas_cmpxform_t *pxform) { 	jas_cmpxform_t *tmppxform; 	int n; 	if (i < 0) 		i = pxformseq->numpxforms; 	assert(i >= 0 && i <= pxformseq->numpxforms); 	if (pxformseq->numpxforms >= pxformseq->maxpxforms) { 		if (jas_cmpxformseq_resize(pxformseq, pxformseq->numpxforms + 		  16)) 			goto error; 	} 	assert(pxformseq->numpxforms < pxformseq->maxpxforms); 	if (!(tmppxform = jas_cmpxform_copy(pxform))) 		goto error; 	n = pxformseq->numpxforms - i; 	if (n > 0) { 		memmove(&pxformseq->pxforms[i + 1], &pxformseq->pxforms[i], 		  n * sizeof(jas_cmpxform_t *)); 	} 	pxformseq->pxforms[i] = tmppxform; 	++pxformseq->numpxforms; 	return 0; error: 	return -1; }
int jpc_enc_encodetiledata(jpc_enc_t *enc) { assert(enc->tmpstream); 	if (jpc_enc_encpkts(enc, enc->tmpstream)) { 		return -1; 	} 	return 0; }
static int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,   jas_stream_t *out) { 	int i;  	/* Eliminate compiler warning about unused variables. */ 	cstate = 0;  	jpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty); 	for (i = 0; i < compparms->numstepsizes; ++i) { 		if (compparms->qntsty == JPC_QCX_NOQNT) { 			jpc_putuint8(out, JPC_QCX_GETEXPN( 			  compparms->stepsizes[i]) << 3); 		} else { 			jpc_putuint16(out, compparms->stepsizes[i]); 		} 	} 	return 0; }
static int jp2_putuint8(jas_stream_t *out, uint_fast8_t val) { 	if (jas_stream_putc(out, val & 0xff) == EOF) { 		return -1; 	} 	return 0; }
static int jp2_putuint16(jas_stream_t *out, uint_fast16_t val) { 	if (jas_stream_putc(out, (val >> 8) & 0xff) == EOF || 	  jas_stream_putc(out, val & 0xff) == EOF) { 		return -1; 	} 	return 0; }
int JPC_ISTERMINATED(int passno, int firstpassno, int numpasses, int termall,   int lazy) { 	int ret; 	int n; 	if (passno - firstpassno == numpasses - 1) { 		ret = 1; 	} else { 		n = JPC_SEGPASSCNT(passno, firstpassno, numpasses, lazy, termall); 		ret = (n <= 1) ? 1 : 0; 	}  	return ret; }
void jpc_save_t2state(jpc_enc_t *enc) { /* stream pos in embedded T1 stream may be wrong since not saved/restored! */  	jpc_enc_tcmpt_t *comp; 	jpc_enc_tcmpt_t *endcomps; 	jpc_enc_rlvl_t *lvl; 	jpc_enc_rlvl_t *endlvls; 	jpc_enc_band_t *band; 	jpc_enc_band_t *endbands; 	jpc_enc_cblk_t *cblk; 	jpc_enc_cblk_t *endcblks; 	jpc_enc_tile_t *tile; 	int prcno; 	jpc_enc_prc_t *prc;  	tile = enc->curtile;  	endcomps = &tile->tcmpts[tile->numtcmpts]; 	for (comp = tile->tcmpts; comp != endcomps; ++comp) { 		endlvls = &comp->rlvls[comp->numrlvls]; 		for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 			if (!lvl->bands) { 				continue; 			} 			endbands = &lvl->bands[lvl->numbands]; 			for (band = lvl->bands; band != endbands; ++band) { 				if (!band->data) { 					continue; 				} 				for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 					if (!prc->cblks) { 						continue; 					} 					jpc_tagtree_copy(prc->savincltree, prc->incltree); 					jpc_tagtree_copy(prc->savnlibtree, prc->nlibtree); 					endcblks = &prc->cblks[prc->numcblks]; 					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						cblk->savedcurpass = cblk->curpass; 						cblk->savednumencpasses = cblk->numencpasses; 						cblk->savednumlenbits = cblk->numlenbits; 					} 				} 			} 		} 	}  }
static int file_write(jas_stream_obj_t *obj, char *buf, int cnt) { 	jas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj); 	return write(fileobj->fd, buf, cnt); }
double jpc_pow2i(int n) { 	double x; 	double a;  	x = 1.0; 	if (n < 0) { 		a = 0.5; 		n = -n; 	} else { 		a = 2.0; 	} 	while (--n >= 0) { 		x *= a; 	} 	return x; }
int jas_stream_ungetc(jas_stream_t *stream, int c) { 	if (!stream->ptr_ || stream->ptr_ == stream->bufbase_) { 		return -1; 	}  	/* Reset the EOF indicator (since we now have at least one character 	  to read). */ 	stream->flags_ &= ~JAS_STREAM_EOF;  	--stream->rwcnt_; 	--stream->ptr_; 	++stream->cnt_; 	*stream->ptr_ = c; 	return 0; }
int jpc_enc_enccblk(jpc_enc_t *enc, jas_stream_t *out, jpc_enc_tcmpt_t *tcmpt, jpc_enc_band_t *band, jpc_enc_cblk_t *cblk) { 	jpc_enc_pass_t *pass; 	jpc_enc_pass_t *endpasses; 	int bitpos; 	int n; 	int adjust; 	int ret; 	int passtype; 	int t; 	jpc_bitstream_t *bout; 	jpc_enc_pass_t *termpass; 	jpc_enc_rlvl_t *rlvl; 	int vcausal; 	int segsym; 	int termmode; 	int c;  	bout = 0; 	rlvl = band->rlvl;  	cblk->stream = jas_stream_memopen(0, 0); 	assert(cblk->stream); 	cblk->mqenc = jpc_mqenc_create(JPC_NUMCTXS, cblk->stream); 	assert(cblk->mqenc); 	jpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);  	cblk->numpasses = (cblk->numbps > 0) ? (3 * cblk->numbps - 2) : 0; 	if (cblk->numpasses > 0) { 		cblk->passes = jas_malloc(cblk->numpasses * sizeof(jpc_enc_pass_t)); 		assert(cblk->passes); 	} else { 		cblk->passes = 0; 	} 	endpasses = &cblk->passes[cblk->numpasses]; 	for (pass = cblk->passes; pass != endpasses; ++pass) { 		pass->start = 0; 		pass->end = 0; 		pass->term = JPC_ISTERMINATED(pass - cblk->passes, 0, cblk->numpasses, (tcmpt->cblksty & JPC_COX_TERMALL) != 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0); 		pass->type = JPC_SEGTYPE(pass - cblk->passes, 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0); 		pass->lyrno = -1; if (pass == endpasses - 1) { assert(pass->term == 1); 	pass->term = 1; } 	}  	cblk->flags = jas_matrix_create(jas_matrix_numrows(cblk->data) + 2, 	  jas_matrix_numcols(cblk->data) + 2); 	assert(cblk->flags);   	bitpos = cblk->numbps - 1; 	pass = cblk->passes; 	n = cblk->numpasses; 	while (--n >= 0) {  		if (pass->type == JPC_SEG_MQ) { 			/* NOP */ 		} else { 			assert(pass->type == JPC_SEG_RAW); 			if (!bout) { 				bout = jpc_bitstream_sopen(cblk->stream, "w"); 				assert(bout); 			} 		}  #if 1 		passtype = (pass - cblk->passes + 2) % 3; #else 		passtype = JPC_PASSTYPE(pass - cblk->passes + 2); #endif 		pass->start = jas_stream_tell(cblk->stream); #if 0 assert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream)); #endif 		assert(bitpos >= 0); 		vcausal = (tcmpt->cblksty & JPC_COX_VSC) != 0; 		segsym = (tcmpt->cblksty & JPC_COX_SEGSYM) != 0; 		if (pass->term) { 			termmode = ((tcmpt->cblksty & JPC_COX_PTERM) ? 			  JPC_MQENC_PTERM : JPC_MQENC_DEFTERM) + 1; 		} else { 			termmode = 0; 		} 		switch (passtype) { 		case JPC_SIGPASS: 			ret = (pass->type == JPC_SEG_MQ) ? jpc_encsigpass(cblk->mqenc, 			  bitpos, band->orient, vcausal, cblk->flags, 			  cblk->data, termmode, &pass->nmsedec) : 			  jpc_encrawsigpass(bout, bitpos, vcausal, cblk->flags, 			  cblk->data, termmode, &pass->nmsedec); 			break; 		case JPC_REFPASS: 			ret = (pass->type == JPC_SEG_MQ) ? jpc_encrefpass(cblk->mqenc, 			  bitpos, vcausal, cblk->flags, cblk->data, termmode, 			  &pass->nmsedec) : jpc_encrawrefpass(bout, bitpos, 			  vcausal, cblk->flags, cblk->data, termmode, 			  &pass->nmsedec); 			break; 		case JPC_CLNPASS: 			assert(pass->type == JPC_SEG_MQ); 			ret = jpc_encclnpass(cblk->mqenc, bitpos, band->orient, 			  vcausal, segsym, cblk->flags, cblk->data, termmode, 			  &pass->nmsedec); 			break; 		default: 			assert(0); 			break; 		}  		if (pass->type == JPC_SEG_MQ) { 			if (pass->term) { 				jpc_mqenc_init(cblk->mqenc); 			} 			jpc_mqenc_getstate(cblk->mqenc, &pass->mqencstate); 			pass->end = jas_stream_tell(cblk->stream); 			if (tcmpt->cblksty & JPC_COX_RESET) { 				jpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs); 			} 		} else { 			if (pass->term) { 				if (jpc_bitstream_pending(bout)) { 					jpc_bitstream_outalign(bout, 0x2a); 				} 				jpc_bitstream_close(bout); 				bout = 0; 				pass->end = jas_stream_tell(cblk->stream); 			} else { 				pass->end = jas_stream_tell(cblk->stream) + 				  jpc_bitstream_pending(bout); /* NOTE - This will not work.  need to adjust by # of pending output bytes */ 			} 		} #if 0 /* XXX - This assertion fails sometimes when various coding modes are used. This seems to be harmless, but why does it happen at all? */ assert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream)); #endif  		pass->wmsedec = jpc_fixtodbl(band->rlvl->tcmpt->synweight) * 		  jpc_fixtodbl(band->rlvl->tcmpt->synweight) * 		  jpc_fixtodbl(band->synweight) * 		  jpc_fixtodbl(band->synweight) * 		  jpc_fixtodbl(band->absstepsize) * jpc_fixtodbl(band->absstepsize) * 		  ((double) (1 << bitpos)) * ((double)(1 << bitpos)) * 		  jpc_fixtodbl(pass->nmsedec); 		pass->cumwmsedec = pass->wmsedec; 		if (pass != cblk->passes) { 			pass->cumwmsedec += pass[-1].cumwmsedec; 		} 		if (passtype == JPC_CLNPASS) { 			--bitpos; 		} 		++pass; 	}  #if 0 dump_passes(cblk->passes, cblk->numpasses, cblk); #endif  	n = 0; 	endpasses = &cblk->passes[cblk->numpasses]; 	for (pass = cblk->passes; pass != endpasses; ++pass) { 		if (pass->start < n) { 			pass->start = n; 		} 		if (pass->end < n) { 			pass->end = n; 		} 		if (!pass->term) { 			termpass = pass; 			while (termpass - pass < cblk->numpasses && 			  !termpass->term) { 				++termpass; 			} 			if (pass->type == JPC_SEG_MQ) { 				t = (pass->mqencstate.lastbyte == 0xff) ? 1 : 0; 				if (pass->mqencstate.ctreg >= 5) { 					adjust = 4 + t; 				} else { 					adjust = 5 + t; 				} 				pass->end += adjust; 			} 			if (pass->end > termpass->end) { 				pass->end = termpass->end; 			} 			if ((c = getthebyte(cblk->stream, pass->end - 1)) == EOF) { 				abort(); 			} 			if (c == 0xff) { 				++pass->end; 			} 			n = JAS_MAX(n, pass->end); 		} else { 			n = JAS_MAX(n, pass->end); 		} 	}  #if 0 dump_passes(cblk->passes, cblk->numpasses, cblk); #endif  	if (bout) { 		jpc_bitstream_close(bout); 	}  	return 0; }
void jas_iccattrval_destroy(jas_iccattrval_t *attrval) { #if 0 jas_eprintf("refcnt=%d\n", attrval->refcnt); #endif 	if (--attrval->refcnt <= 0) { 		if (attrval->ops->destroy) 			(*attrval->ops->destroy)(attrval); 		jas_free(attrval); 	} }
static jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd) { 	jas_seqent_t ret; 	v &= JAS_ONES(prec); 	ret = (sgnd && (v & (1 << (prec - 1)))) ? (v - (1 << prec)) : v; 	return ret; }
jas_taginfo_t *jas_taginfos_lookup(jas_taginfo_t *taginfos, const char *name) { 	jas_taginfo_t *taginfo; 	taginfo = taginfos; 	while (taginfo->id >= 0) { 		if (!strcmp(taginfo->name, name)) { 			return taginfo; 		} 		++taginfo; 	} 	return 0; }
jas_stream_t *jas_stream_memopen(char *buf, int bufsize) { 	jas_stream_t *stream; 	jas_stream_memobj_t *obj;  	if (!(stream = jas_stream_create())) { 		return 0; 	}  	/* A stream associated with a memory buffer is always opened 	for both reading and writing in binary mode. */ 	stream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;  	/* Since the stream data is already resident in memory, buffering 	is not necessary. */ 	/* But... It still may be faster to use buffering anyways. */ 	jas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);  	/* Select the operations for a memory stream. */ 	stream->ops_ = &jas_stream_memops;  	/* Allocate memory for the underlying memory stream object. */ 	if (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) { 		jas_stream_destroy(stream); 		return 0; 	} 	stream->obj_ = (void *) obj;  	/* Initialize a few important members of the memory stream object. */ 	obj->myalloc_ = 0; 	obj->buf_ = 0;  	/* If the buffer size specified is nonpositive, then the buffer 	is allocated internally and automatically grown as needed. */ 	if (bufsize <= 0) { 		obj->bufsize_ = 1024; 		obj->growable_ = 1; 	} else { 		obj->bufsize_ = bufsize; 		obj->growable_ = 0; 	} 	if (buf) { 		obj->buf_ = (unsigned char *) buf; 	} else { 		obj->buf_ = jas_malloc(obj->bufsize_ * sizeof(char)); 		obj->myalloc_ = 1; 	} 	if (!obj->buf_) { 		jas_stream_close(stream); 		return 0; 	}  	if (bufsize > 0 && buf) { 		/* If a buffer was supplied by the caller and its length is positive, 		  make the associated buffer data appear in the stream initially. */ 		obj->len_ = bufsize; 	} else { 		/* The stream is initially empty. */ 		obj->len_ = 0; 	} 	obj->pos_ = 0; 	 	return stream; }
void jpc_init_t2state(jpc_enc_t *enc, int raflag) { /* It is assumed that band->numbps and cblk->numbps precomputed */  	jpc_enc_tcmpt_t *comp; 	jpc_enc_tcmpt_t *endcomps; 	jpc_enc_rlvl_t *lvl; 	jpc_enc_rlvl_t *endlvls; 	jpc_enc_band_t *band; 	jpc_enc_band_t *endbands; 	jpc_enc_cblk_t *cblk; 	jpc_enc_cblk_t *endcblks; 	jpc_enc_pass_t *pass; 	jpc_enc_pass_t *endpasses; 	jpc_tagtreenode_t *leaf; 	jpc_enc_tile_t *tile; 	int prcno; 	jpc_enc_prc_t *prc;  	tile = enc->curtile;  	endcomps = &tile->tcmpts[tile->numtcmpts]; 	for (comp = tile->tcmpts; comp != endcomps; ++comp) { 		endlvls = &comp->rlvls[comp->numrlvls]; 		for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 			if (!lvl->bands) { 				continue; 			} 			endbands = &lvl->bands[lvl->numbands]; 			for (band = lvl->bands; band != endbands; ++band) { 				if (!band->data) { 					continue; 				} 				for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 					if (!prc->cblks) { 						continue; 					} 					jpc_tagtree_reset(prc->incltree); 					jpc_tagtree_reset(prc->nlibtree); 					endcblks = &prc->cblks[prc->numcblks]; 					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						if (jas_stream_rewind(cblk->stream)) { 							assert(0); 						} 						cblk->curpass = (cblk->numpasses > 0) ? cblk->passes : 0; 						cblk->numencpasses = 0; 						cblk->numlenbits = 3; 						cblk->numimsbs = band->numbps - cblk->numbps; 						assert(cblk->numimsbs >= 0); 						leaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks); 						jpc_tagtree_setvalue(prc->nlibtree, leaf, cblk->numimsbs);  						if (raflag) { 							endpasses = &cblk->passes[cblk->numpasses]; 							for (pass = cblk->passes; pass != endpasses; ++pass) { 								pass->lyrno = -1; 								pass->lyrno = 0; 							} 						} 					} 				} 			} 		} 	}  }
jp2_boxinfo_t *jp2_boxinfolookup(int type) { 	jp2_boxinfo_t *boxinfo; 	for (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) { 		if (boxinfo->type == type) { 			return boxinfo; 		} 	} 	return &jp2_boxinfo_unk; }
static int pnm_getuintstr(jas_stream_t *in, uint_fast32_t *val) { 	uint_fast32_t v; 	int c;  	/* Discard any leading whitespace. */ 	do { 		if ((c = pnm_getc(in)) == EOF) { 			return -1; 		} 	} while (isspace(c));  	/* Parse the number. */ 	v = 0; 	while (isdigit(c)) { 		v = 10 * v + c - '0'; 		if ((c = pnm_getc(in)) < 0) { 			return -1; 		} 	}  	/* The number must be followed by whitespace. */ 	if (!isspace(c)) { 		return -1; 	}  	if (val) { 		*val = v; 	} 	return 0; }
void jpc_rct(jas_matrix_t *c0, jas_matrix_t *c1, jas_matrix_t *c2) { 	int numrows; 	int numcols; 	int i; 	int j; 	jpc_fix_t *c0p; 	jpc_fix_t *c1p; 	jpc_fix_t *c2p;  	numrows = jas_matrix_numrows(c0); 	numcols = jas_matrix_numcols(c0);  	/* All three matrices must have the same dimensions. */ 	assert(jas_matrix_numrows(c1) == numrows && jas_matrix_numcols(c1) == numcols 	  && jas_matrix_numrows(c2) == numrows && jas_matrix_numcols(c2) == numcols);  	for (i = 0; i < numrows; i++) { 		c0p = jas_matrix_getref(c0, i, 0); 		c1p = jas_matrix_getref(c1, i, 0); 		c2p = jas_matrix_getref(c2, i, 0); 		for (j = numcols; j > 0; --j) { 			int r; 			int g; 			int b; 			int y; 			int u; 			int v; 			r = *c0p; 			g = *c1p; 			b = *c2p; 			y = (r + (g << 1) + b) >> 2; 			u = b - g; 			v = r - g; 			*c0p++ = y; 			*c1p++ = u; 			*c2p++ = v; 		} 	} }
int jas_init() { 	jas_image_fmtops_t fmtops; 	int fmtid;  	fmtid = 0;  #if !defined(EXCLUDE_MIF_SUPPORT) 	fmtops.decode = mif_decode; 	fmtops.encode = mif_encode; 	fmtops.validate = mif_validate; 	jas_image_addfmt(fmtid, "mif", "mif", "My Image Format (MIF)", &fmtops); 	++fmtid; #endif  #if !defined(EXCLUDE_PNM_SUPPORT) 	fmtops.decode = pnm_decode; 	fmtops.encode = pnm_encode; 	fmtops.validate = pnm_validate; 	jas_image_addfmt(fmtid, "pnm", "pnm", "Portable Graymap/Pixmap (PNM)", 	  &fmtops); 	jas_image_addfmt(fmtid, "pnm", "pgm", "Portable Graymap/Pixmap (PNM)", 	  &fmtops); 	jas_image_addfmt(fmtid, "pnm", "ppm", "Portable Graymap/Pixmap (PNM)", 	  &fmtops); 	++fmtid; #endif  #if !defined(EXCLUDE_BMP_SUPPORT) 	fmtops.decode = bmp_decode; 	fmtops.encode = bmp_encode; 	fmtops.validate = bmp_validate; 	jas_image_addfmt(fmtid, "bmp", "bmp", "Microsoft Bitmap (BMP)", &fmtops); 	++fmtid; #endif  #if !defined(EXCLUDE_RAS_SUPPORT) 	fmtops.decode = ras_decode; 	fmtops.encode = ras_encode; 	fmtops.validate = ras_validate; 	jas_image_addfmt(fmtid, "ras", "ras", "Sun Rasterfile (RAS)", &fmtops); 	++fmtid; #endif  #if !defined(EXCLUDE_JP2_SUPPORT) 	fmtops.decode = jp2_decode; 	fmtops.encode = jp2_encode; 	fmtops.validate = jp2_validate; 	jas_image_addfmt(fmtid, "jp2", "jp2", 	  "JPEG-2000 JP2 File Format Syntax (ISO/IEC 15444-1)", &fmtops); 	++fmtid; 	fmtops.decode = jpc_decode; 	fmtops.encode = jpc_encode; 	fmtops.validate = jpc_validate; 	jas_image_addfmt(fmtid, "jpc", "jpc", 	  "JPEG-2000 Code Stream Syntax (ISO/IEC 15444-1)", &fmtops); 	++fmtid; #endif  #if !defined(EXCLUDE_JPG_SUPPORT) 	fmtops.decode = jpg_decode; 	fmtops.encode = jpg_encode; 	fmtops.validate = jpg_validate; 	jas_image_addfmt(fmtid, "jpg", "jpg", "JPEG (ISO/IEC 10918-1)", &fmtops); 	++fmtid; #endif  #if !defined(EXCLUDE_PGX_SUPPORT) 	fmtops.decode = pgx_decode; 	fmtops.encode = pgx_encode; 	fmtops.validate = pgx_validate; 	jas_image_addfmt(fmtid, "pgx", "pgx", "JPEG-2000 VM Format (PGX)", &fmtops); 	++fmtid; #endif  	/* We must not register the JasPer library exit handler until after 	at least one memory allocation is performed.  This is desirable 	as it ensures that the JasPer exit handler is called before the 	debug memory allocator exit handler. */ 	atexit(jas_cleanup);  	return 0; }
int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v) { 	int m;  	/* We can reliably put at most 31 bits since ISO/IEC 9899 only 	  guarantees that a long can represent values up to 2^31-1. */ 	assert(n >= 0 && n < 32); 	/* Ensure that only the bits to be output are nonzero. */ 	assert(!(v & (~JAS_ONES(n))));  	/* Put the desired number of bits to the specified bit stream. */ 	m = n - 1; 	while (--n >= 0) { 		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) { 			return EOF; 		} 		v <<= 1; 	} 	return 0; }
void jpc_ft_fwdlift_row(jpc_fix_t *a, int numcols, int parity) {  	register jpc_fix_t *lptr; 	register jpc_fix_t *hptr; 	register int n; 	int llen;  	llen = (numcols + 1 - parity) >> 1;  	if (numcols > 1) {  		/* Apply the first lifting step. */ 		lptr = &a[0]; 		hptr = &a[llen]; 		if (parity) { 			hptr[0] -= lptr[0]; 			++hptr; 		} 		n = numcols - llen - parity - (parity == (numcols & 1)); 		while (n-- > 0) { 			hptr[0] -= (lptr[0] + lptr[1]) >> 1; 			++hptr; 			++lptr; 		} 		if (parity == (numcols & 1)) { 			hptr[0] -= lptr[0]; 		}  		/* Apply the second lifting step. */ 		lptr = &a[0]; 		hptr = &a[llen]; 		if (!parity) { 			lptr[0] += (hptr[0] + 1) >> 1; 			++lptr; 		} 		n = llen - (!parity) - (parity != (numcols & 1)); 		while (n-- > 0) { 			lptr[0] += (hptr[0] + hptr[1] + 2) >> 2; 			++lptr; 			++hptr; 		} 		if (parity != (numcols & 1)) { 			lptr[0] += (hptr[0] + 1) >> 1; 		}  	} else {  		if (parity) { 			lptr = &a[0]; 			lptr[0] <<= 1; 		}  	}  }
static uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd) { 	uint_fast32_t ret; 	ret = ((sgnd && v < 0) ? ((1 << prec) + v) : v) & JAS_ONES(prec); 	return ret; }
static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val) { 	int i; 	int c; 	ulonglong v; 	v = 0; 	for (i = n; i > 0; --i) { 		if ((c = jas_stream_getc(in)) == EOF) 			return -1; 		v = (v << 8) | c; 	} 	*val = v; 	return 0; }
static int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out) { 	jpc_cod_t *cod = &ms->parms.cod; 	assert(cod->numlyrs > 0 && cod->compparms.numdlvls <= 32); 	assert(cod->compparms.numdlvls == cod->compparms.numrlvls - 1); 	if (jpc_putuint8(out, cod->compparms.csty) || 	  jpc_putuint8(out, cod->prg) || 	  jpc_putuint16(out, cod->numlyrs) || 	  jpc_putuint8(out, cod->mctrans)) { 		return -1; 	} 	if (jpc_cox_putcompparms(ms, cstate, out, 	  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) { 		return -1; 	} 	return 0; }
int jpc_tsfb_getbands(jpc_tsfb_t *tsfb, uint_fast32_t xstart,   uint_fast32_t ystart, uint_fast32_t xend, uint_fast32_t yend,   jpc_tsfb_band_t *bands) { 	jpc_tsfb_band_t *band;  	band = bands; 	if (tsfb->numlvls > 0) { 		jpc_tsfb_getbands2(tsfb, xstart, ystart, xstart, ystart, xend, yend, 		  &band, tsfb->numlvls); 	} else {  		band->xstart = xstart; 		band->ystart = ystart; 		band->xend = xend; 		band->yend = yend; 		band->locxstart = xstart; 		band->locystart = ystart; 		band->locxend = band->locxstart + band->xend - band->xstart; 		band->locyend = band->locystart + band->yend - band->ystart; 		band->orient = JPC_TSFB_LL; 		band->synenergywt = JPC_FIX_ONE; 		++band; 	} 	return band - bands; }
jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv) { 	int nplh[JPC_TAGTREE_MAXDEPTH]; 	int nplv[JPC_TAGTREE_MAXDEPTH]; 	jpc_tagtreenode_t *node; 	jpc_tagtreenode_t *parentnode; 	jpc_tagtreenode_t *parentnode0; 	jpc_tagtree_t *tree; 	int i; 	int j; 	int k; 	int numlvls; 	int n;  	assert(numleafsh > 0 && numleafsv > 0);  	if (!(tree = jpc_tagtree_alloc())) { 		return 0; 	} 	tree->numleafsh_ = numleafsh; 	tree->numleafsv_ = numleafsv;  	numlvls = 0; 	nplh[0] = numleafsh; 	nplv[0] = numleafsv; 	do { 		n = nplh[numlvls] * nplv[numlvls]; 		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2; 		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2; 		tree->numnodes_ += n; 		++numlvls; 	} while (n > 1);  	if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) { 		return 0; 	}  	/* Initialize the parent links for all nodes in the tree. */  	node = tree->nodes_; 	parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_]; 	parentnode0 = parentnode;  	for (i = 0; i < numlvls - 1; ++i) { 		for (j = 0; j < nplv[i]; ++j) { 			k = nplh[i]; 			while (--k >= 0) { 				node->parent_ = parentnode; 				++node; 				if (--k >= 0) { 					node->parent_ = parentnode; 					++node; 				} 				++parentnode; 			} 			if ((j & 1) || j == nplv[i] - 1) { 				parentnode0 = parentnode; 			} else { 				parentnode = parentnode0; 				parentnode0 += nplh[i]; 			} 		} 	} 	node->parent_ = 0;  	/* Initialize the data values to something sane. */  	jpc_tagtree_reset(tree);  	return tree; }
int jas_iccprof_gethdr(jas_iccprof_t *prof, jas_icchdr_t *hdr) { 	*hdr = prof->hdr; 	return 0; }
int jpc_ft_analyze(jpc_fix_t *a, int xstart, int ystart, int width, int height,   int stride) { 	int numrows = height; 	int numcols = width; 	int rowparity = ystart & 1; 	int colparity = xstart & 1; 	int i; 	jpc_fix_t *startptr; 	int maxcols;  	maxcols = (numcols / JPC_QMFB_COLGRPSIZE) * JPC_QMFB_COLGRPSIZE; 	startptr = &a[0]; 	for (i = 0; i < maxcols; i += JPC_QMFB_COLGRPSIZE) { 		jpc_qmfb_split_colgrp(startptr, numrows, stride, rowparity); 		jpc_ft_fwdlift_colgrp(startptr, numrows, stride, rowparity); 		startptr += JPC_QMFB_COLGRPSIZE; 	} 	if (maxcols < numcols) { 		jpc_qmfb_split_colres(startptr, numrows, numcols - maxcols, stride, 		  rowparity); 		jpc_ft_fwdlift_colres(startptr, numrows, numcols - maxcols, stride, 		  rowparity); 	}  	startptr = &a[0]; 	for (i = 0; i < numrows; ++i) { 		jpc_qmfb_split_row(startptr, numcols, colparity); 		jpc_ft_fwdlift_row(startptr, numcols, colparity); 		startptr += stride; 	}  	return 0;  }
int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n) { 	int all; 	int c; 	int m;  	all = (n < 0) ? 1 : 0;  	m = n; 	while (all || m > 0) { 		if ((c = jas_stream_getc_macro(in)) == EOF) { 			/* The next character of input could not be read. */ 			/* Return with an error if an I/O error occured 			  (not including EOF) or if an explicit copy count 			  was specified. */ 			return (!all || jas_stream_error(in)) ? (-1) : 0; 		} 		if (jas_stream_putc_macro(out, c) == EOF) { 			return -1; 		} 		--m; 	} 	return 0; }
int jpc_enc_encpkts(jpc_enc_t *enc, jas_stream_t *out) { 	jpc_enc_tile_t *tile; 	jpc_pi_t *pi;  	tile = enc->curtile;  	jpc_init_t2state(enc, 0); 	pi = tile->pi; 	jpc_pi_init(pi);  	if (!jpc_pi_next(pi)) { 		for (;;) { 			if (jpc_enc_encpkt(enc, out, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi), 			  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) { 				return -1; 			} 			if (jpc_pi_next(pi)) { 				break; 			} 		} 	} 	 	return 0; }
int JPC_NOMINALGAIN(int qmfbid, int numlvls, int lvlno, int orient) { 	/* Avoid compiler warnings about unused parameters. */ 	numlvls = 0;  if (qmfbid == JPC_COX_INS) { 	return 0; } 	assert(qmfbid == JPC_COX_RFT); 	if (lvlno == 0) { 		assert(orient == JPC_TSFB_LL); 		return 0; 	} else { 		switch (orient) { 		case JPC_TSFB_LH: 		case JPC_TSFB_HL: 			return 1; 			break; 		case JPC_TSFB_HH: 			return 2; 			break; 		} 	} 	abort(); }
void jpc_tagtree_copy(jpc_tagtree_t *dsttree, jpc_tagtree_t *srctree) { 	int n; 	jpc_tagtreenode_t *srcnode; 	jpc_tagtreenode_t *dstnode;  	/* The two tag trees must have similar sizes. */ 	assert(srctree->numleafsh_ == dsttree->numleafsh_ && 	  srctree->numleafsv_ == dsttree->numleafsv_);  	n = srctree->numnodes_; 	srcnode = srctree->nodes_; 	dstnode = dsttree->nodes_; 	while (--n >= 0) { 		dstnode->value_ = srcnode->value_; 		dstnode->low_ = srcnode->low_; 		dstnode->known_ = srcnode->known_; 		++dstnode; 		++srcnode; 	} }
jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len) { 	jas_stream_t *in; 	jas_iccprof_t *prof; 	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len))) 		goto error; 	if (!(prof = jas_iccprof_load(in))) 		goto error; 	jas_stream_close(in); 	return prof; error: 	return 0; }
static void jas_cmpxformseq_destroy(jas_cmpxformseq_t *pxformseq) { 	while (pxformseq->numpxforms > 0) 		jas_cmpxformseq_delete(pxformseq, pxformseq->numpxforms - 1); 	if (pxformseq->pxforms) 		jas_free(pxformseq->pxforms); 	jas_free(pxformseq); }
void jpc_mqenc_setctxs(jpc_mqenc_t *mqenc, int numctxs, jpc_mqctx_t *ctxs) { 	jpc_mqstate_t **ctx; 	int n;  	ctx = mqenc->ctxs; 	n = JAS_MIN(mqenc->maxctxs, numctxs); 	while (--n >= 0) { 		*ctx = &jpc_mqstates[2 * ctxs->ind + ctxs->mps]; 		++ctx; 		++ctxs; 	} 	n = mqenc->maxctxs - numctxs; 	while (--n >= 0) { 		*ctx = &jpc_mqstates[0]; 		++ctx; 	}  }
void jp2_box_destroy(jp2_box_t *box) { 	if (box->ops->destroy) { 		(*box->ops->destroy)(box); 	} 	jas_free(box); }
static int jas_iccgetxyz(jas_stream_t *in, jas_iccxyz_t *xyz) { 	if (jas_iccgetsint32(in, &xyz->x) || 	  jas_iccgetsint32(in, &xyz->y) || 	  jas_iccgetsint32(in, &xyz->z)) { 		return -1; 	} 	return 0; }
void jpc_enc_cp_destroy(jpc_enc_cp_t *cp) { 	if (cp->ccps) { 		if (cp->tcp.ilyrrates) { 			jas_free(cp->tcp.ilyrrates); 		} 		jas_free(cp->ccps); 	} 	jas_free(cp); }
static jas_iccattrtab_t *jas_iccattrtab_copy(jas_iccattrtab_t *attrtab) { 	jas_iccattrtab_t *newattrtab; 	int i; 	if (!(newattrtab = jas_iccattrtab_create())) 		goto error; 	for (i = 0; i < attrtab->numattrs; ++i) { 		if (jas_iccattrtab_add(newattrtab, i, attrtab->attrs[i].name, 		  attrtab->attrs[i].val)) 			goto error; 	} 	return newattrtab; error: 	return 0; }
int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,   jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,   jas_matrix_t *data) { 	jas_image_cmpt_t *cmpt; 	jas_image_coord_t i; 	jas_image_coord_t j; 	int k; 	jas_seqent_t v; 	int c; 	jas_seqent_t *dr; 	jas_seqent_t *d; 	int drs;  	if (cmptno < 0 || cmptno >= image->numcmpts_) { 		return -1; 	}  	cmpt = image->cmpts_[cmptno]; 	if (x >= cmpt->width_ || y >= cmpt->height_ || 	  x + width > cmpt->width_ || 	  y + height > cmpt->height_) { 		return -1; 	}  	if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) { 		if (jas_matrix_resize(data, height, width)) { 			return -1; 		} 	}  	dr = jas_matrix_getref(data, 0, 0); 	drs = jas_matrix_rowstep(data); 	for (i = 0; i < height; ++i, dr += drs) { 		d = dr; 		if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x) 		  * cmpt->cps_, SEEK_SET) < 0) { 			return -1; 		} 		for (j = width; j > 0; --j, ++d) { 			v = 0; 			for (k = cmpt->cps_; k > 0; --k) { 				if ((c = jas_stream_getc(cmpt->stream_)) == EOF) { 					return -1; 				} 				v = (v << 8) | (c & 0xff); 			} 			*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_); 		} 	}  	return 0; }
static int jas_icctxtdesc_input(jas_iccattrval_t *attrval, jas_stream_t *in,   int cnt) { 	int n; 	int c; 	jas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc; 	txtdesc->ascdata = 0; 	txtdesc->ucdata = 0; 	if (jas_iccgetuint32(in, &txtdesc->asclen)) 		goto error; 	if (!(txtdesc->ascdata = jas_malloc(txtdesc->asclen))) 		goto error; 	if (jas_stream_read(in, txtdesc->ascdata, txtdesc->asclen) != 	  JAS_CAST(int, txtdesc->asclen)) 		goto error; 	txtdesc->ascdata[txtdesc->asclen - 1] = '\0'; 	if (jas_iccgetuint32(in, &txtdesc->uclangcode) || 	  jas_iccgetuint32(in, &txtdesc->uclen)) 		goto error; 	if (!(txtdesc->ucdata = jas_malloc(txtdesc->uclen * 2))) 		goto error; 	if (jas_stream_read(in, txtdesc->ucdata, txtdesc->uclen * 2) != 	  JAS_CAST(int, txtdesc->uclen * 2)) 		goto error; 	if (jas_iccgetuint16(in, &txtdesc->sccode)) 		goto error; 	if ((c = jas_stream_getc(in)) == EOF) 		goto error; 	txtdesc->maclen = c; 	if (jas_stream_read(in, txtdesc->macdata, 67) != 67) 		goto error; 	txtdesc->asclen = strlen(txtdesc->ascdata) + 1; #define WORKAROUND_BAD_PROFILES #ifdef WORKAROUND_BAD_PROFILES 	n = txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67; 	if (n > cnt) { 		return -1; 	} 	if (n < cnt) { 		if (jas_stream_gobble(in, cnt - n) != cnt - n) 			goto error; 	} #else 	if (txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67 != cnt) 		return -1; #endif 	return 0; error: 	jas_icctxtdesc_destroy(attrval); 	return -1; }
jpc_pi_t *jpc_pi_create0() { 	jpc_pi_t *pi; 	if (!(pi = jas_malloc(sizeof(jpc_pi_t)))) { 		return 0; 	} 	pi->picomps = 0; 	pi->pchgno = 0; 	if (!(pi->pchglist = jpc_pchglist_create())) { 		jas_free(pi); 		return 0; 	} 	return pi; }
static int jas_iccattrtab_resize(jas_iccattrtab_t *tab, int maxents) { 	jas_iccattr_t *newattrs; 	assert(maxents >= tab->numattrs); 	newattrs = tab->attrs ? jas_realloc(tab->attrs, maxents * 	  sizeof(jas_iccattr_t)) : jas_malloc(maxents * sizeof(jas_iccattr_t)); 	if (!newattrs) 		return -1; 	tab->attrs = newattrs; 	tab->maxattrs = maxents; 	return 0; }
static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn) { 	int p; 	uint_fast32_t mant; 	uint_fast32_t expn; 	int n;  	if (absdelta < 0) { 		abort(); 	}  	p = jpc_firstone(absdelta) - JPC_FIX_FRACBITS; 	n = 11 - jpc_firstone(absdelta); 	mant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff; 	expn = scaleexpn - p; 	if (scaleexpn < p) { 		abort(); 	} 	return JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant); }
jas_iccprof_t *jas_iccprof_load(jas_stream_t *in) { 	jas_iccprof_t *prof; 	int numtags; 	long curoff; 	long reloff; 	long prevoff; 	jas_iccsig_t type; 	jas_iccattrval_t *attrval; 	jas_iccattrval_t *prevattrval; 	jas_icctagtabent_t *tagtabent; 	jas_iccattrvalinfo_t *attrvalinfo; 	int i; 	int len;  	prof = 0; 	attrval = 0;  	if (!(prof = jas_iccprof_create())) { 		goto error; 	}  	if (jas_iccprof_readhdr(in, &prof->hdr)) { 		jas_eprintf("cannot get header\n"); 		goto error; 	} 	if (jas_iccprof_gettagtab(in, &prof->tagtab)) { 		jas_eprintf("cannot get tab table\n"); 		goto error; 	} 	jas_iccprof_sorttagtab(&prof->tagtab);  	numtags = prof->tagtab.numents; 	curoff = JAS_ICC_HDRLEN + 4 + 12 * numtags; 	prevoff = 0; 	prevattrval = 0; 	for (i = 0; i < numtags; ++i) { 		tagtabent = &prof->tagtab.ents[i]; 		if (tagtabent->off == JAS_CAST(jas_iccuint32_t, prevoff)) { 			if (prevattrval) { 				if (!(attrval = jas_iccattrval_clone(prevattrval))) 					goto error; 				if (jas_iccprof_setattr(prof, tagtabent->tag, attrval)) 					goto error; 				jas_iccattrval_destroy(attrval); 			} else { #if 0 				jas_eprintf("warning: skipping unknown tag type\n"); #endif 			} 			continue; 		} 		reloff = tagtabent->off - curoff; 		if (reloff > 0) { 			if (jas_stream_gobble(in, reloff) != reloff) 				goto error; 			curoff += reloff; 		} else if (reloff < 0) { 			/* This should never happen since we read the tagged 			element data in a single pass. */ 			abort(); 		} 		prevoff = curoff; 		if (jas_iccgetuint32(in, &type)) { 			goto error; 		} 		if (jas_stream_gobble(in, 4) != 4) { 			goto error; 		} 		curoff += 8; 		if (!(attrvalinfo = jas_iccattrvalinfo_lookup(type))) { #if 0 			jas_eprintf("warning: skipping unknown tag type\n"); #endif 			prevattrval = 0; 			continue; 		} 		if (!(attrval = jas_iccattrval_create(type))) { 			goto error; 		} 		len = tagtabent->len - 8; 		if ((*attrval->ops->input)(attrval, in, len)) { 			goto error; 		} 		curoff += len; 		if (jas_iccprof_setattr(prof, tagtabent->tag, attrval)) { 			goto error; 		} 		prevattrval = attrval; /* This is correct, but slimey. */ 		jas_iccattrval_destroy(attrval); 		attrval = 0; 	}  	return prof;  error: 	if (prof) 		jas_iccprof_destroy(prof); 	if (attrval) 		jas_iccattrval_destroy(attrval); 	return 0; }
static int jas_icctxt_input(jas_iccattrval_t *attrval, jas_stream_t *in,   int cnt) { 	jas_icctxt_t *txt = &attrval->data.txt; 	txt->string = 0; 	if (!(txt->string = jas_malloc(cnt))) 		goto error; 	if (jas_stream_read(in, txt->string, cnt) != cnt) 		goto error; 	txt->string[cnt - 1] = '\0'; 	if (JAS_CAST(int, strlen(txt->string)) + 1 != cnt) 		goto error; 	return 0; error: 	if (txt->string) 		jas_free(txt->string); 	return -1; }
static void jpc_qcd_destroyparms(jpc_ms_t *ms) { 	jpc_qcd_t *qcd = &ms->parms.qcd; 	jpc_qcx_destroycompparms(&qcd->compparms); }
int jpc_bitstream_align(jpc_bitstream_t *bitstream) { 	int ret; 	if (bitstream->openmode_ & JPC_BITSTREAM_READ) { 		ret = jpc_bitstream_inalign(bitstream, 0, 0); 	} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) { 		ret = jpc_bitstream_outalign(bitstream, 0); 	} else { 		abort(); 	} 	return ret; }
void jpc_tsfb_getbands2(jpc_tsfb_t *tsfb, int locxstart, int locystart,   int xstart, int ystart, int xend, int yend, jpc_tsfb_band_t **bands,   int numlvls) { 	int newxstart; 	int newystart; 	int newxend; 	int newyend; 	jpc_tsfb_band_t *band;  	newxstart = JPC_CEILDIVPOW2(xstart, 1); 	newystart = JPC_CEILDIVPOW2(ystart, 1); 	newxend = JPC_CEILDIVPOW2(xend, 1); 	newyend = JPC_CEILDIVPOW2(yend, 1);  	if (numlvls > 0) {  		jpc_tsfb_getbands2(tsfb, locxstart, locystart, newxstart, newystart, 		  newxend, newyend, bands, numlvls - 1);  		band = *bands; 		band->xstart = JPC_FLOORDIVPOW2(xstart, 1); 		band->ystart = newystart; 		band->xend = JPC_FLOORDIVPOW2(xend, 1); 		band->yend = newyend; 		band->locxstart = locxstart + newxend - newxstart; 		band->locystart = locystart; 		band->locxend = band->locxstart + band->xend - band->xstart; 		band->locyend = band->locystart + band->yend - band->ystart; 		band->orient = JPC_TSFB_HL; 		band->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[ 		  tsfb->numlvls - numlvls] * tsfb->qmfb->lpenergywts[ 		  tsfb->numlvls - numlvls]); 		++(*bands);  		band = *bands; 		band->xstart = newxstart; 		band->ystart = JPC_FLOORDIVPOW2(ystart, 1); 		band->xend = newxend; 		band->yend = JPC_FLOORDIVPOW2(yend, 1); 		band->locxstart = locxstart; 		band->locystart = locystart + newyend - newystart; 		band->locxend = band->locxstart + band->xend - band->xstart; 		band->locyend = band->locystart + band->yend - band->ystart; 		band->orient = JPC_TSFB_LH; 		band->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[ 		  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[ 		  tsfb->numlvls - numlvls]); 		++(*bands);  		band = *bands; 		band->xstart = JPC_FLOORDIVPOW2(xstart, 1); 		band->ystart = JPC_FLOORDIVPOW2(ystart, 1); 		band->xend = JPC_FLOORDIVPOW2(xend, 1); 		band->yend = JPC_FLOORDIVPOW2(yend, 1); 		band->locxstart = locxstart + newxend - newxstart; 		band->locystart = locystart + newyend - newystart; 		band->locxend = band->locxstart + band->xend - band->xstart; 		band->locyend = band->locystart + band->yend - band->ystart; 		band->orient = JPC_TSFB_HH; 		band->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[ 		  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[ 		  tsfb->numlvls - numlvls]); 		++(*bands);  	} else {  		band = *bands; 		band->xstart = xstart; 		band->ystart = ystart; 		band->xend = xend; 		band->yend = yend; 		band->locxstart = locxstart; 		band->locystart = locystart; 		band->locxend = band->locxstart + band->xend - band->xstart; 		band->locyend = band->locystart + band->yend - band->ystart; 		band->orient = JPC_TSFB_LL; 		band->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[ 		  tsfb->numlvls - numlvls - 1] * tsfb->qmfb->lpenergywts[ 		  tsfb->numlvls - numlvls - 1]); 		++(*bands);  	}  }
int rateallocate(jpc_enc_t *enc, int numlyrs, uint_fast32_t *cumlens) { 	jpc_flt_t lo; 	jpc_flt_t hi; 	jas_stream_t *out; 	long cumlen; 	int lyrno; 	jpc_flt_t thresh; 	jpc_flt_t goodthresh; 	int success; 	long pos; 	long oldpos; 	int numiters;  	jpc_enc_tcmpt_t *comp; 	jpc_enc_tcmpt_t *endcomps; 	jpc_enc_rlvl_t *lvl; 	jpc_enc_rlvl_t *endlvls; 	jpc_enc_band_t *band; 	jpc_enc_band_t *endbands; 	jpc_enc_cblk_t *cblk; 	jpc_enc_cblk_t *endcblks; 	jpc_enc_pass_t *pass; 	jpc_enc_pass_t *endpasses; 	jpc_enc_pass_t *pass1; 	jpc_flt_t mxrdslope; 	jpc_flt_t mnrdslope; 	jpc_enc_tile_t *tile; 	jpc_enc_prc_t *prc; 	int prcno;  	tile = enc->curtile;  	for (lyrno = 1; lyrno < numlyrs - 1; ++lyrno) { 		if (cumlens[lyrno - 1] > cumlens[lyrno]) { 			abort(); 		} 	}  	if (!(out = jas_stream_memopen(0, 0))) { 		return -1; 	}   	/* Find minimum and maximum R-D slope values. */ 	mnrdslope = DBL_MAX; 	mxrdslope = 0; 	endcomps = &tile->tcmpts[tile->numtcmpts]; 	for (comp = tile->tcmpts; comp != endcomps; ++comp) { 		endlvls = &comp->rlvls[comp->numrlvls]; 		for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 			if (!lvl->bands) { 				continue; 			} 			endbands = &lvl->bands[lvl->numbands]; 			for (band = lvl->bands; band != endbands; ++band) { 				if (!band->data) { 					continue; 				} 				for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 					if (!prc->cblks) { 						continue; 					} 					endcblks = &prc->cblks[prc->numcblks]; 					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						calcrdslopes(cblk); 						endpasses = &cblk->passes[cblk->numpasses]; 						for (pass = cblk->passes; pass != endpasses; ++pass) { 							if (pass->rdslope > 0) { 								if (pass->rdslope < mnrdslope) { 									mnrdslope = pass->rdslope; 								} 								if (pass->rdslope > mxrdslope) { 									mxrdslope = pass->rdslope; 								} 							} 						} 					} 				} 			} 		} 	} if (jas_getdbglevel()) { 	jas_eprintf("min rdslope = %f max rdslope = %f\n", mnrdslope, mxrdslope); }  	jpc_init_t2state(enc, 1);  	for (lyrno = 0; lyrno < numlyrs; ++lyrno) {  		lo = mnrdslope; 		hi = mxrdslope;  		success = 0; 		goodthresh = 0; 		numiters = 0;  		do {  			cumlen = cumlens[lyrno]; 			if (cumlen == UINT_FAST32_MAX) { 				/* Only the last layer can be free of a rate 				  constraint (e.g., for lossless coding). */ 				assert(lyrno == numlyrs - 1); 				goodthresh = -1; 				success = 1; 				break; 			}  			thresh = (lo + hi) / 2;  			/* Save the tier 2 coding state. */ 			jpc_save_t2state(enc); 			oldpos = jas_stream_tell(out); 			assert(oldpos >= 0);  			/* Assign all passes with R-D slopes greater than or 			  equal to the current threshold to this layer. */ 			endcomps = &tile->tcmpts[tile->numtcmpts]; 			for (comp = tile->tcmpts; comp != endcomps; ++comp) { 				endlvls = &comp->rlvls[comp->numrlvls]; 				for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 					if (!lvl->bands) { 						continue; 					} 					endbands = &lvl->bands[lvl->numbands]; 					for (band = lvl->bands; band != endbands; ++band) { 						if (!band->data) { 							continue; 						} 						for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 							if (!prc->cblks) { 								continue; 							} 							endcblks = &prc->cblks[prc->numcblks]; 							for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 								if (cblk->curpass) { 									endpasses = &cblk->passes[cblk->numpasses]; 									pass1 = cblk->curpass; 									for (pass = cblk->curpass; pass != endpasses; ++pass) { 										if (pass->rdslope >= thresh) { 											pass1 = &pass[1]; 										} 									} 									for (pass = cblk->curpass; pass != pass1; ++pass) { 										pass->lyrno = lyrno; 									} 									for (; pass != endpasses; ++pass) { 										pass->lyrno = -1; 									} 								} 							} 						} 					} 				} 			}  			/* Perform tier 2 coding. */ 			endcomps = &tile->tcmpts[tile->numtcmpts]; 			for (comp = tile->tcmpts; comp != endcomps; ++comp) { 				endlvls = &comp->rlvls[comp->numrlvls]; 				for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 					if (!lvl->bands) { 						continue; 					} 					for (prcno = 0; prcno < lvl->numprcs; ++prcno) { 						if (jpc_enc_encpkt(enc, out, comp - tile->tcmpts, lvl - comp->rlvls, prcno, lyrno)) { 							return -1; 						} 					} 				} 			}  			pos = jas_stream_tell(out);  			/* Check the rate constraint. */ 			assert(pos >= 0); 			if (pos > cumlen) { 				/* The rate is too high. */ 				lo = thresh; 			} else if (pos <= cumlen) { 				/* The rate is low enough, so try higher. */ 				hi = thresh; 				if (!success || thresh < goodthresh) { 					goodthresh = thresh; 					success = 1; 				} 			}  			/* Save the tier 2 coding state. */ 			jpc_restore_t2state(enc); 			if (jas_stream_seek(out, oldpos, SEEK_SET) < 0) { 				abort(); 			}  if (jas_getdbglevel()) { jas_eprintf("maxlen=%08ld actuallen=%08ld thresh=%f\n", cumlen, pos, thresh); }  			++numiters; 		} while (lo < hi - 1e-3 && numiters < 32);  		if (!success) { 			jas_eprintf("warning: empty layer generated\n"); 		}  if (jas_getdbglevel()) { jas_eprintf("success %d goodthresh %f\n", success, goodthresh); }  		/* Assign all passes with R-D slopes greater than or 		  equal to the selected threshold to this layer. */ 		endcomps = &tile->tcmpts[tile->numtcmpts]; 		for (comp = tile->tcmpts; comp != endcomps; ++comp) { 			endlvls = &comp->rlvls[comp->numrlvls]; 			for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { if (!lvl->bands) { 	continue; } 				endbands = &lvl->bands[lvl->numbands]; 				for (band = lvl->bands; band != endbands; ++band) { 					if (!band->data) { 						continue; 					} 					for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 						if (!prc->cblks) { 							continue; 						} 						endcblks = &prc->cblks[prc->numcblks]; 						for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 							if (cblk->curpass) { 								endpasses = &cblk->passes[cblk->numpasses]; 								pass1 = cblk->curpass; 								if (success) { 									for (pass = cblk->curpass; pass != endpasses; ++pass) { 										if (pass->rdslope >= goodthresh) { 											pass1 = &pass[1]; 										} 									} 								} 								for (pass = cblk->curpass; pass != pass1; ++pass) { 									pass->lyrno = lyrno; 								} 								for (; pass != endpasses; ++pass) { 									pass->lyrno = -1; 								} 							} 						} 					} 				} 			} 		}  		/* Perform tier 2 coding. */ 		endcomps = &tile->tcmpts[tile->numtcmpts]; 		for (comp = tile->tcmpts; comp != endcomps; ++comp) { 			endlvls = &comp->rlvls[comp->numrlvls]; 			for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 				if (!lvl->bands) { 					continue; 				} 				for (prcno = 0; prcno < lvl->numprcs; ++prcno) { 					if (jpc_enc_encpkt(enc, out, comp - tile->tcmpts, lvl - comp->rlvls, prcno, lyrno)) { 						return -1; 					} 				} 			} 		} 	}  	if (jas_getdbglevel() >= 5) { 		dump_layeringinfo(enc); 	}  	jas_stream_close(out);  	JAS_DBGLOG(10, ("done doing rateallocation\n")); #if 0 jas_eprintf("DONE RATE ALLOCATE\n"); #endif  	return 0; }
int jpc_putms(jas_stream_t *out, jpc_cstate_t *cstate, jpc_ms_t *ms) { 	jas_stream_t *tmpstream; 	int len;  	/* Output the marker segment type. */ 	if (jpc_putuint16(out, ms->id)) { 		return -1; 	}  	/* Output the marker segment length and parameters if necessary. */ 	if (ms->ops->putparms) { 		/* Create a temporary stream in which to buffer the 		  parameter data. */ 		if (!(tmpstream = jas_stream_memopen(0, 0))) { 			return -1; 		} 		if ((*ms->ops->putparms)(ms, cstate, tmpstream)) { 			jas_stream_close(tmpstream); 			return -1; 		} 		/* Get the number of bytes of parameter data written. */ 		if ((len = jas_stream_tell(tmpstream)) < 0) { 			jas_stream_close(tmpstream); 			return -1; 		} 		ms->len = len; 		/* Write the marker segment length and parameter data to 		  the output stream. */ 		if (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 || 		  jpc_putuint16(out, ms->len + 2) || 		  jas_stream_copy(out, tmpstream, ms->len) < 0) { 			jas_stream_close(tmpstream); 			return -1; 		} 		/* Close the temporary stream. */ 		jas_stream_close(tmpstream); 	}  	/* This is a bit of a hack, but I'm not going to define another 	  type of virtual function for this one special case. */ 	if (ms->id == JPC_MS_SIZ) { 		cstate->numcomps = ms->parms.siz.numcomps; 	}  	if (jas_getdbglevel() > 0) { 		jpc_ms_dump(ms, stderr); 	}  	return 0; }
static int pnm_getint16(jas_stream_t *in, int *val) { 	int v; 	int c;  	if ((c = jas_stream_getc(in)) == EOF) { 		return -1; 	} 	v = c & 0xff; 	if ((c = jas_stream_getc(in)) == EOF) { 		return -1; 	} 	v = (v << 8) | (c & 0xff); 	*val = v;  	return 0; }
int jpc_putuint32(jas_stream_t *out, uint_fast32_t val) { 	if (jas_stream_putc(out, (val >> 24) & 0xff) == EOF || 	  jas_stream_putc(out, (val >> 16) & 0xff) == EOF || 	  jas_stream_putc(out, (val >> 8) & 0xff) == EOF || 	  jas_stream_putc(out, val & 0xff) == EOF) { 		return -1; 	} 	return 0; }
int pnm_validate(jas_stream_t *in) { 	uchar buf[2]; 	int i; 	int n;  	assert(JAS_STREAM_MAXPUTBACK >= 2);  	/* Read the first two characters that constitute the signature. */ 	if ((n = jas_stream_read(in, buf, 2)) < 0) { 		return -1; 	} 	/* Put these characters back to the stream. */ 	for (i = n - 1; i >= 0; --i) { 		if (jas_stream_ungetc(in, buf[i]) == EOF) { 			return -1; 		} 	} 	/* Did we read enough data? */ 	if (n < 2) { 		return -1; 	} 	/* Is this the correct signature for a PNM file? */ 	if (buf[0] == 'P' && isdigit(buf[1])) { 		return 0; 	} 	return -1; }
void jpc_mqenc_getstate(jpc_mqenc_t *mqenc, jpc_mqencstate_t *state) { 	state->areg = mqenc->areg; 	state->creg = mqenc->creg; 	state->ctreg = mqenc->ctreg; 	state->lastbyte = mqenc->lastbyte; }
int jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width,   jas_image_coord_t height, jas_matrix_t *data) { 	jas_image_cmpt_t *cmpt; 	jas_image_coord_t i; 	jas_image_coord_t j; 	jas_seqent_t *d; 	jas_seqent_t *dr; 	int drs; 	jas_seqent_t v; 	int k; 	int c;  	if (cmptno < 0 || cmptno >= image->numcmpts_) { 		return -1; 	}  	cmpt = image->cmpts_[cmptno]; 	if (x >= cmpt->width_ || y >= cmpt->height_ || 	  x + width > cmpt->width_ || 	  y + height > cmpt->height_) { 		return -1; 	}  	if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) { 		return -1; 	}  	dr = jas_matrix_getref(data, 0, 0); 	drs = jas_matrix_rowstep(data); 	for (i = 0; i < height; ++i, dr += drs) { 		d = dr; 		if (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x) 		  * cmpt->cps_, SEEK_SET) < 0) { 			return -1; 		} 		for (j = width; j > 0; --j, ++d) { 			v = inttobits(*d, cmpt->prec_, cmpt->sgnd_); 			for (k = cmpt->cps_; k > 0; --k) { 				c = (v >> (8 * (cmpt->cps_ - 1))) & 0xff; 				if (jas_stream_putc(cmpt->stream_, 				  (unsigned char) c) == EOF) { 					return -1; 				} 				v <<= 8; 			} 		} 	}  	return 0; }
long jas_stream_seek(jas_stream_t *stream, long offset, int origin) { 	long newpos;  	/* The buffer cannot be in use for both reading and writing. */ 	assert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ & 	  JAS_STREAM_WRBUF)));  	/* Reset the EOF indicator (since we may not be at the EOF anymore). */ 	stream->flags_ &= ~JAS_STREAM_EOF;  	if (stream->bufmode_ & JAS_STREAM_RDBUF) { 		if (origin == SEEK_CUR) { 			offset -= stream->cnt_; 		} 	} else if (stream->bufmode_ & JAS_STREAM_WRBUF) { 		if (jas_stream_flush(stream)) { 			return -1; 		} 	} 	stream->cnt_ = 0; 	stream->ptr_ = stream->bufstart_; 	stream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);  	if ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin)) 	  < 0) { 		return -1; 	}  	return newpos; }
static jas_iccattrval_t *jas_iccattrval_create0() { 	jas_iccattrval_t *attrval; 	if (!(attrval = jas_malloc(sizeof(jas_iccattrval_t)))) 		return 0; 	memset(attrval, 0, sizeof(jas_iccattrval_t)); 	attrval->refcnt = 0; 	attrval->ops = 0; 	attrval->type = 0; 	return attrval; }
int jas_stream_read(jas_stream_t *stream, void *buf, int cnt) { 	int n; 	int c; 	char *bufptr;  	bufptr = buf;  	n = 0; 	while (n < cnt) { 		if ((c = jas_stream_getc(stream)) == EOF) { 			return n; 		} 		*bufptr++ = c; 		++n; 	}  	return n; }
int jpc_putuint8(jas_stream_t *out, uint_fast8_t val) { 	if (jas_stream_putc(out, val & 0xff) == EOF) { 		return -1; 	} 	return 0; }
jas_cmprof_t *jas_cmprof_createfromclrspc(int clrspc) { 	jas_iccprof_t *iccprof; 	jas_cmprof_t *prof;  	iccprof = 0; 	prof = 0; 	switch (clrspc) { 	case JAS_CLRSPC_SYCBCR: 		if (!(prof = jas_cmprof_createsycc())) 			goto error; 		break; 	default: 		if (!(iccprof = jas_iccprof_createfromclrspc(clrspc))) 			goto error; 		if (!(prof = jas_cmprof_createfromiccprof(iccprof))) 			goto error; 		jas_iccprof_destroy(iccprof); 		iccprof = 0; 		if (!jas_clrspc_isgeneric(clrspc)) 			prof->clrspc = clrspc; 		break; 	} 	return prof; error: 	if (iccprof) 		jas_iccprof_destroy(iccprof); 	return 0; }
void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart, int ystart,   int xend, int yend) { 	jas_matrix_bindsub(s, s1, ystart - s1->ystart_, xstart - s1->xstart_, 	  yend - s1->ystart_ - 1, xend - s1->xstart_ - 1); }
jas_tvparser_t *jas_tvparser_create(const char *s) { 	jas_tvparser_t *tvp; 	if (!(tvp = jas_malloc(sizeof(jas_tvparser_t)))) { 		return 0; 	} 	if (!(tvp->buf = jas_strdup(s))) { 		jas_tvparser_destroy(tvp); 		return 0; 	} 	tvp->pos = tvp->buf; 	tvp->tag = 0; 	tvp->val = 0; 	return tvp; }
void jas_cleanup() { 	jas_image_clearfmts(); }
jpc_bitstream_t *jpc_bitstream_sopen(jas_stream_t *stream, char *mode) { 	jpc_bitstream_t *bitstream;  	/* Ensure that the open mode is valid. */ #if 1 /* This causes a string literal too long error (with c99 pedantic mode). */ 	assert(!strcmp(mode, "r") || !strcmp(mode, "w") || !strcmp(mode, "r+") 	  || !strcmp(mode, "w+")); #endif  	if (!(bitstream = jpc_bitstream_alloc())) { 		return 0; 	}  	/* By default, do not close the underlying (character) stream, upon 	  the close of the bit stream. */ 	bitstream->flags_ = JPC_BITSTREAM_NOCLOSE;  	bitstream->stream_ = stream; 	bitstream->openmode_ = (mode[0] == 'w') ? JPC_BITSTREAM_WRITE : 	  JPC_BITSTREAM_READ;  	/* Mark the data buffer as empty. */ 	bitstream->cnt_ = (bitstream->openmode_ == JPC_BITSTREAM_READ) ? 0 : 8; 	bitstream->buf_ = 0;  	return bitstream; }
static int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out) { 	jpc_qcc_t *qcc = &ms->parms.qcc; 	if (cstate->numcomps <= 256) { 		jpc_putuint8(out, qcc->compno); 	} else { 		jpc_putuint16(out, qcc->compno); 	} 	if (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) { 		return -1; 	} 	return 0; }
jpc_pchglist_t *jpc_pchglist_create() { 	jpc_pchglist_t *pchglist; 	if (!(pchglist = jas_malloc(sizeof(jpc_pchglist_t)))) { 		return 0; 	} 	pchglist->numpchgs = 0; 	pchglist->maxpchgs = 0; 	pchglist->pchgs = 0; 	return pchglist; }
static void jpc_cod_destroyparms(jpc_ms_t *ms) { 	jpc_cod_t *cod = &ms->parms.cod; 	jpc_cox_destroycompparms(&cod->compparms); }
int jas_image_getfmt(jas_stream_t *in) { 	jas_image_fmtinfo_t *fmtinfo; 	int found; 	int i;  	/* Check for data in each of the supported formats. */ 	found = 0; 	for (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, 	  ++fmtinfo) { 		if (fmtinfo->ops.validate) { 			/* Is the input data valid for this format? */ 			if (!(*fmtinfo->ops.validate)(in)) { 				found = 1; 				break; 			} 		} 	} 	return found ? fmtinfo->id : (-1); }
jas_iccprof_t *jas_iccprof_copy(jas_iccprof_t *prof) { 	jas_iccprof_t *newprof; 	newprof = 0; 	if (!(newprof = jas_iccprof_create())) 		goto error; 	newprof->hdr = prof->hdr; 	newprof->tagtab.numents = 0; 	newprof->tagtab.ents = 0; 	assert(newprof->attrtab); 	jas_iccattrtab_destroy(newprof->attrtab); 	if (!(newprof->attrtab = jas_iccattrtab_copy(prof->attrtab))) 		goto error; 	return newprof; error: 	if (newprof) 		jas_iccprof_destroy(newprof); 	return 0; }
int mif_validate(jas_stream_t *in) { 	uchar buf[MIF_MAGICLEN]; 	uint_fast32_t magic; 	int i; 	int n;  	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);  	/* Read the validation data (i.e., the data used for detecting 	  the format). */ 	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) { 		return -1; 	}  	/* Put the validation data back onto the stream, so that the 	  stream position will not be changed. */ 	for (i = n - 1; i >= 0; --i) { 		if (jas_stream_ungetc(in, buf[i]) == EOF) { 			return -1; 		} 	}  	/* Was enough data read? */ 	if (n < MIF_MAGICLEN) { 		return -1; 	}  	/* Compute the signature value. */ 	magic = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];  	/* Ensure that the signature is correct for this format. */ 	if (magic != MIF_MAGIC) { 		return -1; 	}  	return 0; }
void jas_cmprof_destroy(jas_cmprof_t *prof) {  	int i; 	for (i = 0; i < JAS_CMPROF_NUMPXFORMSEQS; ++i) { 		if (prof->pxformseqs[i]) { 			jas_cmpxformseq_destroy(prof->pxformseqs[i]); 			prof->pxformseqs[i] = 0; 		} 	} 	if (prof->iccprof) 		jas_iccprof_destroy(prof->iccprof); 	jas_free(prof); }
long jas_stream_tell(jas_stream_t *stream) { 	int adjust; 	int offset;  	if (stream->bufmode_ & JAS_STREAM_RDBUF) { 		adjust = -stream->cnt_; 	} else if (stream->bufmode_ & JAS_STREAM_WRBUF) { 		adjust = stream->ptr_ - stream->bufstart_; 	} else { 		adjust = 0; 	}  	if ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) { 		return -1; 	}  	return offset + adjust; }
static void pass_destroy(jpc_enc_pass_t *pass) { 	/* XXX - need to free resources here */ }
int JPC_SEGTYPE(int passno, int firstpassno, int bypass) { 	int passtype; 	if (bypass) { 		passtype = JPC_PASSTYPE(passno); 		if (passtype == JPC_CLNPASS) { 			return JPC_SEG_MQ; 		} 		return ((passno < firstpassno + 10) ? JPC_SEG_MQ : JPC_SEG_RAW); 	} else { 		return JPC_SEG_MQ; 	} }
static void jp2_colr_destroy(jp2_box_t *box) { 	jp2_colr_t *colr = &box->data.colr; 	if (colr->iccp) { 		jas_free(colr->iccp); 	} }
int jpc_mqenc_codelps(jpc_mqenc_t *mqenc) { 	jpc_mqenc_codelps2(mqenc->areg, mqenc->creg, mqenc->ctreg, mqenc->curctx, mqenc); 	return jpc_mqenc_error(mqenc) ? (-1) : 0; }
static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val) { 	ulonglong tmp; 	if (jas_iccgetuint(in, 4, &tmp)) 		return -1; 	*val = (tmp & 0x80000000) ? (-JAS_CAST(longlong, (((~tmp) & 	  0x7fffffff) + 1))) : JAS_CAST(longlong, tmp); 	return 0; }
static void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms) { 	if (compparms->stepsizes) { 		jas_free(compparms->stepsizes); 	} }
char *jas_tvparser_getval(jas_tvparser_t *tvp) { 	return tvp->val; }
const char *jas_getversion() { 	return JAS_VERSION; }
static int jas_cmshapmat_invmat(jas_cmreal_t out[3][4], jas_cmreal_t in[3][4]) { 	jas_cmreal_t d; 	d = in[0][0] * (in[1][1] * in[2][2] - in[1][2] * in[2][1]) 	  - in[0][1] * (in[1][0] * in[2][2] - in[1][2] * in[2][0]) 	  + in[0][2] * (in[1][0] * in[2][1] - in[1][1] * in[2][0]); #if 0 jas_eprintf("delta=%f\n", d); #endif 	if (JAS_ABS(d) < 1e-6) 		return -1; 	out[0][0] = (in[1][1] * in[2][2] - in[1][2] * in[2][1]) / d; 	out[1][0] = -(in[1][0] * in[2][2] - in[1][2] * in[2][0]) / d; 	out[2][0] = (in[1][0] * in[2][1] - in[1][1] * in[2][0]) / d; 	out[0][1] = -(in[0][1] * in[2][2] - in[0][2] * in[2][1]) / d; 	out[1][1] = (in[0][0] * in[2][2] - in[0][2] * in[2][0]) / d; 	out[2][1] = -(in[0][0] * in[2][1] - in[0][1] * in[2][0]) / d; 	out[0][2] = (in[0][1] * in[1][2] - in[0][2] * in[1][1]) / d; 	out[1][2] = -(in[0][0] * in[1][2] - in[1][0] * in[0][2]) / d; 	out[2][2] = (in[0][0] * in[1][1] - in[0][1] * in[1][0]) / d; 	out[0][3] = -in[0][3]; 	out[1][3] = -in[1][3]; 	out[2][3] = -in[2][3]; #if 0 jas_eprintf("[ %f %f %f %f ]\n[ %f %f %f %f ]\n[ %f %f %f %f ]\n", in[0][0], in[0][1], in[0][2], in[0][3], in[1][0], in[1][1], in[1][2], in[1][3], in[2][0], in[2][1], in[2][2], in[2][3]); jas_eprintf("[ %f %f %f %f ]\n[ %f %f %f %f ]\n[ %f %f %f %f ]\n", out[0][0], out[0][1], out[0][2], out[0][3], out[1][0], out[1][1], out[1][2], out[1][3], out[2][0], out[2][1], out[2][2], out[2][3]); #endif 	return 0; }
static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val) { 	ulonglong tmp; 	if (jas_iccgetuint(in, 8, &tmp)) 		return -1; 	*val = tmp; 	return 0; }
int jas_stream_flush(jas_stream_t *stream) { 	if (stream->bufmode_ & JAS_STREAM_RDBUF) { 		return 0; 	} 	return jas_stream_flushbuf(stream, EOF); }
uint_fast32_t jas_image_rawsize(jas_image_t *image) { 	uint_fast32_t rawsize; 	int cmptno; 	jas_image_cmpt_t *cmpt;  	rawsize = 0; 	for (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) { 		cmpt = image->cmpts_[cmptno]; 		rawsize += (cmpt->width_ * cmpt->height_ * cmpt->prec_ + 		  7) / 8; 	} 	return rawsize; }
static int jas_iccprof_gettagtab(jas_stream_t *in, jas_icctagtab_t *tagtab) { 	int i; 	jas_icctagtabent_t *tagtabent;  	if (tagtab->ents) { 		jas_free(tagtab->ents); 		tagtab->ents = 0; 	} 	if (jas_iccgetuint32(in, &tagtab->numents)) 		goto error; 	if (!(tagtab->ents = jas_malloc(tagtab->numents * 	  sizeof(jas_icctagtabent_t)))) 		goto error; 	tagtabent = tagtab->ents; 	for (i = 0; i < JAS_CAST(long, tagtab->numents); ++i) { 		if (jas_iccgetuint32(in, &tagtabent->tag) || 		jas_iccgetuint32(in, &tagtabent->off) || 		jas_iccgetuint32(in, &tagtabent->len)) 			goto error; 		++tagtabent; 	} 	return 0; error: 	if (tagtab->ents) { 		jas_free(tagtab->ents); 		tagtab->ents = 0; 	} 	return -1; }
jas_stream_t *jas_stream_fopen(const char *filename, const char *mode) { 	jas_stream_t *stream; 	jas_stream_fileobj_t *obj; 	int openflags;  	/* Allocate a stream object. */ 	if (!(stream = jas_stream_create())) { 		return 0; 	}  	/* Parse the mode string. */ 	stream->openmode_ = jas_strtoopenmode(mode);  	/* Determine the correct flags to use for opening the file. */ 	if ((stream->openmode_ & JAS_STREAM_READ) && 	  (stream->openmode_ & JAS_STREAM_WRITE)) { 		openflags = O_RDWR; 	} else if (stream->openmode_ & JAS_STREAM_READ) { 		openflags = O_RDONLY; 	} else if (stream->openmode_ & JAS_STREAM_WRITE) { 		openflags = O_WRONLY; 	} else { 		openflags = 0; 	} 	if (stream->openmode_ & JAS_STREAM_APPEND) { 		openflags |= O_APPEND; 	} 	if (stream->openmode_ & JAS_STREAM_BINARY) { 		openflags |= O_BINARY; 	} 	if (stream->openmode_ & JAS_STREAM_CREATE) { 		openflags |= O_CREAT | O_TRUNC; 	}  	/* Allocate space for the underlying file stream object. */ 	if (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) { 		jas_stream_destroy(stream); 		return 0; 	} 	obj->fd = -1; 	obj->flags = 0; 	obj->pathname[0] = '\0'; 	stream->obj_ = (void *) obj;  	/* Select the operations for a file stream object. */ 	stream->ops_ = &jas_stream_fileops;  	/* Open the underlying file. */ 	if ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) { 		jas_stream_destroy(stream); 		return 0; 	}  	/* By default, use full buffering for this type of stream. */ 	jas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);  	return stream; }
static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val) { 	ulonglong tmp; 	if (jas_iccgetuint(in, 2, &tmp)) 		return -1; 	*val = tmp; 	return 0; }
int jpc_getspb(int f) { 	int hc; 	int vc; 	int n;  	hc = JAS_MIN(((f & (JPC_ESIG | JPC_ESGN)) == JPC_ESIG) + ((f & (JPC_WSIG | JPC_WSGN)) == JPC_WSIG), 1) - 	  JAS_MIN(((f & (JPC_ESIG | JPC_ESGN)) == (JPC_ESIG | JPC_ESGN)) + ((f & (JPC_WSIG | JPC_WSGN)) == (JPC_WSIG | JPC_WSGN)), 1); 	vc = JAS_MIN(((f & (JPC_NSIG | JPC_NSGN)) == JPC_NSIG) + ((f & (JPC_SSIG | JPC_SSGN)) == JPC_SSIG), 1) - 	  JAS_MIN(((f & (JPC_NSIG | JPC_NSGN)) == (JPC_NSIG | JPC_NSGN)) + ((f & (JPC_SSIG | JPC_SSGN)) == (JPC_SSIG | JPC_SSGN)), 1); 	if (!hc && !vc) { 		n = 0; 	} else { 		n = (!(hc > 0 || (!hc && vc > 0))); 	} 	return n; }
static void jas_stream_destroy(jas_stream_t *stream) { 	/* If the memory for the buffer was allocated with malloc, free 	this memory. */ 	if ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) { 		jas_free(stream->bufbase_); 		stream->bufbase_ = 0; 	} 	jas_free(stream); }
static void jas_iccattrtab_delete(jas_iccattrtab_t *attrtab, int i) { 	int n; 	jas_iccattrval_destroy(attrtab->attrs[i].val); 	if ((n = attrtab->numattrs - i - 1) > 0) 		memmove(&attrtab->attrs[i], &attrtab->attrs[i + 1], 		  n * sizeof(jas_iccattr_t)); 	--attrtab->numattrs; }
static jas_cmpxform_t *jas_cmpxform_copy(jas_cmpxform_t *pxform) { 	++pxform->refcnt; 	return pxform; }
static jpc_tagtree_t *jpc_tagtree_alloc() { 	jpc_tagtree_t *tree;  	if (!(tree = jas_malloc(sizeof(jpc_tagtree_t)))) { 		return 0; 	} 	tree->numleafsh_ = 0; 	tree->numleafsv_ = 0; 	tree->numnodes_ = 0; 	tree->nodes_ = 0;  	return tree; }
jpc_fix_t jpc_mct_getsynweight(int mctid, int cmptno) { 	jpc_fix_t synweight;  	synweight = JPC_FIX_ONE; 	switch (mctid) { 	case JPC_MCT_RCT: 		switch (cmptno) { 		case 0: 			synweight = jpc_dbltofix(sqrt(3.0)); 			break; 		case 1: 			synweight = jpc_dbltofix(sqrt(0.6875)); 			break; 		case 2: 			synweight = jpc_dbltofix(sqrt(0.6875)); 			break; 		} 		break; 	case JPC_MCT_ICT: 		switch (cmptno) { 		case 0: 			synweight = jpc_dbltofix(sqrt(3.0000)); 			break; 		case 1: 			synweight = jpc_dbltofix(sqrt(3.2584)); 			break; 		case 2: 			synweight = jpc_dbltofix(sqrt(2.4755)); 			break; 		} 		break; #if 0 	default: 		synweight = JPC_FIX_ONE; 		break; #endif 	}  	return synweight; }
static void jpc_siz_destroyparms(jpc_ms_t *ms) { 	jpc_siz_t *siz = &ms->parms.siz; 	if (siz->comps) { 		jas_free(siz->comps); 	} }
void jpc_pi_destroy(jpc_pi_t *pi) { 	jpc_picomp_t *picomp; 	int compno; 	if (pi->picomps) { 		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps; 		  ++compno, ++picomp) { 			jpc_picomp_destroy(picomp); 		} 		jas_free(pi->picomps); 	} 	if (pi->pchglist) { 		jpc_pchglist_destroy(pi->pchglist); 	} 	jas_free(pi); }
int jpc_pchglist_numpchgs(jpc_pchglist_t *pchglist) { 	return pchglist->numpchgs; }
static void jas_cmshapmat_destroy(jas_cmpxform_t *pxform) { 	jas_cmshapmat_t *shapmat = &pxform->data.shapmat; 	int i; 	for (i = 0; i < 3; ++i) 		jas_cmshapmatlut_cleanup(&shapmat->luts[i]); }
int jp2_encode(jas_image_t *image, jas_stream_t *out, char *optstr) { 	jp2_box_t *box; 	jp2_ftyp_t *ftyp; 	jp2_ihdr_t *ihdr; 	jas_stream_t *tmpstream; 	int allcmptssame; 	jp2_bpcc_t *bpcc; 	long len; 	uint_fast16_t cmptno; 	jp2_colr_t *colr; 	char buf[4096]; 	uint_fast32_t overhead; 	jp2_cdefchan_t *cdefchanent; 	jp2_cdef_t *cdef; 	int i; 	uint_fast32_t typeasoc; jas_iccprof_t *iccprof; jas_stream_t *iccstream; int pos; int needcdef; int prec; int sgnd;  	box = 0; 	tmpstream = 0;  	allcmptssame = 1; 	sgnd = jas_image_cmptsgnd(image, 0); 	prec = jas_image_cmptprec(image, 0); 	for (i = 1; i < jas_image_numcmpts(image); ++i) { 		if (jas_image_cmptsgnd(image, i) != sgnd || 		  jas_image_cmptprec(image, i) != prec) { 			allcmptssame = 0; 			break; 		} 	}  	/* Output the signature box. */  	if (!(box = jp2_box_create(JP2_BOX_JP))) { 		goto error; 	} 	box->data.jp.magic = JP2_JP_MAGIC; 	if (jp2_box_put(box, out)) { 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Output the file type box. */  	if (!(box = jp2_box_create(JP2_BOX_FTYP))) { 		goto error; 	} 	ftyp = &box->data.ftyp; 	ftyp->majver = JP2_FTYP_MAJVER; 	ftyp->minver = JP2_FTYP_MINVER; 	ftyp->numcompatcodes = 1; 	ftyp->compatcodes[0] = JP2_FTYP_COMPATCODE; 	if (jp2_box_put(box, out)) { 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* 	 * Generate the data portion of the JP2 header box. 	 * We cannot simply output the header for this box 	 * since we do not yet know the correct value for the length 	 * field. 	 */  	if (!(tmpstream = jas_stream_memopen(0, 0))) { 		goto error; 	}  	/* Generate image header box. */  	if (!(box = jp2_box_create(JP2_BOX_IHDR))) { 		goto error; 	} 	ihdr = &box->data.ihdr; 	ihdr->width = jas_image_width(image); 	ihdr->height = jas_image_height(image); 	ihdr->numcmpts = jas_image_numcmpts(image); 	ihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0), 	  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL; 	ihdr->comptype = JP2_IHDR_COMPTYPE; 	ihdr->csunk = 0; 	ihdr->ipr = 0; 	if (jp2_box_put(box, tmpstream)) { 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Generate bits per component box. */  	if (!allcmptssame) { 		if (!(box = jp2_box_create(JP2_BOX_BPCC))) { 			goto error; 		} 		bpcc = &box->data.bpcc; 		bpcc->numcmpts = jas_image_numcmpts(image); 		if (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts * 		  sizeof(uint_fast8_t)))) { 			goto error; 		} 		for (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) { 			bpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image, 			  cmptno), jas_image_cmptprec(image, cmptno)); 		} 		if (jp2_box_put(box, tmpstream)) { 			goto error; 		} 		jp2_box_destroy(box); 		box = 0; 	}  	/* Generate color specification box. */  	if (!(box = jp2_box_create(JP2_BOX_COLR))) { 		goto error; 	} 	colr = &box->data.colr; 	switch (jas_image_clrspc(image)) { 	case JAS_CLRSPC_SRGB: 	case JAS_CLRSPC_SYCBCR: 	case JAS_CLRSPC_SGRAY: 		colr->method = JP2_COLR_ENUM; 		colr->csid = clrspctojp2(jas_image_clrspc(image)); 		colr->pri = JP2_COLR_PRI; 		colr->approx = 0; 		break; 	default: 		colr->method = JP2_COLR_ICC; 		colr->pri = JP2_COLR_PRI; 		colr->approx = 0; 		iccprof = jas_iccprof_createfromcmprof(jas_image_cmprof(image)); 		assert(iccprof); 		iccstream = jas_stream_memopen(0, 0); 		assert(iccstream); 		if (jas_iccprof_save(iccprof, iccstream)) 			abort(); 		if ((pos = jas_stream_tell(iccstream)) < 0) 			abort(); 		colr->iccplen = pos; 		colr->iccp = jas_malloc(pos); 		assert(colr->iccp); 		jas_stream_rewind(iccstream); 		if (jas_stream_read(iccstream, colr->iccp, colr->iccplen) != colr->iccplen) 			abort(); 		jas_stream_close(iccstream); 		jas_iccprof_destroy(iccprof); 		break; 	} 	if (jp2_box_put(box, tmpstream)) { 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	needcdef = 1; 	switch (jas_clrspc_fam(jas_image_clrspc(image))) { 	case JAS_CLRSPC_FAM_RGB: 		if (jas_image_cmpttype(image, 0) == 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) && 		  jas_image_cmpttype(image, 1) == 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) && 		  jas_image_cmpttype(image, 2) == 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B)) 			needcdef = 0; 		break; 	case JAS_CLRSPC_FAM_YCBCR: 		if (jas_image_cmpttype(image, 0) == 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) && 		  jas_image_cmpttype(image, 1) == 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) && 		  jas_image_cmpttype(image, 2) == 		  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR)) 			needcdef = 0; 		break; 	case JAS_CLRSPC_FAM_GRAY: 		if (jas_image_cmpttype(image, 0) == 		  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y)) 			needcdef = 0; 		break; 	default: 		abort(); 		break; 	}  	if (needcdef) { 		if (!(box = jp2_box_create(JP2_BOX_CDEF))) { 			goto error; 		} 		cdef = &box->data.cdef; 		cdef->numchans = jas_image_numcmpts(image); 		cdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t)); 		for (i = 0; i < jas_image_numcmpts(image); ++i) { 			cdefchanent = &cdef->ents[i]; 			cdefchanent->channo = i; 			typeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i)); 			cdefchanent->type = typeasoc >> 16; 			cdefchanent->assoc = typeasoc & 0x7fff; 		} 		if (jp2_box_put(box, tmpstream)) { 			goto error; 		} 		jp2_box_destroy(box); 		box = 0; 	}  	/* Determine the total length of the JP2 header box. */  	len = jas_stream_tell(tmpstream); 	jas_stream_rewind(tmpstream);  	/* 	 * Output the JP2 header box and all of the boxes which it contains. 	 */  	if (!(box = jp2_box_create(JP2_BOX_JP2H))) { 		goto error; 	} 	box->len = len + JP2_BOX_HDRLEN(false); 	if (jp2_box_put(box, out)) { 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	if (jas_stream_copy(out, tmpstream, len)) { 		goto error; 	}  	jas_stream_close(tmpstream); 	tmpstream = 0;  	/* 	 * Output the contiguous code stream box. 	 */  	if (!(box = jp2_box_create(JP2_BOX_JP2C))) { 		goto error; 	} 	box->len = 0; 	if (jp2_box_put(box, out)) { 		goto error; 	} 	jp2_box_destroy(box); 	box = 0;  	/* Output the JPEG-2000 code stream. */  	overhead = jas_stream_getrwcount(out); 	sprintf(buf, "%s\n_jp2overhead=%lu\n", (optstr ? optstr : ""), 	  (unsigned long) overhead);  	if (jpc_encode(image, out, buf)) { 		goto error; 	}  	return 0; 	abort();  error:  	if (box) { 		jp2_box_destroy(box); 	} 	if (tmpstream) { 		jas_stream_close(tmpstream); 	} 	return -1; }
static void jas_cmshapmatlut_cleanup(jas_cmshapmatlut_t *lut) { 	if (lut->data) { 		jas_free(lut->data); 		lut->data = 0; 	} 	lut->size = 0; }
static int jas_strtoopenmode(const char *s) { 	int openmode = 0; 	while (*s != '\0') { 		switch (*s) { 		case 'r': 			openmode |= JAS_STREAM_READ; 			break; 		case 'w': 			openmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE; 			break; 		case 'b': 			openmode |= JAS_STREAM_BINARY; 			break; 		case 'a': 			openmode |= JAS_STREAM_APPEND; 			break; 		case '+': 			openmode |= JAS_STREAM_READ | JAS_STREAM_WRITE; 			break; 		default: 			break; 		} 		++s; 	} 	return openmode; }
static int mem_close(jas_stream_obj_t *obj) { 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; 	if (m->myalloc_ && m->buf_) { 		jas_free(m->buf_); 		m->buf_ = 0; 	} 	jas_free(obj); 	return 0; }
int jpc_tsfb_analyze(jpc_tsfb_t *tsfb, jas_seq2d_t *a) { 	return (tsfb->numlvls > 0) ? jpc_tsfb_analyze2(tsfb, jas_seq2d_getref(a, 	  jas_seq2d_xstart(a), jas_seq2d_ystart(a)), jas_seq2d_xstart(a), 	  jas_seq2d_ystart(a), jas_seq2d_width(a), 	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0; }
jpc_tagtreenode_t *jpc_tagtree_getleaf(jpc_tagtree_t *tree, int n) { 	return &tree->nodes_[n]; }
static void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt) { 	if (cmpt->stream_) { 		jas_stream_close(cmpt->stream_); 	} 	jas_free(cmpt); }
int jpc_enc_enccblks(jpc_enc_t *enc) { 	jpc_enc_tcmpt_t *tcmpt; 	jpc_enc_tcmpt_t *endcomps; 	jpc_enc_rlvl_t *lvl; 	jpc_enc_rlvl_t *endlvls; 	jpc_enc_band_t *band; 	jpc_enc_band_t *endbands; 	jpc_enc_cblk_t *cblk; 	jpc_enc_cblk_t *endcblks; 	int i; 	int j; 	int mx; 	int bmx; 	int v; 	jpc_enc_tile_t *tile; 	uint_fast32_t prcno; 	jpc_enc_prc_t *prc;  	tile = enc->curtile;  	endcomps = &tile->tcmpts[tile->numtcmpts]; 	for (tcmpt = tile->tcmpts; tcmpt != endcomps; ++tcmpt) { 		endlvls = &tcmpt->rlvls[tcmpt->numrlvls]; 		for (lvl = tcmpt->rlvls; lvl != endlvls; ++lvl) { 			if (!lvl->bands) { 				continue; 			} 			endbands = &lvl->bands[lvl->numbands]; 			for (band = lvl->bands; band != endbands; ++band) { 				if (!band->data) { 					continue; 				} 				for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 					if (!prc->cblks) { 						continue; 					} 					bmx = 0; 					endcblks = &prc->cblks[prc->numcblks]; 					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						mx = 0; 						for (i = 0; i < jas_matrix_numrows(cblk->data); ++i) { 							for (j = 0; j < jas_matrix_numcols(cblk->data); ++j) { 								v = abs(jas_matrix_get(cblk->data, i, j)); 								if (v > mx) { 									mx = v; 								} 							} 						} 						if (mx > bmx) { 							bmx = mx; 						} 						cblk->numbps = JAS_MAX(jpc_firstone(mx) + 1 - JPC_NUMEXTRABITS, 0); 					}  					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						cblk->numimsbs = band->numbps - cblk->numbps; 						assert(cblk->numimsbs >= 0); 					}  					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						if (jpc_enc_enccblk(enc, cblk->stream, tcmpt, band, cblk)) { 							return -1; 						} 					} 				} 			} 		} 	} 	return 0; }
static jas_cmpxformseq_t *jas_cmpxformseq_create() { 	jas_cmpxformseq_t *pxformseq; 	pxformseq = 0; 	if (!(pxformseq = jas_malloc(sizeof(jas_cmpxformseq_t)))) 		goto error; 	pxformseq->pxforms = 0; 	pxformseq->numpxforms = 0; 	pxformseq->maxpxforms = 0; 	if (jas_cmpxformseq_resize(pxformseq, 16)) 		goto error; 	return pxformseq; error: 	if (pxformseq) 		jas_cmpxformseq_destroy(pxformseq); 	return 0; }
void jpc_restore_t2state(jpc_enc_t *enc) {  	jpc_enc_tcmpt_t *comp; 	jpc_enc_tcmpt_t *endcomps; 	jpc_enc_rlvl_t *lvl; 	jpc_enc_rlvl_t *endlvls; 	jpc_enc_band_t *band; 	jpc_enc_band_t *endbands; 	jpc_enc_cblk_t *cblk; 	jpc_enc_cblk_t *endcblks; 	jpc_enc_tile_t *tile; 	int prcno; 	jpc_enc_prc_t *prc;  	tile = enc->curtile;  	endcomps = &tile->tcmpts[tile->numtcmpts]; 	for (comp = tile->tcmpts; comp != endcomps; ++comp) { 		endlvls = &comp->rlvls[comp->numrlvls]; 		for (lvl = comp->rlvls; lvl != endlvls; ++lvl) { 			if (!lvl->bands) { 				continue; 			} 			endbands = &lvl->bands[lvl->numbands]; 			for (band = lvl->bands; band != endbands; ++band) { 				if (!band->data) { 					continue; 				} 				for (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) { 					if (!prc->cblks) { 						continue; 					} 					jpc_tagtree_copy(prc->incltree, prc->savincltree); 					jpc_tagtree_copy(prc->nlibtree, prc->savnlibtree); 					endcblks = &prc->cblks[prc->numcblks]; 					for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 						cblk->curpass = cblk->savedcurpass; 						cblk->numencpasses = cblk->savednumencpasses; 						cblk->numlenbits = cblk->savednumlenbits; 					} 				} 			} 		} 	} }
jpc_mqenc_t *jpc_mqenc_create(int maxctxs, jas_stream_t *out) { 	jpc_mqenc_t *mqenc;  	/* Allocate memory for the MQ encoder. */ 	if (!(mqenc = jas_malloc(sizeof(jpc_mqenc_t)))) { 		goto error; 	} 	mqenc->out = out; 	mqenc->maxctxs = maxctxs;  	/* Allocate memory for the per-context state information. */ 	if (!(mqenc->ctxs = jas_malloc(mqenc->maxctxs * sizeof(jpc_mqstate_t *)))) { 		goto error; 	}  	/* Set the current context to the first one. */ 	mqenc->curctx = mqenc->ctxs;  	jpc_mqenc_init(mqenc);  	/* Initialize the per-context state information to something sane. */ 	jpc_mqenc_setctxs(mqenc, 0, 0);  	return mqenc;  error: 	if (mqenc) { 		jpc_mqenc_destroy(mqenc); 	} 	return 0; }
static int jpc_putnumnewpasses(jpc_bitstream_t *out, int n) { 	int ret;  	if (n <= 0) { 		return -1; 	} else if (n == 1) { 		ret = jpc_bitstream_putbit(out, 0); 	} else if (n == 2) { 		ret = jpc_bitstream_putbits(out, 2, 2); 	} else if (n <= 5) { 		ret = jpc_bitstream_putbits(out, 4, 0xc | (n - 3)); 	} else if (n <= 36) { 		ret = jpc_bitstream_putbits(out, 9, 0x1e0 | (n - 6)); 	} else if (n <= 164) { 		ret = jpc_bitstream_putbits(out, 16, 0xff80 | (n - 37)); 	} else { 		/* The standard has no provision for encoding a larger value. 		In practice, however, it is highly unlikely that this 		limitation will ever be encountered. */ 		return -1; 	}  	return (ret != EOF) ? 0 : (-1); }
int jpc_bitstream_outalign(jpc_bitstream_t *bitstream, int filldata) { 	int n; 	int v;  	/* Ensure that this bit stream is open for writing. */ 	assert(bitstream->openmode_ & JPC_BITSTREAM_WRITE);  	/* Ensure that the first bit of fill data is zero. */ 	/* Note: The first bit of fill data must be zero.  If this were not 	  the case, the fill data itself could cause further bit stuffing to 	  be required (which would cause numerous complications). */ 	assert(!(filldata & (~0x3f)));  	if (!bitstream->cnt_) { 		if ((bitstream->buf_ & 0xff) == 0xff) { 			n = 7; 			v = filldata; 		} else { 			n = 0; 			v = 0; 		} 	} else if (bitstream->cnt_ > 0 && bitstream->cnt_ < 8) { 		n = bitstream->cnt_; 		v = filldata >> (7 - n); 	} else { 		n = 0; 		v = 0; 		return 0; 	}  	/* Write the appropriate fill data to the bit stream. */ 	if (n > 0) { 		if (jpc_bitstream_putbits(bitstream, n, v)) { 			return -1; 		} 	} 	if (bitstream->cnt_ < 8) { 		assert(bitstream->cnt_ >= 0 && bitstream->cnt_ < 8); 		assert((bitstream->buf_ & 0xff) != 0xff); 		/* Force the pending byte of output to be written to the 		  underlying (character) stream. */ 		if (jas_stream_putc(bitstream->stream_, bitstream->buf_ & 0xff) == EOF) { 			return -1; 		} 		bitstream->cnt_ = 8; 		bitstream->buf_ = (bitstream->buf_ << 8) & 0xffff; 	}  	return 0; }
static int icctoclrspc(int iccclrspc, int refflag) { 	if (refflag) { 		switch (iccclrspc) { 		case JAS_ICC_COLORSPC_XYZ: 			return JAS_CLRSPC_CIEXYZ; 		case JAS_ICC_COLORSPC_LAB: 			return JAS_CLRSPC_CIELAB; 		default: 			abort(); 			break; 		} 	} else { 		switch (iccclrspc) { 		case JAS_ICC_COLORSPC_YCBCR: 			return JAS_CLRSPC_GENYCBCR; 		case JAS_ICC_COLORSPC_RGB: 			return JAS_CLRSPC_GENRGB; 		case JAS_ICC_COLORSPC_GRAY: 			return JAS_CLRSPC_GENGRAY; 		default: 			abort(); 			break; 		} 	} }
static void jpc_qcc_destroyparms(jpc_ms_t *ms) { 	jpc_qcc_t *qcc = &ms->parms.qcc; 	jpc_qcx_destroycompparms(&qcc->compparms); }
int jpc_pi_next(jpc_pi_t *pi) { 	jpc_pchg_t *pchg; 	int ret;   	for (;;) {  		pi->valid = false;  		if (!pi->pchg) { 			++pi->pchgno; 			pi->compno = 0; 			pi->rlvlno = 0; 			pi->prcno = 0; 			pi->lyrno = 0; 			pi->prgvolfirst = true; 			if (pi->pchgno < jpc_pchglist_numpchgs(pi->pchglist)) { 				pi->pchg = jpc_pchglist_get(pi->pchglist, pi->pchgno); 			} else if (pi->pchgno == jpc_pchglist_numpchgs(pi->pchglist)) { 				pi->pchg = &pi->defaultpchg; 			} else { 				return 1; 			} 		}  		pchg = pi->pchg; 		switch (pchg->prgord) { 		case JPC_COD_LRCPPRG: 			ret = jpc_pi_nextlrcp(pi); 			break; 		case JPC_COD_RLCPPRG: 			ret = jpc_pi_nextrlcp(pi); 			break; 		case JPC_COD_RPCLPRG: 			ret = jpc_pi_nextrpcl(pi); 			break; 		case JPC_COD_PCRLPRG: 			ret = jpc_pi_nextpcrl(pi); 			break; 		case JPC_COD_CPRLPRG: 			ret = jpc_pi_nextcprl(pi); 			break; 		default: 			ret = -1; 			break; 		} 		if (!ret) { 			pi->valid = true; 			++pi->pktno; 			return 0; 		} 		pi->pchg = 0; 	} }
void jas_matrix_asl(jas_matrix_t *matrix, int n) { 	int i; 	int j; 	jas_seqent_t *rowstart; 	int rowstep; 	jas_seqent_t *data;  	rowstep = jas_matrix_rowstep(matrix); 	for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i, 	  rowstart += rowstep) { 		for (j = matrix->numcols_, data = rowstart; j > 0; --j, 		  ++data) { 			*data <<= n; 		} 	} }
jas_cmprof_t *jas_cmprof_createfromiccprof(jas_iccprof_t *iccprof) { 	jas_cmprof_t *prof; 	jas_icchdr_t icchdr; 	jas_cmpxformseq_t *fwdpxformseq; 	jas_cmpxformseq_t *revpxformseq;  	prof = 0; 	fwdpxformseq = 0; 	revpxformseq = 0;  	if (!(prof = jas_cmprof_create())) 		goto error; 	jas_iccprof_gethdr(iccprof, &icchdr); 	if (!(prof->iccprof = jas_iccprof_copy(iccprof))) 		goto error; 	prof->clrspc = icctoclrspc(icchdr.colorspc, 0); 	prof->refclrspc = icctoclrspc(icchdr.refcolorspc, 1); 	prof->numchans = jas_clrspc_numchans(prof->clrspc); 	prof->numrefchans = jas_clrspc_numchans(prof->refclrspc);  	if (prof->numchans == 1) { 		if (mono(prof->iccprof, 0, &fwdpxformseq)) 			goto error; 		if (mono(prof->iccprof, 1, &revpxformseq)) 			goto error; 	} else if (prof->numchans == 3) { 		if (triclr(prof->iccprof, 0, &fwdpxformseq)) 			goto error; 		if (triclr(prof->iccprof, 1, &revpxformseq)) 			goto error; 	} 	prof->pxformseqs[SEQFWD(0)] = fwdpxformseq; 	prof->pxformseqs[SEQREV(0)] = revpxformseq;  #if 0 	if (prof->numchans > 1) { 		lut(prof->iccprof, 0, PER, &pxformseq); 		pxformseqs_set(prof, SEQFWD(PER), pxformseq); 		lut(prof->iccprof, 1, PER, &pxformseq); 		pxformseqs_set(prof, SEQREV(PER), pxformseq); 		lut(prof->iccprof, 0, CLR, &pxformseq); 		pxformseqs_set(prof, SEQREV(CLR), pxformseq); 		lut(prof->iccprof, 1, CLR, &pxformseq); 		pxformseqs_set(prof, SEQREV(CLR), pxformseq); 		lut(prof->iccprof, 0, SAT, &pxformseq); 		pxformseqs_set(prof, SEQREV(SAT), pxformseq); 		lut(prof->iccprof, 1, SAT, &pxformseq); 		pxformseqs_set(prof, SEQREV(SAT), pxformseq); 	} #endif  	return prof;  error: 	if (fwdpxformseq) { 		jas_cmpxformseq_destroy(fwdpxformseq); 	} 	if (revpxformseq) { 		jas_cmpxformseq_destroy(revpxformseq); 	} 	if (prof) { 		jas_cmprof_destroy(prof); 	}  	return 0; }
int jpc_enc_encpkt(jpc_enc_t *enc, jas_stream_t *out, int compno, int lvlno, int prcno, int lyrno) { 	jpc_enc_tcmpt_t *comp; 	jpc_enc_rlvl_t *lvl; 	jpc_enc_band_t *band; 	jpc_enc_band_t *endbands; 	jpc_enc_cblk_t *cblk; 	jpc_enc_cblk_t *endcblks; 	jpc_bitstream_t *outb; 	jpc_enc_pass_t *pass; 	jpc_enc_pass_t *startpass; 	jpc_enc_pass_t *lastpass; 	jpc_enc_pass_t *endpass; 	jpc_enc_pass_t *endpasses; 	int i; 	int included; 	int ret; 	jpc_tagtreenode_t *leaf; 	int n; 	int t1; 	int t2; 	int adjust; 	int maxadjust; 	int datalen; 	int numnewpasses; 	int passcount; 	jpc_enc_tile_t *tile; 	jpc_enc_prc_t *prc; 	jpc_enc_cp_t *cp; 	jpc_ms_t *ms;  	tile = enc->curtile; 	cp = enc->cp;  	if (cp->tcp.csty & JPC_COD_SOP) { 		if (!(ms = jpc_ms_create(JPC_MS_SOP))) { 			return -1; 		} 		ms->parms.sop.seqno = jpc_pi_getind(tile->pi); 		if (jpc_putms(out, enc->cstate, ms)) { 			return -1; 		} 		jpc_ms_destroy(ms); 	}  	outb = jpc_bitstream_sopen(out, "w+"); 	assert(outb);  	if (jpc_bitstream_putbit(outb, 1) == EOF) { 		return -1; 	} 	JAS_DBGLOG(10, ("\n")); 	JAS_DBGLOG(10, ("present. "));  	comp = &tile->tcmpts[compno]; 	lvl = &comp->rlvls[lvlno]; 	endbands = &lvl->bands[lvl->numbands]; 	for (band = lvl->bands; band != endbands; ++band) { 		if (!band->data) { 			continue; 		} 		prc = &band->prcs[prcno]; 		if (!prc->cblks) { 			continue; 		}  		endcblks = &prc->cblks[prc->numcblks]; 		for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 			if (!lyrno) { 				leaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks); 				jpc_tagtree_setvalue(prc->nlibtree, leaf, cblk->numimsbs); 			} 			pass = cblk->curpass; 			included = (pass && pass->lyrno == lyrno); 			if (included && (!cblk->numencpasses)) { 				assert(pass->lyrno == lyrno); 				leaf = jpc_tagtree_getleaf(prc->incltree, 				  cblk - prc->cblks); 				jpc_tagtree_setvalue(prc->incltree, leaf, pass->lyrno); 			} 		}  		endcblks = &prc->cblks[prc->numcblks]; 		for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 			pass = cblk->curpass; 			included = (pass && pass->lyrno == lyrno); 			if (!cblk->numencpasses) { 				leaf = jpc_tagtree_getleaf(prc->incltree, 				  cblk - prc->cblks); 				if (jpc_tagtree_encode(prc->incltree, leaf, lyrno 				  + 1, outb) < 0) { 					return -1; 				} 			} else { 				if (jpc_bitstream_putbit(outb, included) == EOF) { 					return -1; 				} 			} 			JAS_DBGLOG(10, ("included=%d ", included)); 			if (!included) { 				continue; 			} 			if (!cblk->numencpasses) { 				i = 1; 				leaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks); 				for (;;) { 					if ((ret = jpc_tagtree_encode(prc->nlibtree, leaf, i, outb)) < 0) { 						return -1; 					} 					if (ret) { 						break; 					} 					++i; 				} 				assert(leaf->known_ && i == leaf->value_ + 1); 			}  			endpasses = &cblk->passes[cblk->numpasses]; 			startpass = pass; 			endpass = startpass; 			while (endpass != endpasses && endpass->lyrno == lyrno){ 				++endpass; 			} 			numnewpasses = endpass - startpass; 			if (jpc_putnumnewpasses(outb, numnewpasses)) { 				return -1; 			} 			JAS_DBGLOG(10, ("numnewpasses=%d ", numnewpasses));  			lastpass = endpass - 1; 			n = startpass->start; 			passcount = 1; 			maxadjust = 0; 			for (pass = startpass; pass != endpass; ++pass) { 				if (pass->term || pass == lastpass) { 					datalen = pass->end - n; 					t1 = jpc_firstone(datalen) + 1; 					t2 = cblk->numlenbits + jpc_floorlog2(passcount); 					adjust = JAS_MAX(t1 - t2, 0); 					maxadjust = JAS_MAX(adjust, maxadjust); 					n += datalen; 					passcount = 1; 				} else { 					++passcount; 				} 			} 			if (jpc_putcommacode(outb, maxadjust)) { 				return -1; 			} 			cblk->numlenbits += maxadjust;  			lastpass = endpass - 1; 			n = startpass->start; 			passcount = 1; 			for (pass = startpass; pass != endpass; ++pass) { 				if (pass->term || pass == lastpass) { 					datalen = pass->end - n; assert(jpc_firstone(datalen) < cblk->numlenbits + jpc_floorlog2(passcount)); 					if (jpc_bitstream_putbits(outb, cblk->numlenbits + jpc_floorlog2(passcount), datalen) == EOF) { 						return -1; 					} 					n += datalen; 					passcount = 1; 				} else { 					++passcount; 				} 			} 		} 	}  	jpc_bitstream_outalign(outb, 0); 	jpc_bitstream_close(outb);  	if (cp->tcp.csty & JPC_COD_EPH) { 		if (!(ms = jpc_ms_create(JPC_MS_EPH))) { 			return -1; 		} 		jpc_putms(out, enc->cstate, ms); 		jpc_ms_destroy(ms); 	}  	comp = &tile->tcmpts[compno]; 	lvl = &comp->rlvls[lvlno]; 	endbands = &lvl->bands[lvl->numbands]; 	for (band = lvl->bands; band != endbands; ++band) { 		if (!band->data) { 			continue; 		} 		prc = &band->prcs[prcno]; 		if (!prc->cblks) { 			continue; 		} 		endcblks = &prc->cblks[prc->numcblks]; 		for (cblk = prc->cblks; cblk != endcblks; ++cblk) { 			pass = cblk->curpass;  			if (!pass) { 				continue; 			} 			if (pass->lyrno != lyrno) { 				assert(pass->lyrno < 0 || pass->lyrno > lyrno); 				continue; 			}  			endpasses = &cblk->passes[cblk->numpasses]; 			startpass = pass; 			endpass = startpass; 			while (endpass != endpasses && endpass->lyrno == lyrno){ 				++endpass; 			} 			lastpass = endpass - 1; 			numnewpasses = endpass - startpass;  			jas_stream_seek(cblk->stream, startpass->start, SEEK_SET); 			assert(jas_stream_tell(cblk->stream) == startpass->start); 			if (jas_stream_copy(out, cblk->stream, lastpass->end - startpass->start)) { 				return -1; 			} 			cblk->curpass = (endpass != endpasses) ? endpass : 0; 			cblk->numencpasses += numnewpasses;  		} 	}  	return 0; }
static int jp2_putuint32(jas_stream_t *out, uint_fast32_t val) { 	if (jas_stream_putc(out, (val >> 24) & 0xff) == EOF || 	  jas_stream_putc(out, (val >> 16) & 0xff) == EOF || 	  jas_stream_putc(out, (val >> 8) & 0xff) == EOF || 	  jas_stream_putc(out, val & 0xff) == EOF) { 		return -1; 	} 	return 0; }
static int pnm_gethdr(jas_stream_t *in, pnm_hdr_t *hdr) { 	int_fast32_t maxval; 	int_fast32_t width; 	int_fast32_t height; 	if (pnm_getint16(in, &hdr->magic) || pnm_getsintstr(in, &width) || 	  pnm_getsintstr(in, &height)) { 		return -1; 	} 	hdr->width = width; 	hdr->height = height; 	if (pnm_type(hdr->magic) != PNM_TYPE_PBM) { 		if (pnm_getsintstr(in, &maxval)) { 			return -1; 		} 	} else { 		maxval = 1; 	} 	if (maxval < 0) { 		hdr->maxval = -maxval; 		hdr->sgnd = true; 	} else { 		hdr->maxval = maxval; 		hdr->sgnd = false; 	}  	switch (pnm_type(hdr->magic)) { 	case PNM_TYPE_PBM: 	case PNM_TYPE_PGM: 		hdr->numcmpts = 1; 		break; 	case PNM_TYPE_PPM: 		hdr->numcmpts = 3; 		break; 	default: 		abort(); 		break; 	}  	return 0; }
