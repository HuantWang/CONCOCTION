-----label-----
0
-----code-----
int jpc_tagtree_encode(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf,
  int threshold, jpc_bitstream_t *out)
{
	jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];
	jpc_tagtreenode_t **stkptr;
	jpc_tagtreenode_t *node;
	int low;

	/* Avoid compiler warnings about unused parameters. */
	tree = 0;

	assert(leaf);
	assert(threshold >= 0);

	/* Traverse to the root of the tree, recording the path taken. */
	stkptr = stk;
	node = leaf;
	while (node->parent_) {
		*stkptr++ = node;
		node = node->parent_;
	}

	low = 0;
	for (;;) {
		if (low > node->low_) {
			/* Deferred propagation of the lower bound downward in
			  the tree. */
			node->low_ = low;
		} else {
			low = node->low_;
		}

		while (low < threshold) {
			if (low >= node->value_) {
				if (!node->known_) {
					if (jpc_bitstream_putbit(out, 1) == EOF) {
						return -1;
					}
					node->known_ = 1;
				}
				break;
			}
			if (jpc_bitstream_putbit(out, 0) == EOF) {
				return -1;
			}
			++low;
		}
		node->low_ = low;
		if (stkptr == stk) {
			break;
		}
		node = *--stkptr;

	}
	return (leaf->low_ < threshold) ? 1 : 0;

}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
19,20
21,22
21,23
22,23
24,25
24,26
27,28
27,29
27,30
27,31
27,32
27,33
27,34
27,35
27,36
27,37
27,38
27,39
27,40
28,29
29,30
29,31
30,31
32,33
32,34
32,35
35,36
36,37
36,38
37,38
40,41
41,42
41,43
42,43
44,45
44,46
44,47
48,49
49,50
49,51
50,51
52,53
52,54
55,56
56,57
56,58
58,59
60,61
61,62
61,63
62,63
65,66
66,67
66,68
67,68
69,70
71,72
72,73
72,74
73,74
75,76
75,77
76,77
79,80
80,81
80,82
81,82
83,84
85,86
86,87
86,88
87,88
89,90
91,92
91,93
92,93
92,94
93,94
96,97
96,98
97,98
98,99
98,100
99,100
100,101
101,102
103,104
105,106
106,107
106,108
107,108
109,110
109,111
110,111
113,114
114,115
114,116
115,116
118,119
118,120
120,121
120,122
120,123
120,124
120,125
121,122
121,123
121,124
122,123
122,124
123,124
125,126
125,127
126,127
129,130
130,131
131,132
131,133
132,133
132,134
133,134
136,137
138,139
139,140
140,141
140,142
141,142
143,144
143,145
144,145
147,148
147,149
148,149
148,150
149,150
151,152
153,154
153,155
153,156
154,155
154,156
155,156
155,157
156,157
158,159
158,160
159,160
162,163
162,164
163,164
163,165
164,165
165,166
165,167
166,167
169,170
169,171
170,171
170,172
171,172
171,173
172,173
172,174
172,175
173,174
175,176
178,179
180,181
181,182
182,183
184,185
185,186
185,187
186,187
186,188
187,188
192,193
192,194
193,194
193,195
194,195
194,196
194,197
195,196
197,198
200,201
202,203
203,204
204,205
206,207
207,208
208,209
210,211
211,212
211,213
212,213
212,214
213,214
216,217
218,219
218,220
219,220
219,221
220,221
222,223
224,225
226,227
227,228
227,229
228,229
230,231
231,232
232,233
234,235
235,236
235,237
235,238
236,237
237,238
237,239
238,239
238,240
239,240
242,243
-----nextToken-----
2,4,7,9,10,13,15,16,18,20,23,25,26,31,33,34,38,39,43,45,46,47,51,53,54,57,59,63,64,68,70,74,77,78,82,84,88,90,94,95,102,104,108,111,112,116,117,119,124,127,128,134,135,137,142,145,146,150,152,157,160,161,167,168,174,176,177,179,183,188,189,190,191,196,198,199,201,205,209,214,215,217,221,223,225,229,233,240,241,243,244,245
-----computeFrom-----
36,37
36,38
61,62
61,63
75,76
75,77
80,81
80,82
86,87
86,88
98,99
98,100
106,107
106,108
114,115
114,116
122,123
122,124
131,132
131,133
140,141
140,142
148,149
148,150
155,156
155,157
171,172
171,173
185,186
185,187
193,194
193,195
211,212
211,213
219,220
219,221
227,228
227,229
237,238
237,239
-----guardedBy-----
127,134
124,137
128,135
160,188
-----guardedByNegation-----
127,145
124,142
128,146
-----lastLexicalUse-----
127,145
124,142
128,146
-----jump-----
127,145
124,142
128,146
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;ArrayDeclarator;Pointer;Name;ArrayModifier;BinaryExpression;IdExpression;Name;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;WhileStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ForStatement;NullStatement;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ReturnStatement;ConditionalExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;
-----ast_node-----
int jpc_tagtree_encode(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf,  int threshold, jpc_bitstream_t *out){	jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];	jpc_tagtreenode_t **stkptr;	jpc_tagtreenode_t *node;	int low;	/* Avoid compiler warnings about unused parameters. */	tree = 0;	assert(leaf);	assert(threshold >= 0);	/* Traverse to the root of the tree, recording the path taken. */	stkptr = stk;	node = leaf;	while (node->parent_) {		*stkptr++ = node;		node = node->parent_;	}	low = 0;	for (;;) {		if (low > node->low_) {			/* Deferred propagation of the lower bound downward in			  the tree. */			node->low_ = low;		} else {			low = node->low_;		}		while (low < threshold) {			if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}			if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}			++low;		}		node->low_ = low;		if (stkptr == stk) {			break;		}		node = *--stkptr;	}	return (leaf->low_ < threshold) ? 1 : 0;}
int
jpc_tagtree_encode(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf,  int threshold, jpc_bitstream_t *out)
jpc_tagtree_encode
jpc_tagtree_t *tree
jpc_tagtree_t
jpc_tagtree_t
*tree
*
tree
jpc_tagtreenode_t *leaf
jpc_tagtreenode_t
jpc_tagtreenode_t
*leaf
*
leaf
int threshold
int
threshold
threshold
jpc_bitstream_t *out
jpc_bitstream_t
jpc_bitstream_t
*out
*
out
{	jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];	jpc_tagtreenode_t **stkptr;	jpc_tagtreenode_t *node;	int low;	/* Avoid compiler warnings about unused parameters. */	tree = 0;	assert(leaf);	assert(threshold >= 0);	/* Traverse to the root of the tree, recording the path taken. */	stkptr = stk;	node = leaf;	while (node->parent_) {		*stkptr++ = node;		node = node->parent_;	}	low = 0;	for (;;) {		if (low > node->low_) {			/* Deferred propagation of the lower bound downward in			  the tree. */			node->low_ = low;		} else {			low = node->low_;		}		while (low < threshold) {			if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}			if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}			++low;		}		node->low_ = low;		if (stkptr == stk) {			break;		}		node = *--stkptr;	}	return (leaf->low_ < threshold) ? 1 : 0;}
jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];
jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];
jpc_tagtreenode_t
jpc_tagtreenode_t
*stk[JPC_TAGTREE_MAXDEPTH - 1]
*
stk
[JPC_TAGTREE_MAXDEPTH - 1]
JPC_TAGTREE_MAXDEPTH - 1
JPC_TAGTREE_MAXDEPTH
JPC_TAGTREE_MAXDEPTH
1
jpc_tagtreenode_t **stkptr;
jpc_tagtreenode_t **stkptr;
jpc_tagtreenode_t
jpc_tagtreenode_t
**stkptr
*
*
stkptr
jpc_tagtreenode_t *node;
jpc_tagtreenode_t *node;
jpc_tagtreenode_t
jpc_tagtreenode_t
*node
*
node
int low;
int low;
int
low
low
tree = 0;
tree = 0
tree
tree
0
assert(leaf);
assert(leaf)
assert
assert
leaf
leaf
assert(threshold >= 0);
assert(threshold >= 0)
assert
assert
threshold >= 0
threshold
threshold
0
stkptr = stk;
stkptr = stk
stkptr
stkptr
stk
stk
node = leaf;
node = leaf
node
node
leaf
leaf
while (node->parent_) {		*stkptr++ = node;		node = node->parent_;	}
node->parent_
node
node
parent_
{		*stkptr++ = node;		node = node->parent_;	}
*stkptr++ = node;
*stkptr++ = node
*stkptr++
stkptr++
stkptr
stkptr
node
node
node = node->parent_;
node = node->parent_
node
node
node->parent_
node
node
parent_
low = 0;
low = 0
low
low
0
for (;;) {		if (low > node->low_) {			/* Deferred propagation of the lower bound downward in			  the tree. */			node->low_ = low;		} else {			low = node->low_;		}		while (low < threshold) {			if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}			if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}			++low;		}		node->low_ = low;		if (stkptr == stk) {			break;		}		node = *--stkptr;	}
;
{		if (low > node->low_) {			/* Deferred propagation of the lower bound downward in			  the tree. */			node->low_ = low;		} else {			low = node->low_;		}		while (low < threshold) {			if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}			if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}			++low;		}		node->low_ = low;		if (stkptr == stk) {			break;		}		node = *--stkptr;	}
if (low > node->low_) {			/* Deferred propagation of the lower bound downward in			  the tree. */			node->low_ = low;		} else {			low = node->low_;		}
low > node->low_
low
low
node->low_
node
node
low_
{			/* Deferred propagation of the lower bound downward in			  the tree. */			node->low_ = low;		}
node->low_ = low;
node->low_ = low
node->low_
node
node
low_
low
low
{			low = node->low_;		}
low = node->low_;
low = node->low_
low
low
node->low_
node
node
low_
while (low < threshold) {			if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}			if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}			++low;		}
low < threshold
low
low
threshold
threshold
{			if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}			if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}			++low;		}
if (low >= node->value_) {				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}
low >= node->value_
low
low
node->value_
node
node
value_
{				if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}				break;			}
if (!node->known_) {					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}
!node->known_
node->known_
node
node
known_
{					if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}					node->known_ = 1;				}
if (jpc_bitstream_putbit(out, 1) == EOF) {						return -1;					}
jpc_bitstream_putbit(out, 1) == EOF
jpc_bitstream_putbit(out, 1)
jpc_bitstream_putbit
jpc_bitstream_putbit
out
out
1
EOF
EOF
{						return -1;					}
return -1;
-1
1
node->known_ = 1;
node->known_ = 1
node->known_
node
node
known_
1
break;
if (jpc_bitstream_putbit(out, 0) == EOF) {				return -1;			}
jpc_bitstream_putbit(out, 0) == EOF
jpc_bitstream_putbit(out, 0)
jpc_bitstream_putbit
jpc_bitstream_putbit
out
out
0
EOF
EOF
{				return -1;			}
return -1;
-1
1
++low;
++low
low
low
node->low_ = low;
node->low_ = low
node->low_
node
node
low_
low
low
if (stkptr == stk) {			break;		}
stkptr == stk
stkptr
stkptr
stk
stk
{			break;		}
break;
node = *--stkptr;
node = *--stkptr
node
node
*--stkptr
--stkptr
stkptr
stkptr
return (leaf->low_ < threshold) ? 1 : 0;
(leaf->low_ < threshold) ? 1 : 0
(leaf->low_ < threshold)
leaf->low_ < threshold
leaf->low_
leaf
leaf
low_
threshold
threshold
1
0
-----joern-----
(12,8,0)
(27,0,0)
(68,13,0)
(6,67,0)
(54,28,0)
(56,43,0)
(6,27,0)
(5,21,0)
(52,61,0)
(8,32,0)
(65,46,0)
(44,17,0)
(61,51,0)
(62,42,0)
(44,28,0)
(66,42,0)
(24,45,0)
(10,27,0)
(49,10,0)
(28,51,0)
(22,0,0)
(39,61,0)
(0,11,0)
(32,61,0)
(40,62,0)
(2,28,0)
(57,62,0)
(36,23,0)
(4,21,0)
(8,64,0)
(41,13,0)
(18,6,0)
(59,53,0)
(15,46,0)
(62,51,0)
(26,6,0)
(55,53,0)
(23,24,0)
(5,51,0)
(29,43,0)
(20,43,0)
(24,23,0)
(28,44,0)
(13,21,0)
(37,5,0)
(30,32,0)
(17,11,0)
(53,42,0)
(60,67,0)
(32,43,0)
(34,17,0)
(21,5,0)
(66,29,0)
(17,44,0)
(38,10,0)
(21,43,0)
(4,45,0)
(48,0,0)
(19,60,0)
(42,62,0)
(58,64,0)
(9,43,0)
(63,27,0)
(47,23,0)
(42,66,0)
(27,43,0)
(50,60,0)
(14,21,0)
(1,27,0)
(46,27,0)
(63,45,0)
(0,27,0)
(10,24,0)
(46,41,0)
(61,32,0)
(41,45,0)
(67,60,0)
(23,21,0)
(60,21,0)
(7,4,0)
(3,63,0)
(13,41,0)
(66,44,0)
(53,11,0)
(35,13,0)
(44,66,0)
(42,53,0)
(16,5,0)
(33,43,0)
(25,17,0)
(29,66,0)
(64,8,0)
(67,45,0)
(37,14,1)
(12,27,1)
(67,60,1)
(66,42,1)
(36,10,1)
(13,35,1)
(60,50,1)
(10,27,1)
(31,64,1)
(46,65,1)
(24,23,1)
(25,34,1)
(14,32,1)
(23,21,1)
(58,8,1)
(48,22,1)
(62,51,1)
(32,61,1)
(22,1,1)
(10,38,1)
(42,53,1)
(8,32,1)
(53,59,1)
(34,28,1)
(66,44,1)
(6,27,1)
(39,30,1)
(57,44,1)
(30,29,1)
(13,21,1)
(49,41,1)
(15,67,1)
(17,25,1)
(29,66,1)
(23,47,1)
(28,54,1)
(61,51,1)
(40,57,1)
(21,5,1)
(42,62,1)
(41,13,1)
(5,16,1)
(65,15,1)
(4,7,1)
(53,11,1)
(50,19,1)
(68,46,1)
(26,64,1)
(0,11,1)
(38,49,1)
(0,48,1)
(55,62,1)
(8,12,1)
(64,8,1)
(47,36,1)
(12,4,1)
(60,21,1)
(46,27,1)
(64,58,1)
(1,21,1)
(52,39,1)
(4,21,1)
(35,68,1)
(54,2,1)
(62,40,1)
(63,27,1)
(5,51,1)
(44,28,1)
(19,6,1)
(63,3,1)
(59,55,1)
(7,63,1)
(17,11,1)
(28,51,1)
(6,18,1)
(18,26,1)
(16,37,1)
(61,52,1)
(3,24,1)
(44,17,1)
(27,0,1)
(42,53,2)
(53,44,2)
(19,64,2)
(36,64,2)
(0,11,2)
(10,27,2)
(41,13,2)
(15,64,2)
(63,27,2)
(55,44,2)
(5,51,2)
(44,17,2)
(8,32,2)
(6,64,2)
(61,51,2)
(59,44,2)
(3,64,2)
(38,64,2)
(7,64,2)
(12,64,2)
(4,64,2)
(53,11,2)
(58,64,2)
(49,64,2)
(17,11,2)
(64,64,2)
(24,64,2)
(46,64,2)
(41,64,2)
(13,21,2)
(67,64,2)
(57,44,2)
(32,61,2)
(35,64,2)
(23,64,2)
(40,44,2)
(42,44,2)
(46,27,2)
(24,23,2)
(66,44,2)
(64,8,2)
(28,51,2)
(8,64,2)
(42,62,2)
(13,64,2)
(63,64,2)
(29,66,2)
(68,64,2)
(27,0,2)
(21,5,2)
(60,64,2)
(65,64,2)
(47,64,2)
(18,64,2)
(10,64,2)
(60,21,2)
(66,42,2)
(6,27,2)
(62,51,2)
(50,64,2)
(23,21,2)
(44,28,2)
(67,60,2)
(4,21,2)
(62,44,2)
(26,64,2)
-----------------------------------
(0,dsttree->nodes_)
(1,dstnode)
(2,srctree)
(3,dstnode)
(4,++srcnode)
(5,srctree->nodes_)
(6,dstnode->value_)
(7,srcnode)
(8,--n)
(9,n)
(10,dstnode->known_)
(11,jpc_tagtree_t *dsttree)
(12,n)
(13,srcnode->low_)
(14,srcnode)
(15,dstnode)
(16,nodes_)
(17,dsttree->numleafsh_)
(18,value_)
(19,srcnode)
(20,while (--n >= 0)
(21,srcnode = srctree->nodes_)
(22,dsttree)
(23,srcnode->known_)
(24,dstnode->known_ = srcnode->known_)
(25,numleafsh_)
(26,dstnode)
(27,dstnode = dsttree->nodes_)
(28,srctree->numleafsh_)
(29,assert(srctree->numleafsh_ == dsttree->numleafsh_ &&\\n\\t  srctree->numleafsv_ == dsttree->numleafsv_)
(30,n)
(31,RET)
(32,n = srctree->numnodes_)
(33,srcnode)
(34,dsttree)
(35,low_)
(36,srcnode)
(37,srctree)
(38,known_)
(39,srctree)
(40,numleafsv_)
(41,dstnode->low_ = srcnode->low_)
(42,srctree->numleafsv_ == dsttree->numleafsv_)
(43,)
(44,srctree->numleafsh_ == dsttree->numleafsh_)
(45,)
(46,dstnode->low_)
(47,known_)
(48,nodes_)
(49,dstnode)
(50,value_)
(51,jpc_tagtree_t *srctree)
(52,numnodes_)
(53,dsttree->numleafsv_)
(54,numleafsh_)
(55,dsttree)
(56,dstnode)
(57,srctree)
(58,0)
(59,numleafsv_)
(60,srcnode->value_)
(61,srctree->numnodes_)
(62,srctree->numleafsv_)
(63,++dstnode)
(64,--n >= 0)
(65,low_)
(66,srctree->numleafsh_ == dsttree->numleafsh_ &&\\n\\t  srctree->numleafsv_ == dsttree->numleafsv_)
(67,dstnode->value_ = srcnode->value_)
(68,srcnode)
-----cfg-----
(129,58)
(131,129)
(132,131)
(134,143)
(135,134)
(7,17)
(136,135)
(137,136)
(139,137)
(17,20)
(20,23)
(22,26)
(23,22)
(26,29)
(29,35)
(33,39)
(33,47)
(35,33)
(37,46)
(38,37)
(39,38)
(42,35)
(44,42)
(46,44)
(47,58)
(54,63)
(54,71)
(56,54)
(58,56)
(60,73)
(61,60)
(63,61)
(67,73)
(69,67)
(71,69)
(73,82)
(73,121)
(78,88)
(78,108)
(80,78)
(82,80)
(85,92)
(85,121)
(86,85)
(88,86)
(91,98)
(91,103)
(92,91)
(97,143)
(98,97)
(100,121)
(101,100)
(103,101)
(107,114)
(107,116)
(108,107)
(113,143)
(114,113)
(116,73)
(118,124)
(119,118)
(121,119)
(124,139)
(124,132)
-----path-----
7,17,20,23,22,26,29,35,33,47,58,56,54,63,61,60,73,82,80,78,88,86,85,92,91,98,97,143
7,17,20,23,22,26,29,35,33,47,58,56,54,63,61,60,73,82,80,78,88,86,85,92,91,103,101,100,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,63,61,60,73,82,80,78,88,86,85,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,63,61,60,73,82,80,78,108,107,114,113,143
7,17,20,23,22,26,29,35,33,47,58,56,54,63,61,60,73,82,80,78,108,107,116,73,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,63,61,60,73,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,71,69,67,73,82,80,78,88,86,85,92,91,98,97,143
7,17,20,23,22,26,29,35,33,47,58,56,54,71,69,67,73,82,80,78,88,86,85,92,91,103,101,100,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,71,69,67,73,82,80,78,88,86,85,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,71,69,67,73,82,80,78,108,107,114,113,143
7,17,20,23,22,26,29,35,33,47,58,56,54,71,69,67,73,82,80,78,108,107,116,73,121,119,118,124,139,137,136,135,134,143
7,17,20,23,22,26,29,35,33,47,58,56,54,71,69,67,73,121,119,118,124,139,137,136,135,134,143
-----cfgNode-----
5,<global>
6,<empty>
7,int jpc_tagtree_encode (jpc_tagtree_t *tree,jpc_tagtreenode_t *leaf,int threshold,jpc_bitstream_t *out)
8,jpc_tagtree_t *tree
9,jpc_tagtreenode_t *leaf
10,int threshold
11,jpc_bitstream_t *out
12,<empty>
13,jpc_tagtreenode_t ** [] stk
14,jpc_tagtreenode_t** stkptr
15,jpc_tagtreenode_t* node
16,int low
17,tree = 0
18,tree
19,0
20,assert(leaf)
21,leaf
22,assert(threshold >= 0)
23,threshold >= 0
24,threshold
25,0
26,stkptr = stk
27,stkptr
28,stk
29,node = leaf
30,node
31,leaf
32,while (node->parent_)
33,node->parent_
34,node
35,parent_
36,<empty>
37,*stkptr++ = node
38,*stkptr++
39,stkptr++
40,stkptr
41,node
42,node = node->parent_
43,node
44,node->parent_
45,node
46,parent_
47,low = 0
48,low
49,0
50,for (;;)
51,<empty>
52,<empty>
53,if (low > node->low_)
54,low > node->low_
55,low
56,node->low_
57,node
58,low_
59,<empty>
60,node->low_ = low
61,node->low_
62,node
63,low_
64,low
65,else
66,<empty>
67,low = node->low_
68,low
69,node->low_
70,node
71,low_
72,while (low < threshold)
73,low < threshold
74,low
75,threshold
76,<empty>
77,if (low >= node->value_)
78,low >= node->value_
79,low
80,node->value_
81,node
82,value_
83,<empty>
84,if (!node->known_)
85,!node->known_
86,node->known_
87,node
88,known_
89,<empty>
90,if (jpc_bitstream_putbit(out, 1) == EOF)
91,jpc_bitstream_putbit(out, 1) == EOF
92,jpc_bitstream_putbit(out, 1)
93,out
94,1
95,EOF
96,<empty>
97,return -1;
98,-1
99,1
100,node->known_ = 1
101,node->known_
102,node
103,known_
104,1
105,break;
106,if (jpc_bitstream_putbit(out, 0) == EOF)
107,jpc_bitstream_putbit(out, 0) == EOF
108,jpc_bitstream_putbit(out, 0)
109,out
110,0
111,EOF
112,<empty>
113,return -1;
114,-1
115,1
116,++low
117,low
118,node->low_ = low
119,node->low_
120,node
121,low_
122,low
123,if (stkptr == stk)
124,stkptr == stk
125,stkptr
126,stk
127,<empty>
128,break;
129,node = *--stkptr
130,node
131,*--stkptr
132,--stkptr
133,stkptr
134,return (leaf->low_ < threshold) ? 1 : 0;
135,(leaf->low_ < threshold) ? 1 : 0
136,leaf->low_ < threshold
137,leaf->low_
138,leaf
139,low_
140,threshold
141,1
142,0
143,RET
144,jpc_tagtree_t *tree
145,jpc_tagtreenode_t *leaf
146,int threshold
147,jpc_bitstream_t *out
148,RET
149,int jpc_tagtree_encode (jpc_tagtree_t *tree,jpc_tagtreenode_t *leaf,int threshold,jpc_bitstream_t *out)
150,jpc_tagtree_t *tree
151,jpc_tagtreenode_t *leaf
152,int threshold
153,jpc_bitstream_t *out
154,<empty>
155,jpc_tagtreenode_t ** [] stk
156,jpc_tagtreenode_t** stkptr
157,jpc_tagtreenode_t* node
158,int low
159,tree = 0
160,tree
161,0
162,assert(leaf)
163,leaf
164,assert(threshold >= 0)
165,threshold >= 0
166,threshold
167,0
168,stkptr = stk
169,stkptr
170,stk
171,node = leaf
172,node
173,leaf
174,while (node->parent_)
175,node->parent_
176,node
177,parent_
178,<empty>
179,*stkptr++ = node
180,*stkptr++
181,stkptr++
182,stkptr
183,node
184,node = node->parent_
185,node
186,node->parent_
187,node
188,parent_
189,low = 0
190,low
191,0
192,for (;;)
193,<empty>
194,<empty>
195,if (low > node->low_)
196,low > node->low_
197,low
198,node->low_
199,node
200,low_
201,<empty>
202,node->low_ = low
203,node->low_
204,node
205,low_
206,low
207,else
208,<empty>
209,low = node->low_
210,low
211,node->low_
212,node
213,low_
214,while (low < threshold)
215,low < threshold
216,low
217,threshold
218,<empty>
219,if (low >= node->value_)
220,low >= node->value_
221,low
222,node->value_
223,node
224,value_
225,<empty>
226,if (!node->known_)
227,!node->known_
228,node->known_
229,node
230,known_
231,<empty>
232,if (jpc_bitstream_putbit(out, 1) == EOF)
233,jpc_bitstream_putbit(out, 1) == EOF
234,jpc_bitstream_putbit(out, 1)
235,out
236,1
237,EOF
238,<empty>
239,return -1;
240,-1
241,1
242,node->known_ = 1
243,node->known_
244,node
245,known_
246,1
247,break;
248,if (jpc_bitstream_putbit(out, 0) == EOF)
249,jpc_bitstream_putbit(out, 0) == EOF
250,jpc_bitstream_putbit(out, 0)
251,out
252,0
253,EOF
254,<empty>
255,return -1;
256,-1
257,1
258,++low
259,low
260,node->low_ = low
261,node->low_
262,node
263,low_
264,low
265,if (stkptr == stk)
266,stkptr == stk
267,stkptr
268,stk
269,<empty>
270,break;
271,node = *--stkptr
272,node
273,*--stkptr
274,--stkptr
275,stkptr
276,return (leaf->low_ < threshold) ? 1 : 0;
277,(leaf->low_ < threshold) ? 1 : 0
278,leaf->low_ < threshold
279,leaf->low_
280,leaf
281,low_
282,threshold
283,1
284,0
285,RET
286,jpc_tagtree_t *tree
287,jpc_tagtreenode_t *leaf
288,int threshold
289,jpc_bitstream_t *out
=====================================
----------------dynamic----------------
=======testcase========
model_version:0x01000000
A-data-stat:0xa20000000000000010101010101002100100000000000000a48100000000000000000000101010100000000000000000101010101010101000100000000000001010101010101010c5490a6500000000101010101010101099c4096500000000101010101010101099c40965000000001010101010101010101010101010101010101010101010101010101010101010
A-data:0x503337230a0930230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a230a31370c0c30303123000a0c000c23
=========trace=========
int jpc_tagtree_encode(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf,   int threshold, jpc_bitstream_t *out) {
jpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];
jpc_tagtreenode_t **stkptr;
jpc_tagtreenode_t *node;
int low;
tree = 0;
assert(leaf);
assert(threshold >= 0);
stkptr = stk;
node = leaf;
low = 0;
low = node->low_;
while(low < threshold)
++low;
node->low_ = low;
if(stkptr == stk)
return (leaf->low_ < threshold) ? 1 : 0;
=======================
