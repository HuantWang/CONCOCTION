-----label-----
0
-----code-----
jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv)
{
	int nplh[JPC_TAGTREE_MAXDEPTH];
	int nplv[JPC_TAGTREE_MAXDEPTH];
	jpc_tagtreenode_t *node;
	jpc_tagtreenode_t *parentnode;
	jpc_tagtreenode_t *parentnode0;
	jpc_tagtree_t *tree;
	int i;
	int j;
	int k;
	int numlvls;
	int n;

	assert(numleafsh > 0 && numleafsv > 0);

	if (!(tree = jpc_tagtree_alloc())) {
		return 0;
	}
	tree->numleafsh_ = numleafsh;
	tree->numleafsv_ = numleafsv;

	numlvls = 0;
	nplh[0] = numleafsh;
	nplv[0] = numleafsv;
	do {
		n = nplh[numlvls] * nplv[numlvls];
		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
		tree->numnodes_ += n;
		++numlvls;
	} while (n > 1);

	if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {
		return 0;
	}

	/* Initialize the parent links for all nodes in the tree. */

	node = tree->nodes_;
	parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];
	parentnode0 = parentnode;

	for (i = 0; i < numlvls - 1; ++i) {
		for (j = 0; j < nplv[i]; ++j) {
			k = nplh[i];
			while (--k >= 0) {
				node->parent_ = parentnode;
				++node;
				if (--k >= 0) {
					node->parent_ = parentnode;
					++node;
				}
				++parentnode;
			}
			if ((j & 1) || j == nplv[i] - 1) {
				parentnode0 = parentnode;
			} else {
				parentnode = parentnode0;
				parentnode0 += nplh[i];
			}
		}
	}
	node->parent_ = 0;

	/* Initialize the data values to something sane. */

	jpc_tagtree_reset(tree);

	return tree;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
7,8
7,9
9,10
11,12
11,13
13,14
15,16
15,17
15,18
15,19
15,20
15,21
15,22
15,23
15,24
15,25
15,26
15,27
15,28
15,29
15,30
15,31
15,32
15,33
15,34
15,35
15,36
15,37
15,38
15,39
15,40
15,41
15,42
16,17
17,18
17,19
19,20
19,21
21,22
22,23
24,25
25,26
25,27
27,28
27,29
29,30
30,31
32,33
33,34
33,35
34,35
36,37
36,38
39,40
40,41
40,42
41,42
43,44
43,45
46,47
47,48
47,49
48,49
50,51
50,52
53,54
54,55
54,56
55,56
57,58
57,59
60,61
61,62
61,63
63,64
65,66
66,67
66,68
68,69
70,71
71,72
71,73
73,74
75,76
76,77
76,78
78,79
80,81
81,82
81,83
83,84
85,86
86,87
86,88
87,88
89,90
89,91
90,91
90,92
91,92
94,95
94,96
95,96
98,99
98,100
99,100
100,101
101,102
101,103
102,103
104,105
105,106
107,108
108,109
110,111
111,112
111,113
112,113
112,114
113,114
116,117
118,119
119,120
119,121
120,121
120,122
121,122
124,125
126,127
127,128
127,129
128,129
131,132
132,133
132,134
133,134
133,135
134,135
137,138
139,140
140,141
140,142
141,142
141,143
142,143
145,146
147,148
147,149
148,149
148,150
148,151
148,152
148,153
149,150
150,151
150,152
151,152
153,154
153,155
154,155
154,156
155,156
157,158
159,160
159,161
160,161
162,163
164,165
165,166
165,167
166,167
166,168
167,168
169,170
169,171
170,171
173,174
173,175
174,175
175,176
175,177
176,177
176,178
177,178
179,180
183,184
184,185
184,186
185,186
185,187
186,187
188,189
188,190
189,190
192,193
192,194
193,194
194,195
194,196
195,196
195,197
196,197
198,199
202,203
203,204
203,205
204,205
204,206
205,206
208,209
210,211
211,212
212,213
214,215
214,216
215,216
218,219
218,220
219,220
220,221
221,222
221,223
222,223
222,224
223,224
226,227
226,228
227,228
229,230
229,231
230,231
230,232
231,232
234,235
235,236
235,237
236,237
239,240
240,241
242,243
243,244
243,245
244,245
246,247
246,248
247,248
250,251
251,252
251,253
252,253
254,255
255,256
255,257
256,257
256,258
257,258
260,261
260,262
261,262
261,263
262,263
265,266
265,267
266,267
269,270
270,271
270,272
271,272
273,274
275,276
275,277
275,278
275,279
276,277
277,278
277,279
278,279
281,282
281,283
282,283
284,285
284,286
285,286
288,289
289,290
291,292
292,293
292,294
292,295
292,296
293,294
294,295
294,296
295,296
298,299
298,300
299,300
301,302
301,303
302,303
304,305
306,307
307,308
309,310
309,311
309,312
310,311
311,312
311,313
312,313
314,315
314,316
315,316
317,318
319,320
319,321
320,321
320,322
321,322
322,323
325,326
325,327
325,328
325,329
326,327
327,328
327,329
328,329
328,330
329,330
332,333
334,335
335,336
336,337
338,339
338,340
339,340
339,341
340,341
341,342
344,345
344,346
345,346
346,347
346,348
347,348
347,349
348,349
351,352
353,354
354,355
355,356
357,358
358,359
359,360
361,362
361,363
361,364
362,363
362,364
363,364
364,365
364,366
365,366
368,369
368,370
369,370
371,372
371,373
372,373
372,374
373,374
375,376
378,379
379,380
380,381
380,382
381,382
383,384
385,386
385,387
386,387
387,388
387,389
388,389
390,391
392,393
393,394
393,395
394,395
396,397
396,398
397,398
399,400
401,402
402,403
402,404
403,404
403,405
404,405
408,409
409,410
409,411
410,411
412,413
414,415
415,416
-----nextToken-----
3,5,6,8,10,12,14,18,20,23,26,28,31,35,37,38,42,44,45,49,51,52,56,58,59,62,64,67,69,72,74,77,79,82,84,88,92,93,96,97,103,106,109,114,115,117,122,123,125,129,130,135,136,138,143,144,146,152,156,158,161,163,168,171,172,178,180,181,182,187,190,191,197,199,200,201,206,207,209,213,216,217,224,225,228,232,233,237,238,241,245,248,249,253,258,259,263,264,267,268,272,274,279,280,283,286,287,290,296,297,300,303,305,308,313,316,318,323,324,330,331,333,337,342,343,349,350,352,356,360,366,367,370,374,376,377,382,384,389,391,395,398,400,405,406,407,411,413,416
-----computeFrom-----
89,90
89,91
90,91
90,92
94,95
94,96
101,102
101,103
111,112
111,113
119,120
119,121
127,128
127,129
132,133
132,134
140,141
140,142
150,151
150,152
153,154
153,155
165,166
165,167
169,170
169,171
173,174
173,175
175,176
175,177
184,185
184,186
188,189
188,190
192,193
192,194
194,195
194,196
203,204
203,205
214,215
214,216
221,222
221,223
229,230
229,231
243,244
243,245
251,252
251,253
260,261
260,262
270,271
270,272
277,278
277,279
281,282
281,283
284,285
284,286
294,295
294,296
298,299
298,300
311,312
311,313
320,321
320,322
327,328
327,329
339,340
339,341
346,347
346,348
362,363
362,364
364,365
364,366
368,369
368,370
371,372
371,373
380,381
380,382
387,388
387,389
393,394
393,395
402,403
402,404
-----guardedBy-----
-----guardedByNegation-----
376,400
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;CompoundStatement;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;CompoundStatement;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv){	int nplh[JPC_TAGTREE_MAXDEPTH];	int nplv[JPC_TAGTREE_MAXDEPTH];	jpc_tagtreenode_t *node;	jpc_tagtreenode_t *parentnode;	jpc_tagtreenode_t *parentnode0;	jpc_tagtree_t *tree;	int i;	int j;	int k;	int numlvls;	int n;	assert(numleafsh > 0 && numleafsv > 0);	if (!(tree = jpc_tagtree_alloc())) {		return 0;	}	tree->numleafsh_ = numleafsh;	tree->numleafsv_ = numleafsv;	numlvls = 0;	nplh[0] = numleafsh;	nplv[0] = numleafsv;	do {		n = nplh[numlvls] * nplv[numlvls];		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;		tree->numnodes_ += n;		++numlvls;	} while (n > 1);	if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {		return 0;	}	/* Initialize the parent links for all nodes in the tree. */	node = tree->nodes_;	parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];	parentnode0 = parentnode;	for (i = 0; i < numlvls - 1; ++i) {		for (j = 0; j < nplv[i]; ++j) {			k = nplh[i];			while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}			if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}		}	}	node->parent_ = 0;	/* Initialize the data values to something sane. */	jpc_tagtree_reset(tree);	return tree;}
jpc_tagtree_t
jpc_tagtree_t
*jpc_tagtree_create(int numleafsh, int numleafsv)
*
jpc_tagtree_create
int numleafsh
int
numleafsh
numleafsh
int numleafsv
int
numleafsv
numleafsv
{	int nplh[JPC_TAGTREE_MAXDEPTH];	int nplv[JPC_TAGTREE_MAXDEPTH];	jpc_tagtreenode_t *node;	jpc_tagtreenode_t *parentnode;	jpc_tagtreenode_t *parentnode0;	jpc_tagtree_t *tree;	int i;	int j;	int k;	int numlvls;	int n;	assert(numleafsh > 0 && numleafsv > 0);	if (!(tree = jpc_tagtree_alloc())) {		return 0;	}	tree->numleafsh_ = numleafsh;	tree->numleafsv_ = numleafsv;	numlvls = 0;	nplh[0] = numleafsh;	nplv[0] = numleafsv;	do {		n = nplh[numlvls] * nplv[numlvls];		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;		tree->numnodes_ += n;		++numlvls;	} while (n > 1);	if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {		return 0;	}	/* Initialize the parent links for all nodes in the tree. */	node = tree->nodes_;	parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];	parentnode0 = parentnode;	for (i = 0; i < numlvls - 1; ++i) {		for (j = 0; j < nplv[i]; ++j) {			k = nplh[i];			while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}			if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}		}	}	node->parent_ = 0;	/* Initialize the data values to something sane. */	jpc_tagtree_reset(tree);	return tree;}
int nplh[JPC_TAGTREE_MAXDEPTH];
int nplh[JPC_TAGTREE_MAXDEPTH];
int
nplh[JPC_TAGTREE_MAXDEPTH]
nplh
[JPC_TAGTREE_MAXDEPTH]
JPC_TAGTREE_MAXDEPTH
JPC_TAGTREE_MAXDEPTH
int nplv[JPC_TAGTREE_MAXDEPTH];
int nplv[JPC_TAGTREE_MAXDEPTH];
int
nplv[JPC_TAGTREE_MAXDEPTH]
nplv
[JPC_TAGTREE_MAXDEPTH]
JPC_TAGTREE_MAXDEPTH
JPC_TAGTREE_MAXDEPTH
jpc_tagtreenode_t *node;
jpc_tagtreenode_t *node;
jpc_tagtreenode_t
jpc_tagtreenode_t
*node
*
node
jpc_tagtreenode_t *parentnode;
jpc_tagtreenode_t *parentnode;
jpc_tagtreenode_t
jpc_tagtreenode_t
*parentnode
*
parentnode
jpc_tagtreenode_t *parentnode0;
jpc_tagtreenode_t *parentnode0;
jpc_tagtreenode_t
jpc_tagtreenode_t
*parentnode0
*
parentnode0
jpc_tagtree_t *tree;
jpc_tagtree_t *tree;
jpc_tagtree_t
jpc_tagtree_t
*tree
*
tree
int i;
int i;
int
i
i
int j;
int j;
int
j
j
int k;
int k;
int
k
k
int numlvls;
int numlvls;
int
numlvls
numlvls
int n;
int n;
int
n
n
assert(numleafsh > 0 && numleafsv > 0);
assert(numleafsh > 0 && numleafsv > 0)
assert
assert
numleafsh > 0 && numleafsv > 0
numleafsh > 0
numleafsh
numleafsh
0
numleafsv > 0
numleafsv
numleafsv
0
if (!(tree = jpc_tagtree_alloc())) {		return 0;	}
!(tree = jpc_tagtree_alloc())
(tree = jpc_tagtree_alloc())
tree = jpc_tagtree_alloc()
tree
tree
jpc_tagtree_alloc()
jpc_tagtree_alloc
jpc_tagtree_alloc
{		return 0;	}
return 0;
0
tree->numleafsh_ = numleafsh;
tree->numleafsh_ = numleafsh
tree->numleafsh_
tree
tree
numleafsh_
numleafsh
numleafsh
tree->numleafsv_ = numleafsv;
tree->numleafsv_ = numleafsv
tree->numleafsv_
tree
tree
numleafsv_
numleafsv
numleafsv
numlvls = 0;
numlvls = 0
numlvls
numlvls
0
nplh[0] = numleafsh;
nplh[0] = numleafsh
nplh[0]
nplh
nplh
0
numleafsh
numleafsh
nplv[0] = numleafsv;
nplv[0] = numleafsv
nplv[0]
nplv
nplv
0
numleafsv
numleafsv
do {		n = nplh[numlvls] * nplv[numlvls];		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;		tree->numnodes_ += n;		++numlvls;	} while (n > 1);
{		n = nplh[numlvls] * nplv[numlvls];		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;		tree->numnodes_ += n;		++numlvls;	}
n = nplh[numlvls] * nplv[numlvls];
n = nplh[numlvls] * nplv[numlvls]
n
n
nplh[numlvls] * nplv[numlvls]
nplh[numlvls]
nplh
nplh
numlvls
numlvls
nplv[numlvls]
nplv
nplv
numlvls
numlvls
nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2
nplh[numlvls + 1]
nplh
nplh
numlvls + 1
numlvls
numlvls
1
(nplh[numlvls] + 1) / 2
(nplh[numlvls] + 1)
nplh[numlvls] + 1
nplh[numlvls]
nplh
nplh
numlvls
numlvls
1
2
nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2
nplv[numlvls + 1]
nplv
nplv
numlvls + 1
numlvls
numlvls
1
(nplv[numlvls] + 1) / 2
(nplv[numlvls] + 1)
nplv[numlvls] + 1
nplv[numlvls]
nplv
nplv
numlvls
numlvls
1
2
tree->numnodes_ += n;
tree->numnodes_ += n
tree->numnodes_
tree
tree
numnodes_
n
n
++numlvls;
++numlvls
numlvls
numlvls
n > 1
n
n
1
if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {		return 0;	}
!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))
(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))
tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))
tree->nodes_
tree
tree
nodes_
jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))
jas_malloc
jas_malloc
tree->numnodes_ * sizeof(jpc_tagtreenode_t)
tree->numnodes_
tree
tree
numnodes_
sizeof(jpc_tagtreenode_t)
jpc_tagtreenode_t
jpc_tagtreenode_t
jpc_tagtreenode_t

{		return 0;	}
return 0;
0
node = tree->nodes_;
node = tree->nodes_
node
node
tree->nodes_
tree
tree
nodes_
parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];
parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
parentnode
parentnode
&tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
tree->nodes_
tree
tree
nodes_
tree->numleafsh_ * tree->numleafsv_
tree->numleafsh_
tree
tree
numleafsh_
tree->numleafsv_
tree
tree
numleafsv_
parentnode0 = parentnode;
parentnode0 = parentnode
parentnode0
parentnode0
parentnode
parentnode
for (i = 0; i < numlvls - 1; ++i) {		for (j = 0; j < nplv[i]; ++j) {			k = nplh[i];			while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}			if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}		}	}
i = 0;
i = 0
i
i
0
i < numlvls - 1
i
i
numlvls - 1
numlvls
numlvls
1
++i
i
i
{		for (j = 0; j < nplv[i]; ++j) {			k = nplh[i];			while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}			if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}		}	}
for (j = 0; j < nplv[i]; ++j) {			k = nplh[i];			while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}			if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}		}
j = 0;
j = 0
j
j
0
j < nplv[i]
j
j
nplv[i]
nplv
nplv
i
i
++j
j
j
{			k = nplh[i];			while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}			if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}		}
k = nplh[i];
k = nplh[i]
k
k
nplh[i]
nplh
nplh
i
i
while (--k >= 0) {				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}
--k >= 0
--k
k
k
0
{				node->parent_ = parentnode;				++node;				if (--k >= 0) {					node->parent_ = parentnode;					++node;				}				++parentnode;			}
node->parent_ = parentnode;
node->parent_ = parentnode
node->parent_
node
node
parent_
parentnode
parentnode
++node;
++node
node
node
if (--k >= 0) {					node->parent_ = parentnode;					++node;				}
--k >= 0
--k
k
k
0
{					node->parent_ = parentnode;					++node;				}
node->parent_ = parentnode;
node->parent_ = parentnode
node->parent_
node
node
parent_
parentnode
parentnode
++node;
++node
node
node
++parentnode;
++parentnode
parentnode
parentnode
if ((j & 1) || j == nplv[i] - 1) {				parentnode0 = parentnode;			} else {				parentnode = parentnode0;				parentnode0 += nplh[i];			}
(j & 1) || j == nplv[i] - 1
(j & 1)
j & 1
j
j
1
j == nplv[i] - 1
j
j
nplv[i] - 1
nplv[i]
nplv
nplv
i
i
1
{				parentnode0 = parentnode;			}
parentnode0 = parentnode;
parentnode0 = parentnode
parentnode0
parentnode0
parentnode
parentnode
{				parentnode = parentnode0;				parentnode0 += nplh[i];			}
parentnode = parentnode0;
parentnode = parentnode0
parentnode
parentnode
parentnode0
parentnode0
parentnode0 += nplh[i];
parentnode0 += nplh[i]
parentnode0
parentnode0
nplh[i]
nplh
nplh
i
i
node->parent_ = 0;
node->parent_ = 0
node->parent_
node
node
parent_
0
jpc_tagtree_reset(tree);
jpc_tagtree_reset(tree)
jpc_tagtree_reset
jpc_tagtree_reset
tree
tree
return tree;
tree
tree
-----joern-----
(12,8,0)
(27,0,0)
(68,13,0)
(6,67,0)
(54,28,0)
(56,43,0)
(6,27,0)
(5,21,0)
(52,61,0)
(8,32,0)
(65,46,0)
(44,17,0)
(61,51,0)
(62,42,0)
(44,28,0)
(66,42,0)
(24,45,0)
(10,27,0)
(49,10,0)
(28,51,0)
(22,0,0)
(39,61,0)
(0,11,0)
(32,61,0)
(40,62,0)
(2,28,0)
(57,62,0)
(36,23,0)
(4,21,0)
(8,64,0)
(41,13,0)
(18,6,0)
(59,53,0)
(15,46,0)
(62,51,0)
(26,6,0)
(55,53,0)
(23,24,0)
(5,51,0)
(29,43,0)
(20,43,0)
(24,23,0)
(28,44,0)
(13,21,0)
(37,5,0)
(30,32,0)
(17,11,0)
(53,42,0)
(60,67,0)
(32,43,0)
(34,17,0)
(21,5,0)
(66,29,0)
(17,44,0)
(38,10,0)
(21,43,0)
(4,45,0)
(48,0,0)
(19,60,0)
(42,62,0)
(58,64,0)
(9,43,0)
(63,27,0)
(47,23,0)
(42,66,0)
(27,43,0)
(50,60,0)
(14,21,0)
(1,27,0)
(46,27,0)
(63,45,0)
(0,27,0)
(10,24,0)
(46,41,0)
(61,32,0)
(41,45,0)
(67,60,0)
(23,21,0)
(60,21,0)
(7,4,0)
(3,63,0)
(13,41,0)
(66,44,0)
(53,11,0)
(35,13,0)
(44,66,0)
(42,53,0)
(16,5,0)
(33,43,0)
(25,17,0)
(29,66,0)
(64,8,0)
(67,45,0)
(37,14,1)
(12,27,1)
(67,60,1)
(66,42,1)
(36,10,1)
(13,35,1)
(60,50,1)
(10,27,1)
(31,64,1)
(46,65,1)
(24,23,1)
(25,34,1)
(14,32,1)
(23,21,1)
(58,8,1)
(48,22,1)
(62,51,1)
(32,61,1)
(22,1,1)
(10,38,1)
(42,53,1)
(8,32,1)
(53,59,1)
(34,28,1)
(66,44,1)
(6,27,1)
(39,30,1)
(57,44,1)
(30,29,1)
(13,21,1)
(49,41,1)
(15,67,1)
(17,25,1)
(29,66,1)
(23,47,1)
(28,54,1)
(61,51,1)
(40,57,1)
(21,5,1)
(42,62,1)
(41,13,1)
(5,16,1)
(65,15,1)
(4,7,1)
(53,11,1)
(50,19,1)
(68,46,1)
(26,64,1)
(0,11,1)
(38,49,1)
(0,48,1)
(55,62,1)
(8,12,1)
(64,8,1)
(47,36,1)
(12,4,1)
(60,21,1)
(46,27,1)
(64,58,1)
(1,21,1)
(52,39,1)
(4,21,1)
(35,68,1)
(54,2,1)
(62,40,1)
(63,27,1)
(5,51,1)
(44,28,1)
(19,6,1)
(63,3,1)
(59,55,1)
(7,63,1)
(17,11,1)
(28,51,1)
(6,18,1)
(18,26,1)
(16,37,1)
(61,52,1)
(3,24,1)
(44,17,1)
(27,0,1)
(42,53,2)
(53,44,2)
(19,64,2)
(36,64,2)
(0,11,2)
(10,27,2)
(41,13,2)
(15,64,2)
(63,27,2)
(55,44,2)
(5,51,2)
(44,17,2)
(8,32,2)
(6,64,2)
(61,51,2)
(59,44,2)
(3,64,2)
(38,64,2)
(7,64,2)
(12,64,2)
(4,64,2)
(53,11,2)
(58,64,2)
(49,64,2)
(17,11,2)
(64,64,2)
(24,64,2)
(46,64,2)
(41,64,2)
(13,21,2)
(67,64,2)
(57,44,2)
(32,61,2)
(35,64,2)
(23,64,2)
(40,44,2)
(42,44,2)
(46,27,2)
(24,23,2)
(66,44,2)
(64,8,2)
(28,51,2)
(8,64,2)
(42,62,2)
(13,64,2)
(63,64,2)
(29,66,2)
(68,64,2)
(27,0,2)
(21,5,2)
(60,64,2)
(65,64,2)
(47,64,2)
(18,64,2)
(10,64,2)
(60,21,2)
(66,42,2)
(6,27,2)
(62,51,2)
(50,64,2)
(23,21,2)
(44,28,2)
(67,60,2)
(4,21,2)
(62,44,2)
(26,64,2)
-----------------------------------
(0,dsttree->nodes_)
(1,dstnode)
(2,srctree)
(3,dstnode)
(4,++srcnode)
(5,srctree->nodes_)
(6,dstnode->value_)
(7,srcnode)
(8,--n)
(9,n)
(10,dstnode->known_)
(11,jpc_tagtree_t *dsttree)
(12,n)
(13,srcnode->low_)
(14,srcnode)
(15,dstnode)
(16,nodes_)
(17,dsttree->numleafsh_)
(18,value_)
(19,srcnode)
(20,while (--n >= 0)
(21,srcnode = srctree->nodes_)
(22,dsttree)
(23,srcnode->known_)
(24,dstnode->known_ = srcnode->known_)
(25,numleafsh_)
(26,dstnode)
(27,dstnode = dsttree->nodes_)
(28,srctree->numleafsh_)
(29,assert(srctree->numleafsh_ == dsttree->numleafsh_ &&\\n\\t  srctree->numleafsv_ == dsttree->numleafsv_)
(30,n)
(31,RET)
(32,n = srctree->numnodes_)
(33,srcnode)
(34,dsttree)
(35,low_)
(36,srcnode)
(37,srctree)
(38,known_)
(39,srctree)
(40,numleafsv_)
(41,dstnode->low_ = srcnode->low_)
(42,srctree->numleafsv_ == dsttree->numleafsv_)
(43,)
(44,srctree->numleafsh_ == dsttree->numleafsh_)
(45,)
(46,dstnode->low_)
(47,known_)
(48,nodes_)
(49,dstnode)
(50,value_)
(51,jpc_tagtree_t *srctree)
(52,numnodes_)
(53,dsttree->numleafsv_)
(54,numleafsh_)
(55,dsttree)
(56,dstnode)
(57,srctree)
(58,0)
(59,numleafsv_)
(60,srcnode->value_)
(61,srctree->numnodes_)
(62,srctree->numleafsv_)
(63,++dstnode)
(64,--n >= 0)
(65,low_)
(66,srctree->numleafsh_ == dsttree->numleafsh_ &&\\n\\t  srctree->numleafsv_ == dsttree->numleafsv_)
(67,dstnode->value_ = srcnode->value_)
(68,srcnode)
-----cfg-----
(7,24)
(22,34)
(23,22)
(24,23)
(24,27)
(27,23)
(31,36)
(31,41)
(32,31)
(34,32)
(36,240)
(38,46)
(39,38)
(41,39)
(43,48)
(44,43)
(46,44)
(48,52)
(51,57)
(52,51)
(56,66)
(57,56)
(63,75)
(65,63)
(66,69)
(69,65)
(72,88)
(73,80)
(75,73)
(78,72)
(79,78)
(80,79)
(85,101)
(86,93)
(88,86)
(91,85)
(92,91)
(93,92)
(98,103)
(99,98)
(101,99)
(103,105)
(105,66)
(105,113)
(109,122)
(109,128)
(110,109)
(111,118)
(113,111)
(114,110)
(115,114)
(116,119)
(118,116)
(119,115)
(122,240)
(124,135)
(126,124)
(128,126)
(129,143)
(131,129)
(132,131)
(133,139)
(135,133)
(136,132)
(137,142)
(139,137)
(140,136)
(142,140)
(143,148)
(148,153)
(151,161)
(151,234)
(153,151)
(156,153)
(161,166)
(164,174)
(164,156)
(166,164)
(169,166)
(172,179)
(174,172)
(178,186)
(178,207)
(179,178)
(183,188)
(184,183)
(186,184)
(188,192)
(191,199)
(191,203)
(192,191)
(196,201)
(197,196)
(199,197)
(201,203)
(203,179)
(206,218)
(206,223)
(207,206)
(207,213)
(210,206)
(212,210)
(213,212)
(218,169)
(223,228)
(226,169)
(228,226)
(231,236)
(232,231)
(234,232)
(236,238)
(238,240)
-----path-----
7,24,23,22,34,32,31,36,240
7,24,23,22,34,32,31,41,39,38,46,44,43,48,52,51,57,56,66,69,65,63,75,73,80,79,78,72,88,86,93,92,91,85,101,99,98,103,105,113,111,118,116,119,115,114,110,109,122,240
7,24,23,22,34,32,31,41,39,38,46,44,43,48,52,51,57,56,66,69,65,63,75,73,80,79,78,72,88,86,93,92,91,85,101,99,98,103,105,113,111,118,116,119,115,114,110,109,128,126,124
7,24,27,23,22,34,32,31,36,240
7,24,27,23,22,34,32,31,41,39,38,46,44,43,48,52,51,57,56,66,69,65,63,75,73,80,79,78,72,88,86,93,92,91,85,101,99,98,103,105,113,111,118,116,119,115,114,110,109,122,240
7,24,27,23,22,34,32,31,41,39,38,46,44,43,48,52,51,57,56,66,69,65,63,75,73,80,79,78,72,88,86,93,92,91,85,101,99,98,103,105,113,111,118,116,119,115,114,110,109,128,126
-----cfgNode-----
5,<global>
6,<empty>
7,jpc_tagtree_t jpc_tagtree_create (int numleafsh,int numleafsv)
8,int numleafsh
9,int numleafsv
10,<empty>
11,int[] nplh
12,int[] nplv
13,jpc_tagtreenode_t* node
14,jpc_tagtreenode_t* parentnode
15,jpc_tagtreenode_t* parentnode0
16,jpc_tagtree_t* tree
17,int i
18,int j
19,int k
20,int numlvls
21,int n
22,assert(numleafsh > 0 && numleafsv > 0)
23,numleafsh > 0 && numleafsv > 0
24,numleafsh > 0
25,numleafsh
26,0
27,numleafsv > 0
28,numleafsv
29,0
30,if (!(tree = jpc_tagtree_alloc()))
31,!(tree = jpc_tagtree_alloc())
32,tree = jpc_tagtree_alloc()
33,tree
34,jpc_tagtree_alloc()
35,<empty>
36,return 0;
37,0
38,tree->numleafsh_ = numleafsh
39,tree->numleafsh_
40,tree
41,numleafsh_
42,numleafsh
43,tree->numleafsv_ = numleafsv
44,tree->numleafsv_
45,tree
46,numleafsv_
47,numleafsv
48,numlvls = 0
49,numlvls
50,0
51,nplh[0] = numleafsh
52,nplh[0]
53,nplh
54,0
55,numleafsh
56,nplv[0] = numleafsv
57,nplv[0]
58,nplv
59,0
60,numleafsv
61,do {
62,		n = nplh[numlvls] * nplv[numlvls];
63,		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
64,		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
65,		tree->numnodes_ += n;
66,		++numlvls;
67,	} while (n > 1);
68,<empty>
69,n = nplh[numlvls] * nplv[numlvls]
70,n
71,nplh[numlvls] * nplv[numlvls]
72,nplh[numlvls]
73,nplh
74,numlvls
75,nplv[numlvls]
76,nplv
77,numlvls
78,nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2
79,nplh[numlvls + 1]
80,nplh
81,numlvls + 1
82,numlvls
83,1
84,(nplh[numlvls] + 1) / 2
85,nplh[numlvls] + 1
86,nplh[numlvls]
87,nplh
88,numlvls
89,1
90,2
91,nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2
92,nplv[numlvls + 1]
93,nplv
94,numlvls + 1
95,numlvls
96,1
97,(nplv[numlvls] + 1) / 2
98,nplv[numlvls] + 1
99,nplv[numlvls]
100,nplv
101,numlvls
102,1
103,2
104,tree->numnodes_ += n
105,tree->numnodes_
106,tree
107,numnodes_
108,n
109,++numlvls
110,numlvls
111,n > 1
112,n
113,1
114,if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))))
115,!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))
116,tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))
117,tree->nodes_
118,tree
119,nodes_
120,jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))
121,tree->numnodes_ * sizeof(jpc_tagtreenode_t)
122,tree->numnodes_
123,tree
124,numnodes_
125,sizeof(jpc_tagtreenode_t)
126,jpc_tagtreenode_t
127,<empty>
128,return 0;
129,0
130,node = tree->nodes_
131,node
132,tree->nodes_
133,tree
134,nodes_
135,parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
136,parentnode
137,&tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
138,tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
139,tree->nodes_
140,tree
141,nodes_
142,tree->numleafsh_ * tree->numleafsv_
143,tree->numleafsh_
144,tree
145,numleafsh_
146,tree->numleafsv_
147,tree
148,numleafsv_
149,parentnode0 = parentnode
150,parentnode0
151,parentnode
152,for (i = 0;i < numlvls - 1;++i)
153,<empty>
154,i = 0
155,i
156,0
157,i < numlvls - 1
158,i
159,numlvls - 1
160,numlvls
161,1
162,++i
163,i
164,<empty>
165,for (j = 0;j < nplv[i];++j)
166,<empty>
167,j = 0
168,j
169,0
170,j < nplv[i]
171,j
172,nplv[i]
173,nplv
174,i
175,++j
176,j
177,<empty>
178,k = nplh[i]
179,k
180,nplh[i]
181,nplh
182,i
183,while (--k >= 0)
184,--k >= 0
185,--k
186,k
187,0
188,<empty>
189,node->parent_ = parentnode
190,node->parent_
191,node
192,parent_
193,parentnode
194,++node
195,node
196,if (--k >= 0)
197,--k >= 0
198,--k
199,k
200,0
201,<empty>
202,node->parent_ = parentnode
203,node->parent_
204,node
205,parent_
206,parentnode
207,++node
208,node
209,++parentnode
210,parentnode
211,if ((j & 1) || j == nplv[i] - 1)
212,(j & 1) || j == nplv[i] - 1
213,j & 1
214,j
215,1
216,j == nplv[i] - 1
217,j
218,nplv[i] - 1
219,nplv[i]
220,nplv
221,i
222,1
223,<empty>
224,parentnode0 = parentnode
225,parentnode0
226,parentnode
227,else
228,<empty>
229,parentnode = parentnode0
230,parentnode
231,parentnode0
232,parentnode0 += nplh[i]
233,parentnode0
234,nplh[i]
235,nplh
236,i
237,node->parent_ = 0
238,node->parent_
239,node
240,parent_
241,0
242,jpc_tagtree_reset(tree)
243,tree
244,return tree;
245,tree
246,RET
247,int numleafsh
248,int numleafsv
249,RET
250,jpc_tagtree_t jpc_tagtree_create (int numleafsh,int numleafsv)
251,int numleafsh
252,int numleafsv
253,<empty>
254,int[] nplh
255,int[] nplv
256,jpc_tagtreenode_t* node
257,jpc_tagtreenode_t* parentnode
258,jpc_tagtreenode_t* parentnode0
259,jpc_tagtree_t* tree
260,int i
261,int j
262,int k
263,int numlvls
264,int n
265,assert(numleafsh > 0 && numleafsv > 0)
266,numleafsh > 0 && numleafsv > 0
267,numleafsh > 0
268,numleafsh
269,0
270,numleafsv > 0
271,numleafsv
272,0
273,if (!(tree = jpc_tagtree_alloc()))
274,!(tree = jpc_tagtree_alloc())
275,tree = jpc_tagtree_alloc()
276,tree
277,jpc_tagtree_alloc()
278,<empty>
279,return 0;
280,0
281,tree->numleafsh_ = numleafsh
282,tree->numleafsh_
283,tree
284,numleafsh_
285,numleafsh
286,tree->numleafsv_ = numleafsv
287,tree->numleafsv_
288,tree
289,numleafsv_
290,numleafsv
291,numlvls = 0
292,numlvls
293,0
294,nplh[0] = numleafsh
295,nplh[0]
296,nplh
297,0
298,numleafsh
299,nplv[0] = numleafsv
300,nplv[0]
301,nplv
302,0
303,numleafsv
304,do {
305,		n = nplh[numlvls] * nplv[numlvls];
306,		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
307,		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
308,		tree->numnodes_ += n;
309,		++numlvls;
310,	} while (n > 1);
311,<empty>
312,n = nplh[numlvls] * nplv[numlvls]
313,n
314,nplh[numlvls] * nplv[numlvls]
315,nplh[numlvls]
316,nplh
317,numlvls
318,nplv[numlvls]
319,nplv
320,numlvls
321,nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2
322,nplh[numlvls + 1]
323,nplh
324,numlvls + 1
325,numlvls
326,1
327,(nplh[numlvls] + 1) / 2
328,nplh[numlvls] + 1
329,nplh[numlvls]
330,nplh
331,numlvls
332,1
333,2
334,nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2
335,nplv[numlvls + 1]
336,nplv
337,numlvls + 1
338,numlvls
339,1
340,(nplv[numlvls] + 1) / 2
341,nplv[numlvls] + 1
342,nplv[numlvls]
343,nplv
344,numlvls
345,1
346,2
347,tree->numnodes_ += n
348,tree->numnodes_
349,tree
350,numnodes_
351,n
352,++numlvls
353,numlvls
354,n > 1
355,n
356,1
357,if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))))
358,!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))
359,tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))
360,tree->nodes_
361,tree
362,nodes_
363,jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t))
364,tree->numnodes_ * sizeof(jpc_tagtreenode_t)
365,tree->numnodes_
366,tree
367,numnodes_
368,sizeof(jpc_tagtreenode_t)
369,jpc_tagtreenode_t
370,<empty>
371,return 0;
372,0
373,node = tree->nodes_
374,node
375,tree->nodes_
376,tree
377,nodes_
378,parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
379,parentnode
380,&tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
381,tree->nodes_[tree->numleafsh_ * tree->numleafsv_]
382,tree->nodes_
383,tree
384,nodes_
385,tree->numleafsh_ * tree->numleafsv_
386,tree->numleafsh_
387,tree
388,numleafsh_
389,tree->numleafsv_
390,tree
391,numleafsv_
392,parentnode0 = parentnode
393,parentnode0
394,parentnode
395,for (i = 0;i < numlvls - 1;++i)
396,<empty>
397,i = 0
398,i
399,0
400,i < numlvls - 1
401,i
402,numlvls - 1
403,numlvls
404,1
405,++i
406,i
407,<empty>
408,for (j = 0;j < nplv[i];++j)
409,<empty>
410,j = 0
411,j
412,0
413,j < nplv[i]
414,j
415,nplv[i]
416,nplv
417,i
418,++j
419,j
420,<empty>
421,k = nplh[i]
422,k
423,nplh[i]
424,nplh
425,i
426,while (--k >= 0)
427,--k >= 0
428,--k
429,k
430,0
431,<empty>
432,node->parent_ = parentnode
433,node->parent_
434,node
435,parent_
436,parentnode
437,++node
438,node
439,if (--k >= 0)
440,--k >= 0
441,--k
442,k
443,0
444,<empty>
445,node->parent_ = parentnode
446,node->parent_
447,node
448,parent_
449,parentnode
450,++node
451,node
452,++parentnode
453,parentnode
454,if ((j & 1) || j == nplv[i] - 1)
455,(j & 1) || j == nplv[i] - 1
456,j & 1
457,j
458,1
459,j == nplv[i] - 1
460,j
461,nplv[i] - 1
462,nplv[i]
463,nplv
464,i
465,1
466,<empty>
467,parentnode0 = parentnode
468,parentnode0
469,parentnode
470,else
471,<empty>
472,parentnode = parentnode0
473,parentnode
474,parentnode0
475,parentnode0 += nplh[i]
476,parentnode0
477,nplh[i]
478,nplh
479,i
480,node->parent_ = 0
481,node->parent_
482,node
483,parent_
484,0
485,jpc_tagtree_reset(tree)
486,tree
487,return tree;
488,tree
489,RET
490,int numleafsh
491,int numleafsv
=====================================
----------------dynamic----------------
=======testcase========
model_version:0x01000000
A-data-stat:0xa20000000000000010101010101002100100000000000000a48100000000000000000000101010100000000000000000101010101010101000100000000000001010101010101010c5490a6500000000101010101010101099c4096500000000101010101010101099c40965000000001010101010101010101010101010101010101010101010101010101010101010
A-data:0x503337230a0930230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a230a31370c0c30303123000a0c000c23
=========trace=========
jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv) {
int nplh[JPC_TAGTREE_MAXDEPTH];
int nplv[JPC_TAGTREE_MAXDEPTH];
jpc_tagtreenode_t *node;
jpc_tagtreenode_t *parentnode;
jpc_tagtreenode_t *parentnode0;
jpc_tagtree_t *tree;
int i;
int j;
int k;
int numlvls;
int n;
assert(numleafsh > 0 && numleafsv > 0);
tree->numleafsh_ = numleafsh;
tree->numleafsv_ = numleafsv;
numlvls = 0;
nplh[0] = numleafsh;
nplv[0] = numleafsv;
n = nplh[numlvls] * nplv[numlvls];
nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
tree->numnodes_ += n;
++numlvls;
node = tree->nodes_;
parentnode = &tree->nodes_[tree->numleafsh_ * tree->numleafsv_];
parentnode0 = parentnode;
node->parent_ = 0;
jpc_tagtree_reset(tree);
return tree;
=======================
