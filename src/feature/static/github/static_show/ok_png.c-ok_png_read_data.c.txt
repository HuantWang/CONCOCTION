-----label-----
1
-----code-----
static bool ok_png_read_data(ok_png_decoder *decoder, uint32_t bytes_remaining) {
    ok_png *png = decoder->png;
    size_t inflate_buffer_size = 64 * 1024;
    size_t num_passes = decoder->interlace_method == 0 ? 1 : 7;
    uint8_t bits_per_pixel = decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type];
    uint8_t bytes_per_pixel = (bits_per_pixel + 7) / 8;
    uint64_t max_bytes_per_scanline = 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8;
    size_t platform_max_bytes_per_scanline = (size_t)max_bytes_per_scanline;

    // Create buffers
    if (!png->data) {
        if (decoder->allocator.image_alloc) {
            decoder->allocator.image_alloc(decoder->allocator_user_data,
                                           png->width, png->height, png->bpp,
                                           &png->data, &png->stride);
        } else {
            uint64_t size = (uint64_t)png->stride * png->height;
            size_t platform_size = (size_t)size;
            if (platform_size == size) {
                png->data = ok_alloc(decoder, platform_size);
            }
        }
        if (!png->data) {
            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");
            return false;
        }
        if (png->stride < png->width * png->bpp) {
            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");
            return false;
        }
    }
    if (!decoder->prev_scanline) {
        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {
            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);
        }
    }
    if (!decoder->curr_scanline) {
        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {
            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);
        }
    }
    if (!decoder->inflate_buffer) {
        decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size);
    }
    if (decoder->interlace_method == 1 && !decoder->temp_data_row) {
        decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp);
    }
    if (!decoder->curr_scanline || !decoder->prev_scanline || !decoder->inflate_buffer ||
        (decoder->interlace_method == 1 && !decoder->temp_data_row)) {
        ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers");
        return false;
    }

    // Setup inflater
    if (!decoder->inflater) {
        decoder->inflater = ok_inflater_init(decoder->is_ios_format,
                                             decoder->allocator, decoder->allocator_user_data);
        if (!decoder->inflater) {
            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");
            return false;
        }
    }

    // Sanity check - this happened with one file in the PNG suite
    if (decoder->decoding_completed) {
        if (bytes_remaining > 0) {
            return ok_seek(decoder, (long)bytes_remaining);
        } else {
            return true;
        }
    }

    // Read data
    uint32_t curr_width = ok_png_get_width_for_pass(decoder);
    uint32_t curr_height = ok_png_get_height_for_pass(decoder);
    size_t curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);
    while (true) {
        // Setup pass
        while (decoder->ready_for_next_interlace_pass) {
            decoder->ready_for_next_interlace_pass = false;
            decoder->scanline = 0;
            decoder->interlace_pass++;
            if (decoder->interlace_pass == num_passes + 1) {
                // Done decoding - skip any remaining chunk data
                decoder->decoding_completed = true;
                if (bytes_remaining > 0) {
                    return ok_seek(decoder, (long)bytes_remaining);
                } else {
                    return true;
                }
            }
            curr_width = ok_png_get_width_for_pass(decoder);
            curr_height = ok_png_get_height_for_pass(decoder);
            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);
            if (curr_width == 0 || curr_height == 0) {
                // No data for this pass - happens if width or height <= 4
                decoder->ready_for_next_interlace_pass = true;
            } else {
                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);
                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);
                decoder->inflater_bytes_read = 0;
            }
        }

        // Read compressed data
        if (ok_inflater_needs_input(decoder->inflater)) {
            if (bytes_remaining == 0) {
                // Need more data, but there is no remaining data in this chunk.
                // There may be another IDAT chunk.
                return true;
            }
            const size_t len = min(inflate_buffer_size, bytes_remaining);
            if (!ok_read(decoder, decoder->inflate_buffer, len)) {
                return false;
            }
            bytes_remaining -= len;
            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);
        }

        // Decompress data
        size_t len = ok_inflater_inflate(decoder->inflater,
                                         decoder->curr_scanline + decoder->inflater_bytes_read,
                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);
        if (len == OK_SIZE_MAX) {
            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");
            return false;
        }
        decoder->inflater_bytes_read += len;
        if (decoder->inflater_bytes_read == curr_bytes_per_scanline) {
            // Apply filter
            const int filter = decoder->curr_scanline[0];
            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {
                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,
                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);
            } else if (filter != 0) {
                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");
                return false;
            }

            // Transform
            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);

            // Setup for next scanline or pass
            decoder->scanline++;
            if (decoder->scanline == curr_height) {
                decoder->ready_for_next_interlace_pass = true;
            } else {
                uint8_t *temp = decoder->curr_scanline;
                decoder->curr_scanline = decoder->prev_scanline;
                decoder->prev_scanline = temp;
                decoder->inflater_bytes_read = 0;
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
16,28
16,29
16,30
16,31
16,32
16,33
16,34
16,35
17,18
18,19
18,20
19,20
21,22
21,23
21,24
24,25
25,26
25,27
26,27
29,30
30,31
30,32
31,32
33,34
33,35
35,36
36,37
36,38
39,40
40,41
40,42
41,42
43,44
43,45
45,46
46,47
46,48
46,49
47,48
47,49
48,49
48,50
49,50
55,56
56,57
56,58
57,58
59,60
59,61
61,62
62,63
62,64
63,64
63,65
64,65
67,68
67,69
68,69
70,71
70,72
71,72
74,75
75,76
75,77
76,77
78,79
78,80
80,81
81,82
81,83
82,83
83,84
83,85
84,85
88,89
89,90
89,91
90,91
92,93
92,94
94,95
95,96
95,97
97,98
97,99
98,99
99,100
99,101
100,101
100,102
101,102
101,103
102,103
102,104
103,104
106,107
106,108
107,108
110,111
114,115
115,116
115,117
116,117
118,119
118,120
120,121
121,122
121,123
122,123
122,124
123,124
126,127
128,129
128,130
129,130
130,131
130,132
131,132
134,135
134,136
134,137
135,136
135,137
135,138
136,137
136,138
137,138
137,139
138,139
142,143
143,144
144,145
144,146
144,147
144,148
144,149
144,150
144,151
145,146
145,147
146,147
146,148
147,148
151,152
151,153
152,153
155,156
155,157
156,157
159,160
159,161
160,161
163,164
163,165
164,165
167,168
168,169
168,170
169,170
172,173
173,174
173,175
174,175
177,178
177,179
177,180
178,179
179,180
179,181
180,181
182,183
182,184
184,185
185,186
185,187
186,187
186,188
187,188
187,189
188,189
191,192
191,193
192,193
195,196
195,197
196,197
199,200
200,201
200,202
201,202
203,204
203,205
205,206
206,207
206,208
207,208
207,209
208,209
211,212
213,214
213,215
214,215
214,216
215,216
217,218
219,220
220,221
221,222
221,223
222,223
222,224
223,224
226,227
226,228
226,229
227,228
229,230
231,232
233,234
233,235
234,235
235,236
235,237
236,237
239,240
239,241
240,241
241,242
241,243
241,244
241,245
242,243
244,245
246,247
249,250
251,252
251,253
252,253
252,254
253,254
253,255
254,255
257,258
257,259
258,259
258,260
259,260
262,263
262,264
263,264
266,267
266,268
267,268
268,269
268,270
268,271
268,272
269,270
271,272
273,274
276,277
278,279
278,280
279,280
280,281
280,282
281,282
284,285
285,286
285,287
286,287
286,288
287,288
289,290
291,292
292,293
293,294
293,295
294,295
294,296
295,296
298,299
298,300
298,301
299,300
301,302
303,304
305,306
305,307
306,307
307,308
307,309
308,309
311,312
312,313
312,314
313,314
313,315
314,315
316,317
318,319
319,320
320,321
320,322
321,322
321,323
322,323
325,326
325,327
325,328
326,327
328,329
330,331
332,333
332,334
333,334
334,335
334,336
335,336
338,339
339,340
340,341
340,342
341,342
341,343
342,343
345,346
345,347
345,348
346,347
348,349
350,351
352,353
352,354
353,354
353,355
354,355
354,356
355,356
355,357
356,357
360,361
361,362
361,363
362,363
365,366
366,367
367,368
367,369
368,369
368,370
369,370
372,373
372,374
372,375
373,374
375,376
377,378
377,379
378,379
378,380
379,380
382,383
382,384
383,384
386,387
386,388
387,388
387,389
388,389
388,390
389,390
389,391
390,391
391,392
391,393
392,393
395,396
396,397
396,398
397,398
400,401
401,402
401,403
402,403
405,406
406,407
406,408
407,408
407,409
408,409
408,410
409,410
413,414
414,415
414,416
415,416
418,419
418,420
419,420
420,421
420,422
420,423
420,424
421,422
423,424
425,426
428,429
430,431
430,432
431,432
432,433
432,434
433,434
436,437
436,438
437,438
438,439
438,440
439,440
439,441
440,441
443,444
443,445
443,446
443,447
444,445
446,447
446,448
447,448
450,451
450,452
451,452
454,455
454,456
455,456
458,459
458,460
459,460
460,461
460,462
461,462
464,465
464,466
465,466
466,467
466,468
466,469
466,470
467,468
469,470
471,472
474,475
476,477
476,478
477,478
477,479
478,479
481,482
482,483
482,484
482,485
483,484
483,485
484,485
487,488
488,489
489,490
489,491
489,492
490,491
492,493
494,495
494,496
495,496
495,497
498,499
500,501
501,502
503,504
504,505
504,506
505,506
507,508
507,509
509,510
510,511
510,512
511,512
513,514
515,516
516,517
516,518
517,518
519,520
519,521
521,522
522,523
522,524
523,524
525,526
527,528
528,529
528,530
529,530
531,532
531,533
533,534
534,535
534,536
535,536
536,537
538,539
538,540
540,541
540,542
541,542
542,543
542,544
543,544
543,545
544,545
544,546
545,546
545,547
546,547
549,550
551,552
555,556
555,557
557,558
557,559
557,560
557,561
557,562
557,563
558,559
558,560
559,560
559,561
560,561
563,564
563,565
563,566
563,567
563,568
563,569
563,570
563,571
564,565
565,566
565,567
566,567
566,568
567,568
571,572
572,573
572,574
573,574
573,575
574,575
578,579
579,580
580,581
580,582
581,582
584,585
584,586
585,586
585,587
586,587
586,588
587,588
590,591
590,592
591,592
594,595
594,596
595,596
596,597
596,598
597,598
597,599
598,599
602,603
602,604
602,605
603,604
603,605
604,605
607,608
608,609
609,610
609,611
609,612
610,611
612,613
614,615
614,616
615,616
615,617
618,619
620,621
621,622
623,624
624,625
624,626
625,626
627,628
627,629
628,629
630,631
632,633
633,634
633,635
634,635
636,637
636,638
637,638
639,640
641,642
642,643
642,644
643,644
645,646
645,647
646,647
647,648
649,650
649,651
651,652
651,653
652,653
653,654
653,655
654,655
654,656
655,656
655,657
656,657
656,658
657,658
660,661
662,663
666,667
666,668
666,669
667,668
667,669
668,669
668,670
669,670
672,673
672,674
673,674
676,677
677,678
678,679
678,680
679,680
679,681
680,681
684,685
684,686
684,687
685,686
686,687
686,688
686,689
686,690
687,688
689,690
689,691
690,691
694,695
696,697
697,698
697,699
697,700
697,701
698,699
700,701
700,702
701,702
705,706
707,708
708,709
708,710
709,710
709,711
710,711
714,715
714,716
715,716
715,717
716,717
718,719
718,720
719,720
722,723
722,724
722,725
722,726
722,727
723,724
723,725
724,725
724,726
725,726
728,729
729,730
731,732
732,733
732,734
733,734
735,736
735,737
737,738
738,739
738,740
738,741
739,740
741,742
743,744
745,746
745,747
746,747
747,748
747,749
747,750
747,751
748,749
750,751
752,753
752,754
753,754
756,757
758,759
759,760
761,762
762,763
762,764
763,764
765,766
767,768
768,769
768,770
768,771
768,772
769,770
771,772
771,773
772,773
775,776
775,777
776,777
779,780
781,782
782,783
782,784
783,784
785,786
785,787
787,788
788,789
788,790
788,791
788,792
789,790
791,792
791,793
792,793
795,796
795,797
796,797
796,798
797,798
800,801
800,802
801,802
804,805
804,806
805,806
807,808
807,809
808,809
811,812
811,813
812,813
812,814
813,814
815,816
817,818
817,819
818,819
819,820
819,821
819,822
819,823
820,821
822,823
824,825
827,828
829,830
830,831
830,832
831,832
831,833
832,833
835,836
837,838
837,839
838,839
838,840
839,840
839,841
840,841
843,844
845,846
845,847
845,848
845,849
845,850
846,847
847,848
847,849
849,850
849,851
851,852
852,853
852,854
853,854
853,855
854,855
858,859
858,860
858,861
859,860
859,861
860,861
860,862
861,862
864,865
864,866
865,866
867,868
869,870
870,871
871,872
871,873
871,874
871,875
871,876
871,877
872,873
874,875
874,876
875,876
875,877
876,877
880,881
880,882
881,882
881,883
882,883
886,887
886,888
887,888
890,891
892,893
894,895
894,896
895,896
895,897
896,897
899,900
899,901
900,901
901,902
901,903
901,904
901,905
902,903
904,905
906,907
909,910
911,912
912,913
912,914
912,915
912,916
913,914
915,916
917,918
917,919
918,919
918,920
919,920
923,924
925,926
926,927
927,928
927,929
928,929
931,932
931,933
931,934
932,933
932,934
933,934
933,935
934,935
937,938
939,940
940,941
941,942
941,943
942,943
942,944
943,944
947,948
947,949
947,950
947,951
948,949
949,950
949,951
950,951
952,953
952,954
952,955
955,956
956,957
956,958
957,958
960,961
961,962
961,963
962,963
962,964
963,964
966,967
966,968
967,968
970,971
971,972
971,973
972,973
972,974
973,974
976,977
978,979
979,980
979,981
980,981
980,982
981,982
-----nextToken-----
2,4,7,9,10,13,15,20,22,23,27,28,32,34,37,38,42,44,50,51,52,53,54,58,60,65,66,69,72,73,77,79,85,86,87,91,93,96,104,105,108,109,111,112,113,117,119,124,125,127,132,133,139,140,141,148,149,150,153,154,157,158,161,162,165,166,170,171,175,176,181,183,189,190,193,194,197,198,202,204,209,210,212,216,218,224,225,228,230,232,237,238,243,245,247,248,250,255,256,260,261,264,265,270,272,274,275,277,282,283,288,290,296,297,300,302,304,309,310,315,317,323,324,327,329,331,336,337,343,344,347,349,351,357,358,359,363,364,370,371,374,376,380,381,384,385,393,394,398,399,403,404,410,411,412,416,417,422,424,426,427,429,434,435,441,442,445,448,449,452,453,456,457,462,463,468,470,472,473,475,479,480,485,486,491,493,496,497,499,502,506,508,512,514,518,520,524,526,530,532,537,539,547,548,550,552,553,554,556,561,562,568,569,570,575,576,577,582,583,588,589,592,593,599,600,601,605,606,611,613,616,617,619,622,626,629,631,635,638,640,644,648,650,658,659,661,663,664,665,670,671,674,675,681,682,683,688,691,692,693,695,699,702,703,704,706,711,712,713,717,720,721,726,727,730,734,736,740,742,744,749,751,754,755,757,760,764,766,770,773,774,777,778,780,784,786,790,793,794,798,799,802,803,806,809,810,814,816,821,823,825,826,828,833,834,836,841,842,844,848,850,855,856,857,862,863,866,868,873,877,878,879,883,884,885,888,889,891,893,897,898,903,905,907,908,910,914,916,920,921,922,924,929,930,935,936,938,944,945,946,951,953,954,958,959,964,965,968,969,974,975,977,982,983,984
-----computeFrom-----
36,37
36,38
47,48
47,49
62,63
62,64
81,82
81,83
83,84
83,85
95,96
95,97
97,98
97,99
99,100
99,101
100,101
100,102
185,186
185,187
214,215
214,216
221,222
221,223
252,253
252,254
257,258
257,259
286,287
286,288
293,294
293,295
313,314
313,315
320,321
320,322
340,341
340,342
353,354
353,355
354,355
354,356
367,368
367,369
377,378
377,379
387,388
387,389
388,389
388,390
389,390
389,391
406,407
406,408
407,408
407,409
438,439
438,440
483,484
483,485
538,539
538,540
540,541
540,542
542,543
542,544
543,544
543,545
565,566
565,567
572,573
572,574
585,586
585,587
590,591
590,592
596,597
596,598
603,604
603,605
624,625
624,626
633,634
633,635
642,643
642,644
649,650
649,651
651,652
651,653
653,654
653,655
654,655
654,656
667,668
667,669
668,669
668,670
672,673
672,674
678,679
678,680
708,709
708,710
724,725
724,726
762,763
762,764
795,796
795,797
804,805
804,806
812,813
812,814
830,831
830,832
838,839
838,840
859,860
859,861
860,861
860,862
864,865
864,866
874,875
874,876
880,881
880,882
886,887
886,888
895,896
895,897
917,918
917,919
932,933
932,934
941,942
941,943
961,962
961,963
971,972
971,973
979,980
979,981
-----guardedBy-----
216,232
264,272
290,304
317,331
364,371
363,376
485,499
588,613
605,619
844,888
842,983
841,982
866,891
935,944
-----guardedByNegation-----
866,897
935,982
-----lastLexicalUse-----
866,897
935,982
-----jump-----
866,897
935,982
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;ConditionalExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;ArraySubscriptExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CompoundStatement;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;WhileStatement;LiteralExpression;CompoundStatement;WhileStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;CompoundStatement;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;LiteralExpression;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;
-----ast_node-----
static bool ok_png_read_data(ok_png_decoder *decoder, uint32_t bytes_remaining) {    ok_png *png = decoder->png;    size_t inflate_buffer_size = 64 * 1024;    size_t num_passes = decoder->interlace_method == 0 ? 1 : 7;    uint8_t bits_per_pixel = decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type];    uint8_t bytes_per_pixel = (bits_per_pixel + 7) / 8;    uint64_t max_bytes_per_scanline = 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8;    size_t platform_max_bytes_per_scanline = (size_t)max_bytes_per_scanline;    // Create buffers    if (!png->data) {        if (decoder->allocator.image_alloc) {            decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);        } else {            uint64_t size = (uint64_t)png->stride * png->height;            size_t platform_size = (size_t)size;            if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }        }        if (!png->data) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");            return false;        }        if (png->stride < png->width * png->bpp) {            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");            return false;        }    }    if (!decoder->prev_scanline) {        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }    if (!decoder->curr_scanline) {        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }    if (!decoder->inflate_buffer) {        decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size);    }    if (decoder->interlace_method == 1 && !decoder->temp_data_row) {        decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp);    }    if (!decoder->curr_scanline || !decoder->prev_scanline || !decoder->inflate_buffer ||        (decoder->interlace_method == 1 && !decoder->temp_data_row)) {        ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers");        return false;    }    // Setup inflater    if (!decoder->inflater) {        decoder->inflater = ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data);        if (!decoder->inflater) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");            return false;        }    }    // Sanity check - this happened with one file in the PNG suite    if (decoder->decoding_completed) {        if (bytes_remaining > 0) {            return ok_seek(decoder, (long)bytes_remaining);        } else {            return true;        }    }    // Read data    uint32_t curr_width = ok_png_get_width_for_pass(decoder);    uint32_t curr_height = ok_png_get_height_for_pass(decoder);    size_t curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);    while (true) {        // Setup pass        while (decoder->ready_for_next_interlace_pass) {            decoder->ready_for_next_interlace_pass = false;            decoder->scanline = 0;            decoder->interlace_pass++;            if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }            curr_width = ok_png_get_width_for_pass(decoder);            curr_height = ok_png_get_height_for_pass(decoder);            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);            if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }        }        // Read compressed data        if (ok_inflater_needs_input(decoder->inflater)) {            if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }            const size_t len = min(inflate_buffer_size, bytes_remaining);            if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }            bytes_remaining -= len;            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);        }        // Decompress data        size_t len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);        if (len == OK_SIZE_MAX) {            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");            return false;        }        decoder->inflater_bytes_read += len;        if (decoder->inflater_bytes_read == curr_bytes_per_scanline) {            // Apply filter            const int filter = decoder->curr_scanline[0];            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }            // Transform            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);            // Setup for next scanline or pass            decoder->scanline++;            if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }        }    }}
static bool
ok_png_read_data(ok_png_decoder *decoder, uint32_t bytes_remaining)
ok_png_read_data
ok_png_decoder *decoder
ok_png_decoder
ok_png_decoder
*decoder
*
decoder
uint32_t bytes_remaining
uint32_t
uint32_t
bytes_remaining
bytes_remaining
{    ok_png *png = decoder->png;    size_t inflate_buffer_size = 64 * 1024;    size_t num_passes = decoder->interlace_method == 0 ? 1 : 7;    uint8_t bits_per_pixel = decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type];    uint8_t bytes_per_pixel = (bits_per_pixel + 7) / 8;    uint64_t max_bytes_per_scanline = 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8;    size_t platform_max_bytes_per_scanline = (size_t)max_bytes_per_scanline;    // Create buffers    if (!png->data) {        if (decoder->allocator.image_alloc) {            decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);        } else {            uint64_t size = (uint64_t)png->stride * png->height;            size_t platform_size = (size_t)size;            if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }        }        if (!png->data) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");            return false;        }        if (png->stride < png->width * png->bpp) {            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");            return false;        }    }    if (!decoder->prev_scanline) {        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }    if (!decoder->curr_scanline) {        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }    if (!decoder->inflate_buffer) {        decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size);    }    if (decoder->interlace_method == 1 && !decoder->temp_data_row) {        decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp);    }    if (!decoder->curr_scanline || !decoder->prev_scanline || !decoder->inflate_buffer ||        (decoder->interlace_method == 1 && !decoder->temp_data_row)) {        ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers");        return false;    }    // Setup inflater    if (!decoder->inflater) {        decoder->inflater = ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data);        if (!decoder->inflater) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");            return false;        }    }    // Sanity check - this happened with one file in the PNG suite    if (decoder->decoding_completed) {        if (bytes_remaining > 0) {            return ok_seek(decoder, (long)bytes_remaining);        } else {            return true;        }    }    // Read data    uint32_t curr_width = ok_png_get_width_for_pass(decoder);    uint32_t curr_height = ok_png_get_height_for_pass(decoder);    size_t curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);    while (true) {        // Setup pass        while (decoder->ready_for_next_interlace_pass) {            decoder->ready_for_next_interlace_pass = false;            decoder->scanline = 0;            decoder->interlace_pass++;            if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }            curr_width = ok_png_get_width_for_pass(decoder);            curr_height = ok_png_get_height_for_pass(decoder);            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);            if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }        }        // Read compressed data        if (ok_inflater_needs_input(decoder->inflater)) {            if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }            const size_t len = min(inflate_buffer_size, bytes_remaining);            if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }            bytes_remaining -= len;            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);        }        // Decompress data        size_t len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);        if (len == OK_SIZE_MAX) {            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");            return false;        }        decoder->inflater_bytes_read += len;        if (decoder->inflater_bytes_read == curr_bytes_per_scanline) {            // Apply filter            const int filter = decoder->curr_scanline[0];            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }            // Transform            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);            // Setup for next scanline or pass            decoder->scanline++;            if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }        }    }}
ok_png *png = decoder->png;
ok_png *png = decoder->png;
ok_png
ok_png
*png = decoder->png
*
png
= decoder->png
decoder->png
decoder
decoder
png
size_t inflate_buffer_size = 64 * 1024;
size_t inflate_buffer_size = 64 * 1024;
size_t
size_t
inflate_buffer_size = 64 * 1024
inflate_buffer_size
= 64 * 1024
64 * 1024
64
1024
size_t num_passes = decoder->interlace_method == 0 ? 1 : 7;
size_t num_passes = decoder->interlace_method == 0 ? 1 : 7;
size_t
size_t
num_passes = decoder->interlace_method == 0 ? 1 : 7
num_passes
= decoder->interlace_method == 0 ? 1 : 7
decoder->interlace_method == 0 ? 1 : 7
decoder->interlace_method == 0
decoder->interlace_method
decoder
decoder
interlace_method
0
1
7
uint8_t bits_per_pixel = decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type];
uint8_t bits_per_pixel = decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type];
uint8_t
uint8_t
bits_per_pixel = decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type]
bits_per_pixel
= decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type]
decoder->bit_depth * OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type]
decoder->bit_depth
decoder
decoder
bit_depth
OK_PNG_SAMPLES_PER_PIXEL[decoder->color_type]
OK_PNG_SAMPLES_PER_PIXEL
OK_PNG_SAMPLES_PER_PIXEL
decoder->color_type
decoder
decoder
color_type
uint8_t bytes_per_pixel = (bits_per_pixel + 7) / 8;
uint8_t bytes_per_pixel = (bits_per_pixel + 7) / 8;
uint8_t
uint8_t
bytes_per_pixel = (bits_per_pixel + 7) / 8
bytes_per_pixel
= (bits_per_pixel + 7) / 8
(bits_per_pixel + 7) / 8
(bits_per_pixel + 7)
bits_per_pixel + 7
bits_per_pixel
bits_per_pixel
7
8
uint64_t max_bytes_per_scanline = 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8;
uint64_t max_bytes_per_scanline = 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8;
uint64_t
uint64_t
max_bytes_per_scanline = 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8
max_bytes_per_scanline
= 1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8
1 + ((uint64_t)png->width * bits_per_pixel + 7) / 8
1
((uint64_t)png->width * bits_per_pixel + 7) / 8
((uint64_t)png->width * bits_per_pixel + 7)
(uint64_t)png->width * bits_per_pixel + 7
(uint64_t)png->width * bits_per_pixel
(uint64_t)png->width
uint64_t
uint64_t
uint64_t

png->width
png
png
width
bits_per_pixel
bits_per_pixel
7
8
size_t platform_max_bytes_per_scanline = (size_t)max_bytes_per_scanline;
size_t platform_max_bytes_per_scanline = (size_t)max_bytes_per_scanline;
size_t
size_t
platform_max_bytes_per_scanline = (size_t)max_bytes_per_scanline
platform_max_bytes_per_scanline
= (size_t)max_bytes_per_scanline
(size_t)max_bytes_per_scanline
size_t
size_t
size_t

max_bytes_per_scanline
max_bytes_per_scanline
if (!png->data) {        if (decoder->allocator.image_alloc) {            decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);        } else {            uint64_t size = (uint64_t)png->stride * png->height;            size_t platform_size = (size_t)size;            if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }        }        if (!png->data) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");            return false;        }        if (png->stride < png->width * png->bpp) {            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");            return false;        }    }
!png->data
png->data
png
png
data
{        if (decoder->allocator.image_alloc) {            decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);        } else {            uint64_t size = (uint64_t)png->stride * png->height;            size_t platform_size = (size_t)size;            if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }        }        if (!png->data) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");            return false;        }        if (png->stride < png->width * png->bpp) {            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");            return false;        }    }
if (decoder->allocator.image_alloc) {            decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);        } else {            uint64_t size = (uint64_t)png->stride * png->height;            size_t platform_size = (size_t)size;            if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }        }
decoder->allocator.image_alloc
decoder->allocator
decoder
decoder
allocator
image_alloc
{            decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);        }
decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride);
decoder->allocator.image_alloc(decoder->allocator_user_data,                                           png->width, png->height, png->bpp,                                           &png->data, &png->stride)
decoder->allocator.image_alloc
decoder->allocator
decoder
decoder
allocator
image_alloc
decoder->allocator_user_data
decoder
decoder
allocator_user_data
png->width
png
png
width
png->height
png
png
height
png->bpp
png
png
bpp
&png->data
png->data
png
png
data
&png->stride
png->stride
png
png
stride
{            uint64_t size = (uint64_t)png->stride * png->height;            size_t platform_size = (size_t)size;            if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }        }
uint64_t size = (uint64_t)png->stride * png->height;
uint64_t size = (uint64_t)png->stride * png->height;
uint64_t
uint64_t
size = (uint64_t)png->stride * png->height
size
= (uint64_t)png->stride * png->height
(uint64_t)png->stride * png->height
(uint64_t)png->stride
uint64_t
uint64_t
uint64_t

png->stride
png
png
stride
png->height
png
png
height
size_t platform_size = (size_t)size;
size_t platform_size = (size_t)size;
size_t
size_t
platform_size = (size_t)size
platform_size
= (size_t)size
(size_t)size
size_t
size_t
size_t

size
size
if (platform_size == size) {                png->data = ok_alloc(decoder, platform_size);            }
platform_size == size
platform_size
platform_size
size
size
{                png->data = ok_alloc(decoder, platform_size);            }
png->data = ok_alloc(decoder, platform_size);
png->data = ok_alloc(decoder, platform_size)
png->data
png
png
data
ok_alloc(decoder, platform_size)
ok_alloc
ok_alloc
decoder
decoder
platform_size
platform_size
if (!png->data) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");            return false;        }
!png->data
png->data
png
png
data
{            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");            return false;        }
ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image");
ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate memory for image")
ok_png_error
ok_png_error
png
png
OK_PNG_ERROR_ALLOCATION
OK_PNG_ERROR_ALLOCATION
"Couldn't allocate memory for image"
return false;
false
if (png->stride < png->width * png->bpp) {            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");            return false;        }
png->stride < png->width * png->bpp
png->stride
png
png
stride
png->width * png->bpp
png->width
png
png
width
png->bpp
png
png
bpp
{            ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");            return false;        }
ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride");
ok_png_error(png, OK_PNG_ERROR_API, "Invalid stride")
ok_png_error
ok_png_error
png
png
OK_PNG_ERROR_API
OK_PNG_ERROR_API
"Invalid stride"
return false;
false
if (!decoder->prev_scanline) {        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }
!decoder->prev_scanline
decoder->prev_scanline
decoder
decoder
prev_scanline
{        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }
if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }
max_bytes_per_scanline == platform_max_bytes_per_scanline
max_bytes_per_scanline
max_bytes_per_scanline
platform_max_bytes_per_scanline
platform_max_bytes_per_scanline
{            decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }
decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);
decoder->prev_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline)
decoder->prev_scanline
decoder
decoder
prev_scanline
ok_alloc(decoder, platform_max_bytes_per_scanline)
ok_alloc
ok_alloc
decoder
decoder
platform_max_bytes_per_scanline
platform_max_bytes_per_scanline
if (!decoder->curr_scanline) {        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }
!decoder->curr_scanline
decoder->curr_scanline
decoder
decoder
curr_scanline
{        if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }    }
if (max_bytes_per_scanline == platform_max_bytes_per_scanline) {            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }
max_bytes_per_scanline == platform_max_bytes_per_scanline
max_bytes_per_scanline
max_bytes_per_scanline
platform_max_bytes_per_scanline
platform_max_bytes_per_scanline
{            decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);        }
decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline);
decoder->curr_scanline = ok_alloc(decoder, platform_max_bytes_per_scanline)
decoder->curr_scanline
decoder
decoder
curr_scanline
ok_alloc(decoder, platform_max_bytes_per_scanline)
ok_alloc
ok_alloc
decoder
decoder
platform_max_bytes_per_scanline
platform_max_bytes_per_scanline
if (!decoder->inflate_buffer) {        decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size);    }
!decoder->inflate_buffer
decoder->inflate_buffer
decoder
decoder
inflate_buffer
{        decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size);    }
decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size);
decoder->inflate_buffer = ok_alloc(decoder, inflate_buffer_size)
decoder->inflate_buffer
decoder
decoder
inflate_buffer
ok_alloc(decoder, inflate_buffer_size)
ok_alloc
ok_alloc
decoder
decoder
inflate_buffer_size
inflate_buffer_size
if (decoder->interlace_method == 1 && !decoder->temp_data_row) {        decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp);    }
decoder->interlace_method == 1 && !decoder->temp_data_row
decoder->interlace_method == 1
decoder->interlace_method
decoder
decoder
interlace_method
1
!decoder->temp_data_row
decoder->temp_data_row
decoder
decoder
temp_data_row
{        decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp);    }
decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp);
decoder->temp_data_row = ok_alloc(decoder, png->width * png->bpp)
decoder->temp_data_row
decoder
decoder
temp_data_row
ok_alloc(decoder, png->width * png->bpp)
ok_alloc
ok_alloc
decoder
decoder
png->width * png->bpp
png->width
png
png
width
png->bpp
png
png
bpp
if (!decoder->curr_scanline || !decoder->prev_scanline || !decoder->inflate_buffer ||        (decoder->interlace_method == 1 && !decoder->temp_data_row)) {        ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers");        return false;    }
!decoder->curr_scanline || !decoder->prev_scanline || !decoder->inflate_buffer ||        (decoder->interlace_method == 1 && !decoder->temp_data_row)
!decoder->curr_scanline || !decoder->prev_scanline || !decoder->inflate_buffer
!decoder->curr_scanline || !decoder->prev_scanline
!decoder->curr_scanline
decoder->curr_scanline
decoder
decoder
curr_scanline
!decoder->prev_scanline
decoder->prev_scanline
decoder
decoder
prev_scanline
!decoder->inflate_buffer
decoder->inflate_buffer
decoder
decoder
inflate_buffer
(decoder->interlace_method == 1 && !decoder->temp_data_row)
decoder->interlace_method == 1 && !decoder->temp_data_row
decoder->interlace_method == 1
decoder->interlace_method
decoder
decoder
interlace_method
1
!decoder->temp_data_row
decoder->temp_data_row
decoder
decoder
temp_data_row
{        ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers");        return false;    }
ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers");
ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't allocate buffers")
ok_png_error
ok_png_error
png
png
OK_PNG_ERROR_ALLOCATION
OK_PNG_ERROR_ALLOCATION
"Couldn't allocate buffers"
return false;
false
if (!decoder->inflater) {        decoder->inflater = ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data);        if (!decoder->inflater) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");            return false;        }    }
!decoder->inflater
decoder->inflater
decoder
decoder
inflater
{        decoder->inflater = ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data);        if (!decoder->inflater) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");            return false;        }    }
decoder->inflater = ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data);
decoder->inflater = ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data)
decoder->inflater
decoder
decoder
inflater
ok_inflater_init(decoder->is_ios_format,                                             decoder->allocator, decoder->allocator_user_data)
ok_inflater_init
ok_inflater_init
decoder->is_ios_format
decoder
decoder
is_ios_format
decoder->allocator
decoder
decoder
allocator
decoder->allocator_user_data
decoder
decoder
allocator_user_data
if (!decoder->inflater) {            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");            return false;        }
!decoder->inflater
decoder->inflater
decoder
decoder
inflater
{            ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");            return false;        }
ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater");
ok_png_error(png, OK_PNG_ERROR_ALLOCATION, "Couldn't init inflater")
ok_png_error
ok_png_error
png
png
OK_PNG_ERROR_ALLOCATION
OK_PNG_ERROR_ALLOCATION
"Couldn't init inflater"
return false;
false
if (decoder->decoding_completed) {        if (bytes_remaining > 0) {            return ok_seek(decoder, (long)bytes_remaining);        } else {            return true;        }    }
decoder->decoding_completed
decoder
decoder
decoding_completed
{        if (bytes_remaining > 0) {            return ok_seek(decoder, (long)bytes_remaining);        } else {            return true;        }    }
if (bytes_remaining > 0) {            return ok_seek(decoder, (long)bytes_remaining);        } else {            return true;        }
bytes_remaining > 0
bytes_remaining
bytes_remaining
0
{            return ok_seek(decoder, (long)bytes_remaining);        }
return ok_seek(decoder, (long)bytes_remaining);
ok_seek(decoder, (long)bytes_remaining)
ok_seek
ok_seek
decoder
decoder
(long)bytes_remaining
long
long

bytes_remaining
bytes_remaining
{            return true;        }
return true;
true
uint32_t curr_width = ok_png_get_width_for_pass(decoder);
uint32_t curr_width = ok_png_get_width_for_pass(decoder);
uint32_t
uint32_t
curr_width = ok_png_get_width_for_pass(decoder)
curr_width
= ok_png_get_width_for_pass(decoder)
ok_png_get_width_for_pass(decoder)
ok_png_get_width_for_pass
ok_png_get_width_for_pass
decoder
decoder
uint32_t curr_height = ok_png_get_height_for_pass(decoder);
uint32_t curr_height = ok_png_get_height_for_pass(decoder);
uint32_t
uint32_t
curr_height = ok_png_get_height_for_pass(decoder)
curr_height
= ok_png_get_height_for_pass(decoder)
ok_png_get_height_for_pass(decoder)
ok_png_get_height_for_pass
ok_png_get_height_for_pass
decoder
decoder
size_t curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);
size_t curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);
size_t
size_t
curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8)
curr_bytes_per_scanline
= (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8)
(size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8)
(size_t)
size_t
size_t
1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8
1
((uint64_t)curr_width * bits_per_pixel + 7) / 8
((uint64_t)curr_width * bits_per_pixel + 7)
(uint64_t)curr_width * bits_per_pixel + 7
(uint64_t)curr_width * bits_per_pixel
(uint64_t)curr_width
uint64_t
uint64_t
uint64_t

curr_width
curr_width
bits_per_pixel
bits_per_pixel
7
8
while (true) {        // Setup pass        while (decoder->ready_for_next_interlace_pass) {            decoder->ready_for_next_interlace_pass = false;            decoder->scanline = 0;            decoder->interlace_pass++;            if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }            curr_width = ok_png_get_width_for_pass(decoder);            curr_height = ok_png_get_height_for_pass(decoder);            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);            if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }        }        // Read compressed data        if (ok_inflater_needs_input(decoder->inflater)) {            if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }            const size_t len = min(inflate_buffer_size, bytes_remaining);            if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }            bytes_remaining -= len;            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);        }        // Decompress data        size_t len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);        if (len == OK_SIZE_MAX) {            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");            return false;        }        decoder->inflater_bytes_read += len;        if (decoder->inflater_bytes_read == curr_bytes_per_scanline) {            // Apply filter            const int filter = decoder->curr_scanline[0];            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }            // Transform            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);            // Setup for next scanline or pass            decoder->scanline++;            if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }        }    }
true
{        // Setup pass        while (decoder->ready_for_next_interlace_pass) {            decoder->ready_for_next_interlace_pass = false;            decoder->scanline = 0;            decoder->interlace_pass++;            if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }            curr_width = ok_png_get_width_for_pass(decoder);            curr_height = ok_png_get_height_for_pass(decoder);            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);            if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }        }        // Read compressed data        if (ok_inflater_needs_input(decoder->inflater)) {            if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }            const size_t len = min(inflate_buffer_size, bytes_remaining);            if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }            bytes_remaining -= len;            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);        }        // Decompress data        size_t len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);        if (len == OK_SIZE_MAX) {            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");            return false;        }        decoder->inflater_bytes_read += len;        if (decoder->inflater_bytes_read == curr_bytes_per_scanline) {            // Apply filter            const int filter = decoder->curr_scanline[0];            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }            // Transform            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);            // Setup for next scanline or pass            decoder->scanline++;            if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }        }    }
while (decoder->ready_for_next_interlace_pass) {            decoder->ready_for_next_interlace_pass = false;            decoder->scanline = 0;            decoder->interlace_pass++;            if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }            curr_width = ok_png_get_width_for_pass(decoder);            curr_height = ok_png_get_height_for_pass(decoder);            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);            if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }        }
decoder->ready_for_next_interlace_pass
decoder
decoder
ready_for_next_interlace_pass
{            decoder->ready_for_next_interlace_pass = false;            decoder->scanline = 0;            decoder->interlace_pass++;            if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }            curr_width = ok_png_get_width_for_pass(decoder);            curr_height = ok_png_get_height_for_pass(decoder);            curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);            if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }        }
decoder->ready_for_next_interlace_pass = false;
decoder->ready_for_next_interlace_pass = false
decoder->ready_for_next_interlace_pass
decoder
decoder
ready_for_next_interlace_pass
false
decoder->scanline = 0;
decoder->scanline = 0
decoder->scanline
decoder
decoder
scanline
0
decoder->interlace_pass++;
decoder->interlace_pass++
decoder->interlace_pass
decoder
decoder
interlace_pass
if (decoder->interlace_pass == num_passes + 1) {                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }
decoder->interlace_pass == num_passes + 1
decoder->interlace_pass
decoder
decoder
interlace_pass
num_passes + 1
num_passes
num_passes
1
{                // Done decoding - skip any remaining chunk data                decoder->decoding_completed = true;                if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }            }
decoder->decoding_completed = true;
decoder->decoding_completed = true
decoder->decoding_completed
decoder
decoder
decoding_completed
true
if (bytes_remaining > 0) {                    return ok_seek(decoder, (long)bytes_remaining);                } else {                    return true;                }
bytes_remaining > 0
bytes_remaining
bytes_remaining
0
{                    return ok_seek(decoder, (long)bytes_remaining);                }
return ok_seek(decoder, (long)bytes_remaining);
ok_seek(decoder, (long)bytes_remaining)
ok_seek
ok_seek
decoder
decoder
(long)bytes_remaining
long
long

bytes_remaining
bytes_remaining
{                    return true;                }
return true;
true
curr_width = ok_png_get_width_for_pass(decoder);
curr_width = ok_png_get_width_for_pass(decoder)
curr_width
curr_width
ok_png_get_width_for_pass(decoder)
ok_png_get_width_for_pass
ok_png_get_width_for_pass
decoder
decoder
curr_height = ok_png_get_height_for_pass(decoder);
curr_height = ok_png_get_height_for_pass(decoder)
curr_height
curr_height
ok_png_get_height_for_pass(decoder)
ok_png_get_height_for_pass
ok_png_get_height_for_pass
decoder
decoder
curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8);
curr_bytes_per_scanline = (size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8)
curr_bytes_per_scanline
curr_bytes_per_scanline
(size_t)(1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8)
(size_t)
size_t
size_t
1 + ((uint64_t)curr_width * bits_per_pixel + 7) / 8
1
((uint64_t)curr_width * bits_per_pixel + 7) / 8
((uint64_t)curr_width * bits_per_pixel + 7)
(uint64_t)curr_width * bits_per_pixel + 7
(uint64_t)curr_width * bits_per_pixel
(uint64_t)curr_width
uint64_t
uint64_t
uint64_t

curr_width
curr_width
bits_per_pixel
bits_per_pixel
7
8
if (curr_width == 0 || curr_height == 0) {                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            } else {                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }
curr_width == 0 || curr_height == 0
curr_width == 0
curr_width
curr_width
0
curr_height == 0
curr_height
curr_height
0
{                // No data for this pass - happens if width or height <= 4                decoder->ready_for_next_interlace_pass = true;            }
decoder->ready_for_next_interlace_pass = true;
decoder->ready_for_next_interlace_pass = true
decoder->ready_for_next_interlace_pass
decoder
decoder
ready_for_next_interlace_pass
true
{                memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);                memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);                decoder->inflater_bytes_read = 0;            }
memset(decoder->curr_scanline, 0, curr_bytes_per_scanline);
memset(decoder->curr_scanline, 0, curr_bytes_per_scanline)
memset
memset
decoder->curr_scanline
decoder
decoder
curr_scanline
0
curr_bytes_per_scanline
curr_bytes_per_scanline
memset(decoder->prev_scanline, 0, curr_bytes_per_scanline);
memset(decoder->prev_scanline, 0, curr_bytes_per_scanline)
memset
memset
decoder->prev_scanline
decoder
decoder
prev_scanline
0
curr_bytes_per_scanline
curr_bytes_per_scanline
decoder->inflater_bytes_read = 0;
decoder->inflater_bytes_read = 0
decoder->inflater_bytes_read
decoder
decoder
inflater_bytes_read
0
if (ok_inflater_needs_input(decoder->inflater)) {            if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }            const size_t len = min(inflate_buffer_size, bytes_remaining);            if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }            bytes_remaining -= len;            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);        }
ok_inflater_needs_input(decoder->inflater)
ok_inflater_needs_input
ok_inflater_needs_input
decoder->inflater
decoder
decoder
inflater
{            if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }            const size_t len = min(inflate_buffer_size, bytes_remaining);            if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }            bytes_remaining -= len;            ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);        }
if (bytes_remaining == 0) {                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }
bytes_remaining == 0
bytes_remaining
bytes_remaining
0
{                // Need more data, but there is no remaining data in this chunk.                // There may be another IDAT chunk.                return true;            }
return true;
true
const size_t len = min(inflate_buffer_size, bytes_remaining);
const size_t len = min(inflate_buffer_size, bytes_remaining);
const size_t
size_t
len = min(inflate_buffer_size, bytes_remaining)
len
= min(inflate_buffer_size, bytes_remaining)
min(inflate_buffer_size, bytes_remaining)
min
min
inflate_buffer_size
inflate_buffer_size
bytes_remaining
bytes_remaining
if (!ok_read(decoder, decoder->inflate_buffer, len)) {                return false;            }
!ok_read(decoder, decoder->inflate_buffer, len)
ok_read(decoder, decoder->inflate_buffer, len)
ok_read
ok_read
decoder
decoder
decoder->inflate_buffer
decoder
decoder
inflate_buffer
len
len
{                return false;            }
return false;
false
bytes_remaining -= len;
bytes_remaining -= len
bytes_remaining
bytes_remaining
len
len
ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len);
ok_inflater_set_input(decoder->inflater, decoder->inflate_buffer, len)
ok_inflater_set_input
ok_inflater_set_input
decoder->inflater
decoder
decoder
inflater
decoder->inflate_buffer
decoder
decoder
inflate_buffer
len
len
size_t len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);
size_t len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read);
size_t
size_t
len = ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read)
len
= ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read)
ok_inflater_inflate(decoder->inflater,                                         decoder->curr_scanline + decoder->inflater_bytes_read,                                         curr_bytes_per_scanline - decoder->inflater_bytes_read)
ok_inflater_inflate
ok_inflater_inflate
decoder->inflater
decoder
decoder
inflater
decoder->curr_scanline + decoder->inflater_bytes_read
decoder->curr_scanline
decoder
decoder
curr_scanline
decoder->inflater_bytes_read
decoder
decoder
inflater_bytes_read
curr_bytes_per_scanline - decoder->inflater_bytes_read
curr_bytes_per_scanline
curr_bytes_per_scanline
decoder->inflater_bytes_read
decoder
decoder
inflater_bytes_read
if (len == OK_SIZE_MAX) {            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");            return false;        }
len == OK_SIZE_MAX
len
len
OK_SIZE_MAX
OK_SIZE_MAX
{            ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");            return false;        }
ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error");
ok_png_error(png, OK_PNG_ERROR_INFLATER, "Inflater error")
ok_png_error
ok_png_error
png
png
OK_PNG_ERROR_INFLATER
OK_PNG_ERROR_INFLATER
"Inflater error"
return false;
false
decoder->inflater_bytes_read += len;
decoder->inflater_bytes_read += len
decoder->inflater_bytes_read
decoder
decoder
inflater_bytes_read
len
len
if (decoder->inflater_bytes_read == curr_bytes_per_scanline) {            // Apply filter            const int filter = decoder->curr_scanline[0];            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }            // Transform            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);            // Setup for next scanline or pass            decoder->scanline++;            if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }        }
decoder->inflater_bytes_read == curr_bytes_per_scanline
decoder->inflater_bytes_read
decoder
decoder
inflater_bytes_read
curr_bytes_per_scanline
curr_bytes_per_scanline
{            // Apply filter            const int filter = decoder->curr_scanline[0];            if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }            // Transform            ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);            // Setup for next scanline or pass            decoder->scanline++;            if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }        }
const int filter = decoder->curr_scanline[0];
const int filter = decoder->curr_scanline[0];
const int
filter = decoder->curr_scanline[0]
filter
= decoder->curr_scanline[0]
decoder->curr_scanline[0]
decoder->curr_scanline
decoder
decoder
curr_scanline
0
if (filter > 0 && filter < OK_PNG_NUM_FILTERS) {                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            } else if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }
filter > 0 && filter < OK_PNG_NUM_FILTERS
filter > 0
filter
filter
0
filter < OK_PNG_NUM_FILTERS
filter
filter
OK_PNG_NUM_FILTERS
OK_PNG_NUM_FILTERS
{                ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);            }
ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel);
ok_png_decode_filter(decoder->curr_scanline + 1, decoder->prev_scanline + 1,                                     curr_bytes_per_scanline - 1, filter, bytes_per_pixel)
ok_png_decode_filter
ok_png_decode_filter
decoder->curr_scanline + 1
decoder->curr_scanline
decoder
decoder
curr_scanline
1
decoder->prev_scanline + 1
decoder->prev_scanline
decoder
decoder
prev_scanline
1
curr_bytes_per_scanline - 1
curr_bytes_per_scanline
curr_bytes_per_scanline
1
filter
filter
bytes_per_pixel
bytes_per_pixel
if (filter != 0) {                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }
filter != 0
filter
filter
0
{                ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");                return false;            }
ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type");
ok_png_error(png, OK_PNG_ERROR_INVALID, "Invalid filter type")
ok_png_error
ok_png_error
png
png
OK_PNG_ERROR_INVALID
OK_PNG_ERROR_INVALID
"Invalid filter type"
return false;
false
ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width);
ok_png_transform_scanline(decoder, decoder->curr_scanline + 1, curr_width)
ok_png_transform_scanline
ok_png_transform_scanline
decoder
decoder
decoder->curr_scanline + 1
decoder->curr_scanline
decoder
decoder
curr_scanline
1
curr_width
curr_width
decoder->scanline++;
decoder->scanline++
decoder->scanline
decoder
decoder
scanline
if (decoder->scanline == curr_height) {                decoder->ready_for_next_interlace_pass = true;            } else {                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }
decoder->scanline == curr_height
decoder->scanline
decoder
decoder
scanline
curr_height
curr_height
{                decoder->ready_for_next_interlace_pass = true;            }
decoder->ready_for_next_interlace_pass = true;
decoder->ready_for_next_interlace_pass = true
decoder->ready_for_next_interlace_pass
decoder
decoder
ready_for_next_interlace_pass
true
{                uint8_t *temp = decoder->curr_scanline;                decoder->curr_scanline = decoder->prev_scanline;                decoder->prev_scanline = temp;                decoder->inflater_bytes_read = 0;            }
uint8_t *temp = decoder->curr_scanline;
uint8_t *temp = decoder->curr_scanline;
uint8_t
uint8_t
*temp = decoder->curr_scanline
*
temp
= decoder->curr_scanline
decoder->curr_scanline
decoder
decoder
curr_scanline
decoder->curr_scanline = decoder->prev_scanline;
decoder->curr_scanline = decoder->prev_scanline
decoder->curr_scanline
decoder
decoder
curr_scanline
decoder->prev_scanline
decoder
decoder
prev_scanline
decoder->prev_scanline = temp;
decoder->prev_scanline = temp
decoder->prev_scanline
decoder
decoder
prev_scanline
temp
temp
decoder->inflater_bytes_read = 0;
decoder->inflater_bytes_read = 0
decoder->inflater_bytes_read
decoder
decoder
inflater_bytes_read
0
-----joern-----
(12,48,0)
(46,23,0)
(6,50,0)
(2,50,0)
(34,33,0)
(30,42,0)
(32,45,0)
(24,23,0)
(45,33,0)
(47,30,0)
(6,13,0)
(35,1,0)
(29,47,0)
(22,7,0)
(33,50,0)
(4,2,0)
(2,20,0)
(44,42,0)
(26,33,0)
(30,47,0)
(32,24,0)
(2,49,0)
(42,44,0)
(52,6,0)
(45,23,0)
(1,48,0)
(42,30,0)
(36,23,0)
(45,11,0)
(10,42,0)
(17,50,0)
(13,37,0)
(24,33,0)
(43,37,0)
(47,50,0)
(36,14,0)
(31,7,0)
(20,51,0)
(48,1,0)
(5,23,0)
(15,6,0)
(37,13,0)
(49,8,0)
(18,37,0)
(17,35,0)
(35,17,0)
(14,7,0)
(40,20,0)
(14,48,0)
(20,23,0)
(3,11,0)
(27,45,0)
(47,20,0)
(28,2,0)
(24,41,0)
(16,47,0)
(7,50,0)
(39,17,0)
(7,14,0)
(49,2,0)
(36,51,0)
(21,51,0)
(37,50,0)
(13,44,0)
(25,14,0)
(20,33,0)
(53,49,0)
(7,20,0)
(23,50,0)
(9,51,0)
(44,13,0)
(0,24,0)
(36,33,0)
(1,35,0)
(48,51,0)
(38,17,0)
(14,36,0)
(13,6,0)
(23,36,0)
(33,20,0)
(19,30,0)
(49,8,1)
(23,5,1)
(22,31,1)
(17,38,1)
(46,48,1)
(27,49,1)
(40,33,1)
(1,35,1)
(37,50,1)
(14,48,1)
(36,23,1)
(47,16,1)
(32,24,1)
(49,2,1)
(45,23,1)
(52,37,1)
(20,23,1)
(2,50,1)
(53,2,1)
(44,13,1)
(30,19,1)
(2,20,1)
(48,1,1)
(5,46,1)
(34,36,1)
(16,29,1)
(13,6,1)
(15,52,1)
(45,33,1)
(37,18,1)
(20,40,1)
(7,22,1)
(19,47,1)
(18,43,1)
(49,53,1)
(6,50,1)
(42,10,1)
(42,30,1)
(36,33,1)
(20,33,1)
(38,39,1)
(7,20,1)
(25,23,1)
(28,4,1)
(24,23,1)
(4,20,1)
(47,50,1)
(32,45,1)
(7,50,1)
(14,7,1)
(33,50,1)
(6,15,1)
(24,0,1)
(17,50,1)
(30,47,1)
(36,14,1)
(39,12,1)
(43,49,1)
(2,28,1)
(33,26,1)
(23,50,1)
(13,37,1)
(24,33,1)
(26,34,1)
(12,44,1)
(44,42,1)
(35,17,1)
(47,20,1)
(10,30,1)
(45,27,1)
(31,25,1)
(29,13,1)
(0,44,1)
(30,13,2)
(37,50,2)
(7,44,2)
(20,33,2)
(35,17,2)
(22,44,2)
(5,44,2)
(36,44,2)
(16,13,2)
(23,50,2)
(7,50,2)
(12,44,2)
(20,23,2)
(45,49,2)
(34,44,2)
(36,33,2)
(19,13,2)
(25,44,2)
(32,45,2)
(14,48,2)
(48,44,2)
(24,23,2)
(36,14,2)
(39,44,2)
(17,44,2)
(44,49,2)
(1,35,2)
(20,44,2)
(49,8,2)
(47,50,2)
(26,44,2)
(10,13,2)
(42,30,2)
(46,44,2)
(47,13,2)
(30,47,2)
(53,44,2)
(28,44,2)
(49,44,2)
(43,49,2)
(13,49,2)
(6,50,2)
(15,49,2)
(38,44,2)
(42,13,2)
(1,44,2)
(45,33,2)
(29,13,2)
(0,44,2)
(13,6,2)
(4,44,2)
(14,7,2)
(47,20,2)
(18,49,2)
(44,42,2)
(2,20,2)
(45,23,2)
(32,24,2)
(52,49,2)
(35,44,2)
(44,13,2)
(7,20,2)
(23,44,2)
(49,2,2)
(17,50,2)
(27,49,2)
(13,37,2)
(6,49,2)
(2,44,2)
(37,49,2)
(40,44,2)
(2,50,2)
(33,44,2)
(14,44,2)
(33,50,2)
(36,23,2)
(31,44,2)
(24,44,2)
(24,33,2)
(48,1,2)
-----------------------------------
(0,false)
(1,*inflater->input++)
(2,inflater->input_buffer_bits)
(3,while (inflater->input_buffer_bits < num_bits)
(4,inflater)
(5,input_buffer)
(6,inflater->input_end)
(7,inflater->input_buffer_bits)
(8,unsigned int num_bits)
(9,if (inflater->input == inflater->input_end || inflater->input_buffer_bits + 8 > 32)
(10,32)
(11,)
(12,input)
(13,inflater->input == inflater->input_end)
(14,input << inflater->input_buffer_bits)
(15,input_end)
(16,input_buffer_bits)
(17,inflater->input)
(18,input)
(19,8)
(20,inflater->input_buffer_bits += 8)
(21,input)
(22,input_buffer_bits)
(23,inflater->input_buffer)
(24,return false;)
(25,input)
(26,input_buffer_bits)
(27,true)
(28,input_buffer_bits)
(29,inflater)
(30,inflater->input_buffer_bits + 8)
(31,inflater)
(32,RET)
(33,inflater->input_buffer_bits)
(34,inflater)
(35,inflater->input++)
(36,inflater->input_buffer |= input << inflater->input_buffer_bits)
(37,inflater->input)
(38,input)
(39,inflater)
(40,8)
(41,)
(42,inflater->input_buffer_bits + 8 > 32)
(43,inflater)
(44,inflater->input == inflater->input_end || inflater->input_buffer_bits + 8 > 32)
(45,return true;)
(46,inflater)
(47,inflater->input_buffer_bits)
(48,input = *inflater->input++)
(49,inflater->input_buffer_bits < num_bits)
(50,ok_inflater *inflater)
(51,)
(52,inflater)
(53,num_bits)
=====================================

