[
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int make_mkstemp_template(char *buffer, size_t size)\n{\n#ifdef _WIN32\n\tchar temp_directory[MAX_PATH];\n\tif (GetTempPathA(sizeof(temp_directory), temp_directory) == 0)\n\t\treturn -1;\n\n\t(void)size;\n\n\treturn GetTempFileNameA(temp_directory, \"jasper\", 0, buffer) > 0\n\t\t? 0 : -1;\n#else\n\tstatic const char base[] = \"jasper.XXXXXX\";\n\n\tsize_t length = get_temp_directory(buffer, size);\n\tif (length == 0 || length + sizeof(base) >= size)\n\t\treturn -1;\n\n\tmemcpy(buffer + length, base, sizeof(base));\n\treturn 0;\n#endif\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static void jas_stream_destroy(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_destroy(%p)\\n\", stream));\n\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_gobble(jas_stream_t *in, long n)\n{\n\twhile (--n >= 0) {\n\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_getint16(jas_stream_t *in, int_fast16_t *val)\n{\n\tint lo;\n\tint hi;\n\tif ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = (hi << 8) | lo;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int easy_mkstemp(char *buffer, size_t size)\n{\n#if defined(__linux__) && defined(O_TMPFILE)\n\t/* try to use O_TMPFILE, which is a Linux-specific feature to\n\t   create a temporary file without a name, not linked to any\n\t   directory; this is even more secure than mkstemp() */\n\tconst char *tmpdir = getenv(\"TMPDIR\");\n\tif (tmpdir == NULL)\n\t\ttmpdir = \"/tmp\";\n\n\tint fd = open(tmpdir, O_TMPFILE|O_RDWR, JAS_STREAM_PERMS);\n\tif (fd >= 0) {\n\t\t*buffer = 0;\n\t\treturn fd;\n\t}\n#endif\n\n\tif (make_mkstemp_template(buffer, size))\n\t\treturn -1;\n\n#ifdef _WIN32\n\treturn open(buffer,\n\t\t    O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY | O_CLOEXEC,\n\t\t    JAS_STREAM_PERMS);\n#else\n#ifdef JAS_HAVE_MKOSTEMP\n\treturn mkostemp(buffer, O_CLOEXEC);\n#else\n\treturn mkstemp(buffer);\n#endif\n#endif\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static void jas_stream_destroy(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_destroy(%p)\\n\", stream));\n\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int easy_mkstemp(char *buffer, size_t size)\n{\n#if defined(__linux__) && defined(O_TMPFILE)\n\t/* try to use O_TMPFILE, which is a Linux-specific feature to\n\t   create a temporary file without a name, not linked to any\n\t   directory; this is even more secure than mkstemp() */\n\tconst char *tmpdir = getenv(\"TMPDIR\");\n\tif (tmpdir == NULL)\n\t\ttmpdir = \"/tmp\";\n\n\tint fd = open(tmpdir, O_TMPFILE|O_RDWR, JAS_STREAM_PERMS);\n\tif (fd >= 0) {\n\t\t*buffer = 0;\n\t\treturn fd;\n\t}\n#endif\n\n\tif (make_mkstemp_template(buffer, size))\n\t\treturn -1;\n\n#ifdef _WIN32\n\treturn open(buffer,\n\t\t    O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY | O_CLOEXEC,\n\t\t    JAS_STREAM_PERMS);\n#else\n#ifdef JAS_HAVE_MKOSTEMP\n\treturn mkostemp(buffer, O_CLOEXEC);\n#else\n\treturn mkstemp(buffer);\n#endif\n#endif\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int bmp_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t/* Read the first two characters that constitute the signature. */\n\tif (jas_stream_peek(in, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn -1;\n\n\t/* Is the signature correct for the BMP format? */\n\tif (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "const jas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tunsigned i;\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_gobble(jas_stream_t *in, long n)\n{\n\twhile (--n >= 0) {\n\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "bmp_info_t *bmp_info_create()\n{\n\tbmp_info_t *info;\n\tif (!(info = jas_malloc(sizeof(bmp_info_t)))) {\n\t\treturn 0;\n\t}\n\tinfo->palents = 0;\n\treturn info;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int jp2_ftyp_putdata(const jp2_box_t *box, jas_stream_t *out)\n{\n\tconst jp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int pnm_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t/* Read the first two characters that constitute the signature. */\n\tif (jas_stream_peek(in, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn -1;\n\n\t/* Is this the correct signature for a PNM file? */\n\tif (buf[0] == 'P' && isdigit(buf[1])) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_image_t *bmp_decode(jas_stream_t *in, const char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\tbmp_dec_importopts_t opts;\n\tsize_t num_samples;\n\n\timage = 0;\n\tinfo = 0;\n\n\tif (bmp_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in, &opts))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!jas_safe_size_mul3(info->width, info->height, info->numplanes,\n\t  &num_samples)) {\n\t\tjas_eprintf(\"image size too large\\n\");\n\t\tgoto error;\n\t}\n\n\tif (opts.max_samples > 0 && num_samples > opts.max_samples) {\n\t\tjas_eprintf(\"maximum number of pixels exceeded (%zu)\\n\",\n\t\t  opts.max_samples);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tgoto error;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tgoto error;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "long jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"jas_stream_seek(%p, %ld, %d)\\n\", stream, offset,\n\t  origin));\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_gethdr(jas_stream_t *in, bmp_hdr_t *hdr)\n{\n\tif (bmp_getint16(in, &hdr->magic) || hdr->magic != BMP_MAGIC ||\n\t  bmp_getint32(in, &hdr->siz) || bmp_getint16(in, &hdr->reserved1) ||\n\t  bmp_getint16(in, &hdr->reserved2) || bmp_getint32(in, &hdr->off)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_image_strtofmt(const char *name)\n{\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static bool jas_stream_is_unbuffered(const jas_stream_t *stream)\n{\n\treturn stream->bufsize_ <= 1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void jas_free(void *ptr)\n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int file_close(jas_stream_obj_t *obj)\n{\n\tint ret;\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_close(%p)\\n\", obj));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_image_t *jas_image_decode(jas_stream_t *in, int fmt, const char *optstr)\n{\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\tjas_image_t *image;\n\n\timage = 0;\n\n\t/* If possible, try to determine the format of the input data. */\n\tif (fmt < 0) {\n\t\tif ((fmt = jas_image_getfmt(in)) < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* Is it possible to decode an image represented in this format? */\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt)))\n\t\tgoto error;\n\tif (!fmtinfo->ops.decode)\n\t\tgoto error;\n\n\t/* Decode the image. */\n\tif (!(image = (*fmtinfo->ops.decode)(in, optstr)))\n\t\tgoto error;\n\n\t/* Create a color profile if needed. */\n\tif (!jas_clrspc_isunknown(image->clrspc_) &&\n\t  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {\n\t\tif (!(image->cmprof_ =\n\t\t  jas_cmprof_createfromclrspc(jas_image_clrspc(image))))\n\t\t\tgoto error;\n\t}\n\n\treturn image;\nerror:\n\tif (image)\n\t\tjas_image_destroy(image);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_image_t *jas_image_create(unsigned numcmpts, const jas_image_cmptparm_t *cmptparms,\n  jas_clrspc_t clrspc)\n{\n\tjas_image_t *image;\n\tsize_t rawsize;\n\tunsigned cmptno;\n\tconst jas_image_cmptparm_t *cmptparm;\n\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jas_image_create(%d, %p, %d)\\n\", numcmpts, cmptparms,\n\t  clrspc));\n\n\tif (!(image = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n//\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tgoto error;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n#if 0\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n#endif\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!jas_safe_size_mul3(cmptparm->width, cmptparm->height,\n\t\t  (cmptparm->prec + 7), &rawsize)) {\n\t\t\tgoto error;\n\t\t}\n\t\trawsize /= 8;\n\t\tconst bool inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tgoto error;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n\nerror:\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "unsigned jas_stream_peek(jas_stream_t *stream, void *buf, size_t cnt)\n{\n\tchar *bufptr = buf;\n\n\tconst unsigned n = jas_stream_read(stream, bufptr, cnt);\n\n\t/* Put the characters read back onto the stream. */\n\tfor (unsigned i = n; i-- > 0;)\n\t\tif (jas_stream_ungetc(stream, bufptr[i]) == EOF)\n\t\t\treturn 0;\n\n\treturn n;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tint cmptno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "const jas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tunsigned i;\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n#endif\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\tcmdopts->max_mem = JAS_DEFAULT_MAX_MEM_USAGE;\n#endif\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdusage();\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tif ((cmdopts->infmt = jas_image_strtofmt(jas_optarg)) < 0) {\n\t\t\t\tfprintf(stderr, \"warning: ignoring invalid input format %s\\n\",\n\t\t\t\t  jas_optarg);\n\t\t\t\tcmdopts->infmt = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tif ((cmdopts->outfmt = jas_image_strtofmt(jas_optarg)) < 0) {\n\t\t\t\tfprintf(stderr, \"error: invalid output format %s\\n\", jas_optarg);\n\t\t\t\tbadusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version) {\n\t\tgoto done;\n\t}\n\n\tif (cmdopts->outfmt < 0 && cmdopts->outfile) {\n\t\tif ((cmdopts->outfmt = jas_image_fmtfromname(cmdopts->outfile)) < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t  \"error: cannot guess image format from output file name\\n\");\n\t\t}\n\t}\n\n\tif (cmdopts->outfmt < 0) {\n\t\tfprintf(stderr, \"error: no output format specified\\n\");\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int jp2_ftyp_putdata(const jp2_box_t *box, jas_stream_t *out)\n{\n\tconst jp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void jas_matrix_destroy(jas_matrix_t *matrix)\n{\n\tif (matrix->data_) {\n\t\tassert(!(matrix->flags_ & JAS_MATRIX_REF));\n\t}\n\tjas_free(matrix->data_);\n\tjas_free(matrix->rows_);\n\tjas_free(matrix);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int easy_mkstemp(char *buffer, size_t size)\n{\n#if defined(__linux__) && defined(O_TMPFILE)\n\t/* try to use O_TMPFILE, which is a Linux-specific feature to\n\t   create a temporary file without a name, not linked to any\n\t   directory; this is even more secure than mkstemp() */\n\tconst char *tmpdir = getenv(\"TMPDIR\");\n\tif (tmpdir == NULL)\n\t\ttmpdir = \"/tmp\";\n\n\tint fd = open(tmpdir, O_TMPFILE|O_RDWR, JAS_STREAM_PERMS);\n\tif (fd >= 0) {\n\t\t*buffer = 0;\n\t\treturn fd;\n\t}\n#endif\n\n\tif (make_mkstemp_template(buffer, size))\n\t\treturn -1;\n\n#ifdef _WIN32\n\treturn open(buffer,\n\t\t    O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY | O_CLOEXEC,\n\t\t    JAS_STREAM_PERMS);\n#else\n#ifdef JAS_HAVE_MKOSTEMP\n\treturn mkostemp(buffer, O_CLOEXEC);\n#else\n\treturn mkstemp(buffer);\n#endif\n#endif\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tint cmptno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_getint16(jas_stream_t *in, int_fast16_t *val)\n{\n\tint lo;\n\tint hi;\n\tif ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = (hi << 8) | lo;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr)\n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\n\tjas_iccprof_t *iccprof;\n\tjas_stream_t *iccstream;\n\tint pos;\n\tint needcdef;\n\tint prec;\n\tint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\ticcstream = 0;\n\ticcprof = 0;\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tjas_eprintf(\"cannot create JP box\\n\");\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tjas_eprintf(\"cannot create FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tjas_eprintf(\"cannot create IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tjas_eprintf(\"cannot create BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tjas_eprintf(\"cannot create COLR box\\n\");\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\t/* Ensure that cmprof_ is not null. */\n\t\tif (!jas_image_cmprof(image)) {\n\t\t\tjas_eprintf(\"CM profile is null\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccprof = jas_iccprof_createfromcmprof(\n\t\t  jas_image_cmprof(image)))) {\n\t\t\tjas_eprintf(\"cannot create ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_iccprof_save(iccprof, iccstream)) {\n\t\t\tjas_eprintf(\"cannot write ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0) {\n\t\t\tjas_eprintf(\"cannot get stream position\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcolr->iccplen = pos;\n\t\tif (!(colr->iccp = jas_malloc(pos))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=\n\t\t  colr->iccplen) {\n\t\t\tjas_eprintf(\"cannot read temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(iccstream);\n\t\ticcstream = 0;\n\t\tjas_iccprof_destroy(iccprof);\n\t\ticcprof = 0;\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tjas_eprintf(\"cannot create CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tjas_eprintf(\"cannot create JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tjas_eprintf(\"cannot copy stream\\n\");\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tjas_eprintf(\"cannot create JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tjas_eprintf(\"jpc_encode failed\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (iccprof) {\n\t\tjas_iccprof_destroy(iccprof);\n\t}\n\tif (iccstream) {\n\t\tjas_stream_close(iccstream);\n\t}\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_getopt(int argc, char **argv, const jas_opt_t *opts)\n{\n\tconst char *cp;\n\tint id;\n\tint hasarg;\n\tconst jas_opt_t *opt;\n\tconst char *s;\n\n\tif (!jas_optind) {\n\t\tjas_optind = JAS_MIN(1, argc);\n\t}\n\twhile (jas_optind < argc) {\n\t\ts = cp = argv[jas_optind];\n\t\tif (*cp == '-') {\n\t\t\t/* We are processing an option. */\n\t\t\t++jas_optind;\n\t\t\tif (*++cp == '-') {\n\t\t\t\t/* We are processing a long option. */\n\t\t\t\t++cp;\n\t\t\t\tif (*cp == '\\0') {\n\t\t\t\t\t/* This is the end of the options. */\n\t\t\t\t\treturn JAS_GETOPT_EOF;\n\t\t\t\t}\n\t\t\t\tif (!(opt = jas_optlookup(opts, cp))) {\n\t\t\t\t\tif (jas_opterr) {\n\t\t\t\t\t\tjas_eprintf(\"unknown long option %s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\treturn JAS_GETOPT_ERR;\n\t\t\t\t}\n\t\t\t\thasarg = (opt->flags & JAS_OPT_HASARG) != 0;\n\t\t\t\tid = opt->id;\n\t\t\t} else {\n\t\t\t\t/* We are processing a short option. */\n\t\t\t\tif (strlen(cp) != 1 ||\n\t\t\t\t  !(opt = jas_optlookup(opts, cp))) {\n\t\t\t\t\tif (jas_opterr) {\n\t\t\t\t\t\tjas_eprintf(\"unknown short option %s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\treturn JAS_GETOPT_ERR;\n\t\t\t\t}\n\t\t\t\thasarg = (opt->flags & JAS_OPT_HASARG) != 0;\n\t\t\t\tid = opt->id;\n\t\t\t}\n\t\t\tif (hasarg) {\n\t\t\t\t/* The option has an argument. */\n\t\t\t\tif (jas_optind >= argc) {\n\t\t\t\t\tif (jas_opterr) {\n\t\t\t\t\t\tjas_eprintf(\"missing argument for option %s\\n\", s);\n\t\t\t\t\t}\n\t\t\t\t\treturn JAS_GETOPT_ERR;\n\t\t\t\t}\n\t\t\t\tjas_optarg = argv[jas_optind];\n\t\t\t\t++jas_optind;\n\t\t\t} else {\n\t\t\t\t/* The option does not have an argument. */\n\t\t\t\tjas_optarg = 0;\n\t\t\t}\n\t\t\treturn id;\n\t\t} else {\n\t\t\t/* We are not processing an option. */\n\t\t\treturn JAS_GETOPT_EOF;\n\t\t}\n\t}\n\treturn JAS_GETOPT_EOF;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "const jas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id)\n{\n\tunsigned i;\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (fmtinfo->id == id) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void jas_free(void *ptr)\n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_close(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_image_strtofmt(const char *name)\n{\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int bmp_getint16(jas_stream_t *in, int_fast16_t *val)\n{\n\tint lo;\n\tint hi;\n\tif ((lo = jas_stream_getc(in)) == EOF || (hi = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = (hi << 8) | lo;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void jas_iccattrval_destroy(jas_iccattrval_t *attrval)\n{\n#if 0\njas_eprintf(\"refcnt=%d\\n\", attrval->refcnt);\n#endif\n\tif (--attrval->refcnt <= 0) {\n\t\tif (attrval->ops->destroy)\n\t\t\t(*attrval->ops->destroy)(attrval);\n\t\tjas_free(attrval);\n\t}\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "const jas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tunsigned i;\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n#endif\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n#if defined(JAS_DEFAULT_MAX_MEM_USAGE)\n\tcmdopts->max_mem = JAS_DEFAULT_MAX_MEM_USAGE;\n#endif\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdusage();\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tif ((cmdopts->infmt = jas_image_strtofmt(jas_optarg)) < 0) {\n\t\t\t\tfprintf(stderr, \"warning: ignoring invalid input format %s\\n\",\n\t\t\t\t  jas_optarg);\n\t\t\t\tcmdopts->infmt = -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tif ((cmdopts->outfmt = jas_image_strtofmt(jas_optarg)) < 0) {\n\t\t\t\tfprintf(stderr, \"error: invalid output format %s\\n\", jas_optarg);\n\t\t\t\tbadusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version) {\n\t\tgoto done;\n\t}\n\n\tif (cmdopts->outfmt < 0 && cmdopts->outfile) {\n\t\tif ((cmdopts->outfmt = jas_image_fmtfromname(cmdopts->outfile)) < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t  \"error: cannot guess image format from output file name\\n\");\n\t\t}\n\t}\n\n\tif (cmdopts->outfmt < 0) {\n\t\tfprintf(stderr, \"error: no output format specified\\n\");\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static size_t get_temp_directory(char *buffer, size_t size)\n{\n\tconst char *tmpdir = getenv(\"TMPDIR\");\n\tif (tmpdir == NULL)\n\t\ttmpdir = \"/tmp\";\n\n\tsize_t length = strlen(tmpdir);\n\tif (length + 1 > size)\n\t\treturn 0;\n\n\tmemcpy(buffer, tmpdir, length);\n\tbuffer[length++] = '/';\n\treturn length;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\tJAS_DBGLOG(100, (\"jas_stream_fopen(\\\"%s\\\", \\\"%s\\\")\\n\", filename, mode));\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\topenflags |= O_CLOEXEC;\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\t// Free the underlying file object, since it will not otherwise\n\t\t// be freed.\n\t\tjas_free(obj);\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_close(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void jas_tvparser_destroy(jas_tvparser_t *tvp)\n{\n\tif (tvp->buf) {\n\t\tjas_free(tvp->buf);\n\t}\n\tjas_free(tvp);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_image_strtofmt(const char *name)\n{\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_image_strtofmt(const char *name)\n{\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_image_getfmt(jas_stream_t *in)\n{\n\tconst jas_image_fmtinfo_t *fmtinfo;\n\n\t/* Check for data in each of the supported formats. */\n\tunsigned i;\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\tif (fmtinfo->ops.validate) {\n\t\t\t/* Is the input data valid for this format? */\n\t\t\tJAS_DBGLOG(20, (\"testing for format %s ... \", fmtinfo->name));\n\t\t\tif (!(*fmtinfo->ops.validate)(in)) {\n\t\t\t\tJAS_DBGLOG(20, (\"test succeeded\\n\"));\n\t\t\t\treturn fmtinfo->id;\n\t\t\t}\n\t\t\tJAS_DBGLOG(20, (\"test failed\\n\"));\n\t\t}\n\t}\n\treturn -1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_matrix_t *jas_matrix_create(jas_matind_t numrows, jas_matind_t numcols)\n{\n\tjas_matrix_t *matrix;\n\tjas_matind_t i;\n\tsize_t size;\n\n\tmatrix = 0;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\treturn NULL;\n\t}\n\n\t// matrix->datasize_ = numrows * numcols;\n\tif (!jas_safe_size_mul(numrows, numcols, &size) ||\n\t    size > UINT_FAST32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn NULL;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = size;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tmemset(matrix->data_, 0,\n\t\t       matrix->datasize_ * sizeof(jas_seqent_t));\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n\nerror:\n\tjas_matrix_destroy(matrix);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void *jas_alloc2(size_t num_elements, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tjas_mb_t *mb;\n\tjas_mb_t *old_mb;\n\tsize_t old_size;\n\tsize_t ext_size;\n\tsize_t mem;\n\n\tJAS_DBGLOG(100, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tif (!ptr) {\n\t\treturn jas_malloc(size);\n\t}\n\tif (ptr && !size) {\n\t\tjas_free(ptr);\n\t}\n\tif (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {\n\t\tjas_eprintf(\"requested memory size is too large\\n\");\n\t\treturn 0;\n\t}\n\told_mb = jas_get_mb(ptr);\n\told_size = old_mb->size;\n\tJAS_DBGLOG(101, (\"jas_realloc: old_mb=%x; old_size=%zu\\n\", old_mb,\n\t  old_size));\n\tif (size > old_size) {\n\t\tif (!jas_safe_size_add(jas_mem, ext_size, &mem) || mem > jas_max_mem) {\n\t\t\tjas_eprintf(\"maximum memory limit would be exceeded\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!jas_safe_size_sub(jas_mem, old_size - size, &jas_mem)) {\n\t\t\tjas_eprintf(\"heap corruption detected\\n\");\n\t\t\tabort();\n\t\t}\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc: realloc(%p, %zu)\\n\", old_mb, ext_size));\n\tif (!(mb = realloc(old_mb, ext_size))) {\n\t\tresult = 0;\n\t} else {\n\t\tresult = jas_mb_get_data(mb);\n\t\tmb->size = size;\n\t\tjas_mem = mem;\n\t}\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p (%p)\\n\", ptr, size, result,\n\t  mb));\n\tJAS_DBGLOG(102, (\"max_mem=%zu; mem=%zu\\n\", jas_max_mem, jas_mem));\n\treturn result;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int bmp_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\t/* Read the first two characters that constitute the signature. */\n\tif (jas_stream_peek(in, buf, sizeof(buf)) != sizeof(buf))\n\t\treturn -1;\n\n\t/* Is the signature correct for the BMP format? */\n\tif (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int bmp_numcmpts(bmp_info_t *info)\n{\n\tint numcmpts;\n\n\tif (info->depth == 24) {\n\t\tnumcmpts = 3;\n\t} else if (info->depth == 8) {\n\t\tnumcmpts = bmp_isgrayscalepal(info->palents, info->numcolors) ?\n\t\t  1 : 3;\n\t} else {\n\t\tnumcmpts = 0;\n\t\tabort();\n\t}\n\treturn numcmpts;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tmpfile()\\n\"));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Create the temporary file. */\n\tif ((obj->fd = easy_mkstemp(obj->pathname, sizeof(obj->pathname))) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (*obj->pathname != 0 && unlink(obj->pathname) < 0) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void jas_iccattrval_destroy(jas_iccattrval_t *attrval)\n{\n#if 0\njas_eprintf(\"refcnt=%d\\n\", attrval->refcnt);\n#endif\n\tif (--attrval->refcnt <= 0) {\n\t\tif (attrval->ops->destroy)\n\t\t\t(*attrval->ops->destroy)(attrval);\n\t\tjas_free(attrval);\n\t}\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "unsigned jas_stream_peek(jas_stream_t *stream, void *buf, size_t cnt)\n{\n\tchar *bufptr = buf;\n\n\tconst unsigned n = jas_stream_read(stream, bufptr, cnt);\n\n\t/* Put the characters read back onto the stream. */\n\tfor (unsigned i = n; i-- > 0;)\n\t\tif (jas_stream_ungetc(stream, bufptr[i]) == EOF)\n\t\t\treturn 0;\n\n\treturn n;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "int jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr)\n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\n\tjas_iccprof_t *iccprof;\n\tjas_stream_t *iccstream;\n\tint pos;\n\tint needcdef;\n\tint prec;\n\tint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\ticcstream = 0;\n\ticcprof = 0;\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tjas_eprintf(\"cannot create JP box\\n\");\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tjas_eprintf(\"cannot create FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tjas_eprintf(\"cannot create IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tjas_eprintf(\"cannot create BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tjas_eprintf(\"cannot create COLR box\\n\");\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\t/* Ensure that cmprof_ is not null. */\n\t\tif (!jas_image_cmprof(image)) {\n\t\t\tjas_eprintf(\"CM profile is null\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccprof = jas_iccprof_createfromcmprof(\n\t\t  jas_image_cmprof(image)))) {\n\t\t\tjas_eprintf(\"cannot create ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_iccprof_save(iccprof, iccstream)) {\n\t\t\tjas_eprintf(\"cannot write ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0) {\n\t\t\tjas_eprintf(\"cannot get stream position\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcolr->iccplen = pos;\n\t\tif (!(colr->iccp = jas_malloc(pos))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=\n\t\t  colr->iccplen) {\n\t\t\tjas_eprintf(\"cannot read temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(iccstream);\n\t\ticcstream = 0;\n\t\tjas_iccprof_destroy(iccprof);\n\t\ticcprof = 0;\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tjas_eprintf(\"cannot create CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tjas_eprintf(\"cannot create JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tjas_eprintf(\"cannot copy stream\\n\");\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tjas_eprintf(\"cannot create JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tjas_eprintf(\"jpc_encode failed\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (iccprof) {\n\t\tjas_iccprof_destroy(iccprof);\n\t}\n\tif (iccstream) {\n\t\tjas_stream_close(iccstream);\n\t}\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "char *jas_strdup(const char *s)\n{\n\tsize_t n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "jas_image_t *bmp_decode(jas_stream_t *in, const char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\tbmp_dec_importopts_t opts;\n\tsize_t num_samples;\n\n\timage = 0;\n\tinfo = 0;\n\n\tif (bmp_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in, &opts))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!jas_safe_size_mul3(info->width, info->height, info->numplanes,\n\t  &num_samples)) {\n\t\tjas_eprintf(\"image size too large\\n\");\n\t\tgoto error;\n\t}\n\n\tif (opts.max_samples > 0 && num_samples > opts.max_samples) {\n\t\tjas_eprintf(\"maximum number of pixels exceeded (%zu)\\n\",\n\t\t  opts.max_samples);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tgoto error;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tgoto error;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void *jas_alloc2(size_t num_elements, size_t element_size)\n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static size_t get_temp_directory(char *buffer, size_t size)\n{\n\tconst char *tmpdir = getenv(\"TMPDIR\");\n\tif (tmpdir == NULL)\n\t\ttmpdir = \"/tmp\";\n\n\tsize_t length = strlen(tmpdir);\n\tif (length + 1 > size)\n\t\treturn 0;\n\n\tmemcpy(buffer, tmpdir, length);\n\tbuffer[length++] = '/';\n\treturn length;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "static int bmp_getdata(jas_stream_t *in, bmp_info_t *info, jas_image_t *image)\n{\n\tint i;\n\tint j;\n\tint y;\n\tjas_matrix_t *cmpts[3];\n\tint numpad;\n\tint red;\n\tint grn;\n\tint blu;\n\tint ret;\n\tint numcmpts;\n\tint cmptno;\n\tint ind;\n\tbmp_palent_t *palent;\n\tint mxind;\n\tint haspal;\n\n\tassert(info->depth == 8 || info->depth == 24);\n\tassert(info->enctype == BMP_ENC_RGB);\n\n\tnumcmpts = bmp_numcmpts(info);\n\thaspal = bmp_haspal(info);\n\n\tret = 0;\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tcmpts[i] = 0;\n\t}\n\n\t/* Create temporary matrices to hold component data. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(cmpts[i] = jas_matrix_create(1, info->width))) {\n\t\t\tret = -1;\n\t\t\tgoto bmp_getdata_done;\n\t\t}\n\t}\n\n\t/* Calculate number of padding bytes per row of image data. */\n\tnumpad = (numcmpts * info->width) % 4;\n\tif (numpad) {\n\t\tnumpad = 4 - numpad;\n\t}\n\n\tmxind = (1 << info->depth) - 1;\n\tfor (i = 0; i < info->height; ++i) {\n\t\tfor (j = 0; j < info->width; ++j) {\n\t\t\tif (haspal) {\n\t\t\t\tif ((ind = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind > mxind) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t\tif (ind < info->numcolors) {\n\t\t\t\t\tpalent = &info->palents[ind];\n\t\t\t\t\tred = palent->red;\n\t\t\t\t\tgrn = palent->grn;\n\t\t\t\t\tblu = palent->blu;\n\t\t\t\t} else {\n\t\t\t\t\tred = ind;\n\t\t\t\t\tgrn = ind;\n\t\t\t\t\tblu = ind;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((blu = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (grn = jas_stream_getc(in)) == EOF ||\n\t\t\t\t  (red = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (numcmpts == 3) {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t\tjas_matrix_setv(cmpts[1], j, grn);\n\t\t\t\tjas_matrix_setv(cmpts[2], j, blu);\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(cmpts[0], j, red);\n\t\t\t}\n\t\t}\n\t\tfor (j = numpad; j > 0; --j) {\n\t\t\t\tif (jas_stream_getc(in) == EOF) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto bmp_getdata_done;\n\t\t\t\t}\n\t\t}\n\t\tfor (cmptno = 0; cmptno < numcmpts; ++cmptno) {\n\t\t\ty = info->topdown ? i : (info->height - 1 - i);\n\t\t\tif (jas_image_writecmpt(image, cmptno, 0, y, info->width,\n\t\t\t  1, cmpts[cmptno])) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto bmp_getdata_done;\n\t\t\t}\n\t\t}\n\t}\n\nbmp_getdata_done:\n\t/* Destroy the temporary matrices. */\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (cmpts[i]) {\n\t\t\tjas_matrix_destroy(cmpts[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void jas_image_destroy(jas_image_t *image)\n{\n\tif (image->cmpts_) {\n\t\tfor (unsigned i = 0; i < image->numcmpts_; ++i) {\n\t\t\tjas_image_cmpt_destroy(image->cmpts_[i]);\n\t\t\timage->cmpts_[i] = 0;\n\t\t}\n\t\tjas_free(image->cmpts_);\n\t}\n\tif (image->cmprof_)\n\t\tjas_cmprof_destroy(image->cmprof_);\n\tjas_free(image);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "static int file_close(jas_stream_obj_t *obj)\n{\n\tint ret;\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_close(%p)\\n\", obj));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "jas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 0,
    "func": "void bmp_info_destroy(bmp_info_t *info)\n{\n\tif (info->palents) {\n\t\tjas_free(info->palents);\n\t}\n\tjas_free(info);\n}\n"
  },
  {
    "project": "Jasper",
    "commit_id": "973b1a6b9070e2bf17d17568cbaf4043ce931f51",
    "target": 1,
    "func": "void *jas_malloc(size_t size)\n{\n\treturn malloc(size);\n}\n"
  }
]